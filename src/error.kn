// ============================================================================
// KAIN Error System - Structured error types
// ============================================================================
// Ported from legacy_prototype/src/error.rs
// Provides typed errors with source locations for all compiler phases.
// ============================================================================

use span

/// Error kinds for different compiler phases
enum ErrorKind:
    Lexer
    Parser
    Type
    Effect
    Borrow
    Codegen
    Runtime
    IO

/// A compiler error with location and message
struct KainError:
    kind: ErrorKind
    message: String
    span: Span
    filename: String
    hint: Option<String>

impl KainError:
    /// Create a lexer error
    pub fn lexer(message: String, span: Span) -> KainError:
        return KainError {
            kind: ErrorKind::Lexer,
            message: message,
            span: span,
            filename: "",
            hint: None
        }
    
    /// Create a parser error
    pub fn parser(message: String, span: Span) -> KainError:
        return KainError {
            kind: ErrorKind::Parser,
            message: message,
            span: span,
            filename: "",
            hint: None
        }
    
    /// Create a type error
    pub fn type_error(message: String, span: Span) -> KainError:
        return KainError {
            kind: ErrorKind::Type,
            message: message,
            span: span,
            filename: "",
            hint: None
        }
    
    /// Create an effect error (e.g., pure function calling IO function)
    pub fn effect_error(message: String, span: Span) -> KainError:
        return KainError {
            kind: ErrorKind::Effect,
            message: message,
            span: span,
            filename: "",
            hint: None
        }
    
    /// Create a borrow checker error
    pub fn borrow_error(message: String, span: Span) -> KainError:
        return KainError {
            kind: ErrorKind::Borrow,
            message: message,
            span: span,
            filename: "",
            hint: None
        }
    
    /// Create a code generation error
    pub fn codegen(message: String, span: Span) -> KainError:
        return KainError {
            kind: ErrorKind::Codegen,
            message: message,
            span: span,
            filename: "",
            hint: None
        }
    
    /// Create a runtime error (no span)
    pub fn runtime(message: String) -> KainError:
        return KainError {
            kind: ErrorKind::Runtime,
            message: message,
            span: Span::empty(),
            filename: "",
            hint: None
        }
    
    /// Create an IO error
    pub fn io(message: String) -> KainError:
        return KainError {
            kind: ErrorKind::IO,
            message: message,
            span: Span::empty(),
            filename: "",
            hint: None
        }
    
    /// Add a hint to the error
    pub fn with_hint(self, hint: String) -> KainError:
        return KainError {
            kind: self.kind,
            message: self.message,
            span: self.span,
            filename: self.filename,
            hint: Some(hint)
        }
    
    /// Add filename to the error
    pub fn with_filename(self, filename: String) -> KainError:
        return KainError {
            kind: self.kind,
            message: self.message,
            span: self.span,
            filename: filename,
            hint: self.hint
        }
    
    /// Get the error kind as a string
    pub fn kind_str(self) -> String:
        let v = variant_of(self.kind)
        if v == "Lexer":
            return "Lexer Error"
        if v == "Parser":
            return "Parse Error"
        if v == "Type":
            return "Type Error"
        if v == "Effect":
            return "Effect Error"
        if v == "Borrow":
            return "Borrow Error"
        if v == "Codegen":
            return "Codegen Error"
        if v == "Runtime":
            return "Runtime Error"
        if v == "IO":
            return "IO Error"
        return "Error"
    
    /// Format as a simple string
    pub fn to_string(self) -> String:
        return self.kind_str() + ": " + self.message

/// Result type for KAIN operations (Generics removed for bootstrap)
enum KainResult:
    Ok(i64)
    Err(KainError)

impl KainResult:
    /// Check if result is Ok
    pub fn is_ok(self) -> Bool:
        let v = variant_of(self)
        return v == "Ok"
    
    /// Check if result is Err
    pub fn is_err(self) -> Bool:
        let v = variant_of(self)
        return v == "Err"
    
    /// Unwrap the value, panic if Err
    pub fn unwrap(self) -> i64:
        let v = variant_of(self)
        if v == "Ok":
            return variant_field(self, 0)
        let err = variant_field(self, 0)
        panic("unwrap called on Err: " + err.to_string())
    
    /// Get error if Err
    pub fn error(self) -> Option<KainError>:
        let v = variant_of(self)
        if v == "Err":
            return Some(variant_field(self, 0))
        return None
    
    /// Map the Ok value (Not supported without generics/lambdas fully)
    // pub fn map(self, f: fn(T) -> U) -> KainResult<U>:
    //    ...

/// Collect errors from multiple operations
struct ErrorCollector:
    collector_errors: Array<KainError>

impl ErrorCollector:
    pub fn new() -> ErrorCollector:
        return ErrorCollector { collector_errors: [] }
    
    /// Add an error
    pub fn add(self, error: KainError) -> Unit:
        push(self.collector_errors, error)
    
    /// Check if any errors
    pub fn has_errors(self) -> Bool:
        return array_len(self.collector_errors) > 0
    
    /// Get error count
    pub fn count(self) -> Int:
        return array_len(self.collector_errors)
    
    /// Get all errors
    pub fn get_errors(self) -> Array<KainError>:
        return self.collector_errors
    
    /// Fail if there are errors
    pub fn fail_if_errors(self) -> KainResult:
        if array_len(self.collector_errors) > 0:
            return KainResult::Err(self.collector_errors[0])
        return KainResult::Ok(0)
