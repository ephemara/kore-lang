// ============================================================================
// KORE Import Resolver & Module System
// ============================================================================
// Handles module resolution, import paths, and dependency tracking.
// ============================================================================

use types
use parser_v2

// =============================================================================
// Path Utilities
// =============================================================================

fn parent_dir(path: String) -> String:
    let s = path
    let len = str_len(s)
    let i = len - 1
    while i >= 0:
        let c = substring(s, i, i+1)
        if str_eq(c, "/") || str_eq(c, "\\"):
            if i == 0:
                return "/"
            return substring(s, 0, i)
        i = i - 1
    return "."

fn join_path(a: String, b: String) -> String:
    if str_len(a) == 0:
        return b
    if str_eq(a, "."):
        return b
    
    // Check if b is already absolute
    if starts_with(b, "/") || contains(b, ":\\"):
        return b
        
    let last_a = substring(a, str_len(a) - 1, str_len(a))
    if str_eq(last_a, "/") || str_eq(last_a, "\\"):
        return a + b
    
    return a + "/" + b

extern fn file_exists(path: String) -> Bool
extern fn read_file(path: String) -> String

// =============================================================================
// Module Paths
// =============================================================================

enum ModulePath:
    Relative(Array<String>)     // ./foo/bar -> [".", "foo", "bar"]
    Absolute(Array<String>)     // std/collections -> ["std", "collections"]
    Package(String, Array<String>) // pkg::foo/bar -> "pkg", ["foo", "bar"]

impl ModulePath:
    pub fn parse(path: String) -> ModulePath:
        // Simple split by / or ::
        if starts_with(path, "./") || starts_with(path, "../"):
            return ModulePath::Relative(split(path, "/"))
        
        // Handle "stdlib::math"
        if contains(path, "::"):
            let parts = split(path, "::")
            let pkg = parts[0]
            let rest_str = ""
            if array_len(parts) > 1:
                rest_str = parts[1]
            
            // If rest_str is empty, we have "pkg", but split("") gives [] or [""]?
            // Actually, if we have "stdlib::math", rest_str is "math"
            // If we have "stdlib::math::extra", rest_str is "math::extra"? No, split handles that.
            // Wait, split(path, "::") on "stdlib::math" gives ["stdlib", "math"]
            // The existing code was: let rest_str = parts[1]
            // We need to support nested parts: "stdlib::math::foo" -> pkg="stdlib", parts=["math", "foo"]
            // But for now, let's assume one level of :: separates package from path
            
            // Re-implement robustly:
            // "stdlib::math" -> pkg="stdlib", rest="math" -> parts=["math"]
            
            // For now, let's trust the split behavior, but fix the panic if any.
            // The panic might be in split() if not implemented for "::"? 
            // Or maybe ModulePath::Package construction?
            
            // Let's look at the failure. "match path" -> "Relative"
            // Wait, the logs said:
            // DEBUG: find_file stdlib::math
            // DEBUG: calling parse
            // DEBUG: calling parent_dir
            // DEBUG: parent_dir done
            // DEBUG: match path
            // DEBUG: Relative   <-- This is WRONG! "stdlib::math" should not be Relative!
            
            // Ah! The `parse` function returned `Relative`? 
            // No, the logs show:
            // DEBUG: parsing path: stdlib::math
            // DEBUG: path is Relative
            
            // WHY?
            // if starts_with(path, "./") || starts_with(path, "../"):
            // "stdlib::math" does NOT start with ./ or ../
            
            // Maybe starts_with is broken?
            
            return ModulePath::Package(pkg, split(rest_str, "/"))
            
        return ModulePath::Absolute(split(path, "/"))
    
    pub fn to_string(self) -> String:
        match self:
            ModulePath::Relative(parts) => join(parts, "/")
            ModulePath::Absolute(parts) => join(parts, "/")
            ModulePath::Package(pkg, parts) =>
                if array_len(parts) == 0:
                    pkg
                else:
                    pkg + "::" + join(parts, "/")

// =============================================================================
// Resolved Module
// =============================================================================

struct ResolvedModule:
    path: ModulePath
    file_path: String
    source: String
    items: Array<Item>
    dependencies: Array<String>

// =============================================================================
// Import Resolver
// =============================================================================

struct ImportResolver:
    root_path: String
    cache: Map<String, ResolvedModule>
    loading: Array<String> // Manual array for set behavior

impl ImportResolver:
    pub fn new(root_path: String) -> ImportResolver:
        let c = Map::new()
        let l = []
        return ImportResolver {
            root_path: root_path,
            cache: c,
            loading: l
        }
    
    pub fn resolve_all(self, start_file: String) -> Array<Item>:
        let visited = []
        let modules = []
        self.resolve_recursive(start_file, visited, modules)
        
        // Combine all items in topological order (for now just return all)
        let all_items = []
        for m in modules:
            for item in m.items:
                push(all_items, item)
        return all_items

    fn array_contains(self, arr: Array<String>, val: String) -> Bool:
        for item in arr:
            if str_eq(item, val):
                return true
        return false

    fn resolve_recursive(self, file_path: String, visited: Array<String>, result: Array<ResolvedModule>) -> Unit:
        println("DEBUG: resolve_recursive for " + file_path)
        if self.array_contains(visited, file_path):
            println("DEBUG: already visited")
            return
        push(visited, file_path)
        
        // 1. Load and parse
        let source = read_file(file_path)
        println("DEBUG: source loaded, len=" + to_string(str_len(source)))
        
        if str_len(source) == 0:
            println("ERROR: Failed to read file or empty: " + file_path)
            return
        
        println("DEBUG: creating lexer")
        let lexer = Lexer::new(source, file_path)
        println("DEBUG: tokenizing")
        let tokens = tokenize(lexer)
        println("DEBUG: creating parser")
        let parser = parser_new(tokens, source, file_path)
        
        let items = parse_program_v2(parser)


        
        // 2. Scan for imports
        let deps = []
        for item in items:
            let v = variant_of(item)
            // println("DEBUG: item variant: " + v)
            if str_eq(v, "Use"):
                let path_str = variant_field(item, 0)
                let dep_file = self.find_file(file_path, path_str)
                if str_len(dep_file) > 0:
                    push(deps, dep_file)
                    self.resolve_recursive(dep_file, visited, result)
        
        let m = ResolvedModule {
            path: ModulePath::parse(file_path),
            file_path: file_path,
            source: source,
            items: items,
            dependencies: deps
        }
        
        push(result, m)

    fn find_file(self, from_file: String, import_path: String) -> String:
        let path = ModulePath::parse(import_path)
        let dir = parent_dir(from_file)
        match path:
            ModulePath::Relative(parts) =>
                let rel = join(parts, "/")
                let candidate = join_path(dir, rel + ".kr")
                if file_exists(candidate):
                    return candidate
                return ""
            ModulePath::Absolute(parts) =>
                // Try relative to root/src or root/stdlib
                let rel = join(parts, "/")
                let in_src = join_path(self.root_path, "src/" + rel + ".kr")
                if file_exists(in_src):
                    return in_src
                let in_std = join_path(self.root_path, "stdlib/" + rel + ".kr")
                if file_exists(in_std):
                    return in_std
                return ""
            ModulePath::Package(pkg, parts) =>
                // Special case for stdlib
                if str_eq(pkg, "stdlib"):
                    let rel = join(parts, "/")
                    let in_std = join_path(self.root_path, "stdlib/" + rel + ".kr")
                    if file_exists(in_std):
                        return in_std
                    return ""
                
                // Look in packages directory: packages/<pkg>/src/...
                let pkg_base = join_path(self.root_path, "packages/" + pkg + "/src")
                let rel = join(parts, "/")
                let in_pkg = join_path(pkg_base, rel + ".kr")
                
                if file_exists(in_pkg):
                    return in_pkg
                return ""
        
        return ""
