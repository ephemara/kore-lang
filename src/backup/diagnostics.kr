// ============================================================================
// KORE Diagnostics - Pretty error reporting
// ============================================================================
// Ported from legacy_prototype/src/diagnostics.rs
// Shows source context with line numbers and error highlighting.
// ============================================================================

/// Diagnostic renderer for pretty error messages
struct Diagnostics:
    source: String
    filename: String
    lines: Array<String>

impl Diagnostics:
    /// Create a new diagnostics renderer
    pub fn new(source: String, filename: String) -> Diagnostics:
        // Split source into lines
        let lines = split(source, "\n")
        return Diagnostics {
            source: source,
            filename: filename,
            lines: lines
        }
    
    /// Format an error with source context
    pub fn format_error(self, error: KoreError) -> String:
        let v = variant_of(error.kind)
        
        if v == "Runtime" || v == "IO":
            // No source context for runtime errors
            return self.format_simple_error(error)
        
        return self.format_with_context(error)
    
    /// Format error with source code context
    fn format_with_context(self, error: KoreError) -> String:
        let line_info = self.get_line_info(error.span)
        let line_num = line_info.line
        let col = line_info.column
        let line_content = line_info.content
        
        let output = ""
        
        // Error header with color (ANSI escape codes)
        output = output + "\n\x1b[1;31merror[" + error.kind_str() + "]\x1b[0m: " + error.message + "\n"
        
        // Location
        output = output + "  \x1b[1;34m-->\x1b[0m " + self.filename + ":" + str(line_num) + ":" + str(col) + "\n"
        
        // Separator
        output = output + "   \x1b[1;34m|\x1b[0m\n"
        
        // Source line with line number
        let line_num_str = str(line_num)
        // Pad line number to 3 digits
        while len(line_num_str) < 3:
            line_num_str = " " + line_num_str
        output = output + "\x1b[1;34m" + line_num_str + " |\x1b[0m " + line_content + "\n"
        
        // Error pointer
        let pointer_offset = col - 1
        if pointer_offset < 0:
            pointer_offset = 0
        
        let span_len = error.span.end - error.span.start
        if span_len < 1:
            span_len = 1
        
        // Build pointer line
        let spaces = ""
        for i in range(0, pointer_offset):
            spaces = spaces + " "
        
        let pointers = ""
        for i in range(0, span_len):
            pointers = pointers + "^"
        
        output = output + "   \x1b[1;34m|\x1b[0m " + spaces + "\x1b[1;31m" + pointers + "\x1b[0m\n"
        
        // Hint if present
        if error.hint != None:
            output = output + "   \x1b[1;34m|\x1b[0m\n"
            output = output + "   \x1b[1;34m= help:\x1b[0m " + error.hint + "\n"
        
        // Separator
        output = output + "   \x1b[1;34m|\x1b[0m\n"
        
        return output
    
    /// Format error without source context
    fn format_simple_error(self, error: KoreError) -> String:
        return "\n\x1b[1;31merror\x1b[0m: " + error.message + "\n"
    
    /// Get line number, column, and line content for a span
    fn get_line_info(self, span: Span) -> LineInfo:
        let line_num = 1
        let line_start = 0
        let pos = 0
        
        // Find which line the span starts on
        for i in range(0, len(self.source)):
            if i >= span.start:
                break
            let ch = char_at(self.source, i)
            if ch == "\n":
                line_num = line_num + 1
                line_start = i + 1
        
        let col = span.start - line_start + 1
        if col < 1:
            col = 1
        
        // Get line content
        let line_content = ""
        if line_num - 1 < array_len(self.lines):
            line_content = self.lines[line_num - 1]
        
        return LineInfo {
            line: line_num,
            column: col,
            content: line_content
        }
    
    /// Print formatted error to console
    pub fn print_error(self, error: KoreError) -> Unit:
        let formatted = self.format_error(error)
        print(formatted)
    
    /// Print all errors from a collector
    pub fn print_errors(self, collector: ErrorCollector) -> Unit:
        for error in collector.get_errors():
            self.print_error(error)

/// Helper struct for line info
struct LineInfo:
    line: Int
    column: Int
    content: String

/// Format an error without source context (standalone function)
pub fn format_simple_error(error: KoreError) -> String:
    return error.kind_str() + ": " + error.message

/// Print error to stderr with colors
pub fn print_error(error: KoreError) -> Unit:
    let msg = "\x1b[1;31merror\x1b[0m: " + error.message
    println(msg)
