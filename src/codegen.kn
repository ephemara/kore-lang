// ============================================================================
// KAIN Code Generator (LLVM)
// ============================================================================

// use std/io
// use std/collections
use ast
use types

// =============================================================================
// NaN-Boxing Constants (must match kain_runtime.c exactly!)
// =============================================================================
// 
// Bit layout:
//   Float:  Any value < NANBOX_QNAN is a valid IEEE 754 double
//   Tagged: [0xFFF8 prefix (16 bits)][tag (3 bits)][payload (45 bits)]
//
// Type tags: PTR=0, INT=1, BOOL=2, NULL=3, STR=4
// =============================================================================

// These are computed as: NANBOX_QNAN | (TAG << 45) | payload
// NANBOX_QNAN = 0xFFF8000000000000 = 18442240474082181120

fn nanbox_int_tag() -> String:
    return "-2216615441596416"

fn nanbox_bool_tag() -> String:
    return "-2181431069507584"

fn nanbox_null_tag() -> String:
    return "-2146246697418752"

fn nanbox_string_tag() -> String:
    return "-2111062325329920"

fn nanbox_ptr_tag() -> String:
    return "-2251799813685248"

fn nanbox_bool(b: Bool) -> String:
    if b:
        return "-2181431069507583"
    return "-2181431069507584"

fn nanbox_int(n: Int) -> String:
    // This is problematic as a pure helper because it needs to generate an add instruction
    // But for gen_expr (typed) we can use a fresh local
    return "???" // We'll inline it instead

// =============================================================================
// StringBuilder
// =============================================================================

struct StringBuilder:
    lines: Array<String>

impl StringBuilder:
    pub fn new() -> StringBuilder:
        return StringBuilder { lines: [] }
    
    pub fn push(self, text: String) -> Unit:
        push(self.lines, text)
    
    pub fn push_line(self, text: String) -> Unit:
        push(self.lines, text + "\n")
    
    pub fn build(self) -> String:
        return join(self.lines, "")

// =============================================================================
// Code Generator
// =============================================================================

struct VarInfo:
    name: String
    ptr: String

struct CodeGenData:
    output: StringBuilder
    indent: Int
    local_counter: Int
    string_counter: Int
    label_counter: Int
    strings: Array<String>
    // Variable environment: maps name -> alloca pointer
    vars: Array<VarInfo>
    
    // Loop labels for break/continue
    loop_labels: Array<String>         // end labels (for break)
    loop_continue_labels: Array<String>  // start labels (for continue)
    
    // Struct layout info
    struct_layouts: Map<String, Array<String>>
    field_map: Map<String, String>
    method_map: Map<String, String>

struct CodeGen:
    inner: Array<CodeGenData>

impl CodeGen:
    pub fn new() -> CodeGen:
        let data = CodeGenData {
            output: StringBuilder::new(),
            indent: 0,
            local_counter: 0,
            string_counter: 0,
            label_counter: 0,
            strings: [],
            vars: [],
            loop_labels: [],
            loop_continue_labels: [],
            struct_layouts: Map::new(),
            field_map: Map::new(),
            method_map: Map::new()
        }
        return CodeGen { inner: [data] }
    
    /// Generate a fresh local variable name
    fn fresh_local(self) -> String:
        let ctx = self.inner[0]
        let n = ctx.local_counter
        ctx.local_counter = ctx.local_counter + 1
        self.inner[0] = ctx
        return "%t" + str(n)
    
    /// Generate a fresh label name
    fn fresh_label(self, prefix: String) -> String:
        let ctx = self.inner[0]
        let n = ctx.label_counter
        ctx.label_counter = ctx.label_counter + 1
        self.inner[0] = ctx
        return prefix + str(n)
    
    /// Emit a line of IR
    fn write_line(self, text: String) -> Unit:
        let ctx = self.inner[0]
        ctx.output.push_line(text)
    
    /// Helper to find variable pointer by name
    /// Helper to find variable pointer by name
    fn find_var(self, name: String) -> String:
        // Search in reverse order to handle shadowing
        let ctx = self.inner[0]
        let i = array_len(ctx.vars) - 1
        while i >= 0:
            let info = ctx.vars[i]
            // Use manual comparison to be safe? Or str_eq?
            // str_eq should be safe if name is valid
            if str_eq(info.name, name):
                return info.ptr
            i = i - 1
        return ""
        
    /// Increment indent
    fn inc_indent(self) -> Unit:
        let ctx = self.inner[0]
        ctx.indent = ctx.indent + 1
        self.inner[0] = ctx
        
    /// Decrement indent
    fn dec_indent(self) -> Unit:
        let ctx = self.inner[0]
        ctx.indent = ctx.indent - 1
        self.inner[0] = ctx
        
    /// Reset usage counters for new function
    fn reset_locals(self) -> Unit:
        let ctx = self.inner[0]
        ctx.local_counter = 0
        ctx.vars = []
        self.inner[0] = ctx
        
    /// Add variable to scope
    fn add_var(self, name: String, ptr: String) -> Unit:
        let ctx = self.inner[0]
        push(ctx.vars, VarInfo { name: name, ptr: ptr })
        // Array push modifies heap, no writeback needed for ctx.vars pointer
        
    /// Add string literal and return ID
    fn add_string_literal(self, s: String) -> Int:
        let ctx = self.inner[0]
        let id = ctx.string_counter
        ctx.string_counter = ctx.string_counter + 1
        push(ctx.strings, s)
        self.inner[0] = ctx // Writeback for string_counter
        return id
        
    // =========================================================================
    // Program Generation
    // =========================================================================
    
    /// Generate IR for an entire program
    /// FIX: Accept Array<TypedItem> directly to bypass struct passing bugs in bootstrap compiler
    pub fn gen_program(self, items: Array<TypedItem>) -> String:
        let ctx = self.inner[0]
        
        // Emit header
        self.write_line("; KAIN Compiler Output - LLVM IR")
        self.write_line("; Generated by Project Ouroboros")
        println("DEBUG: headers written")
        self.write_line("; Compile with: clang output.ll -o output")
        self.write_line("")
        
        // Target triple (x86_64 Windows for now)
        // self.write_line("target triple = \"x86_64-pc-windows-msvc\"")
        self.write_line("")
        
        // Emit external declarations
        self.emit_externals()
        self.emit_builtin_types()
        self.write_line("")
        
        // Pre-pass: Index structs and fields
        let item_idx = 0
        let items_len = array_len(items)
        while item_idx < items_len:
            let item = items[item_idx]
            let v = variant_of(item)
            if str_eq(v, "1") || str_eq(v, "Struct"):
                let name = variant_field(item, 0)
                let fields = variant_field(item, 1)
                
                let field_names = []
                let f_idx = 0
                let fields_len = array_len(fields)
                while f_idx < fields_len:
                    let f = fields[f_idx]
                    push(field_names, f.name)
                    f_idx = f_idx + 1
                    
                map_set(ctx.struct_layouts, name, field_names)
            else if str_eq(v, "3") || str_eq(v, "Impl"):
                let target = variant_field(item, 0)
                let methods = variant_field(item, 1) // Array<TypedFunction>
                
                let m_idx = 0
                let methods_len = array_len(methods)
                while m_idx < methods_len:
                    let m = methods[m_idx] // TypedFunction struct
                    map_set(ctx.method_map, m.name, target)
                    m_idx = m_idx + 1
            
            item_idx = item_idx + 1

        // Emit each item
        print_phase("CODEGEN", "START", "Main pass")
        
        // Recalculate length to be safe
        let m_len = array_len(items)
        print_phase("DEBUG", "Items len check", str(m_len))
        
        let m_idx = 0
        while m_idx < m_len:
            let item = items[m_idx]
            self.gen_item(item)
            self.write_line("")
            m_idx = m_idx + 1
        
        // Emit string constants at the end
        if array_len(ctx.strings) > 0:
            self.write_line("; String Constants")
            for i in range(0, array_len(ctx.strings)):
                let s = ctx.strings[i]
                let name = "@.str." + str(i)
                let escaped = self.escape_string(s)
                let quote = chr(34)
                self.write_line(name + " = private unnamed_addr constant [" + str(str_len(s) + 1) + " x i8] c" + quote + escaped + "\\00" + quote + ", align 8")
        
        return ctx.output.build()
    
    /// Generate IR for an entire program (UNTYPED version - bypasses type checker)
    pub fn gen_program_untyped(self, program: Program) -> String:
        // println("DEBUG: gen_program_untyped START")
        // Emit header
        self.write_line("; KAIN Compiler Output - LLVM IR (Untyped)")
        self.write_line("; Generated by Project Ouroboros")
        self.write_line("; Compile with: clang output.ll -o output")
        self.write_line("")
        self.write_line("")
        
        // println("DEBUG: Emitting externals")
        // Emit external declarations
        self.emit_externals()
        self.emit_builtin_types()
        self.write_line("")
        
        // println("DEBUG: Pre-pass starting, items count = " + str(array_len(program.items)))
        // Pre-pass: Index structs and fields
        let pre_idx = 0
        for item in program.items:
            // println("DEBUG: Pre-pass item " + str(pre_idx))
            let iv = variant_of(item)
            // println("DEBUG: Pre-pass variant = " + iv)
            if str_eq(iv, "Struct"):
                let def = variant_field(item, 0)
                self.register_struct_fields(def)
            else if str_eq(iv, "Impl"):
                let def = variant_field(item, 0)
                self.register_impl_methods(def)
            pre_idx = pre_idx + 1

        // println("DEBUG: Pre-pass done, starting item generation")
        
        // Pass 1: Generate Types (Structs and Enums)
        // println("DEBUG: Gen pass 1 (Types)")
        let gen_idx = 0
        for item in program.items:
            let v = variant_of(item)
            if str_eq(v, "Struct") || str_eq(v, "Enum"):
                // println("DEBUG: Gen type " + str(gen_idx))
                self.gen_item_untyped(item)
                self.write_line("")
            gen_idx = gen_idx + 1
            
        // Pass 2: Generate Code (Functions, Impls, etc.)
        // println("DEBUG: Gen pass 2 (Code)")
        gen_idx = 0
        for item in program.items:
            let v = variant_of(item)
            if !str_eq(v, "Struct") && !str_eq(v, "Enum"):
                // println("DEBUG: Gen code " + str(gen_idx) + " variant=" + v)
                self.gen_item_untyped(item)
                self.write_line("")
            gen_idx = gen_idx + 1
        
        // Emit string constants at the end
        if array_len(self.strings) > 0:
            self.write_line("; String Constants")
            for i in range(0, array_len(self.strings)):
                let s = self.strings[i]
                let name = "@.str." + str(i)
                let escaped = self.escape_string(s)
                let quote = chr(34)
                self.write_line(name + " = private unnamed_addr constant [" + str(str_len(s) + 1) + " x i8] c" + quote + escaped + "\\00" + quote + ", align 8")
        
        return self.output.build()
    
    /// Emit external function declarations (Kain runtime)
    fn emit_externals(self) -> Unit:
        self.write_line("; External Runtime Functions")
        self.write_line("declare i8* @malloc(i64)")
        self.write_line("declare void @free(i8*)")
        self.write_line("declare i32 @printf(i8*, ...)")
        self.write_line("declare i32 @puts(i8*)")
        self.write_line("declare i64 @kain_is_truthy(i64)")
        self.write_line("")
        self.write_line("; Kain Runtime")
        self.write_line("declare i64 @kain_print_i64(i64)")
        self.write_line("declare i64 @kain_print_str(i64)")
        self.write_line("declare i64 @kain_println_str(i64)")
        self.write_line("declare i64 @kain_str_concat(i64, i64)")
        self.write_line("declare i64 @kain_array_new()")
        self.write_line("declare i64 @kain_array_push(i64, i64)")
        self.write_line("declare i64 @kain_array_pop(i64)")
        self.write_line("declare i64 @kain_array_get(i64, i64)")
        self.write_line("declare i64 @kain_array_set(i64, i64, i64)")
        self.write_line("declare i64 @kain_array_len(i64)")
        self.write_line("declare i64 @Map_new()")
        self.write_line("declare i64 @kain_contains(i64, i64)")
        self.write_line("declare i64 @kain_contains_key(i64, i64)")
        self.write_line("declare void @kain_map_set(i64, i64, i64)")
        self.write_line("declare i64 @kain_map_get(i64, i64)")
        self.write_line("declare i64 @kain_split(i64, i64)")
        self.write_line("declare i64 @kain_join(i64, i64)")
        self.write_line("declare i64 @kain_str_starts_with(i64, i64)")
        self.write_line("declare i64 @kain_str_ends_with(i64, i64)")
        self.write_line("declare i64 @kain_str_replace(i64, i64, i64)")
        self.write_line("declare i64 @kain_str_len(i64)")
        self.write_line("declare i64 @kain_len(i64)")
        self.write_line("declare i64 @kain_str_eq(i64, i64)")
        self.write_line("declare i64 @kain_to_string(i64)")
        self.write_line("declare i64 @kain_to_int(i64)")
        self.write_line("declare i64 @kain_to_float(i64)")
        self.write_line("declare i64 @kain_range(i64, i64)")
        self.write_line("declare i64 @kain_ord(i64)")
        self.write_line("declare i64 @kain_chr(i64)")
        self.write_line("declare i64 @kain_char_at(i64, i64)")
        self.write_line("declare i64 @kain_char_code_at(i64, i64)")
        self.write_line("declare i64 @kain_file_read(i64)")
        self.write_line("declare i64 @kain_file_write(i64, i64)")
        self.write_line("declare i64 @read_file(i64)")
        self.write_line("declare i64 @write_file(i64, i64)")
        self.write_line("declare i64 @file_exists(i64)")
        self.write_line("declare i64 @kain_substring(i64, i64, i64)")
        self.write_line("declare void @kain_panic(i8*)")
        self.write_line("declare i64 @kain_variant_of(i64)")
        self.write_line("declare i64 @kain_variant_field(i64, i64)")
        self.write_line("declare i64 @kain_some(i64)")
        self.write_line("declare i64 @kain_none()")
        self.write_line("declare i64 @kain_alloc(i64)")
        self.write_line("declare i8* @kain_unbox_any_ptr(i64)")
        self.write_line("declare i64 @kain_box_ptr(i8*)")
        self.write_line("declare i64 @kain_add_op(i64, i64)")
        self.write_line("declare i64 @kain_sub_op(i64, i64)")
        self.write_line("declare i64 @kain_mul_op(i64, i64)")
        self.write_line("declare i64 @kain_div_op(i64, i64)")
        self.write_line("declare i64 @kain_rem_op(i64, i64)")
        self.write_line("declare i64 @kain_eq_op(i64, i64)")
        self.write_line("declare i64 @kain_neq_op(i64, i64)")
        self.write_line("declare i64 @kain_lt_op(i64, i64)")
        self.write_line("declare i64 @kain_le_op(i64, i64)")
        self.write_line("declare i64 @kain_gt_op(i64, i64)")
        self.write_line("declare i64 @kain_ge_op(i64, i64)")
        self.write_line("declare i64 @kain_create_token_simple(i64)")
        self.write_line("declare i64 @kain_create_token_payload(i64, i64)")
        self.write_line("declare i64 @args()")
        self.write_line("declare void @exit(i64)")
        self.write_line("declare i64 @kain_unwrap(i64)")
    
    fn emit_builtin_types(self) -> Unit:
        self.write_line("; Built-in Types")
        self.write_line("%Option = type { i64, i8*, i8* }")
        self.write_line("%Result = type { i64, i8*, i8* }")
        self.write_line("")
    
    /// Map Kain stdlib function names to their C runtime names
    fn map_function_name(self, name: String) -> String:
        // Core array operations
        if str_eq(name, "push"): return "kain_array_push"
        if str_eq(name, "pop"): return "kain_array_pop"
        if str_eq(name, "array_len"): return "kain_array_len"
        if str_eq(name, "array_get"): return "kain_array_get"
        
        // Map operations
        if str_eq(name, "contains_key"): return "kain_contains_key"
        if str_eq(name, "map_get"): return "kain_map_get"
        if str_eq(name, "map_set"): return "kain_map_set"
        
        // String operations
        if str_eq(name, "split"): return "kain_split"
        if str_eq(name, "join"): return "kain_join"
        if str_eq(name, "len"): return "kain_len"
        if str_eq(name, "str_len"): return "kain_str_len"
        if str_eq(name, "str_eq"): return "kain_str_eq"
        if str_eq(name, "substring"): return "kain_substring"
        if str_eq(name, "char_at"): return "kain_char_at"
        if str_eq(name, "char_code_at"): return "kain_char_code_at"
        if str_eq(name, "ord"): return "kain_ord"
        if str_eq(name, "chr"): return "kain_chr"
        if str_eq(name, "char_from_code"): return "kain_chr"
        
        // Type conversions
        if str_eq(name, "str"): return "kain_to_string"
        if str_eq(name, "to_int"): return "kain_to_int"
        if str_eq(name, "to_float"): return "kain_to_float"
        
        // Utility functions
        if str_eq(name, "range"): return "kain_range"
        if str_eq(name, "contains"): return "kain_contains"
        if str_eq(name, "println"): return "kain_println_str"
        if str_eq(name, "print"): return "kain_print_str"
        if str_eq(name, "panic"): return "kain_panic"
        if str_eq(name, "starts_with"): return "kain_str_starts_with"
        if str_eq(name, "ends_with"): return "kain_str_ends_with"
        if str_eq(name, "replace"): return "kain_str_replace"
        
        // File I/O
        if str_eq(name, "read_file"): return "read_file"
        if str_eq(name, "write_file"): return "write_file"
        if str_eq(name, "file_exists"): return "file_exists"
        
        // Variant introspection
        if str_eq(name, "variant_of"): return "kain_variant_of"
        if str_eq(name, "variant_field"): return "kain_variant_field"
        
        // Option
        if str_eq(name, "Some"): return "kain_some"
        if str_eq(name, "None"): return "kain_none"
        if str_eq(name, "unwrap"): return "kain_unwrap"
        
        // Memory
        if str_eq(name, "alloc"): return "kain_alloc"
        
        // Default: return as-is (user-defined function)
        return name
    
    fn escape_string(self, s: String) -> String:
        // Escape special chars for LLVM string literals
        // Use chr() to avoid bootstrap compiler escape sequence bugs
        let quote_char = chr(34)
        let backslash_char = chr(92)
        let result = ""
        let chars = split(s, "")
        for c in chars:
            if str_eq(c, "\n"):
                result = result + "\\0A"
            else if str_eq(c, "\t"):
                result = result + "\\09"
            else if str_eq(c, backslash_char):
                result = result + "\\5C"
            else if str_eq(c, quote_char):
                result = result + "\\22"
            else:
                result = result + c
        return result
    
    // =========================================================================
    // Item Generation
    // =========================================================================
    
    fn gen_item(self, item: TypedItem) -> Unit:
        let v = variant_of(item)
        
        // Check for both numeric tags (V1 bootstrap) and named variants
        if str_eq(v, "0") || str_eq(v, "Function"):
            let name = variant_field(item, 0)
            let params = variant_field(item, 1)
            let body = variant_field(item, 3)
            self.gen_function(name, params, body)
        else if str_eq(v, "1") || str_eq(v, "Struct"):
            let name = variant_field(item, 0)
            let fields = variant_field(item, 1)
            self.gen_struct(name, fields)
        else if str_eq(v, "2") || str_eq(v, "Enum"):
            let name = variant_field(item, 0)
            let variants = variant_field(item, 1)
            self.gen_enum(name, variants)
        else if str_eq(v, "3") || str_eq(v, "Impl"):
            let target = variant_field(item, 0)
            let methods = variant_field(item, 1)
            self.gen_impl(target, methods)
        else if str_eq(v, "5") || str_eq(v, "ExternFn"):
            let name = variant_field(item, 0)
            let params = variant_field(item, 1)
            let return_type = variant_field(item, 2)
            self.gen_extern_fn(name, params, return_type)
        // v == "4" or "Use" -> skip (no codegen needed)
            
    // =========================================================================
    // Declarations
    // =========================================================================
    
    fn gen_struct(self, name: String, fields_in: Array<TypedField>) -> Unit:
        self.write_line("; struct " + name)
        // For now, all fields are i64
        let types = ""
        let first = true
        
        let i = 0
        let len = array_len(fields_in)
        while i < len:
            // let field_def = fields_in[i] // Unused, avoid struct copy
            if !first:
                types = types + ", "
            types = types + "i64"
            first = false
            i = i + 1
            
        self.write_line("%" + name + " = type { " + types + " }")

    fn gen_enum(self, name: String, variants: Array<TypedVariant>) -> Unit:
        self.write_line("; enum " + name)
        self.write_line("%" + name + " = type { i64, i8*, i8* }")
        
        let i = 0
        let len = array_len(variants)
        while i < len:
            let variant = variants[i]
            self.write_line("; variant " + variant.name)
            i = i + 1

    fn gen_impl(self, target: String, methods: Array<TypedFunction>) -> Unit:
        self.write_line("; impl " + target)
        let i = 0
        let len = array_len(methods)
        while i < len:
            let method = methods[i]
            self.gen_function(method.name, method.params, method.body)
            i = i + 1
    
    /// Generate LLVM declaration for external function
    fn gen_extern_fn(self, name: String, params: Array<Param>, return_type: Array<ResolvedType>) -> Unit:
        // Build parameter list
        let params_ir = ""
        let first = true
        
        // FIX: Use while loop to avoid struct iteration bug
        let p_idx = 0
        let p_len = array_len(params)
        
        while p_idx < p_len:
            // let p = params[p_idx] // Unused, avoid struct copy crash
            if !first:
                params_ir = params_ir + ", "
            params_ir = params_ir + "i64"  // All types are i64 in NaN-boxing
            first = false
            p_idx = p_idx + 1
        
        // Determine return type
        let ret_ir = "i64"  // Default return type
        if array_len(return_type) > 0:
            let rt = return_type[0]
            let v = variant_of(rt)
            if str_eq(v, "Unit"):
                ret_ir = "void"
        
        // Map to runtime name
        let runtime_name = self.map_function_name(name)
        
        // Emit declaration (no body)
        self.write_line("declare " + ret_ir + " @" + runtime_name + "(" + params_ir + ")")
            
    fn gen_function(self, name_in: String, params_in: Array<TypedParam>, body_in: Array<TypedStmt>) -> Unit:
        let ctx = self.inner[0]
        let name = name_in
        
        // Rename main to main_kain to work with runtime's main wrapper
        if str_eq(name, "main"):
            name = "main_kain"
        
        // Mangling: if inside impl, prepend struct name
        if contains_key(ctx.method_map, name):
            let struct_name = map_get(ctx.method_map, name)
            // Verify this method belongs to this struct (simple check)
            // TODO: better name mangling
            name = struct_name + "_" + name
        
        let params_str = ""
        let first = true
        let p_idx = 0
        let params_len = array_len(params_in)
        while p_idx < params_len:
            let param = params_in[p_idx]
            if !first:
                params_str = params_str + ", "
            params_str = params_str + "i64 %" + param.name
            first = false
            p_idx = p_idx + 1
        
        self.write_line("define i64 @" + name + "(" + params_str + ") {")
        self.write_line("entry:")
        self.inc_indent()
        
        // Reset local counters and vars
        self.reset_locals()
        
        // Generate body
        let s_idx = 0
        let len = array_len(body_in)
        println("DEBUG gen_function: body_in len = " + str(len))
        while s_idx < len:
            println("DEBUG gen_function: processing stmt " + str(s_idx))
            let stmt = body_in[s_idx]
            self.gen_stmt(stmt)
            s_idx = s_idx + 1
            
        // Default return 0 (Unit) if not returned
        self.write_line("ret i64 0")
        
        self.dec_indent()
        self.write_line("}")
    
    // =========================================================================
    // Statements
    // =========================================================================
    
    fn gen_stmt(self, stmt: TypedStmt) -> Unit:
        let v = variant_of(stmt)
        println("DEBUG gen_stmt variant: " + v)
        println("DEBUG is Let? " + str(str_eq(v, "Let")))
        println("DEBUG is 0? " + str(str_eq(v, "0")))
        println("DEBUG is Expr? " + str(str_eq(v, "Expr")))
        println("DEBUG is 8? " + str(str_eq(v, "8")))
        
        if str_eq(v, "0") || str_eq(v, "Let"):
            let name = variant_field(stmt, 0)
            let val_expr = variant_field(stmt, 2)
            let val = self.gen_expr(val_expr.expr, val_expr.ty)
            
            // Allocate stack space
            let ptr = self.fresh_local()
            self.write_line(ptr + " = alloca i64")
            self.write_line("store i64 " + val + ", i64* " + ptr)
            self.add_var(name, ptr)
            return
            
        if str_eq(v, "1") || str_eq(v, "Var"):
            let name = variant_field(stmt, 0)
            let val_expr = variant_field(stmt, 2)
            let val = self.gen_expr(val_expr.expr, val_expr.ty)
            
            let ptr = self.fresh_local()
            self.write_line(ptr + " = alloca i64")
            self.write_line("store i64 " + val + ", i64* " + ptr)
            self.add_var(name, ptr)
            return
            
        if str_eq(v, "2") || str_eq(v, "Assign"):
            let target = variant_field(stmt, 0)
            let value = variant_field(stmt, 1)
            let val = self.gen_expr(value.expr, value.ty)
            
            // For now only Ident assignment
            // TODO: Field/Index assignment
            let target_expr = target.expr
            if str_eq(variant_of(target_expr), "Ident"):
                let name = variant_field(target_expr, 0)
                let ptr = self.find_var(name)
                if !str_eq(ptr, ""):
                    self.write_line("store i64 " + val + ", i64* " + ptr)
                else:
                    // Global or Param (can't assign to param currently without alloca)
                    // TODO: handle globals
                    ()
            return
            
        if str_eq(v, "3") || str_eq(v, "Return"):
            let expr_opt = variant_field(stmt, 0)
            if !str_eq(variant_of(expr_opt), "None") && !str_eq(variant_of(expr_opt), "1"):
                // Option<TypedExpr>
                // Need to unwrap option.
                // But wait, TypedStmt::Return(Option<TypedExpr>)
                // How to access Option value in Kain?
                // Option is enum: Some(val), None.
                let val = variant_field(expr_opt, 0) // Unwrap Some
                let res = self.gen_expr(val.expr, val.ty)
                self.write_line("ret i64 " + res)
            else:
                self.write_line("ret i64 0")
            return
            
        if str_eq(v, "8") || str_eq(v, "Expr"):
            let expr = variant_field(stmt, 0)
            self.gen_expr(expr.expr, expr.ty)
            return
            
        if str_eq(v, "4") || str_eq(v, "If"):
            let cond = variant_field(stmt, 0)
            let then_block = variant_field(stmt, 1)
            let else_block = variant_field(stmt, 2)
            
            let cond_val = self.gen_expr(cond.expr, cond.ty)
            // Compare with 0 (false)
            let cond_bool = self.fresh_local()
            self.write_line(cond_bool + " = icmp ne i64 " + cond_val + ", 0")
            
            let then_label = self.fresh_label("then")
            let else_label = self.fresh_label("else")
            let merge_label = self.fresh_label("merge")
            
            let has_else = !str_eq(variant_of(else_block), "None")
            // let actual_else = if has_else then else_label else merge_label
            let actual_else = merge_label
            if has_else:
                actual_else = else_label
            
            self.write_line("br i1 " + cond_bool + ", label %" + then_label + ", label %" + actual_else)
            
            self.write_line(then_label + ":")
            self.inc_indent()
            
            let t_idx = 0
            let t_len = array_len(then_block)
            while t_idx < t_len:
                let s = then_block[t_idx]
                self.gen_stmt(s)
                t_idx = t_idx + 1
                
            self.write_line("br label %" + merge_label)
            self.dec_indent()
            
            if has_else:
                self.write_line(else_label + ":")
                self.inc_indent()
                let else_stmts = variant_field(else_block, 0) // Unwrap Some
                
                let e_idx = 0
                let e_len = array_len(else_stmts)
                while e_idx < e_len:
                    let s = else_stmts[e_idx]
                    self.gen_stmt(s)
                    e_idx = e_idx + 1
                    
                self.write_line("br label %" + merge_label)
                self.dec_indent()
                
            self.write_line(merge_label + ":")
            return
            
        if str_eq(v, "5") || str_eq(v, "While"):
            let cond = variant_field(stmt, 0)
            let body = variant_field(stmt, 1)
            
            let cond_label = self.fresh_label("cond")
            let body_label = self.fresh_label("body")
            let end_label = self.fresh_label("end")
            
            // Push loop labels
            // TODO: stack of loop labels
            
            self.write_line("br label %" + cond_label)
            self.write_line(cond_label + ":")
            
            let cond_val = self.gen_expr(cond.expr, cond.ty)
            let cond_bool = self.fresh_local()
            self.write_line(cond_bool + " = icmp ne i64 " + cond_val + ", 0")
            self.write_line("br i1 " + cond_bool + ", label %" + body_label + ", label %" + end_label)
            
            self.write_line(body_label + ":")
            self.inc_indent()
            
            let b_idx = 0
            let b_len = array_len(body)
            while b_idx < b_len:
                let s = body[b_idx]
                self.gen_stmt(s)
                b_idx = b_idx + 1

            self.write_line("br label %" + cond_label)
            self.dec_indent()
            
            self.write_line(end_label + ":")
            return
            
        if str_eq(v, "Break"):
            // TODO: jump to end_label
            return
            
        if str_eq(v, "Continue"):
            // TODO: jump to cond_label
            return
            
        if str_eq(v, "For"):
            // TODO: implement for loop
            return
            
        if str_eq(v, "Match"):
             // TODO
             return
        
    
    // =========================================================================
    // Expressions
    // =========================================================================
    
    fn gen_expr(self, expr_in: TypedExprKind, ty_in: Array<ResolvedType>) -> String:
        let expr = expr_in
        let v = variant_of(expr)
        
        if str_eq(v, "0") || str_eq(v, "Int"):
            let val = variant_field(expr, 0)
            let result = self.fresh_local()
            self.write_line(result + " = add i64 " + str(val) + ", -2216615441596416")
            return result
            
        if str_eq(v, "Float"):
            // TODO: float constants - need proper IEEE 754 bit handling
            return "0"
            
        if str_eq(v, "2") || str_eq(v, "Bool"):
            let val = variant_field(expr, 0)
            return nanbox_bool(val)
            
        if str_eq(v, "3") || str_eq(v, "String"):
            let s = variant_field(expr, 0)
            let id = self.add_string_literal(s)
            
            let str_name = "@.str." + str(id)
            let len = str_len(s) + 1
            
            // Get pointer as raw i64 (matches runtime's kain_box_string behavior)
            // The runtime returns raw pointers, so we must too for str_eq to work
            let ptr = self.fresh_local()
            self.write_line(ptr + " = ptrtoint [" + str(len) + " x i8]* " + str_name + " to i64")
            return ptr
            
        if str_eq(v, "4") || str_eq(v, "Ident"):
            let name = variant_field(expr, 0)
            
            if contains_key(self.vars, name):
                let ptr = self.find_var(name)
                let result = self.fresh_local()
                self.write_line(result + " = load i64, i64* " + ptr)
                return result
            
            // Assume param or global
            return "%" + name
            
        if str_eq(v, "5") || str_eq(v, "Binary"):
            // TypedExpr::Binary stores Box<TypedExpr> pointers
            let left_box = variant_field(expr, 0)
            let op = variant_field(expr, 1)
            let right_box = variant_field(expr, 2)
            
            let left_e = left_box[0]
            let right_e = right_box[0]
            let left_val = self.gen_expr(left_e.expr, left_e.ty)
            let right_val = self.gen_expr(right_e.expr, right_e.ty)
            
            let res = self.fresh_local()
            
            if str_eq(op, "+"):
                self.write_line(res + " = call i64 @kain_add_op(i64 " + left_val + ", i64 " + right_val + ")")
            else if str_eq(op, "-"):
                self.write_line(res + " = call i64 @kain_sub_op(i64 " + left_val + ", i64 " + right_val + ")")
            else if str_eq(op, "*"):
                self.write_line(res + " = call i64 @kain_mul_op(i64 " + left_val + ", i64 " + right_val + ")")
            else if str_eq(op, "/"):
                self.write_line(res + " = call i64 @kain_div_op(i64 " + left_val + ", i64 " + right_val + ")")
            else if str_eq(op, "%"):
                self.write_line(res + " = call i64 @kain_rem_op(i64 " + left_val + ", i64 " + right_val + ")")
            else if str_eq(op, "=="):
                self.write_line(res + " = call i64 @kain_eq_op(i64 " + left_val + ", i64 " + right_val + ")")
            else if str_eq(op, "!="):
                self.write_line(res + " = call i64 @kain_neq_op(i64 " + left_val + ", i64 " + right_val + ")")
            else if str_eq(op, "<"):
                self.write_line(res + " = call i64 @kain_lt_op(i64 " + left_val + ", i64 " + right_val + ")")
            else if str_eq(op, ">"):
                self.write_line(res + " = call i64 @kain_gt_op(i64 " + left_val + ", i64 " + right_val + ")")
            else if str_eq(op, "<="):
                self.write_line(res + " = call i64 @kain_le_op(i64 " + left_val + ", i64 " + right_val + ")")
            else if str_eq(op, ">="):
                self.write_line(res + " = call i64 @kain_ge_op(i64 " + left_val + ", i64 " + right_val + ")")
            else:
                return "0"
                
            return res
            
        if str_eq(v, "Unary"):
            let op = variant_field(expr, 0)
            let operand = variant_field(expr, 1)
            let op_e = operand[0]
            let val = self.gen_expr(op_e.expr, op_e.ty)
            let res = self.fresh_local()
            
            if str_eq(op, "-"):
                self.write_line(res + " = sub i64 0, " + val)
            else if str_eq(op, "!"):
                let tmp = self.fresh_local()
                self.write_line(tmp + " = icmp eq i64 " + val + ", 0")
                self.write_line(res + " = zext i1 " + tmp + " to i64")
            else:
                return val
            return res
            
        if str_eq(v, "7") || str_eq(v, "Call"):
            let callee = variant_field(expr, 0)
            let args = variant_field(expr, 1)
            
            // Assume callee is Ident for now
            let callee_boxed = callee[0]
            let callee_expr = callee_boxed.expr
            if str_eq(variant_of(callee_expr), "Ident"):
                let name = variant_field(callee_expr, 0)
                
                // Map built-in functions
                if str_eq(name, "println"):
                    name = "kain_println_str"
                else if str_eq(name, "print"):
                    name = "kain_print_str"
                else if str_eq(name, "str"):
                    name = "kain_to_string"
                
                let args_str = ""
                let first = true
                for arg in args:
                    let arg_val = self.gen_expr(arg.expr, arg.ty)
                    if !first:
                        args_str = args_str + ", "
                    args_str = args_str + "i64 " + arg_val
                    first = false
                
                let res = self.fresh_local()
                self.write_line(res + " = call i64 @" + name + "(" + args_str + ")")
                return res
            
            return "0"
            
        if str_eq(v, "8") || str_eq(v, "MethodCall"):
            let receiver = variant_field(expr, 0)
            let method = variant_field(expr, 1)
            let args = variant_field(expr, 2)
            
            let receiver_boxed = receiver[0]
            let receiver_val = self.gen_expr(receiver_boxed.expr, receiver_boxed.ty)
            
            // Get receiver type to mangle name
            let receiver_ty = receiver_boxed.ty
            let type_name = ""
            let ty_v = variant_of(receiver_ty)
            if str_eq(ty_v, "Struct"):
                type_name = variant_field(receiver_ty, 0)
            else if str_eq(ty_v, "Enum"):
                type_name = variant_field(receiver_ty, 0)
            else:
                type_name = ty_v // Int, String etc.
            
            let func_name = type_name + "_" + method
            
            let args_str = "i64 " + receiver_val
            for arg in args:
                let arg_val = self.gen_expr(arg.expr, arg.ty)
                args_str = args_str + ", i64 " + arg_val
            
            let res = self.fresh_local()
            self.write_line(res + " = call i64 @" + func_name + "(" + args_str + ")")
            return res
            
        if str_eq(v, "Field"):
            let obj = variant_field(expr, 0)
            let field_name = variant_field(expr, 1)
            
            let obj_boxed = obj[0]
            let obj_val = self.gen_expr(obj_boxed.expr, obj_boxed.ty)
            let obj_ty = obj_boxed.ty
            
            // Get struct name
            let struct_name = ""
            // obj_ty is Array<ResolvedType>
            if array_len(obj_ty) > 0:
                let ty_v = variant_of(obj_ty[0])
                if str_eq(ty_v, "Struct"):
                    struct_name = variant_field(obj_ty[0], 0)
                else:
                    return "0"
            else:
                return "0"
            
            // Find field index
            if contains_key(self.struct_layouts, struct_name):
                let fields = map_get(self.struct_layouts, struct_name)
                let idx = -1
                let i = 0
                for f in fields:
                    if str_eq(f, field_name):
                        idx = i
                        break
                    i = i + 1
                
                if idx != -1:
                    let obj_ptr = self.fresh_local()
                    self.write_line(obj_ptr + " = inttoptr i64 " + obj_val + " to %" + struct_name + "*")
                    let field_ptr = self.fresh_local()
                    self.write_line(field_ptr + " = getelementptr %" + struct_name + ", %" + struct_name + "* " + obj_ptr + ", i32 0, i32 " + str(idx))
                    let res = self.fresh_local()
                    self.write_line(res + " = load i64, i64* " + field_ptr)
                    return res
            
            return "0"
            
        if str_eq(v, "Struct"):
            let name = variant_field(expr, 0)
            let inits = variant_field(expr, 1) // Array<TypedFieldInit>
            
            // Allocate struct
            let ptr = self.fresh_local()
            let fields_count = 0
            if contains_key(self.struct_layouts, name):
                fields_count = array_len(map_get(self.struct_layouts, name))
            
            let size = fields_count * 8
            if size == 0: size = 8 // Min size
            
            self.write_line(ptr + " = call i64 @kain_alloc(i64 " + str(size) + ")")
            let struct_ptr = self.fresh_local()
            self.write_line(struct_ptr + " = inttoptr i64 " + ptr + " to %" + name + "*")
            
            // Initialize fields
            if contains_key(self.struct_layouts, name):
                let fields = map_get(self.struct_layouts, name)
                
                for init in inits:
                    let init_name = init.name
                    let val_e = init.value
                    let init_val = self.gen_expr(val_e.expr, val_e.ty)
                    
                    let idx = -1
                    let i = 0
                    for f in fields:
                        if str_eq(f, init_name):
                            idx = i
                            break
                        i = i + 1
                    
                    if idx != -1:
                        let field_ptr = self.fresh_local()
                        self.write_line(field_ptr + " = getelementptr %" + name + ", %" + name + "* " + struct_ptr + ", i32 0, i32 " + str(idx))
                        self.write_line("store i64 " + init_val + ", i64* " + field_ptr)
            
            return ptr
            
        if str_eq(v, "EnumVariant"):
            let enum_name = variant_field(expr, 0)
            let variant_name = variant_field(expr, 1)
            let args = variant_field(expr, 2)
            
            // Special handling for Box::new
            if str_eq(enum_name, "Box") && str_eq(variant_name, "new"):
                let arg_val = "0"
                if array_len(args) > 0:
                    let arg_e = args[0]
                    arg_val = self.gen_expr(arg_e.expr, arg_e.ty)
                let result = self.fresh_local()
                self.write_line(result + " = call i64 @kain_box(i64 " + arg_val + ")")
                return result
            
            // Special handling for Map::new
            if str_eq(enum_name, "Map") && str_eq(variant_name, "new"):
                let result = self.fresh_local()
                self.write_line(result + " = call i64 @Map_new()")
                return result
            
            // Check if this is a static method call on a struct (e.g., Token::new)
            if contains_key(self.struct_layouts, enum_name):
                // It's a struct type - treat as static method call
                let mangled = enum_name + "_" + variant_name
                let args_str = ""
                let first = true
                for arg in args:
                    let arg_val = self.gen_expr(arg.expr, arg.ty)
                    if !first:
                        args_str = args_str + ", "
                    args_str = args_str + "i64 " + arg_val
                    first = false
                let result = self.fresh_local()
                self.write_line(result + " = call i64 @" + mangled + "(" + args_str + ")")
                return result
            
            // Otherwise, it's an actual enum variant
            // println("DEBUG: Gen EnumVariant dynamic: " + enum_name + "::" + variant_name)
            self.write_line("; enum variant: " + enum_name + "::" + variant_name)
            
            // TODO: Look up tag from variant_map. For now, use 0 as default.
            let tag_idx = 0
            
            // Allocate 24 bytes for enum: { i64, i8*, i8* }
            let ptr_i8 = self.fresh_local()
            self.write_line(ptr_i8 + " = call i8* @malloc(i64 24)")
            let ptr = self.fresh_local()
            self.write_line(ptr + " = bitcast i8* " + ptr_i8 + " to %" + enum_name + "*")
            
            // Store tag at field 0
            let tag_ptr = self.fresh_local()
            self.write_line(tag_ptr + " = getelementptr %" + enum_name + ", %" + enum_name + "* " + ptr + ", i32 0, i32 0")
            self.write_line("store i64 " + str(tag_idx) + ", i64* " + tag_ptr)
            
            // Store payload at field 1
            let payload_ptr = self.fresh_local()
            self.write_line(payload_ptr + " = getelementptr %" + enum_name + ", %" + enum_name + "* " + ptr + ", i32 0, i32 1")
            if array_len(args) > 0:
                // Allocate tuple for payload
                let tuple_size = array_len(args) * 8
                let tuple_i8 = self.fresh_local()
                self.write_line(tuple_i8 + " = call i8* @malloc(i64 " + str(tuple_size) + ")")
                let tuple_ptr = self.fresh_local()
                self.write_line(tuple_ptr + " = bitcast i8* " + tuple_i8 + " to i64*")
                
                // Store each arg in tuple
                let arg_idx = 0
                for arg in args:
                    let arg_val = self.gen_expr(arg.expr, arg.ty)
                    let slot_ptr = self.fresh_local()
                    self.write_line(slot_ptr + " = getelementptr i64, i64* " + tuple_ptr + ", i32 " + str(arg_idx))
                    self.write_line("store i64 " + arg_val + ", i64* " + slot_ptr)
                    arg_idx = arg_idx + 1
                
                // Store tuple pointer as payload
                self.write_line("store i8* " + tuple_i8 + ", i8** " + payload_ptr)
            else:
                // Null payload 
                self.write_line("store i8* null, i8** " + payload_ptr)
            
            // Store variant name at field 2
            let name_str_id = self.string_counter
            self.string_counter = self.string_counter + 1
            push(self.strings, variant_name)
            
            let name_ptr_reg = self.fresh_local()
            self.write_line(name_ptr_reg + " = getelementptr %" + enum_name + ", %" + enum_name + "* " + ptr + ", i32 0, i32 2")
            let str_const_ptr = self.fresh_local()
            let name_len = str_len(variant_name) + 1
            self.write_line(str_const_ptr + " = getelementptr [" + str(name_len) + " x i8], [" + str(name_len) + " x i8]* @.str." + str(name_str_id) + ", i64 0, i64 0")
            self.write_line("store i8* " + str_const_ptr + ", i8** " + name_ptr_reg)
            
            // Return pointer as i64
            let int_val = self.fresh_local()
            self.write_line(int_val + " = ptrtoint %" + enum_name + "* " + ptr + " to i64")
            return int_val
            
        if str_eq(v, "None"):
            return "0"
        
        return "0"

    // =========================================================================
    // UNTYPED Code Generation (works with raw AST, bypasses type checker)
    // =========================================================================
    
    fn gen_item_untyped(self, item: Item) -> Unit:
        let v = variant_of(item)
        // Dispatch based on item variant
        if str_eq(v, "Function"):
            let def = variant_field(item, 0)
            self.gen_function_untyped(def)
        else if str_eq(v, "Struct"):
            let def = variant_field(item, 0)
            self.gen_struct_untyped(def)
        else if str_eq(v, "Enum"):
            let def = variant_field(item, 0)
            self.gen_enum_untyped(def)
        else if str_eq(v, "Impl"):
            let def = variant_field(item, 0)
            self.gen_impl_untyped(def)
        else if str_eq(v, "Use"):
            let path = variant_field(item, 0)
            self.write_line("; use " + path)
        else if str_eq(v, "ExternFn"):
            let def = variant_field(item, 0)
            self.gen_extern_fn_untyped(def)
    
    fn gen_struct_untyped(self, struct_def: StructDef) -> Unit:
        // println("DEBUG: gen_struct_untyped " + struct_def.name + " fields len=" + str(array_len(struct_def.fields)))
        self.write_line("; struct " + struct_def.name)
        let fields_str = ""
        let first = true
        let field_count = 0
        for field in struct_def.fields:
            // println("DEBUG: gen_struct field " + str(field_count))
            if !first:
                fields_str = fields_str + ", "
            first = false
            fields_str = fields_str + "i64"
            field_count = field_count + 1
        // println("DEBUG: gen_struct total fields=" + str(field_count))
        if str_eq(fields_str, ""):
            fields_str = "i64"
        self.write_line("%" + struct_def.name + " = type { " + fields_str + " }")
    
    /// Helper to register struct fields - workaround for variant_field + field access bug
    fn register_struct_fields(self, struct_def: StructDef) -> Unit:
        // println("DEBUG: register_struct_fields " + struct_def.name + " fields len=" + str(array_len(struct_def.fields)))
        let field_names = []
        for f in struct_def.fields:
            // println("DEBUG:   field: " + f.name)
            push(field_names, f.name)
            map_set(self.field_map, f.name, struct_def.name)
        map_set(self.struct_layouts, struct_def.name, field_names)
        // println("DEBUG: Registered " + struct_def.name + " with " + str(array_len(field_names)) + " fields")
    
    /// Helper to register impl methods - workaround for variant_field + field access bug
    fn register_impl_methods(self, impl_def: ImplDef) -> Unit:
        // println("DEBUG: register_impl_methods " + impl_def.target + " methods len=" + str(array_len(impl_def.methods)))
        for m_box in impl_def.methods:
            // methods are boxed as Array<FnDef>, unbox first
            let m = m_box[0]
            map_set(self.method_map, m.name, impl_def.target)
    
    fn gen_enum_untyped(self, enum_def: EnumDef) -> Unit:
        self.write_line("; enum " + enum_def.name)
        // Enums are {tag: i64, payload: i8*, name: i8*}
        // MUST match bootstrap compiler layout for runtime compatibility
        self.write_line("%" + enum_def.name + " = type { i64, i8*, i8* }")
    
    /// Generate LLVM declaration for external function (untyped path)
    fn gen_extern_fn_untyped(self, def: ExternFnDef) -> Unit:
        // Build parameter list
        let params_ir = ""
        let first = true
        for p in def.params:
            if !first:
                params_ir = params_ir + ", "
            params_ir = params_ir + "i64"
            first = false
        
        // Determine return type
        let ret_ir = "i64"
        if array_len(def.return_type) == 0:
            ret_ir = "void"
        
        // Map to runtime name
        let runtime_name = self.map_function_name(def.name)
        
        self.write_line("declare " + ret_ir + " @" + runtime_name + "(" + params_ir + ")")
    
    /// Helper to generate field access IR - separated to avoid nested control flow bugs
    fn gen_field_access(self, obj_val: String, field_name: String) -> String:
        // println("DEBUG: gen_field_access obj_val=" + obj_val + " field=" + field_name)
        // Check if field exists in field_map
        if !contains_key(self.field_map, field_name):
            // println("DEBUG: gen_field_access field not in field_map")
            return "0"
        
        let struct_name = map_get(self.field_map, field_name)
        // println("DEBUG: gen_field_access struct_name=" + struct_name)
        
        // Check if struct exists in layouts
        if !contains_key(self.struct_layouts, struct_name):
            // println("DEBUG: gen_field_access struct not in layouts")
            return "0"
        
        // println("DEBUG: gen_field_access calling find_field_index")
        let idx = self.find_field_index(struct_name, field_name)
        // println("DEBUG: gen_field_access idx=" + str(idx))
        
        if idx == -1:
            return "0"
        
        // println("DEBUG: gen_field_access generating IR")
        // Generate the IR
        let unboxed = self.fresh_local()
        self.write_line(unboxed + " = call i8* @kain_unbox_any_ptr(i64 " + obj_val + ")")
        
        let obj_ptr = self.fresh_local()
        self.write_line(obj_ptr + " = bitcast i8* " + unboxed + " to %" + struct_name + "*")
        
        // println("DEBUG: gen_field_access getelementptr")
        let field_ptr = self.fresh_local()
        self.write_line(field_ptr + " = getelementptr %" + struct_name + ", %" + struct_name + "* " + obj_ptr + ", i32 0, i32 " + str(idx))
        
        // println("DEBUG: gen_field_access load")
        let res = self.fresh_local()
        self.write_line(res + " = load i64, i64* " + field_ptr)
        // println("DEBUG: gen_field_access done, returning " + res)
        return res
    
    /// Find the index of a field in a struct - uses while loop to avoid for+if codegen bugs
    fn find_field_index(self, struct_name: String, field_name: String) -> Int:
        if !contains_key(self.struct_layouts, struct_name):
            return -1
        
        let fields = map_get(self.struct_layouts, struct_name)
        let len = array_len(fields)
        let i = 0
        let result = -1
        while i < len:
            let f = fields[i]
            
            // Manual string comparison to avoid potential str_eq bugs in bootstrap
            let is_match = false
            let len_f = str_len(f)
            let len_fn = str_len(field_name)
            
            if len_f == len_fn:
                let j = 0
                let slen = len_f
                let match_chars = true
                while j < slen:
                    let c1 = substring(f, j, j+1)
                    let c2 = substring(field_name, j, j+1)
                    if ord(c1) != ord(c2):
                        match_chars = false
                        break
                    j = j + 1
                is_match = match_chars
            
            if is_match:
                result = i
                // break emulation
                i = len 
            else:
                i = i + 1
        
        return result
    
    /// Helper to generate struct field initialization
    fn gen_struct_field_init(self, struct_name: String, struct_ptr: String, init: FieldInit, init_idx: Int) -> Unit:
        let init_name = init.name
        let init_val = self.gen_expr_untyped(init.value)
        
        let idx = self.find_field_index(struct_name, init_name)
        
        // Use idx >= 0 instead of idx != -1 to avoid comparison bug
        let is_valid = idx >= 0
        if is_valid:
            let field_ptr = self.fresh_local()
            self.write_line(field_ptr + " = getelementptr %" + struct_name + ", %" + struct_name + "* " + struct_ptr + ", i32 0, i32 " + str(idx))
            self.write_line("store i64 " + init_val + ", i64* " + field_ptr)
    
    fn gen_impl_untyped(self, impl_def: ImplDef) -> Unit:
        // println("DEBUG: gen_impl_untyped target=" + impl_def.target)
        self.write_line("; impl " + impl_def.target)
        let method_idx = 0
        for method_box in impl_def.methods:
            // methods are boxed as Array<FnDef>, unbox first
            let method = method_box[0]
            // println("DEBUG: impl method " + str(method_idx) + " name=" + method.name)
            let orig_name = method.name
            method.name = impl_def.target + "_" + method.name
            self.gen_function_untyped(method)
            method.name = orig_name
            method_idx = method_idx + 1
        // println("DEBUG: gen_impl_untyped DONE")
    
    fn gen_function_untyped(self, fn_def: FnDef) -> Unit:
        let name = fn_def.name
        
        if str_eq(name, "main"):
            name = "main_kain"
        
        self.local_counter = 0
        self.vars = []
        
        let params_str = ""
        let first = true
        for param in fn_def.params:
            if !first:
                params_str = params_str + ", "
            first = false
            params_str = params_str + "i64 %" + param.name
        
        self.write_line("define i64 @" + name + "(" + params_str + ") {")
        self.indent = self.indent + 1
        self.write_line("entry:")
        
        let stmt_idx = 0
        let last_was_return = false
        for stmt in fn_def.body:
            self.gen_stmt_untyped(stmt)
            let v = variant_of(stmt)
            last_was_return = (str_eq(v, "Return")) || (str_eq(v, "7"))
            stmt_idx = stmt_idx + 1
        
        // Only add default return if body doesn't end with a return
        if !last_was_return:
            self.write_line("ret i64 0")
        self.indent = self.indent - 1
        self.write_line("}")
    
    fn gen_assign_ident(self, name: String, val: String) -> Unit:
        let ptr = self.find_var(name)
        if !str_eq(ptr, ""):
            self.write_line("store i64 " + val + ", i64* " + ptr)

    fn gen_assign_field(self, obj: Expr, field_name: String, val: String) -> Unit:
        let obj_ptr_i64 = self.gen_expr_untyped(obj)
        
        if !contains_key(self.field_map, field_name):
            return
            
        let struct_name = map_get(self.field_map, field_name)
        let index = self.find_field_index(struct_name, field_name)
        
        if index < 0:
            return
            
        let unboxed = self.fresh_local()
        self.write_line(unboxed + " = call i8* @kain_unbox_any_ptr(i64 " + obj_ptr_i64 + ")")
        
        let obj_ptr = self.fresh_local()
        self.write_line(obj_ptr + " = bitcast i8* " + unboxed + " to %" + struct_name + "*")
        let field_ptr = self.fresh_local()
        self.write_line(field_ptr + " = getelementptr %" + struct_name + ", %" + struct_name + "* " + obj_ptr + ", i32 0, i32 " + str(index))
        self.write_line("store i64 " + val + ", i64* " + field_ptr)

    fn gen_assign_stmt(self, lhs: Expr, rhs: Expr) -> Unit:
        let val = self.gen_expr_untyped(rhs)
        let lhs_v = variant_of(lhs)
        
        if str_eq(lhs_v, "Ident"):
            let name = variant_field(lhs, 0)
            self.gen_assign_ident(name, val)
            return
            
        if str_eq(lhs_v, "Field"):
            let obj = variant_field(lhs, 0)
            let field_name = variant_field(lhs, 1)
            self.gen_assign_field(obj, field_name, val)
            return

    fn gen_return_stmt(self, maybe_expr: Expr) -> Unit:
        // maybe_expr is an Option<Expr> - variant is "Some" or "None"
        let v = variant_of(maybe_expr)
        if str_eq(v, "Some") || str_eq(v, "1"):
            // Unwrap the expression from Some(expr)
            let expr = variant_field(maybe_expr, 0)
            let val = self.gen_expr_untyped(expr)
            self.write_line("ret i64 " + val)
            return
        self.write_line("ret i64 0")

    fn gen_block(self, block: Array<Stmt>) -> Unit:
        let i = 0
        let len = array_len(block)
        while i < len:
            let s = block[i]
            self.gen_stmt_untyped(s)
            i = i + 1

    fn gen_if_stmt(self, cond: Expr, then_block: Array<Stmt>, else_block: Any) -> Unit:
        let cond_val = self.gen_expr_untyped(cond)
        let is_truthy = self.fresh_local()
        self.write_line(is_truthy + " = call i64 @kain_is_truthy(i64 " + cond_val + ")")
        let cond_bool = self.fresh_local()
        self.write_line(cond_bool + " = icmp ne i64 " + is_truthy + ", 0")
        
        let then_label = self.fresh_label("then")
        let else_label = self.fresh_label("else")
        let end_label = self.fresh_label("endif")
        
        if !str_eq(variant_of(else_block), "None"):
            self.write_line("br i1 " + cond_bool + ", label %" + then_label + ", label %" + else_label)
        else:
            self.write_line("br i1 " + cond_bool + ", label %" + then_label + ", label %" + end_label)
        
        self.write_line(then_label + ":")
        self.gen_block(then_block)
        self.write_line("br label %" + end_label)
        
        if !str_eq(variant_of(else_block), "None"):
            let block = variant_field(else_block, 0)
            self.write_line(else_label + ":")
            self.gen_block(block)
            self.write_line("br label %" + end_label)
        
        self.write_line(end_label + ":")

    fn gen_while_stmt(self, cond: Expr, body: Array<Stmt>) -> Unit:
        let cond_label = self.fresh_label("while_cond")
        let body_label = self.fresh_label("while_body")
        let end_label = self.fresh_label("while_end")
        
        push(self.loop_labels, end_label)
        push(self.loop_continue_labels, cond_label)
        
        self.write_line("br label %" + cond_label)
        self.write_line(cond_label + ":")
        let cond_val = self.gen_expr_untyped(cond)
        let is_truthy = self.fresh_local()
        self.write_line(is_truthy + " = call i64 @kain_is_truthy(i64 " + cond_val + ")")
        let cond_bool = self.fresh_local()
        self.write_line(cond_bool + " = icmp ne i64 " + is_truthy + ", 0")
        self.write_line("br i1 " + cond_bool + ", label %" + body_label + ", label %" + end_label)
        
        self.write_line(body_label + ":")
        self.gen_block(body)
        self.write_line("br label %" + cond_label)
        self.write_line(end_label + ":")
        
        pop(self.loop_labels)
        pop(self.loop_continue_labels)

    fn gen_stmt_untyped(self, stmt: Stmt) -> Unit:
        let v = variant_of(stmt)
        
        if str_eq(v, "Let"):
            let name = variant_field(stmt, 0)
            let value = variant_field(stmt, 2)
            let val_reg = self.gen_expr_untyped(value)
            let ptr = self.fresh_local()
            self.write_line(ptr + " = alloca i64")
            self.write_line("store i64 " + val_reg + ", i64* " + ptr)
            push(self.vars, VarInfo { name: name, ptr: ptr })
            return
        
        if str_eq(v, "Var"):
            let name = variant_field(stmt, 0)
            let value = variant_field(stmt, 2)
            let val_reg = self.gen_expr_untyped(value)
            let ptr = self.fresh_local()
            self.write_line(ptr + " = alloca i64")
            self.write_line("store i64 " + val_reg + ", i64* " + ptr)
            push(self.vars, VarInfo { name: name, ptr: ptr })
            return
        
        if str_eq(v, "Return"):
            let maybe_expr = variant_field(stmt, 0)
            self.gen_return_stmt(maybe_expr)
            return
        
        if str_eq(v, "Expr"):
            let expr = variant_field(stmt, 0)
            self.gen_expr_untyped(expr)
            return
        
        if str_eq(v, "If"):
            let cond = variant_field(stmt, 0)
            let then_block = variant_field(stmt, 1)
            let else_block = variant_field(stmt, 2)
            self.gen_if_stmt(cond, then_block, else_block)
            return
        
        if str_eq(v, "While"):
            let cond = variant_field(stmt, 0)
            let body = variant_field(stmt, 1)
            self.gen_while_stmt(cond, body)
            return
        
        if str_eq(v, "For"):
            let var_name = variant_field(stmt, 0)
            let iter_expr = variant_field(stmt, 1)
            let body = variant_field(stmt, 2)

            // Generate labels
            let cond_label = self.fresh_label("for_cond")
            let body_label = self.fresh_label("for_body")
            let inc_label = self.fresh_label("for_inc")
            let end_label = self.fresh_label("for_end")

            // Push loop labels for break/continue
            push(self.loop_labels, end_label)
            push(self.loop_continue_labels, inc_label)

            // Evaluate iterator expression
            let iter_val = self.gen_expr_untyped(iter_expr)

            // Get array length (returns raw int)
            let len_val = self.fresh_local()
            self.write_line(len_val + " = call i64 @array_len(i64 " + iter_val + ")")

            // Allocate index counter (raw int)
            let idx_ptr = self.fresh_local()
            self.write_line(idx_ptr + " = alloca i64")
            self.write_line("store i64 0, i64* " + idx_ptr)

            // Allocate loop variable (will hold boxed values)
            let var_ptr = self.fresh_local()
            self.write_line(var_ptr + " = alloca i64")
            self.add_var(var_name, var_ptr)

            // Jump to condition
            self.write_line("br label %" + cond_label)

            // Condition block
            self.write_line(cond_label + ":")
            let idx_val = self.fresh_local()
            self.write_line(idx_val + " = load i64, i64* " + idx_ptr)

            // Compare raw integers
            let cmp = self.fresh_local()
            self.write_line(cmp + " = icmp slt i64 " + idx_val + ", " + len_val)
            self.write_line("br i1 " + cmp + ", label %" + body_label + ", label %" + end_label)

            // Body block
            self.write_line(body_label + ":")

            // Load element: array[idx]
            let elem_val = self.fresh_local()
            self.write_line(elem_val + " = call i64 @array_get(i64 " + iter_val + ", i64 " + idx_val + ")")
            self.write_line("store i64 " + elem_val + ", i64* " + var_ptr)

            // Execute body statements
            let body_idx = 0
            let body_len = array_len(body)
            while body_idx < body_len:
                let s = body[body_idx]
                self.gen_stmt_untyped(s)
                body_idx = body_idx + 1

            // Jump to increment
            self.write_line("br label %" + inc_label)

            // Increment block
            self.write_line(inc_label + ":")
            let idx_loaded = self.fresh_local()
            self.write_line(idx_loaded + " = load i64, i64* " + idx_ptr)

            // Add 1 to index (raw integer arithmetic)
            let idx_incremented = self.fresh_local()
            self.write_line(idx_incremented + " = add i64 " + idx_loaded + ", 1")
            self.write_line("store i64 " + idx_incremented + ", i64* " + idx_ptr)

            // Jump back to condition
            self.write_line("br label %" + cond_label)

            // End block
            self.write_line(end_label + ":")

            // Pop loop labels
            pop(self.loop_labels)
            pop(self.loop_continue_labels)
            return
        
        if str_eq(v, "Loop"):
            let body = variant_field(stmt, 0)
            let loop_label = self.fresh_label("loop")
            let end_label = self.fresh_label("loop_end")
            
            push(self.loop_labels, end_label)
            push(self.loop_continue_labels, loop_label)
            
            self.write_line("br label %" + loop_label)
            self.write_line(loop_label + ":")
            for s in body:
                self.gen_stmt_untyped(s)
            self.write_line("br label %" + loop_label)
            self.write_line(end_label + ":")
            
            pop(self.loop_labels)
            pop(self.loop_continue_labels)
            return
        
        if str_eq(v, "Match"):
            self.write_line("; match (TODO)")
            return
        
        if str_eq(v, "Break"):
            if array_len(self.loop_labels) > 0:
                let end_label = self.loop_labels[array_len(self.loop_labels) - 1]
                self.write_line("br label %" + end_label)
            return
        
        if str_eq(v, "Continue"):
            if array_len(self.loop_continue_labels) > 0:
                let loop_label = self.loop_continue_labels[array_len(self.loop_continue_labels) - 1]
                self.write_line("br label %" + loop_label)
            return
        
        if str_eq(v, "Assign"):
            let lhs = variant_field(stmt, 0)
            let rhs = variant_field(stmt, 1)
            self.gen_assign_stmt(lhs, rhs)
            return
    
    fn gen_binary_expr(self, left: Expr, op: String, right: Expr) -> String:
        let left_val = self.gen_expr_untyped(left)
        let right_val = self.gen_expr_untyped(right)
        let res = self.fresh_local()
        
        if str_eq(op, "+"):
            // Use kain_add_op for polymorphic add (handles both int and string)
            self.write_line(res + " = call i64 @kain_add_op(i64 " + left_val + ", i64 " + right_val + ")")
            return res
        
        if str_eq(op, "-"):
            self.write_line(res + " = call i64 @kain_sub_op(i64 " + left_val + ", i64 " + right_val + ")")
            return res
            
        if str_eq(op, "*"):
            self.write_line(res + " = call i64 @kain_mul_op(i64 " + left_val + ", i64 " + right_val + ")")
            return res
            
        if str_eq(op, "/"):
            self.write_line(res + " = call i64 @kain_div_op(i64 " + left_val + ", i64 " + right_val + ")")
            return res
            
        if str_eq(op, "%"):
            self.write_line(res + " = call i64 @kain_rem_op(i64 " + left_val + ", i64 " + right_val + ")")
            return res
            
        if str_eq(op, "=="):
            self.write_line(res + " = call i64 @kain_eq_op(i64 " + left_val + ", i64 " + right_val + ")")
            return res
            
        if str_eq(op, "!="):
            self.write_line(res + " = call i64 @kain_neq_op(i64 " + left_val + ", i64 " + right_val + ")")
            return res
            
        if str_eq(op, "<"):
            self.write_line(res + " = call i64 @kain_lt_op(i64 " + left_val + ", i64 " + right_val + ")")
            return res
            
        if str_eq(op, ">"):
            self.write_line(res + " = call i64 @kain_gt_op(i64 " + left_val + ", i64 " + right_val + ")")
            return res
            
        if str_eq(op, "<="):
            self.write_line(res + " = call i64 @kain_le_op(i64 " + left_val + ", i64 " + right_val + ")")
            return res
            
        if str_eq(op, ">="):
            self.write_line(res + " = call i64 @kain_ge_op(i64 " + left_val + ", i64 " + right_val + ")")
            return res
            
        if str_eq(op, "&&"):
            let tmp = self.fresh_local()
            self.write_line(tmp + " = and i64 " + left_val + ", " + right_val)
            return tmp
            
        if str_eq(op, "||"):
            let tmp = self.fresh_local()
            self.write_line(tmp + " = or i64 " + left_val + ", " + right_val)
            return tmp
            
        // println("DEBUG: gen_binary_expr unknown op returning 0")
        return "0"

    fn gen_unary_expr(self, op: String, operand: Expr) -> String:
        let val = self.gen_expr_untyped(operand)
        let res = self.fresh_local()
        
        if str_eq(op, "-"):
            self.write_line(res + " = sub i64 0, " + val)
        else if str_eq(op, "!"):
            let tmp = self.fresh_local()
            self.write_line(tmp + " = icmp eq i64 " + val + ", 0")
            self.write_line(res + " = zext i1 " + tmp + " to i64")
        else:
            return val
        return res

    fn gen_call_expr(self, callee: Expr, args: Array<Expr>) -> String:
        let callee_v = variant_of(callee)
        if str_eq(callee_v, "Ident"):
            let name = variant_field(callee, 0)
            
            // Map built-in functions
            if str_eq(name, "println"):
                name = "kain_println_str"
            else if str_eq(name, "print"):
                name = "kain_print_str"
            else if str_eq(name, "str"):
                name = "kain_to_string"
            
            let runtime_name = self.map_function_name(name)
            
            let args_str = ""
            let first = true
            for arg in args:
                let arg_val = self.gen_expr_untyped(arg)
                if !first:
                    args_str = args_str + ", "
                args_str = args_str + "i64 " + arg_val
                first = false
            
            let res = self.fresh_local()
            self.write_line(res + " = call i64 @" + runtime_name + "(" + args_str + ")")
            return res
        return "0"

    fn gen_method_call_expr(self, receiver: Expr, method: String, args: Array<Expr>) -> String:
        let receiver_val = self.gen_expr_untyped(receiver)
        
        let type_name = "Unknown"
        if contains_key(self.method_map, method):
            type_name = map_get(self.method_map, method)
        
        let func_name = type_name + "_" + method
        
        let args_str = "i64 " + receiver_val
        for arg in args:
            let arg_val = self.gen_expr_untyped(arg)
            args_str = args_str + ", i64 " + arg_val
        
        let res = self.fresh_local()
        self.write_line(res + " = call i64 @" + func_name + "(" + args_str + ")")
        return res

    fn gen_array_expr(self, elements: Array<Expr>) -> String:
        let arr = self.fresh_local()
        self.write_line(arr + " = call i64 @kain_array_new()")
        
        let elem_idx = 0
        for elem in elements:
            let elem_val = self.gen_expr_untyped(elem)
            self.write_line("call void @kain_array_push(i64 " + arr + ", i64 " + elem_val + ")")
            elem_idx = elem_idx + 1
        
        return arr

    fn gen_struct_expr(self, name: String, inits: Array<FieldInit>) -> String:
        let fields_count = 0
        if contains_key(self.struct_layouts, name):
            fields_count = array_len(map_get(self.struct_layouts, name))
        
        let size = fields_count * 8
        if size == 0:
            size = 8
        
        let ptr = self.fresh_local()
        self.write_line(ptr + " = call i64 @kain_alloc(i64 " + str(size) + ")")
        
        let raw_ptr = self.fresh_local()
        self.write_line(raw_ptr + " = call i8* @kain_unbox_any_ptr(i64 " + ptr + ")")
        
        let struct_ptr = self.fresh_local()
        self.write_line(struct_ptr + " = bitcast i8* " + raw_ptr + " to %" + name + "*")
        
        let init_idx = 0
        for init in inits:
            self.gen_struct_field_init(name, struct_ptr, init, init_idx)
            init_idx = init_idx + 1
        let boxed = self.fresh_local()
        self.write_line(boxed + " = call i64 @kain_box_ptr(i8* " + raw_ptr + ")")
        return boxed

    fn gen_index_expr(self, arr: Expr, idx: Expr) -> String:
        let arr_val = self.gen_expr_untyped(arr)
        let idx_val = self.gen_expr_untyped(idx)
        
        let res = self.fresh_local()
        self.write_line(res + " = call i64 @kain_array_get(i64 " + arr_val + ", i64 " + idx_val + ")")
        return res
    
    fn gen_field_expr(self, obj: Expr, field_name: String) -> String:
        let obj_val = self.gen_expr_untyped(obj)
        let result = self.gen_field_access(obj_val, field_name)
        return result

    fn gen_ident_expr(self, name: String) -> String:
        // Handle built-in constants
        if str_eq(name, "None"):
            return "-2146246697418752"
        if str_eq(name, "true"):
            return "-2181431069507583"
        if str_eq(name, "false"):
            return "-2181431069507584"
        
        let ptr = self.find_var(name)
        if !str_eq(ptr, ""):
            let result = self.fresh_local()
            self.write_line(result + " = load i64, i64* " + ptr)
            return result
        return "%" + name

    fn gen_expr_untyped(self, expr: Expr) -> String:
        let v = variant_of(expr)
        
        if str_eq(v, "Int"):
            let n = variant_field(expr, 0)
            let res = self.fresh_local()
            self.write_line(res + " = add i64 " + str(n) + ", -2216615441596416")
            return res
        
        if str_eq(v, "Float"):
            let f = variant_field(expr, 0)
            // TODO: Floats are already in correct format (unboxed)
            // For now return as-is, need proper float literal handling
            return str(f)
        
        if str_eq(v, "Bool"):
            let b = variant_field(expr, 0)
            if b:
                return "-2181431069507583"
            return "-2181431069507584"
        
        if str_eq(v, "String"):
            let s = variant_field(expr, 0)
            push(self.strings, s)
            let name = "@.str." + str(array_len(self.strings) - 1)
            let result = self.fresh_local()
            self.write_line(result + " = getelementptr [" + str(str_len(s) + 1) + " x i8], [" + str(str_len(s) + 1) + " x i8]* " + name + ", i64 0, i64 0")
            let ptr_i64 = self.fresh_local()
            self.write_line(ptr_i64 + " = ptrtoint i8* " + result + " to i64")
            
            // Shift right by 3 (assumes 8-byte alignment)
            let ptr_shifted = self.fresh_local()
            self.write_line(ptr_shifted + " = lshr i64 " + ptr_i64 + ", 3")
            
            // NaN-box the string pointer: OR with string tag
            let str_tag = nanbox_string_tag() // Returns "-2111062325329920"
            let boxed = self.fresh_local()
            self.write_line(boxed + " = or i64 " + ptr_shifted + ", " + str_tag)
            return boxed
        
        if str_eq(v, "Ident"):
            let name = variant_field(expr, 0)
            return self.gen_ident_expr(name)
        
        if str_eq(v, "Binary"):
            let left = variant_field(expr, 0)
            let op = variant_field(expr, 1)
            let right = variant_field(expr, 2)
            return self.gen_binary_expr(left, op, right)
        
        if str_eq(v, "Unary"):
            let op = variant_field(expr, 0)
            let operand = variant_field(expr, 1)
            return self.gen_unary_expr(op, operand)
        
        if str_eq(v, "Call"):
            let callee = variant_field(expr, 0)
            let args = variant_field(expr, 1)
            return self.gen_call_expr(callee, args)
        
        if str_eq(v, "MethodCall"):
            let receiver = variant_field(expr, 0)
            let method = variant_field(expr, 1)
            let args = variant_field(expr, 2)
            return self.gen_method_call_expr(receiver, method, args)
        
        if str_eq(v, "Field"):
            let obj = variant_field(expr, 0)
            let field_name = variant_field(expr, 1)
            return self.gen_field_expr(obj, field_name)
        
        if str_eq(v, "Index"):
            let arr = variant_field(expr, 0)
            let idx = variant_field(expr, 1)
            return self.gen_index_expr(arr, idx)
        
        if str_eq(v, "Array"):
            let elements = variant_field(expr, 0)
            return self.gen_array_expr(elements)
        
        if str_eq(v, "Struct"):
            let name = variant_field(expr, 0)
            let inits = variant_field(expr, 1)
            return self.gen_struct_expr(name, inits)
        
        if str_eq(v, "EnumVariant"):
            let enum_name = variant_field(expr, 0)
            let variant_name = variant_field(expr, 1)
            let args = variant_field(expr, 2)
            
            // Special handling for Box::new
            if str_eq(enum_name, "Box") && str_eq(variant_name, "new"):
                let arg_val = "0"
                if array_len(args) > 0:
                    arg_val = self.gen_expr_untyped(args[0])
                let result = self.fresh_local()
                self.write_line(result + " = call i64 @kain_box(i64 " + arg_val + ")")
                return result
            
            // Special handling for Map::new
            if str_eq(enum_name, "Map") && str_eq(variant_name, "new"):
                let result = self.fresh_local()
                self.write_line(result + " = call i64 @Map_new()")
                return result
            
            // Check if this is a static method call on a struct (e.g., Token::new)
            if contains_key(self.struct_layouts, enum_name):
                // It's a struct type - treat as static method call
                let mangled = enum_name + "_" + variant_name
                let args_str = ""
                let first = true
                for arg in args:
                    let arg_val = self.gen_expr_untyped(arg)
                    if !first:
                        args_str = args_str + ", "
                    args_str = args_str + "i64 " + arg_val
                    first = false
                let result = self.fresh_local()
                self.write_line(result + " = call i64 @" + mangled + "(" + args_str + ")")
                return result
            
            // Otherwise, it's an actual enum variant
            self.write_line("; enum variant: " + enum_name + "::" + variant_name)
            
            // TODO: Look up tag from variant_map. For now, use 0 as default.
            let tag_idx = 0
            
            // Allocate 24 bytes for enum: { i64, i8*, i8* }
            let boxed_ptr = self.fresh_local()
            self.write_line(boxed_ptr + " = call i64 @kain_alloc(i64 24)")
            
            let raw_ptr = self.fresh_local()
            self.write_line(raw_ptr + " = call i8* @kain_unbox_any_ptr(i64 " + boxed_ptr + ")")
            
            let ptr = self.fresh_local()
            self.write_line(ptr + " = bitcast i8* " + raw_ptr + " to %" + enum_name + "*")
            
            // Store tag at field 0
            let tag_ptr = self.fresh_local()
            self.write_line(tag_ptr + " = getelementptr %" + enum_name + ", %" + enum_name + "* " + ptr + ", i32 0, i32 0")
            self.write_line("store i64 " + str(tag_idx) + ", i64* " + tag_ptr)
            
            // Store payload at field 1
            let payload_ptr = self.fresh_local()
            self.write_line(payload_ptr + " = getelementptr %" + enum_name + ", %" + enum_name + "* " + ptr + ", i32 0, i32 1")
            if array_len(args) > 0:
                // Allocate tuple for payload
                let tuple_size = array_len(args) * 8
                let tuple_i8 = self.fresh_local()
                self.write_line(tuple_i8 + " = call i8* @malloc(i64 " + str(tuple_size) + ")")
                let tuple_ptr = self.fresh_local()
                self.write_line(tuple_ptr + " = bitcast i8* " + tuple_i8 + " to i64*")
                
                // Store each arg in tuple
                let arg_idx = 0
                for arg in args:
                    let arg_val = self.gen_expr_untyped(arg)
                    let slot_ptr = self.fresh_local()
                    self.write_line(slot_ptr + " = getelementptr i64, i64* " + tuple_ptr + ", i32 " + str(arg_idx))
                    self.write_line("store i64 " + arg_val + ", i64* " + slot_ptr)
                    arg_idx = arg_idx + 1
                
                // Store tuple pointer as payload
                self.write_line("store i8* " + tuple_i8 + ", i8** " + payload_ptr)
            else:
                // Null payload 
                self.write_line("store i8* null, i8** " + payload_ptr)
            
            // Store variant name at field 2
            let name_str_id = self.string_counter
            self.string_counter = self.string_counter + 1
            push(self.strings, variant_name)
            
            let name_ptr_reg = self.fresh_local()
            self.write_line(name_ptr_reg + " = getelementptr %" + enum_name + ", %" + enum_name + "* " + ptr + ", i32 0, i32 2")
            let str_const_ptr = self.fresh_local()
            let name_len = str_len(variant_name) + 1
            self.write_line(str_const_ptr + " = getelementptr [" + str(name_len) + " x i8], [" + str(name_len) + " x i8]* @.str." + str(name_str_id) + ", i64 0, i64 0")
            self.write_line("store i8* " + str_const_ptr + ", i8** " + name_ptr_reg)
            
            // Return boxed pointer
            return boxed_ptr
            
        if str_eq(v, "None"):
            return "0"
        
        return "0"
