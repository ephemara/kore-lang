// ============================================================================
// KORE Bootstrap Compiler - Lexer
// ============================================================================
// Project Ouroboros - Phase 2
//
// This is the lexer for the self-hosted KORE compiler.
// It tokenizes KORE source code into a stream of tokens.
//
// This module is written in KORE itself!
// ============================================================================

// use std/io  -- Built-in functions available
// use std/fs
// use std/collections

// =============================================================================
// Token Types
// =============================================================================

/// All possible token types in KORE
enum TokenKind:
    // Literals
    Int(Int)
    Float(Float)
    String(String)
    Bool(Bool)
    
    // Identifiers and Keywords
    Ident(String)
    Keyword(String)
    
    // Operators
    Plus
    Minus
    Star
    Slash
    Percent
    Eq
    EqEq
    NotEq
    Lt
    LtEq
    Gt
    GtEq
    And
    Or
    Not
    Arrow      // ->
    FatArrow   // =>
    Dot
    DotDot     // ..
    Colon
    ColonColon // ::
    Comma
    Semicolon
    Pipe       // |
    Ampersand  // &
    
    // Brackets
    LParen
    RParen
    LBracket
    RBracket
    LBrace
    RBrace
    LAngle     // <
    RAngle     // >
    
    // Whitespace (significant in KORE!)
    Newline
    Indent
    Dedent
    
    // Special
    Eof
    Error(String)

// =============================================================================
// Token
// =============================================================================

/// A token with its kind and source location
struct Token:
    kind: TokenKind
    line: Int
    column: Int
    lexeme: String

impl Token:
    pub fn new(kind: TokenKind, line: Int, column: Int, lexeme: String) -> Token:
        
        return Token { kind: kind, line: line, column: column, lexeme: lexeme }
    
    pub fn is_keyword(self, kw: String) -> Bool:
        // Workaround: check lexeme directly since it matches keyword text
        // Also check that it's actually a keyword token type using known keywords list
        let keywords = [
            "fn", "let", "var", "if", "else", "while", "for", "in",
            "return", "match", "struct", "enum", "impl", "use", "pub",
            "async", "await", "spawn", "actor", "on", "send",
            "true", "false", "none", "self",
            "test", "comptime", "with", "break", "continue", "loop"
        ]
        return self.lexeme == kw && contains(keywords, self.lexeme)
    
    pub fn is_ident(self) -> Bool:
        // Check if it's NOT a keyword and has alphanumeric chars
        let keywords = [
            "fn", "let", "var", "if", "else", "while", "for", "in",
            "return", "match", "struct", "enum", "impl", "use", "pub",
            "async", "await", "spawn", "actor", "on", "send",
            "true", "false", "none", "self",
            "test", "comptime", "with", "break", "continue", "loop"
        ]
        if str_len(self.lexeme) == 0:
            return false
        // If it's not a keyword but starts with a letter, it's an ident
        let c = ord(self.lexeme)
        let is_alpha = (c >= 97 && c <= 122) || (c >= 65 && c <= 90) || c == 95
        return is_alpha && !contains(keywords, self.lexeme)

    pub fn is_error(self) -> Bool:
        // TODO: Fix error token detection
        // For now, return false since we're debugging the parser control flow
        // Error tokens should be rare and we'll see them via the lexeme anyway
        return false
    
    pub fn is_indent(self) -> Bool:
        // Check if the lexeme looks like an indent (spaces at start of indented block)
        return self.lexeme == "    " || self.lexeme == "INDENT"
    
    pub fn is_dedent(self) -> Bool:
        // Check for dedent token
        return self.lexeme == "DEDENT"
    
    pub fn is_newline(self) -> Bool:
        return self.lexeme == "\n" || self.lexeme == "\r\n"

// =============================================================================
// Lexer
// =============================================================================

/// The KORE lexer - converts source text to tokens
struct Lexer:
    source: String
    chars: Array<String>
    pos: Int
    line: Int
    column: Int
    indent_stack: Array<Int>

impl Lexer:
    /// Create a new lexer for the given source code
    pub fn new(source: String) -> Lexer:
        let chars = split(source, "")
        return Lexer {
            source: source,
            chars: chars,
            pos: 0,
            line: 1,
            column: 1,
            indent_stack: [0]
        }
    
    /// Check if we've reached end of input
    fn is_eof(self) -> Bool:
        return self.pos >= array_len(self.chars)
    
    /// Get current character without advancing
    fn peek(self) -> String:
        if self.is_eof():
            return ""
        return self.chars[self.pos]
    
    /// Get character at offset without advancing
    fn peek_n(self, n: Int) -> String:
        let idx = self.pos + n
        if idx >= array_len(self.chars):
            return ""
        return self.chars[idx]
    
    /// Advance and return current character
    fn advance(self) -> String:
        if self.is_eof():
            return ""
        let c = self.chars[self.pos]
        self.pos = self.pos + 1
        if c == "\n":
            self.line = self.line + 1
            self.column = 1
        else:
            self.column = self.column + 1
        return c
    
    /// Skip whitespace (not newlines - those are significant!)
    fn skip_spaces(self) -> Unit:
        while !self.is_eof():
            let c = self.peek()
            if c == " " || c == "\r":
                self.advance()
            else:
                break
    
    /// Make a token at current position
    fn make_token(self, kind: TokenKind, lexeme: String) -> Token:
        return Token::new(kind, self.line, self.column, lexeme)
    
    /// Tokenize a number literal
    fn lex_number(self) -> Token:
        let start = self.pos
        let start_col = self.column
        
        while !self.is_eof() && is_digit(self.peek()):
            self.advance()
        
        // Check for float
        if self.peek() == "." && is_digit(self.peek_n(1)):
            self.advance() // consume '.'
            while !self.is_eof() && is_digit(self.peek()):
                self.advance()
            let lexeme = substring_range(self.source, start, self.pos)
            return Token::new(TokenKind::Float(to_float(lexeme)), self.line, start_col, lexeme)
        
        let lexeme = substring_range(self.source, start, self.pos)
        return Token::new(TokenKind::Int(to_int(lexeme)), self.line, start_col, lexeme)
    
    /// Tokenize a string literal
    fn lex_string(self) -> Token:
        let start_col = self.column
        let quote = self.advance() // consume opening quote
        let pieces = []
        
        while !self.is_eof() && self.peek() != quote:
            let c = self.advance()
            if c == "\\":
                // Escape sequence
                let next = self.advance()
                if next == "n":
                    push(pieces, "\n")
                else if next == "t":
                    push(pieces, "\t")
                else if next == "\\":
                    push(pieces, "\\")
                else if next == "\"":
                    push(pieces, "\"")
                else:
                    push(pieces, next)
            else:
                push(pieces, c)
        
        let value = join(pieces, "")
        self.advance() // consume closing quote
        let lexeme_pieces = ["\"", value, "\""]
        let lexeme = join(lexeme_pieces, "")
        return Token::new(TokenKind::String(value), self.line, start_col, lexeme)
    
    /// Tokenize an identifier or keyword
    fn lex_ident(self) -> Token:
        let start = self.pos
        let start_col = self.column
        
        while !self.is_eof() && is_ident_char(self.peek()):
            self.advance()
        
        let lexeme = substring_range(self.source, start, self.pos)
        
        // Check for keywords
        let keywords = [
            "fn", "let", "var", "if", "else", "while", "for", "in",
            "return", "match", "struct", "enum", "impl", "use", "pub",
            "async", "await", "spawn", "actor", "on", "send",
            "true", "false", "none", "self",
            "test", "comptime", "with"
        ]
        
        if contains(keywords, lexeme):
            if lexeme == "true":
                return Token::new(TokenKind::Bool(true), self.line, start_col, lexeme)
            else if lexeme == "false":
                return Token::new(TokenKind::Bool(false), self.line, start_col, lexeme)
            return Token::new(TokenKind::Keyword(lexeme), self.line, start_col, lexeme)
        
        return Token::new(TokenKind::Ident(lexeme), self.line, start_col, lexeme)
    
    /// Get the next token
    pub fn next_token(self) -> Token:
        self.skip_spaces()
        
        if self.is_eof():
            return self.make_token(TokenKind::Eof, "")
        
        let c = self.peek()
        
        // Single-line comment
        if c == "#" || (c == "/" && self.peek_n(1) == "/"):
            while !self.is_eof() && self.peek() != "\n":
                self.advance()
            return self.next_token()
        
        // Skip carriage return (Windows CRLF line endings)
        if c == "\r":
            self.advance()
            return self.next_token()  // Skip it, get next real token
        
        // Newline (significant!)
        if c == "\n":
            self.advance()
            return self.make_token(TokenKind::Newline, "\n")
        
        // Numbers
        if is_digit(c):
            return self.lex_number()
        
        // Strings
        let code = ord(c)
        if code == 34 || code == 39: // " or '
            return self.lex_string()
        
        // Identifiers and keywords
        if is_ident_start(c):
            return self.lex_ident()
        
        // Operators and punctuation
        self.advance()
        
        match c:
            "+" => return self.make_token(TokenKind::Plus, "+")
            "-" =>
                if self.peek() == ">":
                    self.advance()
                    return self.make_token(TokenKind::Arrow, "->")
                return self.make_token(TokenKind::Minus, "-")
            "*" => return self.make_token(TokenKind::Star, "*")
            "/" => return self.make_token(TokenKind::Slash, "/")
            "%" => return self.make_token(TokenKind::Percent, "%")
            "=" =>
                if self.peek() == "=":
                    self.advance()
                    return self.make_token(TokenKind::EqEq, "==")
                if self.peek() == ">":
                    self.advance()
                    return self.make_token(TokenKind::FatArrow, "=>")
                return self.make_token(TokenKind::Eq, "=")
            "!" =>
                if self.peek() == "=":
                    self.advance()
                    return self.make_token(TokenKind::NotEq, "!=")
                return self.make_token(TokenKind::Not, "!")
            "<" =>
                if self.peek() == "=":
                    self.advance()
                    return self.make_token(TokenKind::LtEq, "<=")
                return self.make_token(TokenKind::Lt, "<")
            ">" =>
                if self.peek() == "=":
                    self.advance()
                    return self.make_token(TokenKind::GtEq, ">=")
                return self.make_token(TokenKind::Gt, ">")
            "&" =>
                if self.peek() == "&":
                    self.advance()
                    return self.make_token(TokenKind::And, "&&")
                return self.make_token(TokenKind::Ampersand, "&")
            "|" =>
                if self.peek() == "|":
                    self.advance()
                    return self.make_token(TokenKind::Or, "||")
                return self.make_token(TokenKind::Pipe, "|")
            "." =>
                if self.peek() == ".":
                    self.advance()
                    return self.make_token(TokenKind::DotDot, "..")
                return self.make_token(TokenKind::Dot, ".")
            ":" =>
                if self.peek() == ":":
                    self.advance()
                    return self.make_token(TokenKind::ColonColon, "::")
                return self.make_token(TokenKind::Colon, ":")
            "," => return self.make_token(TokenKind::Comma, ",")
            ";" => return self.make_token(TokenKind::Semicolon, ";")
            "(" => return self.make_token(TokenKind::LParen, "(")
            ")" => return self.make_token(TokenKind::RParen, ")")
            "[" => return self.make_token(TokenKind::LBracket, "[")
            "]" => return self.make_token(TokenKind::RBracket, "]")
            "{" => return self.make_token(TokenKind::LBrace, "{")
            "}" => return self.make_token(TokenKind::RBrace, "}")
            _ => return self.make_token(TokenKind::Error("Unknown character: " + c), c)
    
    /// Tokenize entire source into array of tokens with Indent/Dedent injection
    pub fn tokenize(self) -> Array<Token>:
        let tokens = []
        let at_start_of_line = true
        
        loop:
            if self.is_eof():
                // Emit remaining dedents at EOF
                while array_len(self.indent_stack) > 1:
                    pop(self.indent_stack)
                    push(tokens, Token::new(TokenKind::Dedent, self.line, self.column, "DEDENT"))
                push(tokens, Token::new(TokenKind::Eof, self.line, self.column, ""))
                break
            
            // 1. Skip non-newline whitespace and count spaces (only at start of line)
            let spaces = 0
            if at_start_of_line:
                while !self.is_eof():
                    let c = self.peek()
                    if c == " ":
                        spaces = spaces + 1
                        self.advance()
                    else if c == "\t":
                        spaces = spaces + 4  // Tab = 4 spaces
                        self.advance()
                    else if c == "\r":
                        self.advance()  // Skip carriage return
                    else:
                        break
            else:
                // Not at start of line - just skip spaces normally
                while !self.is_eof():
                    let c = self.peek()
                    if c == " " || c == "\r":
                        self.advance()
                    else:
                        break
            
            // 2. Check for EOF after whitespace
            if self.is_eof():
                continue
            
            // 3. Handle newline
            if self.peek() == "\n":
                self.advance()
                push(tokens, Token::new(TokenKind::Newline, self.line, self.column, "\n"))
                at_start_of_line = true
                continue
            
            // 4. Skip comments
            if self.peek() == "#":
                while !self.is_eof() && self.peek() != "\n":
                    self.advance()
                continue
            
            if self.peek() == "/" && self.peek_n(1) == "/":
                while !self.is_eof() && self.peek() != "\n":
                    self.advance()
                continue
            
            // 5. Handle Indent/Dedent at start of line
            if at_start_of_line:
                let last_indent = 0
                if array_len(self.indent_stack) > 0:
                    last_indent = self.indent_stack[array_len(self.indent_stack) - 1]
                
                if spaces > last_indent:
                    push(self.indent_stack, spaces)
                    push(tokens, Token::new(TokenKind::Indent, self.line, self.column, "    "))
                else if spaces < last_indent:
                    while array_len(self.indent_stack) > 0:
                        let top = self.indent_stack[array_len(self.indent_stack) - 1]
                        if top <= spaces:
                            break
                        pop(self.indent_stack)
                        push(tokens, Token::new(TokenKind::Dedent, self.line, self.column, "DEDENT"))
                
                at_start_of_line = false
            
            // 6. Get the actual token
            let tok = self.next_token()
            push(tokens, tok)
        
        return tokens

// =============================================================================
// Helper Functions
// =============================================================================

fn is_digit(c: String) -> Bool:
    if str_len(c) == 0:
        return false
    let code = ord(c)
    return code >= 48 && code <= 57  // '0' = 48, '9' = 57

fn is_alpha(c: String) -> Bool:
    if str_len(c) == 0:
        return false
    let code = ord(c)
    // 'a' = 97, 'z' = 122, 'A' = 65, 'Z' = 90
    return (code >= 97 && code <= 122) || (code >= 65 && code <= 90)

fn is_ident_start(c: String) -> Bool:
    return is_alpha(c) || c == "_"

fn is_ident_char(c: String) -> Bool:
    return is_alpha(c) || is_digit(c) || c == "_"

fn substring_range(s: String, start: Int, end: Int) -> String:
    let chars = split(s, "")
    let pieces = []
    let i = start
    let max = array_len(chars)
    while i < end:
        if i < max:
            push(pieces, chars[i])
        i = i + 1
    return join(pieces, "")

// =============================================================================
// Entry Point (for testing)
// =============================================================================



// ============================================================================
// KORE Bootstrap Compiler - Parser
// ============================================================================
// Project Ouroboros - Phase 2
//
// This is the parser for the self-hosted KORE compiler.
// It converts a token stream into an Abstract Syntax Tree (AST).
//
// This module is written in KORE itself!
// ============================================================================

// TODO: These need stdlib implementations
// use std/io
// use std/collections

// Import the lexer module

// =============================================================================
// AST Node Types
// =============================================================================

/// A KORE program is a list of top-level items
struct Program:
    items: Array<Item>

/// Top-level items
enum Item:
    Function(FnDef)
    Struct(StructDef)
    Enum(EnumDef)
    Impl(ImplDef)
    Use(String)

/// Function definition
struct FnDef:
    name: String
    params: Array<Param>
    return_type: Option<String>
    body: Array<Stmt>
    is_pub: Bool
    is_async: Bool

/// Function parameter
struct Param:
    name: String
    ty: Option<String>

/// Struct definition
struct StructDef:
    name: String
    fields: Array<Field>
    is_pub: Bool

/// Struct field
struct Field:
    name: String
    ty: String

/// Enum definition
struct EnumDef:
    name: String
    variants: Array<Variant>

/// Enum variant
struct Variant:
    name: String
    fields: Array<String>

/// Impl block
struct ImplDef:
    target: String
    methods: Array<FnDef>

// =============================================================================
// Statements
// =============================================================================

enum Stmt:
    Let(String, Option<String>, Expr)
    Var(String, Option<String>, Expr)
    Assign(Expr, Expr)
    Return(Option<Expr>)
    If(Expr, Array<Stmt>, Option<Array<Stmt> >)
    While(Expr, Array<Stmt>)
    Loop(Array<Stmt>)
    For(String, Expr, Array<Stmt>)
    Match(Expr, Array<MatchArm>)
    Expr(Expr)
    Break
    Continue

struct MatchArm:
    pattern: Pattern
    body: Array<Stmt>

enum Pattern:
    Wildcard
    Ident(String)
    Literal(Expr)
    Variant(String, Array<Pattern>)

// =============================================================================
// Expressions
// =============================================================================

enum Expr:
    Int(Int)
    Float(Float)
    String(String)
    Bool(Bool)
    None
    Ident(String)
    Binary(Expr, String, Expr)
    Unary(String, Expr)
    Call(Expr, Array<Expr>)
    MethodCall(Expr, String, Array<Expr>)
    Index(Expr, Expr)
    Field(Expr, String)
    Array(Array<Expr>)
    Struct(String, Array<FieldInit>)
    EnumVariant(String, String, Array<Expr>)
    If(Expr, Expr, Option<Expr>)
    Lambda(Array<String>, Expr)
    Await(Expr)

struct FieldInit:
    name: String
    value: Expr

// =============================================================================
// Parser
// =============================================================================

struct Parser:
    tokens: Array<Token>
    pos: Int

impl Parser:
    pub fn new(tokens: Array<Token>) -> Parser:
        return Parser { tokens: tokens, pos: 0 }
    
    fn is_eof(self) -> Bool:
        if self.pos >= array_len(self.tokens):
            return true
        // Also check if current token is EOF (empty lexeme from tokenizer)
        let tok = self.tokens[self.pos]
        return tok.lexeme == "" && !tok.is_dedent() && !tok.is_indent()
    
    fn peek(self) -> Token:
        if self.is_eof():
            return Token::new(TokenKind::Eof, 0, 0, "")
        let t = self.tokens[self.pos]
        return t
    
    fn advance(self) -> Token:
        let tok = self.peek()
        self.pos = self.pos + 1
        return tok
    
    fn expect_keyword(self, kw: String) -> Token:
        let tok = self.advance()
        if !tok.is_keyword(kw):
            panic("Expected keyword '" + kw + "', got: " + tok.lexeme)
        return tok
    
    fn expect(self, kind_name: String) -> Token:
        let tok = self.advance()
        // Simple check - in real impl we'd match on kind
        return tok
    
    fn skip_newlines(self) -> Unit:
        
        while !self.is_eof():
            // Inline peek to avoid call issue
            let tok = self.tokens[self.pos]
            
            // Skip newlines and dedents only - NOT indents (those are significant for block parsing)
            if tok.is_newline() || tok.is_dedent():
                self.advance()
            else:
                break
    
    /// Parse a complete program
    pub fn parse_program(self) -> Program:
        
        let items = []
        
        
        self.skip_newlines()
        
        
        while !self.is_eof():
            // Skip spurious indents at top level
            while true:
                
                if self.is_eof():
                     break
                let p = self.tokens[self.pos]
                
                if p.is_indent() || p.is_dedent():
                    
                    self.advance()
                    self.skip_newlines()
                else:
                    break
            
            if self.is_eof():
                break
                
            let item = self.parse_item()
            push(items, item)
            self.skip_newlines()
        
        return Program { items: items }
    
    /// Parse a top-level item
    fn parse_item(self) -> Item:
        let tok = self.peek()
        
        if tok.is_keyword("fn"):
            return Item::Function(self.parse_fn_def(false, false))
        else if tok.is_keyword("pub"):
            self.advance()
            let next = self.peek()
            if next.is_keyword("fn"):
                return Item::Function(self.parse_fn_def(true, false))
            else if next.is_keyword("struct"):
                return Item::Struct(self.parse_struct_def(true))
            else:
                panic("Expected fn or struct after pub")
        else if tok.is_keyword("async"):
            self.advance()
            self.expect_keyword("fn")
            return Item::Function(self.parse_fn_def(false, true))
        else if tok.is_keyword("struct"):
            return Item::Struct(self.parse_struct_def(false))
        else if tok.is_keyword("enum"):
            return Item::Enum(self.parse_enum_def())
        else if tok.is_keyword("impl"):
            return Item::Impl(self.parse_impl_def())
        else if tok.is_keyword("use"):
            return Item::Use(self.parse_use())
        else:
            // Debug print token kind
            let kind_str = "Unknown"
            match tok.kind:
                TokenKind::Int(_) => kind_str = "Int"
                TokenKind::String(_) => kind_str = "String"
                TokenKind::Ident(_) => kind_str = "Ident"
                TokenKind::Keyword(_) => kind_str = "Keyword"
                TokenKind::Error(msg) => kind_str = "Error(" + msg + ")"
                _ => kind_str = "Other"
            
            panic("Unexpected token at top level: [" + tok.lexeme + "] Kind: " + kind_str)
    
    /// Parse function definition (assumes 'fn' is next or just consumed)
    fn parse_fn_def(self, is_pub: Bool, is_async: Bool) -> FnDef:
        self.expect_keyword("fn")
        
        let name_tok = self.advance()
        let name = name_tok.lexeme
        
        // Parse parameters
        self.expect("(")
        let params = self.parse_params()
        self.expect(")")
        
        // Parse return type if present
        let return_type = None
        if self.peek().lexeme == "->":
            self.advance()  // consume '->'
            return_type = Some(self.parse_type())
        
        // Skip 'with Effect' if present
        if self.peek().is_keyword("with"):
            self.advance()  // consume 'with'
            self.advance()  // consume effect name
        
        // Parse body
        self.expect(":")
        self.skip_newlines()
        let body = self.parse_block()
        
        return FnDef {
            name: name,
            params: params,
            return_type: return_type,
            body: body,
            is_pub: is_pub,
            is_async: is_async
        }
    
    fn parse_params(self) -> Array<Param>:
        let params = []
        while !self.is_eof():
            let tok = self.peek()
            
            // Stop at closing paren
            if tok.lexeme == ")":
                break
            
            // Handle 'self' parameter
            if tok.is_keyword("self"):
                self.advance()
                push(params, Param { name: "self", ty: Some("Self") })
                if self.peek().lexeme == ",":
                    self.advance()
                continue
            
            // Check if it's an identifier
            if tok.is_ident():
                self.advance()
                let param_name = tok.lexeme
                let param_type = None
                
                // Check for type annotation
                if self.peek().lexeme == ":":
                    self.advance()  // consume ':'
                    param_type = Some(self.parse_type())
                
                push(params, Param { name: param_name, ty: param_type })
                
                // Check for comma
                if self.peek().lexeme == ",":
                    self.advance()
            else:
                break
        
        return params
    
    /// Parse a type (handles Array<T>, Option<T>, etc.)
    fn parse_type(self) -> String:
        let base = self.advance().lexeme
        
        // Check for generic parameters
        if self.peek().lexeme == "<":
            self.advance()  // consume '<'
            let inner = self.parse_type()
            
            // Handle nested generics like Option<Box<Expr>>
            while self.peek().lexeme == ",":
                self.advance()
                inner = inner + ", " + self.parse_type()
            
            self.advance()  // consume '>'
            return base + "<" + inner + ">"
        
        return base
    
    fn parse_block(self) -> Array<Stmt>:
        let stmts = []
        let max_stmts = 10000  // Safety limit
        
        // Skip any leading newlines
        self.skip_newlines()
        
        // Check for Indent token - indicates an indented block
        let has_indent = false
        let peek_tok = self.peek()
        if peek_tok.is_indent():
            self.advance()  // consume Indent
            has_indent = true
        
        while !self.is_eof() && array_len(stmts) < max_stmts:
            let tok = self.peek()
            
            // Check for Dedent - end of indented block
            if has_indent && tok.is_dedent():
                self.advance()  // consume Dedent
                break
            
            // Check for newlines - skip them
            if tok.is_newline():
                self.advance()
                continue
            
            // If NOT indented, top-level keywords end the block
            if !has_indent:
                if tok.is_keyword("fn") || tok.is_keyword("pub") || tok.is_keyword("struct") || tok.is_keyword("enum") || tok.is_keyword("impl") || tok.is_keyword("use"):
                    break
            
            // Parse a statement
            let start_pos = self.pos
            let stmt = self.parse_stmt()
            push(stmts, stmt)
            
            // Safety: if position didn't advance, break to prevent infinite loop
            if self.pos == start_pos:
                break
            
            // If not indented, only parse one statement (inline block like: if x: return y)
            if !has_indent:
                break
        
        return stmts
    
    fn parse_stmt(self) -> Stmt:
        let tok = self.peek()
        
        if tok.is_error():
            self.advance()
            return Stmt::Expr(Expr::None)
        
        if tok.is_keyword("let"):
            return self.parse_let()
        
        if tok.is_keyword("var"):
            return self.parse_var()
        
        if tok.is_keyword("return"):
            return self.parse_return()
        
        if tok.is_keyword("if"):
            return self.parse_if()
        
        if tok.is_keyword("while"):
            return self.parse_while()
        
        if tok.is_keyword("for"):
            return self.parse_for()
        
        if tok.is_keyword("match"):
            return self.parse_match()
        
        if tok.is_keyword("break"):
            self.advance()
            return Stmt::Break
        
        if tok.is_keyword("continue"):
            self.advance()
            return Stmt::Continue
        
        if tok.is_keyword("loop"):
            return self.parse_loop()
        
        // If we get here, it's an expression statement
        let expr = self.parse_expr()
        
        // Check for assignment
        if self.peek().lexeme == "=":
            self.advance()
            let value = self.parse_expr()
            return Stmt::Assign(expr, value)
        
        return Stmt::Expr(expr)
    
    fn parse_let(self) -> Stmt:
        self.expect_keyword("let")
        let name_tok = self.advance()
        let name = name_tok.lexeme
        self.expect("=")
        let value = self.parse_expr()
        return Stmt::Let(name, None, value)
    
    fn parse_var(self) -> Stmt:
        self.expect_keyword("var")
        let name_tok = self.advance()
        let name = name_tok.lexeme
        self.expect("=")
        let value = self.parse_expr()
        return Stmt::Var(name, None, value)
    
    fn parse_return(self) -> Stmt:
        self.expect_keyword("return")
        if self.peek().lexeme == "\n":
            return Stmt::Return(None)
        let expr = self.parse_expr()
        return Stmt::Return(Some(expr))
    
    fn parse_if(self) -> Stmt:
        self.expect_keyword("if")
        let cond = self.parse_expr()
        self.expect(":")
        self.skip_newlines()
        let then_block = self.parse_block()
        
        let else_block = None
        if self.peek().is_keyword("else"):
            self.advance()
            self.expect(":")
            self.skip_newlines()
            else_block = Some(self.parse_block())
        
        return Stmt::If(cond, then_block, else_block)
    
    fn parse_while(self) -> Stmt:
        self.expect_keyword("while")
        let cond = self.parse_expr()
        self.expect(":")
        self.skip_newlines()
        let body = self.parse_block()
        return Stmt::While(cond, body)
    
    fn parse_for(self) -> Stmt:
        self.expect_keyword("for")
        let var_tok = self.advance()
        let var_name = var_tok.lexeme
        self.expect_keyword("in")
        let iter = self.parse_expr()
        self.expect(":")
        self.skip_newlines()
        let body = self.parse_block()
        return Stmt::For(var_name, iter, body)
    
    fn parse_loop(self) -> Stmt:
        self.expect_keyword("loop")
        self.expect(":")
        self.skip_newlines()
        let body = self.parse_block()
        return Stmt::Loop(body)
    
    fn parse_match(self) -> Stmt:
        self.expect_keyword("match")
        let scrutinee = self.parse_expr()
        self.expect(":")
        self.skip_newlines()
        
        let arms = []
        // Parse match arms until we hit a dedent
        while !self.is_eof():
            let tok = self.peek()
            
            // Stop at new statement-level keywords (outside match)
            if tok.is_keyword("fn") || tok.is_keyword("let") || tok.is_keyword("var") || tok.is_keyword("return") || tok.is_keyword("if") || tok.is_keyword("while") || tok.is_keyword("for"):
                break
            if tok.is_keyword("struct") || tok.is_keyword("enum") || tok.is_keyword("impl") || tok.is_keyword("use") || tok.is_keyword("pub"):
                break
            
            // Skip newlines
            if tok.lexeme == "\n":
                self.advance()
                continue
            
            // Parse pattern => body
            let pattern = self.parse_pattern()
            self.expect("=")  // expect =>  (we already consumed =)
            self.expect(">")
            
            // Parse arm body (could be single expr or block)
            let body = []
            if self.peek().lexeme == "\n":
                self.skip_newlines()
                body = self.parse_block()
            else:
                let expr = self.parse_expr()
                push(body, Stmt::Expr(expr))
            
            push(arms, MatchArm { pattern: pattern, body: body })
        
        return Stmt::Match(scrutinee, arms)
    
    fn parse_pattern(self) -> Pattern:
        let tok = self.peek()
        
        // Wildcard pattern
        if tok.lexeme == "_":
            self.advance()
            return Pattern::Wildcard
        
        // Identifier or variant pattern
        if tok.is_ident():
            self.advance()
            let name = tok.lexeme
            
            // Check for variant with bindings: Variant(x, y)
            if self.peek().lexeme == "(":
                self.advance()  // consume '('
                let bindings = []
                while self.peek().lexeme != ")":
                    push(bindings, self.parse_pattern())
                    if self.peek().lexeme == ",":
                        self.advance()
                self.advance()  // consume ')'
                return Pattern::Variant(name, bindings)
            
            return Pattern::Ident(name)
        
        // Literal pattern (numbers, strings)
        let expr = self.parse_primary()
        return Pattern::Literal(expr)
    
    // Expression parser with operator precedence
    fn parse_expr(self) -> Expr:
        return self.parse_or()
    
    fn parse_or(self) -> Expr:
        let left = self.parse_and()
        while self.peek().lexeme == "||":
            self.advance()
            let right = self.parse_and()
            left = Expr::Binary(left, "||", right)
        return left
    
    fn parse_and(self) -> Expr:
        let left = self.parse_equality()
        while self.peek().lexeme == "&&":
            self.advance()
            let right = self.parse_equality()
            left = Expr::Binary(left, "&&", right)
        return left
    
    fn parse_equality(self) -> Expr:
        let left = self.parse_comparison()
        while self.peek().lexeme == "==" || self.peek().lexeme == "!=":
            let op = self.advance().lexeme
            let right = self.parse_comparison()
            left = Expr::Binary(left, op, right)
        return left
    
    fn parse_comparison(self) -> Expr:
        let left = self.parse_term()
        while self.peek().lexeme == "<" || self.peek().lexeme == ">" || self.peek().lexeme == "<=" || self.peek().lexeme == ">=":
            let op = self.advance().lexeme
            let right = self.parse_term()
            left = Expr::Binary(left, op, right)
        return left
    
    fn parse_term(self) -> Expr:
        let left = self.parse_factor()
        while self.peek().lexeme == "+" || self.peek().lexeme == "-":
            let op = self.advance().lexeme
            let right = self.parse_factor()
            left = Expr::Binary(left, op, right)
        return left
    
    fn parse_factor(self) -> Expr:
        let left = self.parse_unary()
        while self.peek().lexeme == "*" || self.peek().lexeme == "/" || self.peek().lexeme == "%":
            let op = self.advance().lexeme
            let right = self.parse_unary()
            left = Expr::Binary(left, op, right)
        return left
    
    fn parse_unary(self) -> Expr:
        if self.peek().lexeme == "!" || self.peek().lexeme == "-":
            let op = self.advance().lexeme
            let operand = self.parse_unary()
            return Expr::Unary(op, operand)
        return self.parse_postfix()
    
    fn parse_postfix(self) -> Expr:
        let expr = self.parse_primary()
        
        // Handle postfix operations: field access, method calls, indexing
        loop:
            let next = self.peek().lexeme
            
            if next == ".":
                self.advance()  // consume '.'
                let field = self.advance().lexeme
                
                // Check if it's a method call
                if self.peek().lexeme == "(":
                    self.advance()  // consume '('
                    let args = self.parse_args()
                    self.advance()  // consume ')'
                    expr = Expr::MethodCall(expr, field, args)
                else:
                    expr = Expr::Field(expr, field)
                continue
            
            if next == "[":
                self.advance()  // consume '['
                let index = self.parse_expr()
                self.advance()  // consume ']'
                expr = Expr::Index(expr, index)
                continue
            
            if next == "(":
                // Direct function call on expression
                self.advance()  // consume '('
                let args = self.parse_args()
                self.advance()  // consume ')'
                expr = Expr::Call(expr, args)
                continue
            
            // None of the above - break out
            break
        
        return expr
    
    fn parse_args(self) -> Array<Expr>:
        let args = []
        while self.peek().lexeme != ")":
            push(args, self.parse_expr())
            if self.peek().lexeme == ",":
                self.advance()
        return args
    
    fn parse_primary(self) -> Expr:
        let tok = self.peek()
        
        // Parenthesized expression
        if tok.lexeme == "(":
            self.advance()  // consume '('
            let expr = self.parse_expr()
            self.advance()  // consume ')'
            return expr
        
        // Array literal
        if tok.lexeme == "[":
            self.advance()  // consume '['
            let elements = []
            
            self.skip_newlines()
            
            while self.peek().lexeme != "]":
                // Skip indent/dedent/newline inside array
                let p = self.peek()
                if p.is_indent() || p.is_dedent() || p.is_newline():
                    self.advance()
                    continue

                push(elements, self.parse_expr())
                
                if self.peek().lexeme == ",":
                    self.advance()
                
                self.skip_newlines()
            
            self.advance()  // consume ']'
            return Expr::Array(elements)
        
        // Now consume the token
        self.advance()
        
        // Check for integer literal (digits only)
        if str_len(tok.lexeme) > 0:
            let first_char = ord(tok.lexeme)
            let is_digit = first_char >= 48 && first_char <= 57
            if is_digit:
                return Expr::Int(int(tok.lexeme))
        
        // Check for float (contains .)
        if contains(split(tok.lexeme, ""), "."):
            let first_char = ord(tok.lexeme)
            let is_digit = first_char >= 48 && first_char <= 57
            if is_digit:
                return Expr::Float(float(tok.lexeme))
        
        // Check for string literal (starts with quote)
        if str_len(tok.lexeme) > 0:
            let first_char = ord(tok.lexeme)
            if first_char == 34 || first_char == 39:  // " or '
                return Expr::String(tok.lexeme)
        
        // Check for bool/keywords
        if tok.lexeme == "true":
            return Expr::Bool(true)
        if tok.lexeme == "false":
            return Expr::Bool(false)
        if tok.lexeme == "none" || tok.lexeme == "None":
            return Expr::None
        
        // Check for struct/enum construction: Name { ... } or Name::Variant
        if tok.is_ident():
            let name = tok.lexeme
            
            // Enum variant: Name::Variant or Name::Variant(...)
            if self.peek().lexeme == ":":
                if self.peek_n(1).lexeme == ":":
                    self.advance()  // consume first ':'
                    self.advance()  // consume second ':'
                    let variant = self.advance().lexeme
                    
                    // Check for variant with data
                    if self.peek().lexeme == "(":
                        self.advance()  // consume '('
                        let args = self.parse_args()
                        self.advance()  // consume ')'
                        return Expr::EnumVariant(name, variant, args)
                    
                    return Expr::EnumVariant(name, variant, [])
            
            // Struct literal: Name { field: value, ... }
            if self.peek().lexeme == "{":
                self.advance()  // consume '{'
                let fields = []
                while self.peek().lexeme != "}":
                    let field_name = self.advance().lexeme
                    self.expect(":")
                    let field_value = self.parse_expr()
                    push(fields, FieldInit { name: field_name, value: field_value })
                    if self.peek().lexeme == ",":
                        self.advance()
                self.advance()  // consume '}'
                return Expr::Struct(name, fields)
            
            return Expr::Ident(name)
        
        // Fallback - treat as identifier
        return Expr::Ident(tok.lexeme)
    
    /// Peek ahead n tokens
    fn peek_n(self, n: Int) -> Token:
        let idx = self.pos + n
        if idx >= array_len(self.tokens):
            return Token::new(TokenKind::Eof, 0, 0, "")
        return self.tokens[idx]
    
    // =========================================================================
    // Struct/Enum/Impl parsing
    // =========================================================================
    
    fn parse_struct_def(self, is_pub: Bool) -> StructDef:
        self.expect_keyword("struct")
        let name = self.advance().lexeme
        self.expect(":")
        self.skip_newlines()
        
        // Handle indentation
        let has_indent = false
        if self.peek().is_indent():
            self.advance()
            has_indent = true
        
        let fields = []
        // Parse fields until we hit a dedent (new top-level item)
        while !self.is_eof():
            let tok = self.peek()
            
            // Check for Dedent
            if has_indent && tok.is_dedent():
                self.advance()
                break
            
            // Stop at new top-level items if not indented
            if !has_indent:
                if tok.is_keyword("fn") || tok.is_keyword("pub") || tok.is_keyword("struct") || tok.is_keyword("enum") || tok.is_keyword("impl") || tok.is_keyword("use"):
                    break
            
            // Skip newlines
            if tok.lexeme == "\n":
                self.advance()
                continue
            
            // Parse field: name: Type
            if tok.is_ident():
                let field_name = self.advance().lexeme
                self.expect(":")
                let field_type = self.parse_type()
                push(fields, Field { name: field_name, ty: field_type })
            else:
                break
        
        return StructDef { name: name, fields: fields, is_pub: is_pub }
    
    fn parse_enum_def(self) -> EnumDef:
        self.expect_keyword("enum")
        let name = self.advance().lexeme
        self.expect(":")
        self.skip_newlines()
        
        // Handle indentation
        let has_indent = false
        if self.peek().is_indent():
            self.advance()
            has_indent = true
        
        let variants = []
        // Parse variants until we hit a dedent
        while !self.is_eof():
            let tok = self.peek()
            
            // Check for Dedent
            if has_indent && tok.is_dedent():
                self.advance()
                break
            
            // Stop at new top-level items if not indented
            if !has_indent:
                if tok.is_keyword("fn") || tok.is_keyword("pub") || tok.is_keyword("struct") || tok.is_keyword("enum") || tok.is_keyword("impl") || tok.is_keyword("use"):
                    break
            
            // Skip newlines and comments
            if tok.lexeme == "\n":
                self.advance()
                continue
            
            // Parse variant: Name or Name(Type1, Type2)
            if tok.is_ident():
                let variant_name = self.advance().lexeme
                let variant_fields = []
                
                // Check for variant data
                if self.peek().lexeme == "(":
                    self.advance()  // consume '('
                    while self.peek().lexeme != ")":
                        push(variant_fields, self.parse_type())
                        if self.peek().lexeme == ",":
                            self.advance()
                    self.advance()  // consume ')'
                
                push(variants, Variant { name: variant_name, fields: variant_fields })
            else:
                break
        
        return EnumDef { name: name, variants: variants }
    
    fn parse_impl_def(self) -> ImplDef:
        self.expect_keyword("impl")
        let target = self.advance().lexeme
        self.expect(":")
        self.skip_newlines()
        
        // Handle indentation
        let has_indent = false
        if self.peek().is_indent():
            self.advance()
            has_indent = true
        
        let methods = []
        // Parse methods until we hit a dedent
        while !self.is_eof():
            let tok = self.peek()
            
            // Check for Dedent
            if has_indent && tok.is_dedent():
                self.advance()
                break
            
            // Stop at new top-level items (but not 'fn' or 'pub fn' which are methods)
            if !has_indent:
                if tok.is_keyword("struct") || tok.is_keyword("enum") || tok.is_keyword("impl") || tok.is_keyword("use"):
                    break
            
            // Skip newlines
            if tok.lexeme == "\n":
                self.advance()
                continue
            
            // Parse method
            if tok.is_keyword("pub"):
                self.advance()
                if self.peek().is_keyword("fn"):
                    let method = self.parse_fn_def(true, false)
                    push(methods, method)
                else:
                    break
            else if tok.is_keyword("fn"):
                let method = self.parse_fn_def(false, false)
                push(methods, method)
            else:
                break
        
        return ImplDef { target: target, methods: methods }
    
    fn parse_use(self) -> String:
        self.expect_keyword("use")
        let path = self.advance().lexeme
        return path

// =============================================================================
// Entry Point
// =============================================================================



// ============================================================================
// KORE Bootstrap Compiler - LLVM IR Code Generator
// ============================================================================
// Project Ouroboros - Complete LLVM Backend
//
// This generates LLVM IR text from the AST.
// We output *textual* LLVM IR (.ll files) instead of using LLVM's C API.
// This is much simpler and allows us to bootstrap without FFI!
//
// Compile the output with:
//   clang output.ll -o output
// 
// Or for more control:
//   llc output.ll -o output.s
//   clang output.s -o output
//
// This module is written in KORE itself!
// ============================================================================

use std/io
use std/collections

// =============================================================================
// Code Generator
// =============================================================================

struct CodeGen:
    output: StringBuilder
    indent: Int
    local_counter: Int
    string_counter: Int
    label_counter: Int
    strings: Array<String>
    // Variable environment: maps name -> alloca pointer
    vars: Map<String, String>
    
    // Loop labels for break/continue
    loop_labels: Array<String>
    
    // Struct layout info
    struct_layouts: Map<String, Array<String>>
    field_map: Map<String, String>
    method_map: Map<String, String>

impl CodeGen:
    pub fn new() -> CodeGen:
        return CodeGen {
            output: StringBuilder::new(),
            indent: 0,
            local_counter: 0,
            string_counter: 0,
            label_counter: 0,
            strings: [],
            vars: Map::new(),
            loop_labels: [],
            struct_layouts: Map::new(),
            field_map: Map::new(),
            method_map: Map::new()
        }
    
    /// Generate a fresh local variable name
    fn fresh_local(self) -> String:
        let n = self.local_counter
        self.local_counter = self.local_counter + 1
        return "%t" + str(n)
        return "%dummy"
    
    /// Generate a fresh label name
    fn fresh_label(self, prefix: String) -> String:
        let n = self.label_counter
        self.label_counter = self.label_counter + 1
        return prefix + str(n)
    
    /// Generate a fresh string constant name
    fn fresh_string(self) -> String:
        let n = self.string_counter
        self.string_counter = self.string_counter + 1
        return "@.str." + str(n)
    
    /// Emit a line of IR
    fn write_line(self, line: String) -> Unit:
        let indent_str = ""
        for i in range(0, self.indent):
            indent_str = indent_str + "  "
        self.output.push_line(indent_str + line)
    
    /// Emit raw text (no newline)
    fn emit_raw(self, text: String) -> Unit:
        self.output.push(text)
    
    // =========================================================================
    // Program Generation
    // =========================================================================
    
    /// Generate IR for an entire program
    pub fn gen_program(self, program: Program) -> String:
        // Emit header
        self.write_line("; KORE Compiler Output - LLVM IR")
        self.write_line("; Generated by Project Ouroboros")
        self.write_line("; Compile with: clang output.ll -o output")
        self.write_line("")
        
        // Target triple (x86_64 Windows for now)
        // self.write_line("target triple = \"x86_64-pc-windows-msvc\"")
        self.write_line("")
        
        // Emit external declarations
        self.emit_externals()
        self.write_line("")
        
        // Pre-pass: Index structs and fields
        
        for item in program.items:
            match item:
                Struct(def) =>
                    let field_names = []
                    for f in def.fields:
                        push(field_names, f.name)
                        map_set(self.field_map, f.name, def.name)
                    map_set(self.struct_layouts, def.name, field_names)
                Impl(def) =>
                    for m in def.methods:
                        map_set(self.method_map, m.name, def.target)
                _ => ()

        // Emit each item
        
        
        let items_ptr = program.items
        
        println(items_ptr)
        
        let count = array_len(items_ptr)
        
        println(count)
        
        for item in program.items:
            
            self.gen_item(item)
            self.write_line("")
        
        // Emit string constants at the end
        if array_len(self.strings) > 0:
            self.write_line("; String Constants")
            for i in range(0, array_len(self.strings)):
                let s = self.strings[i]
                let name = "@.str." + str(i)
                let escaped = self.escape_string(s)
                self.write_line(name + " = private unnamed_addr constant [" + str(str_len(s) + 1) + " x i8] c\"" + escaped + "\\00\"")
        
        return self.output.build()
    
    /// Emit external function declarations (Kore runtime)
    fn emit_externals(self) -> Unit:
        self.write_line("; External Runtime Functions")
        self.write_line("declare i8* @malloc(i64)")
        self.write_line("declare void @free(i8*)")
        self.write_line("declare i32 @printf(i8*, ...)")
        self.write_line("declare i32 @puts(i8*)")
        self.write_line("")
        self.write_line("; Kore Runtime")
        self.write_line("declare void @kore_print_i64(i64)")
        self.write_line("declare void @kore_print_str(i8*)")
        self.write_line("declare void @kore_println_str(i8*)")
        self.write_line("declare i8* @kore_str_concat(i8*, i8*)")
        self.write_line("declare i64 @kore_array_new()")
        self.write_line("declare void @kore_array_push(i64, i64)")
        self.write_line("declare i64 @kore_array_get(i64, i64)")
        self.write_line("declare i64 @kore_array_len(i64)")
    
    fn escape_string(self, s: String) -> String:
        // Escape special chars for LLVM string literals
        let result = ""
        let chars = split(s, "")
        for c in chars:
            if c == "\n":
                result = result + "\\0A"
            else if c == "\t":
                result = result + "\\09"
            else if c == "\\":
                result = result + "\\\\"
            else if c == "\"":
                result = result + "\\22"
            else:
                result = result + c
        return result
    
    // =========================================================================
    // Item Generation
    // =========================================================================
    
    fn gen_item(self, item: Item) -> Unit:
        
        let v = variant_of(item)
        match item:
            Function(fn_def) => 
                
                self.gen_function(fn_def)
            Struct(struct_def) => 
                
                self.gen_struct(struct_def)
            Enum(enum_def) => 
                
                self.gen_enum(enum_def)
            Impl(impl_def) => 
                
                self.gen_impl(impl_def)
            Use(path) => 
                
                self.write_line("; use " + path)
    
    fn gen_function(self, fn_def: FnDef) -> Unit:
        let name = fn_def.name
        // println("DEBUG: Got function name: " + name)
        
        if name == "main":
            
            name = "main_kore"
        
        // Reset local counter for each function
        
        self.local_counter = 0
        
        self.vars = Map::new()
        
        
        // Build parameter list
        let params_str = ""
        let first = true
        
        let params_ptr = fn_def.params
        
        
        for param in fn_def.params:
            
            if !first:
                params_str = params_str + ", "
            first = false
            params_str = params_str + "i64 %" + param.name
        
        
        // Emit function definition
        
        self.write_line("define i64 @" + name + "(" + params_str + ") {")
        
        
        
        self.indent = self.indent + 1
        
        
        
        self.write_line("entry:")
        
        
        // Store parameters in alloca'd slots
        // 
        // println("DEBUG: params ptr 2: " + str(fn_def.params))
        // for param in fn_def.params:
        //    let ptr = self.fresh_local()
        //    self.write_line(ptr + " = alloca i64")
        //    self.write_line("store i64 %" + param.name + ", i64* " + ptr)
        //    self.vars[param.name] = ptr
        //    self.write_line(ptr + " = alloca i64")
        //    self.write_line("store i64 %" + param.name + ", i64* " + ptr)
        //    self.vars[param.name] = ptr
        
        // Generate body
        for stmt in fn_def.body:
            
            self.gen_stmt(stmt)
        
        // Ensure we have a return (for functions that don't explicitly return)
        self.write_line("ret i64 0")
        
        self.indent = self.indent - 1
        self.write_line("}")
    
    fn gen_struct(self, struct_def: StructDef) -> Unit:
        self.write_line("; struct " + struct_def.name)
        // Build struct type from fields
        let fields_str = ""
        let first = true
        for field in struct_def.fields:
            if !first:
                fields_str = fields_str + ", "
            first = false
            fields_str = fields_str + "i64"  // For now, all fields are i64
        if fields_str == "":
            fields_str = "i64"  // Empty struct gets a dummy field
        self.write_line("%" + struct_def.name + " = type { " + fields_str + " }")
    
    fn gen_enum(self, enum_def: EnumDef) -> Unit:
        self.write_line("; enum " + enum_def.name)
        // Enums are {tag: i64, payload: i8*}
        self.write_line("%" + enum_def.name + " = type { i64, i8* }")
    
    fn gen_impl(self, impl_def: ImplDef) -> Unit:
        self.write_line("; impl " + impl_def.target)
        for method in impl_def.methods:
            // Mangle method name: Type_method
            let orig_name = method.name
            method.name = impl_def.target + "_" + method.name
            self.gen_function(method)
            method.name = orig_name
    
    // =========================================================================
    // Statement Generation
    // =========================================================================
    
    fn gen_stmt(self, stmt: Stmt) -> Unit:
        
        let v = variant_of(stmt)
        
        if v == "Let":
            let name = variant_field(stmt, 0)
            let ty = variant_field(stmt, 1)
            let value = variant_field(stmt, 2)
            
            let val_reg = self.gen_expr(value)
            let ptr = self.fresh_local()
            self.write_line(ptr + " = alloca i64")
            self.write_line("store i64 " + val_reg + ", i64* " + ptr)
            map_set(self.vars, name, ptr)
            
            return
        
        if v == "Var":
            let name = variant_field(stmt, 0)
            let ty = variant_field(stmt, 1)
            let value = variant_field(stmt, 2)
            let val_reg = self.gen_expr(value)
            let ptr = self.fresh_local()
            self.write_line(ptr + " = alloca i64")
            self.write_line("store i64 " + val_reg + ", i64* " + ptr)
            map_set(self.vars, name, ptr)
            return
        
        if v == "Return":
            let maybe_expr = variant_field(stmt, 0)
            if maybe_expr != None:
                let val = self.gen_expr(maybe_expr)
                self.write_line("ret i64 " + val)
            else:
                self.write_line("ret i64 0")
            return
        
        if v == "Expr":
            let expr = variant_field(stmt, 0)
            self.gen_expr(expr)
            return
        
        if v == "If":
            let cond = variant_field(stmt, 0)
            let then_block = variant_field(stmt, 1)
            let else_block = variant_field(stmt, 2)
            
            let cond_val = self.gen_expr(cond)
            let cond_bool = self.fresh_local()
            self.write_line(cond_bool + " = icmp ne i64 " + cond_val + ", 0")
            
            let then_label = self.fresh_label("then")
            let else_label = self.fresh_label("else")
            let end_label = self.fresh_label("endif")
            
            if else_block != None:
                self.write_line("br i1 " + cond_bool + ", label %" + then_label + ", label %" + else_label)
            else:
                self.write_line("br i1 " + cond_bool + ", label %" + then_label + ", label %" + end_label)
            
            // Then block
            self.write_line(then_label + ":")
            for s in then_block:
                self.gen_stmt(s)
            self.write_line("br label %" + end_label)
            
            // Else block
            if else_block != None:
                self.write_line(else_label + ":")
                for s in else_block:
                    self.gen_stmt(s)
                self.write_line("br label %" + end_label)
            
            self.write_line(end_label + ":")
            return
        
        if v == "While":
            let cond = variant_field(stmt, 0)
            let body = variant_field(stmt, 1)
            
            let cond_label = self.fresh_label("while_cond")
            let body_label = self.fresh_label("while_body")
            let end_label = self.fresh_label("while_end")
            
            push(self.loop_labels, end_label)
            
            self.write_line("br label %" + cond_label)
            
            self.write_line(cond_label + ":")
            let cond_val = self.gen_expr(cond)
            let cond_bool = self.fresh_local()
            self.write_line(cond_bool + " = icmp ne i64 " + cond_val + ", 0")
            self.write_line("br i1 " + cond_bool + ", label %" + body_label + ", label %" + end_label)
            
            self.write_line(body_label + ":")
            for s in body:
                self.gen_stmt(s)
            self.write_line("br label %" + cond_label)
            
            self.write_line(end_label + ":")
            
            pop(self.loop_labels)
            return
        
        if v == "For":
            // For loops get lowered to while loops
            // for x in iter: body  =>  let i = 0; while i < len(iter): let x = iter[i]; body; i = i + 1
            self.write_line("; for loop (simplified as iteration)")
            return
        
        if v == "Loop":
            let body = variant_field(stmt, 0)
            let loop_label = self.fresh_label("loop")
            let end_label = self.fresh_label("loop_end")
            
            push(self.loop_labels, end_label)
            
            self.write_line("br label %" + loop_label)
            self.write_line(loop_label + ":")
            for s in body:
                self.gen_stmt(s)
            self.write_line("br label %" + loop_label)
            self.write_line(end_label + ":")
            
            pop(self.loop_labels)
            return
        
        if v == "Match":
            self.write_line("; Complex pattern matching evaluation remains in the experimental stage.")
            return
        
        if v == "Break":
            if array_len(self.loop_labels) > 0:
                let end_label = self.loop_labels[array_len(self.loop_labels) - 1]
                self.write_line("br label %" + end_label)
            else:
                self.write_line("; Error: break outside loop")
            return
        
        if v == "Continue":
            self.write_line("; Loop control jump labels pending final integration.")
            return
        
        if v == "Assign":
            let lhs = variant_field(stmt, 0)
            let rhs = variant_field(stmt, 1)
            let val = self.gen_expr(rhs)
            let lhs_v = variant_of(lhs)
            
            if lhs_v == "Ident":
                let name = variant_field(lhs, 0)
                if contains_key(self.vars, name):
                    let ptr = self.vars[name]
                    self.write_line("store i64 " + val + ", i64* " + ptr)
            
            else if lhs_v == "Field":
                let obj = variant_field(lhs, 0)
                let field_name = variant_field(lhs, 1)
                
                // 1. Evaluate object (pointer)
                let obj_ptr_i64 = self.gen_expr(obj)
                
                // 2. Determine struct type
                if contains_key(self.field_map, field_name):
                    let struct_name = self.field_map[field_name]
                    let fields = self.struct_layouts[struct_name]
                    
                    // 3. Find field index
                    let index = -1
                    for i in range(0, array_len(fields)):
                        if str_eq(fields[i], field_name):
                            index = i
                            break
                    
                    self.write_line("; DEBUG: Resolved field " + field_name + " in " + struct_name + " to index " + str(index))
                    
                    if index != -1:
                        // 4. Calculate address
                        let obj_ptr = self.fresh_local()
                        self.write_line(obj_ptr + " = inttoptr i64 " + obj_ptr_i64 + " to %" + struct_name + "*")
                        
                        let field_ptr = self.fresh_local()
                        self.write_line(field_ptr + " = getelementptr %" + struct_name + ", %" + struct_name + "* " + obj_ptr + ", i32 0, i32 " + str(index))
                        
                        // 5. Store
                        self.write_line("store i64 " + val + ", i64* " + field_ptr)
                    else:
                        self.write_line("; Error: Field " + field_name + " not found in struct " + struct_name)
                else:
                    self.write_line("; Error: Unknown field " + field_name)
            
            return
        
    
    // =========================================================================
    // Expression Generation
    // =========================================================================
    
    fn gen_expr(self, expr: Expr) -> String:
        
        let v = variant_of(expr)
        
        if v == "Int":
            let n = variant_field(expr, 0)
            return str(n)
        
        if v == "Float":
            let f = variant_field(expr, 0)
            // LLVM uses hex for floats, but we'll just use the number for now
            return str(f)
        
        if v == "Bool":
            let b = variant_field(expr, 0)
            if b:
                return "1"
            return "0"
        
        if v == "String":
            let s = variant_field(expr, 0)
            // Add to string table
            push(self.strings, s)
            let name = "@.str." + str(array_len(self.strings) - 1)
            let result = self.fresh_local()
            // Get pointer to first element
            self.write_line(result + " = getelementptr [" + str(str_len(s) + 1) + " x i8], [" + str(str_len(s) + 1) + " x i8]* " + name + ", i64 0, i64 0")
            // Cast to i64
            let cast_result = self.fresh_local()
            self.write_line(cast_result + " = ptrtoint i8* " + result + " to i64")
            return cast_result
        
        if v == "Ident":
            let name = variant_field(expr, 0)
            // Look up in variable environment
            if contains_key(self.vars, name):
                let ptr = map_get_string(self.vars, name)
                let result = self.fresh_local()
                self.write_line(result + " = load i64, i64* " + ptr)
                return result
            // Might be a global or parameter we didn't track
            return "%" + name
        
        if v == "Binary":
            let left = variant_field(expr, 0)
            let op = variant_field(expr, 1)
            let right = variant_field(expr, 2)
            let l = self.gen_expr(left)
            let r = self.gen_expr(right)
            let result = self.fresh_local()
            
            if op == "+":
                self.write_line(result + " = add i64 " + l + ", " + r)
            else if op == "-":
                self.write_line(result + " = sub i64 " + l + ", " + r)
            else if op == "*":
                self.write_line(result + " = mul i64 " + l + ", " + r)
            else if op == "/":
                self.write_line(result + " = sdiv i64 " + l + ", " + r)
            else if op == "%":
                self.write_line(result + " = srem i64 " + l + ", " + r)
            else if op == "==" || op == "eq":
                let cmp = self.fresh_local()
                self.write_line(cmp + " = icmp eq i64 " + l + ", " + r)
                self.write_line(result + " = zext i1 " + cmp + " to i64")
            else if op == "!=" || op == "ne":
                let cmp = self.fresh_local()
                self.write_line(cmp + " = icmp ne i64 " + l + ", " + r)
                self.write_line(result + " = zext i1 " + cmp + " to i64")
            else if op == "<" || op == "lt":
                let cmp = self.fresh_local()
                self.write_line(cmp + " = icmp slt i64 " + l + ", " + r)
                self.write_line(result + " = zext i1 " + cmp + " to i64")
            else if op == "<=" || op == "le":
                let cmp = self.fresh_local()
                self.write_line(cmp + " = icmp sle i64 " + l + ", " + r)
                self.write_line(result + " = zext i1 " + cmp + " to i64")
            else if op == ">" || op == "gt":
                let cmp = self.fresh_local()
                self.write_line(cmp + " = icmp sgt i64 " + l + ", " + r)
                self.write_line(result + " = zext i1 " + cmp + " to i64")
            else if op == ">=" || op == "ge":
                let cmp = self.fresh_local()
                self.write_line(cmp + " = icmp sge i64 " + l + ", " + r)
                self.write_line(result + " = zext i1 " + cmp + " to i64")
            else if op == "&&" || op == "and":
                self.write_line(result + " = and i64 " + l + ", " + r)
            else if op == "||" || op == "or":
                self.write_line(result + " = or i64 " + l + ", " + r)
            else:
                self.write_line("; unknown op: " + op)
                return "0"
            return result
        
        if v == "Unary":
            let op = variant_field(expr, 0)
            let operand = variant_field(expr, 1)
            let o = self.gen_expr(operand)
            let result = self.fresh_local()
            
            if op == "-":
                self.write_line(result + " = sub i64 0, " + o)
            else if op == "!" || op == "not":
                let cmp = self.fresh_local()
                self.write_line(cmp + " = icmp eq i64 " + o + ", 0")
                self.write_line(result + " = zext i1 " + cmp + " to i64")
            else:
                return o
            return result
        
        if v == "Call":
            let callee = variant_field(expr, 0)
            let args = variant_field(expr, 1)
            
            // Generate args
            let arg_regs = []
            for arg in args:
                push(arg_regs, self.gen_expr(arg))
            
            let callee_v = variant_of(callee)
            if callee_v == "Ident":
                let fn_name = variant_field(callee, 0)
                
                // Handle built-in print functions
                if fn_name == "println" || fn_name == "print":
                    if array_len(arg_regs) > 0:
                        self.write_line("call void @kore_print_i64(i64 " + arg_regs[0] + ")")
                    return "0"
                
                let result = self.fresh_local()
                let args_str = ""
                let first = true
                for reg in arg_regs:
                    if !first:
                        args_str = args_str + ", "
                    first = false
                    args_str = args_str + "i64 " + reg
                self.write_line(result + " = call i64 @" + fn_name + "(" + args_str + ")")
                return result
            
            self.write_line("; Indirect function resolution logic is being finalized.")
            return "0"
        
        if v == "None":
            return "0"
        
        if v == "Array":
            // Arrays need runtime support
            self.write_line("; Array literal initialization backend remains under development.")
            return "0"
        
        if v == "Index":
            let arr = variant_field(expr, 0)
            let idx = variant_field(expr, 1)
            let arr_val = self.gen_expr(arr)
            let idx_val = self.gen_expr(idx)
            let result = self.fresh_local()
            self.write_line(result + " = call i64 @kore_array_get(i64 " + arr_val + ", i64 " + idx_val + ")")
            return result
        
        if v == "Field":
            let obj = variant_field(expr, 0)
            let field_name = variant_field(expr, 1)
            
            let obj_val = self.gen_expr(obj)
            
            if contains_key(self.field_map, field_name):
                let struct_name = map_get_string(self.field_map, field_name)
                let fields = map_get_array(self.struct_layouts, struct_name)
                
                let idx = -1
                for i in range(0, array_len(fields)):
                    if str_eq(fields[i], field_name):
                        idx = i
                        break
                
                self.write_line("; DEBUG: Resolved field " + field_name + " in " + struct_name + " to index " + str(idx))
                
                if idx != -1:
                    let obj_ptr = self.fresh_local()
                    self.write_line(obj_ptr + " = inttoptr i64 " + obj_val + " to %" + struct_name + "*")
                    
                    let field_ptr = self.fresh_local()
                    self.write_line(field_ptr + " = getelementptr %" + struct_name + ", %" + struct_name + "* " + obj_ptr + ", i32 0, i32 " + str(idx))
                    
                    let val = self.fresh_local()
                    self.write_line(val + " = load i64, i64* " + field_ptr)
                    return val
                else:
                    self.write_line("; Error: Field " + field_name + " not found in struct " + struct_name)
            else:
                self.write_line("; Error: Unknown field " + field_name)
            
            return "0"
        
        if v == "Struct":
            let name = variant_field(expr, 0)
            let inits = variant_field(expr, 1)
            
            if contains_key(self.struct_layouts, name):
                let fields = map_get_array(self.struct_layouts, name)
                let size = array_len(fields) * 8
                if size == 0:
                    size = 8 // Minimum allocation
                
                // Allocate memory
                let ptr_i8 = self.fresh_local()
                self.write_line(ptr_i8 + " = call i8* @malloc(i64 " + str(size) + ")")
                
                let ptr = self.fresh_local()
                self.write_line(ptr + " = bitcast i8* " + ptr_i8 + " to %" + name + "*")
                
                // Initialize fields
                for init in inits:
                    let fname = init.name
                    let fval = self.gen_expr(init.value)
                    
                    // Find index
                    let idx = -1
                    for i in range(0, array_len(fields)):
                        if str_eq(fields[i], fname):
                            idx = i
                            break
                    
                    if idx != -1:
                        let fptr = self.fresh_local()
                        self.write_line(fptr + " = getelementptr %" + name + ", %" + name + "* " + ptr + ", i32 0, i32 " + str(idx))
                        self.write_line("store i64 " + fval + ", i64* " + fptr)
                
                // Return pointer as int
                let result = self.fresh_local()
                self.write_line(result + " = ptrtoint %" + name + "* " + ptr + " to i64")
                return result
            
            return "0"
        
        if v == "MethodCall":
            let obj = variant_field(expr, 0)
            let method = variant_field(expr, 1)
            let args = variant_field(expr, 2)
            
            // 1. Evaluate receiver
            let obj_val = self.gen_expr(obj)
            
            // 2. Resolve method target
            if contains_key(self.method_map, method):
                let target_type = map_get_string(self.method_map, method)
                let mangled = target_type + "_" + method
                
                // 3. Prepare args (prepend self)
                let arg_regs = []
                push(arg_regs, obj_val)
                for arg in args:
                    push(arg_regs, self.gen_expr(arg))
                
                let args_str = ""
                let first = true
                for reg in arg_regs:
                    if !first:
                        args_str = args_str + ", "
                    first = false
                    args_str = args_str + "i64 " + reg
                
                let result = self.fresh_local()
                self.write_line(result + " = call i64 @" + mangled + "(" + args_str + ")")
                return result
            else:
                self.write_line("; Error: Unknown method " + method)
            
            return "0"

        if v == "EnumVariant":
            self.write_line("; Enum variant instantiation logic is being refined.")
            return "0"
        
        // Fallback
        self.write_line("; unknown expr: " + v)
        return "0"

// =============================================================================
// Entry Point
// =============================================================================



// ============================================================================
// KORE Bootstrap Compiler - Rust Code Generator
// ============================================================================
// Project Ouroboros - Hybrid Backend
//
// This transpiles Kore AST to Rust source code.
// The generated Rust can be compiled with `cargo build`.
//
// Benefits:
//   - Access to entire Rust ecosystem (tokio, serde, bevy, etc.)
//   - Rust's borrow checker validates your Kore code
//   - Cross-compilation to any Rust target
//
// Usage:
//   kore compile main.kr --target rust
//   cd output && cargo build --release
//
// This module is written in KORE itself!
// ============================================================================

// Module imports - lexer and parser for tokenization and parsing

// TODO: These need stdlib implementations
// use std/io
// use std/fs
// use std/collections

// =============================================================================
// StringBuilder - Simple string accumulator
// =============================================================================

struct StringBuilder:
    lines: Array<String>

impl StringBuilder:
    pub fn new() -> StringBuilder:
        return StringBuilder { lines: [] }
    
    pub fn push(self, text: String) -> Unit:
        push(self.lines, text)
    
    pub fn push_line(self, text: String) -> Unit:
        push(self.lines, text + "\n")
    
    pub fn build(self) -> String:
        return join(self.lines, "")

// =============================================================================
// Rust Code Generator
// =============================================================================

struct RustGen:
    output: StringBuilder
    indent: Int
    use_statements: Array<String>
    struct_impls: StringBuilder  // Collect impl blocks to emit after structs

impl RustGen:
    pub fn new() -> RustGen:
        return RustGen {
            output: StringBuilder::new(),
            indent: 0,
            use_statements: [],
            struct_impls: StringBuilder::new()
        }
    
    /// Increase indentation
    fn push_indent(self) -> Unit:
        self.indent = self.indent + 1
    
    /// Decrease indentation
    fn pop_indent(self) -> Unit:
        if self.indent > 0:
            self.indent = self.indent - 1
    
    /// Get current indent string
    fn indent_str(self) -> String:
        let s = ""
        for i in range(0, self.indent):
            s = s + "    "
        return s
    
    /// Emit a line with current indentation
    fn write_line(self, line: String) -> Unit:
        self.output.push(self.indent_str())
        self.output.push_line(line)
    
    /// Emit raw text (no indent, no newline)
    fn write_raw(self, text: String) -> Unit:
        self.output.push(text)
    
    /// Emit a blank line
    fn write_blank(self) -> Unit:
        self.output.push_line("")
    
    // =========================================================================
    // Program Generation
    // =========================================================================
    
    /// Generate Rust code for an entire program
    pub fn gen_program(self, program: Program) -> String:
        // Header
        self.write_line("// Generated by KORE Compiler (Project Ouroboros)")
        self.write_line("// Do not edit - regenerate from .kr source")
        self.write_blank()
        self.write_line("#![allow(unused_variables)]")
        self.write_line("#![allow(unused_mut)]")
        self.write_line("#![allow(dead_code)]")
        self.write_line("#![allow(unused_parens)]")
        self.write_blank()
        
        // Standard imports
        self.write_line("use std::collections::HashMap;")
        self.write_line("use std::rc::Rc;")
        self.write_line("use std::cell::RefCell;")
        self.write_blank()
        
        // Generate each item
        for item in program.items:
            self.gen_item(item)
            self.write_blank()
        
        // Emit collected impl blocks
        let impls = self.struct_impls.build()
        if array_len(impls) > 0:
            self.output.push(impls)
        
        return self.output.build()
    
    // =========================================================================
    // Item Generation
    // =========================================================================
    
    fn gen_item(self, item: Item) -> Unit:
        match item:
            Function(fn_def) => self.gen_function(fn_def)
            Struct(struct_def) => self.gen_struct(struct_def)
            Enum(enum_def) => self.gen_enum(enum_def)
            Impl(impl_def) => self.gen_impl(impl_def)
            Use(path) => self.gen_use(path)
    
    /// Generate a function definition
    fn gen_function(self, fn_def: FnDef) -> Unit:
        // Visibility
        let vis = ""
        if fn_def.is_pub:
            vis = "pub "
        
        // Async modifier
        let async_mod = ""
        if fn_def.is_async:
            async_mod = "async "
        
        // Parameters
        let params = self.gen_params(fn_def.params)
        
        // Return type - infer i64 if missing and function has return statements
        let ret = ""
        if fn_def.return_type != None:
            ret = " -> " + self.map_type(fn_def.return_type)
        else:
            // Check if function has return statements (heuristic: non-main functions need return types)
            if fn_def.name != "main":
                // For bootstrap, assume functions return i64 unless otherwise specified
                // This is a temporary workaround
                ret = ""  // Actually, let's leave it empty and let Rust infer
        
        // Function signature
        self.write_line(vis + async_mod + "fn " + fn_def.name + "(" + params + ")" + ret + " {")
        self.push_indent()
        
        // Body
        for stmt in fn_def.body:
            self.gen_stmt(stmt)
        
        self.pop_indent()
        self.write_line("}")
    
    /// Generate function parameters
    fn gen_params(self, params: Array<Param>) -> String:
        let parts = []
        for param in params:
            let ty = "i64"  // Default type
            if param.ty != None:
                ty = self.map_type(param.ty)
            push(parts, param.name + ": " + ty)
        return join(parts, ", ")
    
    /// Generate a struct definition
    fn gen_struct(self, struct_def: StructDef) -> Unit:
        let vis = ""
        if struct_def.is_pub:
            vis = "pub "
        
        self.write_line("#[derive(Debug, Clone)]")
        self.write_line(vis + "struct " + struct_def.name + " {")
        self.push_indent()
        
        for field in struct_def.fields:
            self.write_line("pub " + field.name + ": " + self.map_type(field.ty) + ",")
        
        self.pop_indent()
        self.write_line("}")
    
    /// Generate an enum definition
    fn gen_enum(self, enum_def: EnumDef) -> Unit:
        self.write_line("#[derive(Debug, Clone, PartialEq)]")
        self.write_line("pub enum " + enum_def.name + " {")
        self.push_indent()
        
        for variant in enum_def.variants:
            if array_len(variant.fields) == 0:
                self.write_line(variant.name + ",")
            else:
                let fields = join(variant.fields, ", ")
                self.write_line(variant.name + "(" + fields + "),")
        
        self.pop_indent()
        self.write_line("}")
    
    /// Generate an impl block
    fn gen_impl(self, impl_def: ImplDef) -> Unit:
        self.write_line("impl " + impl_def.target + " {")
        self.push_indent()
        
        for method in impl_def.methods:
            // Add &self or &mut self as first param
            let params = []
            push(params, "&self")
            for param in method.params:
                let ty = "i64"
                match param.ty:
                    Some(t) => ty = self.map_type(t)
                    None => ty = "i64"
                push(params, param.name + ": " + ty)
            
            let params_str = join(params, ", ")
            let ret = ""
            match method.return_type:
                Some(ty) => ret = " -> " + self.map_type(ty)
                None => ret = ""
            
            let vis = ""
            if method.is_pub:
                vis = "pub "
            
            self.write_line(vis + "fn " + method.name + "(" + params_str + ")" + ret + " {")
            self.push_indent()
            
            for stmt in method.body:
                self.gen_stmt(stmt)
            
            self.pop_indent()
            self.write_line("}")
            self.write_blank()
        
        self.pop_indent()
        self.write_line("}")
    
    /// Generate a use statement
    fn gen_use(self, path: String) -> Unit:
        // Convert Kore path to Rust path
        let rust_path = replace(path, "/", "::")
        self.write_line("use " + rust_path + ";")
    
    // =========================================================================
    // Statement Generation
    // =========================================================================
    
    fn gen_stmt(self, stmt: Stmt) -> Unit:
        // Bootstrap workaround: use variant_of/variant_field instead of pattern matching
        let v = variant_of(stmt)
        
        if v == "Let":
            let name = variant_field(stmt, 0)
            let ty = variant_field(stmt, 1)
            let value = variant_field(stmt, 2)
            let ty_str = ""
            if ty != None:
                ty_str = ": " + self.map_type(ty)
            self.write_line("let " + name + ty_str + " = " + self.gen_expr(value) + ";")
            return
        
        if v == "Var":
            let name = variant_field(stmt, 0)
            let ty = variant_field(stmt, 1)
            let value = variant_field(stmt, 2)
            let ty_str = ""
            if ty != None:
                ty_str = ": " + self.map_type(ty)
            self.write_line("let mut " + name + ty_str + " = " + self.gen_expr(value) + ";")
            return
        
        if v == "Assign":
            let lhs = variant_field(stmt, 0)
            let rhs = variant_field(stmt, 1)
            self.write_line(self.gen_expr(lhs) + " = " + self.gen_expr(rhs) + ";")
            return
        
        if v == "Return":
            let maybe_expr = variant_field(stmt, 0)
            if maybe_expr != None:
                self.write_line("return " + self.gen_expr(maybe_expr) + ";")
            else:
                self.write_line("return;")
            return
        
        if v == "If":
            let cond = variant_field(stmt, 0)
            let then_block = variant_field(stmt, 1)
            let else_block = variant_field(stmt, 2)
            self.write_line("if " + self.gen_expr(cond) + " {")
            self.push_indent()
            for s in then_block:
                self.gen_stmt(s)
            self.pop_indent()
            if else_block != None:
                self.write_line("} else {")
                self.push_indent()
                for s in else_block:
                    self.gen_stmt(s)
                self.pop_indent()
                self.write_line("}")
            else:
                self.write_line("}")
            return
        
        if v == "While":
            let cond = variant_field(stmt, 0)
            let body = variant_field(stmt, 1)
            self.write_line("while " + self.gen_expr(cond) + " {")
            self.push_indent()
            for s in body:
                self.gen_stmt(s)
            self.pop_indent()
            self.write_line("}")
            return
        
        if v == "For":
            let var_name = variant_field(stmt, 0)
            let iter = variant_field(stmt, 1)
            let body = variant_field(stmt, 2)
            self.write_line("for " + var_name + " in " + self.gen_expr(iter) + " {")
            self.push_indent()
            for s in body:
                self.gen_stmt(s)
            self.pop_indent()
            self.write_line("}")
            return
        
        if v == "Loop":
            let body = variant_field(stmt, 0)
            self.write_line("loop {")
            self.push_indent()
            for s in body:
                self.gen_stmt(s)
            self.pop_indent()
            self.write_line("}")
            return
        
        if v == "Match":
            let scrutinee = variant_field(stmt, 0)
            let arms = variant_field(stmt, 1)
            self.write_line("match " + self.gen_expr(scrutinee) + " {")
            self.push_indent()
            for arm in arms:
                let pat = self.gen_pattern(arm.pattern)
                self.write_line(pat + " => {")
                self.push_indent()
                for s in arm.body:
                    self.gen_stmt(s)
                self.pop_indent()
                self.write_line("}")
            self.pop_indent()
            self.write_line("}")
            return
        
        if v == "Expr":
            let expr = variant_field(stmt, 0)
            self.write_line(self.gen_expr(expr) + ";")
            return
        
        if v == "Break":
            self.write_line("break;")
            return
        
        if v == "Continue":
            self.write_line("continue;")
            return
    
    // =========================================================================
    // Expression Generation
    // =========================================================================
    
    fn gen_expr(self, expr: Expr) -> String:
        // Bootstrap workaround: use variant_of/variant_field instead of pattern matching
        let v = variant_of(expr)
        
        if v == "Int":
            let n = variant_field(expr, 0)
            return str(n)
        
        if v == "Float":
            let f = variant_field(expr, 0)
            return str(f)
        
        if v == "String":
            let s = variant_field(expr, 0)
            return "\"" + self.escape_string(s) + "\".to_string()"
        
        if v == "Bool":
            let b = variant_field(expr, 0)
            if b:
                return "true"
            return "false"
        
        if v == "None":
            return "None"
        
        if v == "Ident":
            let name = variant_field(expr, 0)
            return name
        
        if v == "Binary":
            let left = variant_field(expr, 0)
            let op = variant_field(expr, 1)
            let right = variant_field(expr, 2)
            let l = self.gen_expr(left)
            let r = self.gen_expr(right)
            let rust_op = self.map_op(op)
            return "(" + l + " " + rust_op + " " + r + ")"
        
        if v == "Unary":
            let op = variant_field(expr, 0)
            let operand = variant_field(expr, 1)
            let o = self.gen_expr(operand)
            return "(" + op + o + ")"
        
        if v == "Call":
            let callee = variant_field(expr, 0)
            let args = variant_field(expr, 1)
            let fn_name = self.gen_expr(callee)
            
            // Convert Kore builtins to Rust macros with format strings
            if fn_name == "println" || fn_name == "print":
                let arg_strs = []
                let format_placeholders = []
                for arg in args:
                    push(arg_strs, self.gen_expr(arg))
                    push(format_placeholders, "{}")
                
                let format_str = "\"" + join(format_placeholders, " ") + "\""
                if array_len(arg_strs) > 0:
                    return fn_name + "!(" + format_str + ", " + join(arg_strs, ", ") + ")"
                return fn_name + "!()"
            
            let arg_strs = []
            for arg in args:
                push(arg_strs, self.gen_expr(arg))
            return fn_name + "(" + join(arg_strs, ", ") + ")"
        
        if v == "MethodCall":
            let receiver = variant_field(expr, 0)
            let method = variant_field(expr, 1)
            let args = variant_field(expr, 2)
            let recv = self.gen_expr(receiver)
            let arg_strs = []
            for arg in args:
                push(arg_strs, self.gen_expr(arg))
            return recv + "." + method + "(" + join(arg_strs, ", ") + ")"
        
        if v == "Index":
            let array = variant_field(expr, 0)
            let index = variant_field(expr, 1)
            return self.gen_expr(array) + "[" + self.gen_expr(index) + "]"
        
        if v == "Field":
            let obj = variant_field(expr, 0)
            let field = variant_field(expr, 1)
            return self.gen_expr(obj) + "." + field
        
        if v == "Array":
            let elements = variant_field(expr, 0)
            let elems = []
            for e in elements:
                push(elems, self.gen_expr(e))
            return "vec![" + join(elems, ", ") + "]"
        
        if v == "Struct":
            let name = variant_field(expr, 0)
            let field_inits = variant_field(expr, 1)
            let fields = []
            for fi in field_inits:
                push(fields, fi.name + ": " + self.gen_expr(fi.value))
            return name + " { " + join(fields, ", ") + " }"
        
        if v == "EnumVariant":
            let enum_name = variant_field(expr, 0)
            let variant_name = variant_field(expr, 1)
            let args = variant_field(expr, 2)
            if array_len(args) == 0:
                return enum_name + "::" + variant_name
            let arg_strs = []
            for arg in args:
                push(arg_strs, self.gen_expr(arg))
            return enum_name + "::" + variant_name + "(" + join(arg_strs, ", ") + ")"
        
        if v == "If":
            let cond = variant_field(expr, 0)
            let then_expr = variant_field(expr, 1)
            let else_expr = variant_field(expr, 2)
            let c = self.gen_expr(cond)
            let t = self.gen_expr(then_expr)
            if else_expr != None:
                return "(if " + c + " { " + t + " } else { " + self.gen_expr(else_expr) + " })"
            return "(if " + c + " { " + t + " } else { () })"
        
        if v == "Lambda":
            let params = variant_field(expr, 0)
            let body = variant_field(expr, 1)
            let p = join(params, ", ")
            return "|" + p + "| " + self.gen_expr(body)
        
        if v == "Await":
            let future = variant_field(expr, 0)
            return self.gen_expr(future) + ".await"
        
        // Fallback
        return "/* unsupported expr: " + v + " */"
    
    /// Generate a pattern for match arms
    fn gen_pattern(self, pattern: Pattern) -> String:
        // Bootstrap workaround: use variant_of/variant_field instead of pattern matching
        let v = variant_of(pattern)
        
        if v == "Wildcard":
            return "_"
        
        if v == "Ident":
            let name = variant_field(pattern, 0)
            return name
        
        if v == "Literal":
            let expr = variant_field(pattern, 0)
            return self.gen_expr(expr)
        
        if v == "Variant":
            let name = variant_field(pattern, 0)
            let fields = variant_field(pattern, 1)
            if array_len(fields) == 0:
                return name
            let field_pats = []
            for f in fields:
                push(field_pats, self.gen_pattern(f))
            return name + "(" + join(field_pats, ", ") + ")"
        
        return "/* unsupported pattern */"
    
    // =========================================================================
    // Type Mapping
    // =========================================================================
    
    fn map_type(self, ty: String) -> String:
        if ty == "Int":
            return "i64"
        if ty == "Float":
            return "f64"
        if ty == "Bool":
            return "bool"
        if ty == "String":
            return "String"
        if ty == "Unit":
            return "()"
        if ty == "Array":
            return "Vec<i64>"
        
        // Check for Array<T> pattern
        if starts_with(ty, "Array<"):
            let inner = substring(ty, 6, str_len(ty) - 1)
            return "Vec<" + self.map_type(inner) + ">"
        // Check for Option<T> pattern
        if starts_with(ty, "Option<"):
            let inner = substring(ty, 7, str_len(ty) - 1)
            return "Option<" + self.map_type(inner) + ">"
        // Assume it's a custom type
        return ty
    
    /// Map Kore operator to Rust operator
    fn map_op(self, op: String) -> String:
        if op == "and":
            return "&&"
        if op == "or":
            return "||"
        if op == "not":
            return "!"
        return op
    
    /// Escape special characters in strings
    fn escape_string(self, s: String) -> String:
        let result = ""
        let chars = split(s, "")
        for c in chars:
            if c == "\n":
                result = result + "\\n"
            else if c == "\t":
                result = result + "\\t"
            else if c == "\\":
                result = result + "\\\\"
            else if c == "\"":
                result = result + "\\\""
            else:
                result = result + c
        return result

// =============================================================================
// Cargo.toml Generator
// =============================================================================

fn gen_cargo_toml(name: String, deps: Array<String>) -> String:
    let sb = StringBuilder::new()
    
    sb.push_line("[package]")
    sb.push_line("name = \"" + name + "\"")
    sb.push_line("version = \"0.1.0\"")
    sb.push_line("edition = \"2021\"")
    sb.push_line("")
    sb.push_line("# Generated by KORE Compiler")
    sb.push_line("")
    sb.push_line("[dependencies]")
    
    for dep in deps:
        sb.push_line(dep + " = \"*\"")
    
    return sb.build()

// =============================================================================
// Entry Point
// =============================================================================



// ============================================================================
// KORE Bootstrap Compiler - Main Entry Point
// ============================================================================
// Project Ouroboros - The Self-Hosted Compiler
//
// This is the main compiler driver written in KORE itself.
// It orchestrates lexing, parsing, and code generation.
//
// Usage:
//   kore compile main.kr                    # Default: LLVM backend
//   kore compile main.kr --target rust      # Rust transpiler
//   kore compile main.kr --target llvm      # LLVM IR
//   kore compile main.kr --target wasm      # WebAssembly
//
// This module is written in KORE itself!
// ============================================================================

use std/io
use std/fs
use std/env

struct Path:
    path: String

impl Path:
    pub fn new(path: String) -> Path:
        return Path { path: path }
    
    pub fn with_extension(self, ext: String) -> String:
        // Simple implementation: remove last extension if present, add new one
        // Note: this returns a String, not a Path, as per usage
        let p = self.path
        // Logic for specialized path parsing remains under development.
        return p + "." + ext
        
    pub fn parent(self) -> String:
        // Logic for specialized path parsing remains under development.
        return "."
        
    pub fn stem(self) -> String:
        // Logic for specialized path parsing remains under development.
        return "project"

// =============================================================================
// Argument Parsing
// =============================================================================

struct ArgParser:
    args: Vec<String>

impl ArgParser:
    pub fn new() -> ArgParser:
        return ArgParser { args: args() }
    
    pub fn get_value(self, flag: String) -> Option<String>:
        let i = 0
        while i < array_len(self.args) - 1:
            if str_eq(self.args[i], flag):
                return Option::Some(self.args[i+1])
            i = i + 1
        return Option::None
    
    pub fn has_flag(self, flag: String) -> Bool:
        for arg in self.args:
            if str_eq(arg, flag):
                return true
        return false
    
    pub fn input_file(self) -> Option<String>:
        let i = 1
        while i < array_len(self.args):
            let arg = self.args[i]
            let first = substring(arg, 0, 1)
            if !str_eq(first, "-"):
                let prev = self.args[i-1]
                if !str_eq(prev, "-o") && !str_eq(prev, "--target"):
                    return Option::Some(arg)
            i = i + 1
        return Option::None

// =============================================================================
// Compiler Configuration
// =============================================================================

enum Target:
    LLVM
    Rust
    WASM

struct CompilerConfig:
    input_file: String
    output_file: Option<String>
    target: Target
    verbose: Bool

impl CompilerConfig:
    pub fn from_args() -> CompilerConfig:
        let parser = ArgParser::new()
        
        let output = parser.get_value("-o")
        let verbose = parser.has_flag("--verbose") || parser.has_flag("-v")
        
        let input = ""
        match parser.input_file():
            Some(f) => input = f
            None => 
                println("Error: No input file specified")
                exit(1)
        
        let target = Target::LLVM
        match parser.get_value("--target"):
            Some(t) =>
                if str_eq(t, "rust"):
                    target = Target::Rust
                else if str_eq(t, "wasm"):
                    target = Target::WASM
                else:
                    target = Target::LLVM
            None =>
                target = Target::LLVM
        
        return CompilerConfig {
            input_file: input,
            output_file: output,
            target: target,
            verbose: verbose
        }

// =============================================================================
// Compiler Driver
// =============================================================================

struct Compiler:
    config: CompilerConfig

impl Compiler:
    pub fn new(config: CompilerConfig) -> Compiler:
        return Compiler { config: config }
    
    /// Run the full compilation pipeline
    pub fn compile(self) -> Bool:
        if self.config.verbose:
            println(" KORE Compiler (Ouroboros)")
            println("")
        
        // 1. Read source file
        if self.config.verbose:
            println(" Reading: " + self.config.input_file)
        
        let source = read_file(self.config.input_file)
        
        // 2. Tokenize
        if self.config.verbose:
            println(" Tokenizing...")
        
        let lexer = Lexer::new(source)
        
        let tokens = lexer.tokenize()
        
        if self.config.verbose:
            println("   " + str(array_len(tokens)) + " tokens")
        
        // 3. Parse
        if self.config.verbose:
            println(" Parsing...")
        
        
        let parser = Parser::new(tokens)
        
        let program = parser.parse_program()
        
        if self.config.verbose:
            println("   " + str(array_len(program.items)) + " items")
        
        // 4. Generate code based on target
        let output_code = ""
        let output_ext = ""
        
        match self.config.target:
            Target::LLVM =>
                if self.config.verbose:
                    println(" Generating LLVM IR...")
                
                let gen = CodeGen::new()
                output_code = gen.gen_program(program)
                output_ext = ".ll"
            
            Target::Rust =>
                if self.config.verbose:
                    println(" Generating Rust...")
                let gen = RustGen::new()
                output_code = gen.gen_program(program)
                output_ext = ".rs"
            
            Target::WASM =>
                if self.config.verbose:
                    println(" Generating WASM...")
                // WebAssembly backend integration is currently in the late-stage development phase.
                println("WASM backend not yet implemented in bootstrap compiler")
                return false
        
        // 5. Write output
        let output_path = ""
        match self.config.output_file:
            Some(p) => output_path = p
            None =>
                let input_path = Path::new(self.config.input_file)
                output_path = input_path.with_extension(substring(output_ext, 1, str_len(output_ext)))
        
        if self.config.verbose:
            println(" Writing: " + output_path)
        
        
        write_file(output_path, output_code)
        
        // 6. Success!
        println(" Compiled to: " + output_path)
        
        // 7. Generate Cargo.toml for Rust target
        match self.config.target:
            Target::Rust =>
                let cargo_path = Path::new(output_path).parent() + "/Cargo.toml"
                let input_path = Path::new(self.config.input_file)
                let cargo_content = gen_cargo_toml(input_path.stem(), [])
                write_file(cargo_path, cargo_content)
                println("   Generated: " + cargo_path)
            _ =>
                // No extra files for other targets
                pass
        
        return true

// =============================================================================
// Main Entry Point
// =============================================================================

fn main():
    let args = args()
    
    // Show help if no args
    if array_len(args) < 2:
        print_help()
        exit(0)
    
    // Check for help flag
    if contains(args, "--help") || contains(args, "-h"):
        print_help()
        exit(0)
    
    // Parse config and compile
    let config = CompilerConfig::from_args()
    let compiler = Compiler::new(config)
    
    if compiler.compile():
        exit(0)
    else:
        exit(1)

fn print_help():
    println(" KORE Compiler (Ouroboros) - Self-Hosted Edition")
    println("")
    println("USAGE:")
    println("    korec <input.kr> [OPTIONS]")
    println("")
    println("OPTIONS:")
    println("    --target <TARGET>   Set compilation target:")
    println("                        - llvm  : LLVM IR (default)")
    println("                        - rust  : Rust source code")
    println("                        - wasm  : WebAssembly")
    println("    -o <FILE>           Output file path")
    println("    -v, --verbose       Verbose output")
    println("    -h, --help          Show this help")
    println("")
    println("EXAMPLES:")
    println("    korec main.kr                     # Compile to LLVM IR")
    println("    korec main.kr --target rust       # Transpile to Rust")
    println("    korec main.kr -o out.ll           # Specify output")
    println("")
    println("PROJECT OUROBOROS")
    println("    This compiler is written in KORE itself!")
    println("    github.com/ephemara/kore-lang")

// Run!











