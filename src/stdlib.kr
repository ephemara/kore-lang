// ============================================================================
// KORE Standard Library - Built-in function registry
// ============================================================================
// Ported from legacy_prototype/src/stdlib.rs
// Defines all built-in functions with their types for type checking.
// ============================================================================

/// A built-in function definition
struct BuiltinFn:
    name: String
    params: Array<BuiltinParam>
    return_type: String
    doc: String
    effects: EffectSet

struct BuiltinParam:
    name: String
    ty: String

/// Standard library function registry
struct StdLib:
    functions: Map<String, BuiltinFn>
    types: Map<String, ResolvedType>

struct ParamInfo:
    name: String
    ty: String

impl StdLib:
    /// Create a new standard library with all built-in functions
    pub fn new() -> StdLib:
        let lib = StdLib {
            functions: Map::new(),
            types: Map::new()
        }
        
        // Register all built-in functions
        lib.register_all()
        
        return lib
    
    /// Helper to create param info
    fn p(self, name: String, ty: String) -> ParamInfo:
        return ParamInfo { name: name, ty: ty }

    /// Register all built-in functions
    fn register_all(self) -> Unit:
        // =================================================================
        // Option/Result Constructors
        // =================================================================
        self.add_pure("Some", [self.p("value", "Any")], "Option", "Option Some variant")
        self.add_pure("Ok", [self.p("value", "Any")], "Result", "Result Ok variant")
        self.add_pure("Err", [self.p("error", "Any")], "Result", "Result Err variant")

        // =================================================================
        // I/O Functions
        // =================================================================
        self.add_fn("print", [self.p("value", "Any")], "Unit", "Print value to console", EffectSet::new().with(Effect::IO))
        self.add_fn("println", [self.p("value", "Any")], "Unit", "Print value with newline", EffectSet::new().with(Effect::IO))
        self.add_fn("read_line", [], "String", "Read line from stdin", EffectSet::new().with(Effect::IO))
        self.add_fn("read_file", [self.p("path", "String")], "String", "Read file contents", EffectSet::new().with(Effect::IO))
        self.add_fn("write_file", [self.p("path", "String"), self.p("content", "String")], "Unit", "Write to file", EffectSet::new().with(Effect::IO))
        
        // =================================================================
        // Math Functions
        // =================================================================
        self.add_pure("abs", [self.p("x", "Int")], "Int", "Absolute value")
        self.add_pure("sqrt", [self.p("x", "Float")], "Float", "Square root")
        self.add_pure("pow", [self.p("base", "Float"), self.p("exp", "Float")], "Float", "Power")
        self.add_pure("sin", [self.p("x", "Float")], "Float", "Sine")
        self.add_pure("cos", [self.p("x", "Float")], "Float", "Cosine")
        self.add_pure("tan", [self.p("x", "Float")], "Float", "Tangent")
        self.add_pure("floor", [self.p("x", "Float")], "Int", "Floor")
        self.add_pure("ceil", [self.p("x", "Float")], "Int", "Ceiling")
        self.add_pure("round", [self.p("x", "Float")], "Int", "Round")
        self.add_pure("min", [self.p("a", "Int"), self.p("b", "Int")], "Int", "Minimum")
        self.add_pure("max", [self.p("a", "Int"), self.p("b", "Int")], "Int", "Maximum")
        self.add_pure("clamp", [self.p("x", "Int"), self.p("lo", "Int"), self.p("hi", "Int")], "Int", "Clamp between bounds")
        
        // =================================================================
        // Vector Math (for shaders)
        // =================================================================
        self.add_pure("vec2", [self.p("x", "Float"), self.p("y", "Float")], "Vec2", "Create 2D vector")
        self.add_pure("vec3", [self.p("x", "Float"), self.p("y", "Float"), self.p("z", "Float")], "Vec3", "Create 3D vector")
        self.add_pure("vec4", [self.p("x", "Float"), self.p("y", "Float"), self.p("z", "Float"), self.p("w", "Float")], "Vec4", "Create 4D vector")
        self.add_pure("dot", [self.p("a", "Vec3"), self.p("b", "Vec3")], "Float", "Dot product")
        self.add_pure("cross", [self.p("a", "Vec3"), self.p("b", "Vec3")], "Vec3", "Cross product")
        self.add_pure("normalize", [self.p("v", "Vec3")], "Vec3", "Normalize vector")
        self.add_pure("length", [self.p("v", "Vec3")], "Float", "Vector length")
        self.add_pure("distance", [self.p("a", "Vec3"), self.p("b", "Vec3")], "Float", "Distance between points")
        self.add_pure("mix", [self.p("a", "Float"), self.p("b", "Float"), self.p("t", "Float")], "Float", "Linear interpolation")
        self.add_pure("smoothstep", [self.p("edge0", "Float"), self.p("edge1", "Float"), self.p("x", "Float")], "Float", "Smooth step")
        
        // =================================================================
        // Collection Functions
        // =================================================================
        self.add_pure("len", [self.p("collection", "Any")], "Int", "Get length")
        self.add_pure("array_len", [self.p("array", "Array")], "Int", "Get array length")
        self.add_fn("push", [self.p("array", "Array"), self.p("value", "Any")], "Unit", "Push to array", EffectSet::new().with(Effect::Alloc))
        self.add_fn("pop", [self.p("array", "Array")], "Any", "Pop from array", EffectSet::new().with(Effect::Alloc))
        self.add_pure("range", [self.p("start", "Int"), self.p("end", "Int")], "Array", "Create range")
        
        // =================================================================
        // Map Functions
        // =================================================================
        self.add_fn("map_new", [], "Map", "Create new map", EffectSet::new().with(Effect::Alloc))
        self.add_fn("map_set", [self.p("map", "Map"), self.p("key", "String"), self.p("value", "Any")], "Unit", "Set map key", EffectSet::new().with(Effect::Alloc))
        self.add_pure("map_get", [self.p("map", "Map"), self.p("key", "String")], "Any", "Get map value")
        self.add_pure("map_get_string", [self.p("map", "Map"), self.p("key", "String")], "String", "Get map value as string")
        self.add_pure("map_get_array", [self.p("map", "Map"), self.p("key", "String")], "Array", "Get map value as array")
        self.add_pure("contains_key", [self.p("map", "Map"), self.p("key", "String")], "Bool", "Check if map contains key")
        
        // =================================================================
        // String Functions
        // =================================================================
        self.add_pure("split", [self.p("s", "String"), self.p("sep", "String")], "Array", "Split string")
        self.add_pure("join", [self.p("arr", "Array"), self.p("sep", "String")], "String", "Join array to string")
        self.add_pure("trim", [self.p("s", "String")], "String", "Trim whitespace")
        self.add_pure("to_upper", [self.p("s", "String")], "String", "To uppercase")
        self.add_pure("to_lower", [self.p("s", "String")], "String", "To lowercase")
        self.add_pure("contains", [self.p("s", "String"), self.p("sub", "String")], "Bool", "Check contains")
        self.add_pure("replace", [self.p("s", "String"), self.p("from", "String"), self.p("to", "String")], "String", "Replace substring")
        self.add_pure("starts_with", [self.p("s", "String"), self.p("prefix", "String")], "Bool", "Check prefix")
        self.add_pure("ends_with", [self.p("s", "String"), self.p("suffix", "String")], "Bool", "Check suffix")
        self.add_pure("substring", [self.p("s", "String"), self.p("start", "Int"), self.p("end", "Int")], "String", "Get substring")
        self.add_pure("char_at", [self.p("s", "String"), self.p("idx", "Int")], "String", "Get character at index")
        self.add_pure("char_code_at", [self.p("s", "String"), self.p("idx", "Int")], "Int", "Get character code at index")
        self.add_pure("str_eq", [self.p("a", "String"), self.p("b", "String")], "Bool", "String equality")
        
        // =================================================================
        // Conversion Functions
        // =================================================================
        self.add_pure("str", [self.p("value", "Any")], "String", "Convert to string")
        self.add_pure("to_string", [self.p("value", "Any")], "String", "Convert to string")
        self.add_pure("char_from_code", [self.p("code", "Int")], "String", "Convert code to char string")
        self.add_pure("to_int", [self.p("value", "Any")], "Int", "Convert to int")
        self.add_pure("to_float", [self.p("value", "Any")], "Float", "Convert to float")
        
        // =================================================================
        // Debug Functions
        // =================================================================
        self.add_fn("dbg", [self.p("value", "Any")], "Any", "Debug print and return", EffectSet::new().with(Effect::IO))
        self.add_fn("panic", [self.p("message", "String")], "Never", "Panic with message", EffectSet::new().with(Effect::Panic))
        self.add_fn("assert", [self.p("condition", "Bool"), self.p("message", "String")], "Unit", "Assert condition", EffectSet::new().with(Effect::Panic))
        
        // =================================================================
        // Time Functions
        // =================================================================
        self.add_fn("now", [], "Float", "Current time in seconds", EffectSet::new().with(Effect::IO))
        self.add_fn("sleep", [self.p("seconds", "Float")], "Unit", "Sleep for seconds", EffectSet::new().with(Effect::IO))
        
        // =================================================================
        // Concurrency Functions
        // =================================================================
        self.add_fn("spawn", [self.p("actor", "Actor")], "ActorRef", "Spawn actor", EffectSet::new().with(Effect::Async))
        self.add_fn("send", [self.p("actor", "ActorRef"), self.p("message", "Message")], "Unit", "Send message", EffectSet::new().with(Effect::Async))
        
        // =================================================================
        // Variant Functions (runtime reflection)
        // =================================================================
        self.add_pure("variant_of", [self.p("value", "Any")], "String", "Get variant name of enum")
        self.add_pure("variant_field", [self.p("value", "Any"), self.p("idx", "Int")], "Any", "Get variant field by index")
    
    /// Add a pure function
    fn add_pure(self, name: String, params: Array<ParamInfo>, ret_type: String, doc: String) -> Unit:
        self.add_fn(name, params, ret_type, doc, EffectSet::pure())
    
    /// Add a function with effects
    fn add_fn(self, name: String, params: Array<ParamInfo>, ret_type: String, doc: String, effects: EffectSet) -> Unit:
        let builtin_params = []
        for p in params:
            push(builtin_params, BuiltinParam { name: p.name, ty: p.ty })
        
        let func = BuiltinFn {
            name: name,
            params: builtin_params,
            return_type: ret_type,
            doc: doc,
            effects: effects
        }
        
        map_set(self.functions, name, func)
    
    /// Look up a function by name
    pub fn get_function(self, name: String) -> Option<BuiltinFn>:
        if contains_key(self.functions, name):
            return Some(map_get(self.functions, name))
        return None
    
    /// Get the return type of a function
    pub fn get_return_type(self, name: String) -> Option<String>:
        if contains_key(self.functions, name):
            let func = map_get(self.functions, name)
            return Some(func.return_type)
        return None
    
    /// Check if a function exists
    pub fn has_function(self, name: String) -> Bool:
        return contains_key(self.functions, name)

/// Global standard library instance
pub fn get_stdlib() -> StdLib:
    return StdLib::new()

// =============================================================================
// Built-in Function Declarations (Code Generation)
// =============================================================================
// These extern declarations allow the compiler to generate LLVM declarations
// for runtime functions without hardcoding them in the compiler backend.
// Note: 'Int' is used for 'Any' since all values are NaN-boxed i64s.

extern fn print(value: Int) -> Unit
extern fn println(value: Int) -> Unit
extern fn read_line() -> String
extern fn read_file(path: String) -> String
extern fn write_file(path: String, content: String) -> Unit
extern fn abs(x: Int) -> Int
extern fn sqrt(x: Float) -> Float
extern fn pow(base: Float, exp: Float) -> Float
extern fn sin(x: Float) -> Float
extern fn cos(x: Float) -> Float
extern fn tan(x: Float) -> Float
extern fn floor(x: Float) -> Int
extern fn ceil(x: Float) -> Int
extern fn round(x: Float) -> Int
extern fn min(a: Int, b: Int) -> Int
extern fn max(a: Int, b: Int) -> Int
extern fn clamp(x: Int, lo: Int, hi: Int) -> Int
extern fn len(collection: Int) -> Int
extern fn array_len(array: Array<Int>) -> Int
extern fn push(array: Array<Int>, value: Int) -> Unit
extern fn pop(array: Array<Int>) -> Int
extern fn range(start: Int, end: Int) -> Array<Int>
extern fn map_new() -> Map<String, Int>
extern fn map_set(map: Map<String, Int>, key: String, value: Int) -> Unit
extern fn map_get(map: Map<String, Int>, key: String) -> Int
extern fn map_get_string(map: Map<String, Int>, key: String) -> String
extern fn map_get_array(map: Map<String, Int>, key: String) -> Array<Int>
extern fn contains_key(map: Map<String, Int>, key: String) -> Bool
extern fn split(s: String, sep: String) -> Array<String>
extern fn join(arr: Array<String>, sep: String) -> String
extern fn trim(s: String) -> String
extern fn to_upper(s: String) -> String
extern fn to_lower(s: String) -> String
extern fn contains(s: String, sub: String) -> Bool
extern fn replace(s: String, from: String, to: String) -> String
extern fn starts_with(s: String, prefix: String) -> Bool
extern fn ends_with(s: String, suffix: String) -> Bool
extern fn substring(s: String, start: Int, end: Int) -> String
extern fn char_at(s: String, idx: Int) -> String
extern fn char_code_at(s: String, idx: Int) -> Int
extern fn str_eq(a: String, b: String) -> Bool
extern fn to_string(value: Int) -> String
extern fn char_from_code(code: Int) -> String
extern fn to_int(value: Int) -> Int
extern fn to_float(value: Int) -> Float
extern fn dbg(value: Int) -> Int
extern fn panic(message: String) -> Unit
extern fn assert(condition: Bool, message: String) -> Unit
extern fn now() -> Float
extern fn sleep(seconds: Float) -> Unit
extern fn variant_of(value: Int) -> String
extern fn variant_field(value: Int, idx: Int) -> Int
extern fn exit(code: Int) -> Unit
extern fn args() -> Array<String>
