// ============================================================================
// KAIN Abstract Syntax Tree - Complete AST definitions
// ============================================================================
// Ported from legacy_prototype/src/ast.rs
// Defines all AST node types for the Kain language.
// ============================================================================

use span

// =============================================================================
// Program - Top level
// =============================================================================

/// A complete KAIN program/module
struct Program:
    items: Array<Item>
    span: Span

/// Top-level items in a module
enum Item:
    Function(FnDef)
    Struct(StructDef)
    Enum(EnumDef)
    Impl(ImplDef)
    ExternFn(ExternFnDef)
    Trait(TraitDef)
    Use(String)
    Const(ConstDef)
    Component(ComponentDef)
    Shader(ShaderDef)
    Actor(ActorDef)
    Test(TestDef)
    ExternFn(ExternFnDef)

// =============================================================================
// Functions
// =============================================================================

/// Function definition
struct FnDef:
    name: String
    params: Array<Param>
    generics: Array<GenericDef>
    return_type: Array<String>
    body: Array<Stmt>
    effects: Array<String>
    span: Span
    is_pub: Bool
    is_async: Bool

/// Function parameter
struct Param:
    name: String
    ty: Array<String>
    default: Option<Expr>
    is_mut: Bool
    span: Span

/// Generic type parameter
struct GenericDef:
    name: String
    bounds: Array<String>
    span: Span

/// External function declaration (no body)
struct ExternFnDef:
    name: String
    params: Array<Param>
    return_type: Array<String> // Was Option<String>
    span: Span

// =============================================================================
// Structs and Fields
// =============================================================================

/// Struct definition
struct StructDef:
    name: String
    generics: Array<GenericDef>
    fields: Array<FieldDef>
    is_pub: Bool
    span: Span

/// Struct field
struct FieldDef:
    name: String
    ty: String
    default: Option<Expr>
    is_pub: Bool
    span: Span

// =============================================================================
// Enums
// =============================================================================

/// Enum definition
struct EnumDef:
    name: String
    generics: Array<GenericDef>
    variants: Array<VariantDef>
    is_pub: Bool
    span: Span

/// Enum variant
struct VariantDef:
    name: String
    fields: VariantFields
    span: Span

/// Variant field types
enum VariantFields:
    Unit                      // No payload
    Tuple(Array<String>)      // Positional types: Foo(Int, String)
    Struct(Array<FieldDef>)   // Named fields: Foo { x: Int, y: String }

// =============================================================================
// Impl blocks
// =============================================================================

/// Impl block
struct ImplDef:
    target: String
    generics: Array<GenericDef>
    trait_name: Array<String>
    methods: Array<Array<FnDef>>
    span: Span

// =============================================================================
// Traits
// =============================================================================

/// Trait definition
struct TraitDef:
    name: String
    generics: Array<GenericDef>
    methods: Array<TraitMethod>
    span: Span

/// Trait method signature
struct TraitMethod:
    name: String
    params: Array<Param>
    return_type: Option<String>
    default_impl: Option<Array<Stmt>>
    span: Span

// =============================================================================
// Constants
// =============================================================================

/// Constant definition
struct ConstDef:
    name: String
    ty: String
    value: Expr
    is_pub: Bool
    span: Span

// =============================================================================
// Components (React-like UI)
// =============================================================================

/// Component definition
struct ComponentDef:
    name: String
    props: Array<FieldDef>
    state: Array<StateDecl>
    render: JSXNode
    span: Span

/// Component state declaration
struct StateDecl:
    name: String
    ty: String
    initial: Expr
    span: Span

/// JSX node types
enum JSXNode:
    Element(JSXElement)
    Text(String)
    Expr(Expr)
    For(JSXFor)
    If(JSXIf)
    Fragment(Array<JSXNode>)

struct JSXElement:
    tag: String
    attributes: Array<JSXAttribute>
    children: Array<JSXNode>
    span: Span

struct JSXAttribute:
    name: String
    value: JSXAttrValue
    span: Span

enum JSXAttrValue:
    String(String)
    Expr(Expr)
    Bool(Bool)

struct JSXFor:
    binding: String
    iter: Expr
    body: Box<JSXNode>
    span: Span

struct JSXIf:
    condition: Expr
    then_branch: Box<JSXNode>
    else_branch: Option<Box<JSXNode>>
    span: Span

// =============================================================================
// Shaders (GPU programs)
// =============================================================================

/// Shader definition
struct ShaderDef:
    name: String
    stage: ShaderStage
    inputs: Array<Param>
    outputs: String
    uniforms: Array<UniformDef>
    body: Array<Stmt>
    span: Span

enum ShaderStage:
    Vertex
    Fragment
    Compute

struct UniformDef:
    name: String
    ty: String
    span: Span

// =============================================================================
// Actors (Erlang-style concurrency)
// =============================================================================

/// Actor definition
struct ActorDef:
    name: String
    state: Array<FieldDef>
    handlers: Array<MessageHandler>
    span: Span

/// Message handler
struct MessageHandler:
    message_type: String
    params: Array<Param>
    body: Array<Stmt>
    span: Span

// =============================================================================
// Tests
// =============================================================================

/// Test definition
struct TestDef:
    name: String
    body: Array<Stmt>
    span: Span

// =============================================================================
// Statements
// =============================================================================

/// Statement types
enum Stmt:
    Let(String, Option<String>, Expr)              // let name: Type = value
    Var(String, Option<String>, Expr)              // var name: Type = value
    Assign(Expr, Expr)                              // target = value
    OpAssign(Expr, String, Expr)                    // target += value
    Return(Option<Expr>)                            // return expr
    If(Expr, Array<Stmt>, Option<Array<Stmt>>)     // if cond: ... else: ...
    While(Expr, Array<Stmt>)                        // while cond: ...
    For(String, Expr, Array<Stmt>)                  // for x in iter: ...
    Loop(Array<Stmt>)                               // loop: ...
    Match(Expr, Array<MatchArm>)                    // match expr: ...
    Break
    Continue
    Expr(Expr)                                      // standalone expression

/// Match arm
struct MatchArm:
    pattern: Pattern
    guard: Option<Expr>
    body: Array<Stmt>
    span: Span

/// Pattern types
enum Pattern:
    Wildcard                                        // _
    Ident(String)                                   // x
    Literal(Expr)                                   // 42, "hello"
    Tuple(Array<Pattern>)                           // (a, b, c)
    Struct(String, Array<FieldPattern>)             // Foo { x, y }
    Variant(String, String, Array<Pattern>)         // Enum::Variant(a, b)
    Or(Array<Pattern>)                              // a | b | c

struct FieldPattern:
    name: String
    pattern: Pattern
    span: Span

// =============================================================================
// Expressions
// =============================================================================

/// Expression types
enum Expr:
    // Literals
    Int(Int)
    Float(Float)
    Bool(Bool)
    String(String)
    Char(String)
    None
    
    // References
    Ident(String)
    Field(Expr, String)                        // expr.field
    Index(Expr, Expr)                     // expr[index]
    
    // Operations
    Binary(Expr, String, Expr)            // left op right
    Unary(String, Expr)                        // op expr
    
    // Calls
    Call(Expr, Array<String>, Array<Expr>)     // callee<T>(args)
    MethodCall(Expr, String, Array<String>, Array<Expr>)      // receiver.method<T>(args)
    
    // Constructors
    Array(Array<Expr>)                              // [1, 2, 3]
    Tuple(Array<Expr>)                              // (1, 2, 3)
    Struct(String, Array<FieldInit>)                // Foo { x: 1, y: 2 }
    EnumVariant(String, String, Array<Expr>)        // Enum::Variant(args)
    
    // Closures
    Lambda(Array<Param>, Expr)                 // |x, y| x + y
    
    // Control flow (expression form)
    If(Expr, Array<Stmt>, Option<Array<Stmt>>) // if cond: ... else: ...
    Match(Expr, Array<MatchArm>)               // match expr: ...
    
    // Async
    Await(Expr)                                // await expr
    
    // Range
    Range(Option<Expr>, Option<Expr>, Bool) // start..end or start..=end

/// Struct field initialization
struct FieldInit:
    name: String
    value: Expr
    span: Span

// =============================================================================
// Types (AST representation)
// =============================================================================

/// Type annotation
enum TypeAnnotation:
    Named(String, Array<TypeAnnotation>)            // Foo<T, U>
    Tuple(Array<TypeAnnotation>)                    // (A, B, C)
    Function(Array<TypeAnnotation>, TypeAnnotation) // fn(A, B) -> C
    Array(TypeAnnotation, Option<Int>)         // [T] or [T; N]
    Ref(Bool, TypeAnnotation)                  // &T or &mut T
    Option(TypeAnnotation)                     // T?
    Result(TypeAnnotation, TypeAnnotation) // T!E
    Unit                                            // ()
    Never                                           // !
    Infer                                           // _ (infer type)

// =============================================================================
// Binary and Unary Operators
// =============================================================================

/// Binary operators
enum BinaryOp:
    Add       // +
    Sub       // -
    Mul       // *
    Div       // /
    Mod       // %
    Pow       // **
    Eq        // ==
    Ne        // !=
    Lt        // <
    Le        // <=
    Gt        // >
    Ge        // >=
    And       // &&
    Or        // ||
    BitAnd    // &
    BitOr     // |
    BitXor    // ^
    Shl       // <<
    Shr       // >>

/// Unary operators
enum UnaryOp:
    Neg       // -
    Not       // !
    BitNot    // ~
    Ref       // &
    Deref     // *
