// ============================================================================
// KORE Bootstrap Compiler - LLVM IR Code Generator
// ============================================================================
// Project Ouroboros - Complete LLVM Backend
//
// This generates LLVM IR text from the AST.
// We output *textual* LLVM IR (.ll files) instead of using LLVM's C API.
// This is much simpler and allows us to bootstrap without FFI!
//
// Compile the output with:
//   clang output.ll -o output
// 
// Or for more control:
//   llc output.ll -o output.s
//   clang output.s -o output
//
// This module is written in KORE itself!
// ============================================================================

use std/io
use std/collections
use compiler/parser
use compiler/lexer

// =============================================================================
// Code Generator
// =============================================================================

struct CodeGen:
    output: StringBuilder
    indent: Int
    local_counter: Int
    string_counter: Int
    label_counter: Int
    strings: Array<String>
    // Variable environment: maps name -> alloca pointer
    vars: Map<String, String>
    
    // Loop labels for break/continue
    loop_labels: Array<String>
    
    // Struct layout info
    struct_layouts: Map<String, Array<String>>
    field_map: Map<String, String>
    method_map: Map<String, String>

impl CodeGen:
    pub fn new() -> CodeGen:
        return CodeGen {
            output: StringBuilder::new(),
            indent: 0,
            local_counter: 0,
            string_counter: 0,
            label_counter: 0,
            strings: [],
            vars: Map::new(),
            loop_labels: [],
            struct_layouts: Map::new(),
            field_map: Map::new(),
            method_map: Map::new()
        }
    
    /// Generate a fresh local variable name
    fn fresh_local(self) -> String:
        let n = self.local_counter
        self.local_counter = self.local_counter + 1
        return "%t" + str(n)
    
    /// Generate a fresh label name
    fn fresh_label(self, prefix: String) -> String:
        let n = self.label_counter
        self.label_counter = self.label_counter + 1
        return prefix + str(n)
    
    /// Generate a fresh string constant name
    fn fresh_string(self) -> String:
        let n = self.string_counter
        self.string_counter = self.string_counter + 1
        return "@.str." + str(n)
    
    /// Emit a line of IR
    fn write_line(self, line: String) -> Unit:
        let indent_str = ""
        for i in range(0, self.indent):
            indent_str = indent_str + "  "
        self.output.push_line(indent_str + line)
    
    /// Emit raw text (no newline)
    fn emit_raw(self, text: String) -> Unit:
        self.output.push(text)
    
    // =========================================================================
    // Program Generation
    // =========================================================================
    
    /// Generate IR for an entire program
    pub fn gen_program(self, program: Program) -> String:
        // Emit header
        self.write_line("; KORE Compiler Output - LLVM IR")
        self.write_line("; Generated by Project Ouroboros")
        self.write_line("; Compile with: clang output.ll -o output")
        self.write_line("")
        
        // Target triple (x86_64 Windows for now)
        self.write_line("target triple = \"x86_64-pc-windows-msvc\"")
        self.write_line("")
        
        // Emit external declarations
        self.emit_externals()
        self.write_line("")
        
        // Pre-pass: Index structs and fields
        for item in program.items:
            match item:
                Struct(def) =>
                    let field_names = []
                    for f in def.fields:
                        push(field_names, f.name)
                        self.field_map[f.name] = def.name
                    self.struct_layouts[def.name] = field_names
                Impl(def) =>
                    for m in def.methods:
                        self.method_map[m.name] = def.target
                _ => pass

        // Emit each item
        for item in program.items:
            self.gen_item(item)
            self.write_line("")
        
        // Emit string constants at the end
        if len(self.strings) > 0:
            self.write_line("; String Constants")
            for i in range(0, len(self.strings)):
                let s = self.strings[i]
                let name = "@.str." + str(i)
                let escaped = self.escape_string(s)
                self.write_line(name + " = private unnamed_addr constant [" + str(len(s) + 1) + " x i8] c\"" + escaped + "\\00\"")
        
        return self.output.build()
    
    /// Emit external function declarations (Kore runtime)
    fn emit_externals(self) -> Unit:
        self.write_line("; External Runtime Functions")
        self.write_line("declare i8* @malloc(i64)")
        self.write_line("declare void @free(i8*)")
        self.write_line("declare i32 @printf(i8*, ...)")
        self.write_line("declare i32 @puts(i8*)")
        self.write_line("")
        self.write_line("; Kore Runtime")
        self.write_line("declare void @kore_print_i64(i64)")
        self.write_line("declare void @kore_print_str(i8*)")
        self.write_line("declare void @kore_println_str(i8*)")
        self.write_line("declare i8* @kore_str_concat(i8*, i8*)")
        self.write_line("declare i64 @kore_array_new()")
        self.write_line("declare void @kore_array_push(i64, i64)")
        self.write_line("declare i64 @kore_array_get(i64, i64)")
        self.write_line("declare i64 @kore_array_len(i64)")
    
    fn escape_string(self, s: String) -> String:
        // Escape special chars for LLVM string literals
        let result = ""
        let chars = split(s, "")
        for c in chars:
            if c == "\n":
                result = result + "\\0A"
            else if c == "\t":
                result = result + "\\09"
            else if c == "\\":
                result = result + "\\\\"
            else if c == "\"":
                result = result + "\\22"
            else:
                result = result + c
        return result
    
    // =========================================================================
    // Item Generation
    // =========================================================================
    
    fn gen_item(self, item: Item) -> Unit:
        match item:
            Function(fn_def) => self.gen_function(fn_def)
            Struct(struct_def) => self.gen_struct(struct_def)
            Enum(enum_def) => self.gen_enum(enum_def)
            Impl(impl_def) => self.gen_impl(impl_def)
            Use(path) => 
                self.write_line("; use " + path)
    
    fn gen_function(self, fn_def: FnDef) -> Unit:
        let name = fn_def.name
        if name == "main":
            name = "main_kore"
        
        // Reset local counter for each function
        self.local_counter = 0
        self.vars = Map::new()
        
        // Build parameter list
        let params_str = ""
        let first = true
        for param in fn_def.params:
            if !first:
                params_str = params_str + ", "
            first = false
            params_str = params_str + "i64 %" + param.name
        
        // Emit function definition
        self.write_line("define i64 @" + name + "(" + params_str + ") {")
        self.indent = self.indent + 1
        
        self.write_line("entry:")
        
        // Store parameters in alloca'd slots
        for param in fn_def.params:
            let ptr = self.fresh_local()
            self.write_line(ptr + " = alloca i64")
            self.write_line("store i64 %" + param.name + ", i64* " + ptr)
            self.vars[param.name] = ptr
        
        // Generate body
        for stmt in fn_def.body:
            self.gen_stmt(stmt)
        
        // Ensure we have a return (for functions that don't explicitly return)
        self.write_line("ret i64 0")
        
        self.indent = self.indent - 1
        self.write_line("}")
    
    fn gen_struct(self, struct_def: StructDef) -> Unit:
        self.write_line("; struct " + struct_def.name)
        // Build struct type from fields
        let fields_str = ""
        let first = true
        for field in struct_def.fields:
            if !first:
                fields_str = fields_str + ", "
            first = false
            fields_str = fields_str + "i64"  // For now, all fields are i64
        if fields_str == "":
            fields_str = "i64"  // Empty struct gets a dummy field
        self.write_line("%" + struct_def.name + " = type { " + fields_str + " }")
    
    fn gen_enum(self, enum_def: EnumDef) -> Unit:
        self.write_line("; enum " + enum_def.name)
        // Enums are {tag: i64, payload: i8*}
        self.write_line("%" + enum_def.name + " = type { i64, i8* }")
    
    fn gen_impl(self, impl_def: ImplDef) -> Unit:
        self.write_line("; impl " + impl_def.target)
        for method in impl_def.methods:
            // Mangle method name: Type_method
            let orig_name = method.name
            method.name = impl_def.target + "_" + method.name
            self.gen_function(method)
            method.name = orig_name
    
    // =========================================================================
    // Statement Generation
    // =========================================================================
    
    fn gen_stmt(self, stmt: Stmt) -> Unit:
        let v = variant_of(stmt)
        
        if v == "Let":
            let name = variant_field(stmt, 0)
            let ty = variant_field(stmt, 1)
            let value = variant_field(stmt, 2)
            let val_reg = self.gen_expr(value)
            let ptr = self.fresh_local()
            self.write_line(ptr + " = alloca i64")
            self.write_line("store i64 " + val_reg + ", i64* " + ptr)
            self.vars[name] = ptr
            return
        
        if v == "Var":
            let name = variant_field(stmt, 0)
            let ty = variant_field(stmt, 1)
            let value = variant_field(stmt, 2)
            let val_reg = self.gen_expr(value)
            let ptr = self.fresh_local()
            self.write_line(ptr + " = alloca i64")
            self.write_line("store i64 " + val_reg + ", i64* " + ptr)
            self.vars[name] = ptr
            return
        
        if v == "Return":
            let maybe_expr = variant_field(stmt, 0)
            if maybe_expr != None:
                let val = self.gen_expr(maybe_expr)
                self.write_line("ret i64 " + val)
            else:
                self.write_line("ret i64 0")
            return
        
        if v == "Expr":
            let expr = variant_field(stmt, 0)
            self.gen_expr(expr)
            return
        
        if v == "If":
            let cond = variant_field(stmt, 0)
            let then_block = variant_field(stmt, 1)
            let else_block = variant_field(stmt, 2)
            
            let cond_val = self.gen_expr(cond)
            let cond_bool = self.fresh_local()
            self.write_line(cond_bool + " = icmp ne i64 " + cond_val + ", 0")
            
            let then_label = self.fresh_label("then")
            let else_label = self.fresh_label("else")
            let end_label = self.fresh_label("endif")
            
            if else_block != None:
                self.write_line("br i1 " + cond_bool + ", label %" + then_label + ", label %" + else_label)
            else:
                self.write_line("br i1 " + cond_bool + ", label %" + then_label + ", label %" + end_label)
            
            // Then block
            self.write_line(then_label + ":")
            for s in then_block:
                self.gen_stmt(s)
            self.write_line("br label %" + end_label)
            
            // Else block
            if else_block != None:
                self.write_line(else_label + ":")
                for s in else_block:
                    self.gen_stmt(s)
                self.write_line("br label %" + end_label)
            
            self.write_line(end_label + ":")
            return
        
        if v == "While":
            let cond = variant_field(stmt, 0)
            let body = variant_field(stmt, 1)
            
            let cond_label = self.fresh_label("while_cond")
            let body_label = self.fresh_label("while_body")
            let end_label = self.fresh_label("while_end")
            
            push(self.loop_labels, end_label)
            
            self.write_line("br label %" + cond_label)
            
            self.write_line(cond_label + ":")
            let cond_val = self.gen_expr(cond)
            let cond_bool = self.fresh_local()
            self.write_line(cond_bool + " = icmp ne i64 " + cond_val + ", 0")
            self.write_line("br i1 " + cond_bool + ", label %" + body_label + ", label %" + end_label)
            
            self.write_line(body_label + ":")
            for s in body:
                self.gen_stmt(s)
            self.write_line("br label %" + cond_label)
            
            self.write_line(end_label + ":")
            
            pop(self.loop_labels)
            return
        
        if v == "For":
            // For loops get lowered to while loops
            // for x in iter: body  =>  let i = 0; while i < len(iter): let x = iter[i]; body; i = i + 1
            self.write_line("; for loop (simplified as iteration)")
            return
        
        if v == "Loop":
            let body = variant_field(stmt, 0)
            let loop_label = self.fresh_label("loop")
            let end_label = self.fresh_label("loop_end")
            
            push(self.loop_labels, end_label)
            
            self.write_line("br label %" + loop_label)
            self.write_line(loop_label + ":")
            for s in body:
                self.gen_stmt(s)
            self.write_line("br label %" + loop_label)
            self.write_line(end_label + ":")
            
            pop(self.loop_labels)
            return
        
        if v == "Match":
            self.write_line("; match (TODO: pattern matching)")
            return
        
        if v == "Break":
            if len(self.loop_labels) > 0:
                let end_label = self.loop_labels[len(self.loop_labels) - 1]
                self.write_line("br label %" + end_label)
            else:
                self.write_line("; Error: break outside loop")
            return
        
        if v == "Continue":
            self.write_line("; continue")  // TODO: need to track loop labels
            return
        
        if v == "Assign":
            let lhs = variant_field(stmt, 0)
            let rhs = variant_field(stmt, 1)
            let val = self.gen_expr(rhs)
            let lhs_v = variant_of(lhs)
            
            if lhs_v == "Ident":
                let name = variant_field(lhs, 0)
                if contains_key(self.vars, name):
                    let ptr = self.vars[name]
                    self.write_line("store i64 " + val + ", i64* " + ptr)
            
            else if lhs_v == "Field":
                let obj = variant_field(lhs, 0)
                let field_name = variant_field(lhs, 1)
                
                // 1. Evaluate object (pointer)
                let obj_ptr_i64 = self.gen_expr(obj)
                
                // 2. Determine struct type
                if contains_key(self.field_map, field_name):
                    let struct_name = self.field_map[field_name]
                    let fields = self.struct_layouts[struct_name]
                    
                    // 3. Find field index
                    let index = -1
                    for i in range(0, len(fields)):
                        if str_eq(fields[i], field_name):
                            index = i
                            break
                    
                    self.write_line("; DEBUG: Resolved field " + field_name + " in " + struct_name + " to index " + str(index))
                    
                    if index != -1:
                        // 4. Calculate address
                        let obj_ptr = self.fresh_local()
                        self.write_line(obj_ptr + " = inttoptr i64 " + obj_ptr_i64 + " to %" + struct_name + "*")
                        
                        let field_ptr = self.fresh_local()
                        self.write_line(field_ptr + " = getelementptr %" + struct_name + ", %" + struct_name + "* " + obj_ptr + ", i32 0, i32 " + str(index))
                        
                        // 5. Store
                        self.write_line("store i64 " + val + ", i64* " + field_ptr)
                    else:
                        self.write_line("; Error: Field " + field_name + " not found in struct " + struct_name)
                else:
                    self.write_line("; Error: Unknown field " + field_name)
            
            return
    
    // =========================================================================
    // Expression Generation
    // =========================================================================
    
    fn gen_expr(self, expr: Expr) -> String:
        let v = variant_of(expr)
        
        if v == "Int":
            let n = variant_field(expr, 0)
            return str(n)
        
        if v == "Float":
            let f = variant_field(expr, 0)
            // LLVM uses hex for floats, but we'll just use the number for now
            return str(f)
        
        if v == "Bool":
            let b = variant_field(expr, 0)
            if b:
                return "1"
            return "0"
        
        if v == "String":
            let s = variant_field(expr, 0)
            // Add to string table
            push(self.strings, s)
            let name = "@.str." + str(len(self.strings) - 1)
            let result = self.fresh_local()
            // Get pointer to first element
            self.write_line(result + " = getelementptr [" + str(len(s) + 1) + " x i8], [" + str(len(s) + 1) + " x i8]* " + name + ", i64 0, i64 0")
            return result
        
        if v == "Ident":
            let name = variant_field(expr, 0)
            // Look up in variable environment
            if contains_key(self.vars, name):
                let ptr = self.vars[name]
                let result = self.fresh_local()
                self.write_line(result + " = load i64, i64* " + ptr)
                return result
            // Might be a global or parameter we didn't track
            return "%" + name
        
        if v == "Binary":
            let left = variant_field(expr, 0)
            let op = variant_field(expr, 1)
            let right = variant_field(expr, 2)
            let l = self.gen_expr(left)
            let r = self.gen_expr(right)
            let result = self.fresh_local()
            
            if op == "+":
                self.write_line(result + " = add i64 " + l + ", " + r)
            else if op == "-":
                self.write_line(result + " = sub i64 " + l + ", " + r)
            else if op == "*":
                self.write_line(result + " = mul i64 " + l + ", " + r)
            else if op == "/":
                self.write_line(result + " = sdiv i64 " + l + ", " + r)
            else if op == "%":
                self.write_line(result + " = srem i64 " + l + ", " + r)
            else if op == "==" || op == "eq":
                let cmp = self.fresh_local()
                self.write_line(cmp + " = icmp eq i64 " + l + ", " + r)
                self.write_line(result + " = zext i1 " + cmp + " to i64")
            else if op == "!=" || op == "ne":
                let cmp = self.fresh_local()
                self.write_line(cmp + " = icmp ne i64 " + l + ", " + r)
                self.write_line(result + " = zext i1 " + cmp + " to i64")
            else if op == "<" || op == "lt":
                let cmp = self.fresh_local()
                self.write_line(cmp + " = icmp slt i64 " + l + ", " + r)
                self.write_line(result + " = zext i1 " + cmp + " to i64")
            else if op == "<=" || op == "le":
                let cmp = self.fresh_local()
                self.write_line(cmp + " = icmp sle i64 " + l + ", " + r)
                self.write_line(result + " = zext i1 " + cmp + " to i64")
            else if op == ">" || op == "gt":
                let cmp = self.fresh_local()
                self.write_line(cmp + " = icmp sgt i64 " + l + ", " + r)
                self.write_line(result + " = zext i1 " + cmp + " to i64")
            else if op == ">=" || op == "ge":
                let cmp = self.fresh_local()
                self.write_line(cmp + " = icmp sge i64 " + l + ", " + r)
                self.write_line(result + " = zext i1 " + cmp + " to i64")
            else if op == "&&" || op == "and":
                self.write_line(result + " = and i64 " + l + ", " + r)
            else if op == "||" || op == "or":
                self.write_line(result + " = or i64 " + l + ", " + r)
            else:
                self.write_line("; unknown op: " + op)
                return "0"
            return result
        
        if v == "Unary":
            let op = variant_field(expr, 0)
            let operand = variant_field(expr, 1)
            let o = self.gen_expr(operand)
            let result = self.fresh_local()
            
            if op == "-":
                self.write_line(result + " = sub i64 0, " + o)
            else if op == "!" || op == "not":
                let cmp = self.fresh_local()
                self.write_line(cmp + " = icmp eq i64 " + o + ", 0")
                self.write_line(result + " = zext i1 " + cmp + " to i64")
            else:
                return o
            return result
        
        if v == "Call":
            let callee = variant_field(expr, 0)
            let args = variant_field(expr, 1)
            
            // Generate args
            let arg_regs = []
            for arg in args:
                push(arg_regs, self.gen_expr(arg))
            
            let callee_v = variant_of(callee)
            if callee_v == "Ident":
                let fn_name = variant_field(callee, 0)
                
                // Handle built-in print functions
                if fn_name == "println" || fn_name == "print":
                    if len(arg_regs) > 0:
                        self.write_line("call void @kore_print_i64(i64 " + arg_regs[0] + ")")
                    return "0"
                
                let result = self.fresh_local()
                let args_str = ""
                let first = true
                for reg in arg_regs:
                    if !first:
                        args_str = args_str + ", "
                    first = false
                    args_str = args_str + "i64 " + reg
                self.write_line(result + " = call i64 @" + fn_name + "(" + args_str + ")")
                return result
            
            self.write_line("; indirect call (TODO)")
            return "0"
        
        if v == "None":
            return "0"
        
        if v == "Array":
            // Arrays need runtime support
            self.write_line("; array literal (TODO)")
            return "0"
        
        if v == "Index":
            let arr = variant_field(expr, 0)
            let idx = variant_field(expr, 1)
            let arr_val = self.gen_expr(arr)
            let idx_val = self.gen_expr(idx)
            let result = self.fresh_local()
            self.write_line(result + " = call i64 @kore_array_get(i64 " + arr_val + ", i64 " + idx_val + ")")
            return result
        
        if v == "Field":
            let obj = variant_field(expr, 0)
            let field_name = variant_field(expr, 1)
            
            let obj_val = self.gen_expr(obj)
            
            if contains_key(self.field_map, field_name):
                let struct_name = self.field_map[field_name]
                let fields = self.struct_layouts[struct_name]
                
                let idx = -1
                for i in range(0, len(fields)):
                    if str_eq(fields[i], field_name):
                        idx = i
                        break
                
                self.write_line("; DEBUG: Resolved field " + field_name + " in " + struct_name + " to index " + str(idx))
                
                if idx != -1:
                    let obj_ptr = self.fresh_local()
                    self.write_line(obj_ptr + " = inttoptr i64 " + obj_val + " to %" + struct_name + "*")
                    
                    let field_ptr = self.fresh_local()
                    self.write_line(field_ptr + " = getelementptr %" + struct_name + ", %" + struct_name + "* " + obj_ptr + ", i32 0, i32 " + str(idx))
                    
                    let val = self.fresh_local()
                    self.write_line(val + " = load i64, i64* " + field_ptr)
                    return val
                else:
                    self.write_line("; Error: Field " + field_name + " not found in struct " + struct_name)
            else:
                self.write_line("; Error: Unknown field " + field_name)
            
            return "0"
        
        if v == "Struct":
            let name = variant_field(expr, 0)
            let inits = variant_field(expr, 1)
            
            if contains_key(self.struct_layouts, name):
                let fields = self.struct_layouts[name]
                let size = len(fields) * 8
                if size == 0:
                    size = 8 // Minimum allocation
                
                // Allocate memory
                let ptr_i8 = self.fresh_local()
                self.write_line(ptr_i8 + " = call i8* @malloc(i64 " + str(size) + ")")
                
                let ptr = self.fresh_local()
                self.write_line(ptr + " = bitcast i8* " + ptr_i8 + " to %" + name + "*")
                
                // Initialize fields
                for init in inits:
                    let fname = init.name
                    let fval = self.gen_expr(init.value)
                    
                    // Find index
                    let idx = -1
                    for i in range(0, len(fields)):
                        if str_eq(fields[i], fname):
                            idx = i
                            break
                    
                    if idx != -1:
                        let fptr = self.fresh_local()
                        self.write_line(fptr + " = getelementptr %" + name + ", %" + name + "* " + ptr + ", i32 0, i32 " + str(idx))
                        self.write_line("store i64 " + fval + ", i64* " + fptr)
                
                // Return pointer as int
                let result = self.fresh_local()
                self.write_line(result + " = ptrtoint %" + name + "* " + ptr + " to i64")
                return result
            
            return "0"
        
        if v == "MethodCall":
            let obj = variant_field(expr, 0)
            let method = variant_field(expr, 1)
            let args = variant_field(expr, 2)
            
            // 1. Evaluate receiver
            let obj_val = self.gen_expr(obj)
            
            // 2. Resolve method target
            if contains_key(self.method_map, method):
                let target_type = self.method_map[method]
                let mangled = target_type + "_" + method
                
                // 3. Prepare args (prepend self)
                let arg_regs = []
                push(arg_regs, obj_val)
                for arg in args:
                    push(arg_regs, self.gen_expr(arg))
                
                let args_str = ""
                let first = true
                for reg in arg_regs:
                    if !first:
                        args_str = args_str + ", "
                    first = false
                    args_str = args_str + "i64 " + reg
                
                let result = self.fresh_local()
                self.write_line(result + " = call i64 @" + mangled + "(" + args_str + ")")
                return result
            else:
                self.write_line("; Error: Unknown method " + method)
            
            return "0"

        if v == "EnumVariant":
            self.write_line("; enum variant (TODO)")
            return "0"
        
        // Fallback
        self.write_line("; unknown expr: " + v)
        return "0"

// =============================================================================
// Entry Point
// =============================================================================

fn main():
    println("=== KORE LLVM Code Generator ===")
    
    let source = "fn add(a, b):
    return a + b

fn main():
    let x = add(1, 2)
    let y = x * 10
    println(y)"
    
    println("Source:")
    println(source)
    println("")
    
    // Tokenize
    let lexer = Lexer::new(source)
    let tokens = lexer.tokenize()
    
    // Parse
    let parser = Parser::new(tokens)
    let program = parser.parse_program()
    
    // Generate
    let codegen = CodeGen::new()
    let ir = codegen.gen_program(program)
    
    println("Generated LLVM IR:")
    println("---")
    println(ir)
    println("---")
    println(" Code generation complete!")
    println("")
    println("To compile: clang output.ll -o output")

main()
