// ============================================================================
// KORE Bootstrap Compiler - Rust Code Generator
// ============================================================================
// Project Ouroboros - Hybrid Backend
//
// This transpiles Kore AST to Rust source code.
// The generated Rust can be compiled with `cargo build`.
//
// Benefits:
//   - Access to entire Rust ecosystem (tokio, serde, bevy, etc.)
//   - Rust's borrow checker validates your Kore code
//   - Cross-compilation to any Rust target
//
// Usage:
//   kore compile main.kr --target rust
//   cd output && cargo build --release
//
// This module is written in KORE itself!
// ============================================================================

// Module imports - lexer and parser for tokenization and parsing
use compiler/lexer
use compiler/parser

// TODO: These need stdlib implementations
// use std/io
// use std/fs
// use std/collections

// =============================================================================
// StringBuilder - Simple string accumulator
// =============================================================================

struct StringBuilder:
    lines: Array<String>

impl StringBuilder:
    pub fn new() -> StringBuilder:
        return StringBuilder { lines: [] }
    
    pub fn push(self, text: String) -> Unit:
        push(self.lines, text)
    
    pub fn push_line(self, text: String) -> Unit:
        push(self.lines, text + "\n")
    
    pub fn build(self) -> String:
        return join(self.lines, "")

// =============================================================================
// Rust Code Generator
// =============================================================================

struct RustGen:
    output: StringBuilder
    indent: Int
    use_statements: Array<String>
    struct_impls: StringBuilder  // Collect impl blocks to emit after structs

impl RustGen:
    pub fn new() -> RustGen:
        return RustGen {
            output: StringBuilder::new(),
            indent: 0,
            use_statements: [],
            struct_impls: StringBuilder::new()
        }
    
    /// Increase indentation
    fn push_indent(self) -> Unit:
        self.indent = self.indent + 1
    
    /// Decrease indentation
    fn pop_indent(self) -> Unit:
        if self.indent > 0:
            self.indent = self.indent - 1
    
    /// Get current indent string
    fn indent_str(self) -> String:
        let s = ""
        for i in range(0, self.indent):
            s = s + "    "
        return s
    
    /// Emit a line with current indentation
    fn write_line(self, line: String) -> Unit:
        self.output.push(self.indent_str())
        self.output.push_line(line)
    
    /// Emit raw text (no indent, no newline)
    fn write_raw(self, text: String) -> Unit:
        self.output.push(text)
    
    /// Emit a blank line
    fn write_blank(self) -> Unit:
        self.output.push_line("")
    
    // =========================================================================
    // Program Generation
    // =========================================================================
    
    /// Generate Rust code for an entire program
    pub fn gen_program(self, program: Program) -> String:
        // Header
        self.write_line("// Generated by KORE Compiler (Project Ouroboros)")
        self.write_line("// Do not edit - regenerate from .kr source")
        self.write_blank()
        self.write_line("#![allow(unused_variables)]")
        self.write_line("#![allow(unused_mut)]")
        self.write_line("#![allow(dead_code)]")
        self.write_line("#![allow(unused_parens)]")
        self.write_blank()
        
        // Standard imports
        self.write_line("use std::collections::HashMap;")
        self.write_line("use std::rc::Rc;")
        self.write_line("use std::cell::RefCell;")
        self.write_blank()
        
        // Generate each item
        for item in program.items:
            self.gen_item(item)
            self.write_blank()
        
        // Emit collected impl blocks
        let impls = self.struct_impls.build()
        if len(impls) > 0:
            self.output.push(impls)
        
        return self.output.build()
    
    // =========================================================================
    // Item Generation
    // =========================================================================
    
    fn gen_item(self, item: Item) -> Unit:
        match item:
            Function(fn_def) => self.gen_function(fn_def)
            Struct(struct_def) => self.gen_struct(struct_def)
            Enum(enum_def) => self.gen_enum(enum_def)
            Impl(impl_def) => self.gen_impl(impl_def)
            Use(path) => self.gen_use(path)
    
    /// Generate a function definition
    fn gen_function(self, fn_def: FnDef) -> Unit:
        // Visibility
        let vis = ""
        if fn_def.is_pub:
            vis = "pub "
        
        // Async modifier
        let async_mod = ""
        if fn_def.is_async:
            async_mod = "async "
        
        // Parameters
        let params = self.gen_params(fn_def.params)
        
        // Return type - infer i64 if missing and function has return statements
        let ret = ""
        if fn_def.return_type != None:
            ret = " -> " + self.map_type(fn_def.return_type)
        else:
            // Check if function has return statements (heuristic: non-main functions need return types)
            if fn_def.name != "main":
                // For bootstrap, assume functions return i64 unless otherwise specified
                // This is a temporary workaround
                ret = ""  // Actually, let's leave it empty and let Rust infer
        
        // Function signature
        self.write_line(vis + async_mod + "fn " + fn_def.name + "(" + params + ")" + ret + " {")
        self.push_indent()
        
        // Body
        for stmt in fn_def.body:
            self.gen_stmt(stmt)
        
        self.pop_indent()
        self.write_line("}")
    
    /// Generate function parameters
    fn gen_params(self, params: Array<Param>) -> String:
        let parts = []
        for param in params:
            let ty = "i64"  // Default type
            if param.ty != None:
                ty = self.map_type(param.ty)
            push(parts, param.name + ": " + ty)
        return join(parts, ", ")
    
    /// Generate a struct definition
    fn gen_struct(self, struct_def: StructDef) -> Unit:
        let vis = ""
        if struct_def.is_pub:
            vis = "pub "
        
        self.write_line("#[derive(Debug, Clone)]")
        self.write_line(vis + "struct " + struct_def.name + " {")
        self.push_indent()
        
        for field in struct_def.fields:
            self.write_line("pub " + field.name + ": " + self.map_type(field.ty) + ",")
        
        self.pop_indent()
        self.write_line("}")
    
    /// Generate an enum definition
    fn gen_enum(self, enum_def: EnumDef) -> Unit:
        self.write_line("#[derive(Debug, Clone, PartialEq)]")
        self.write_line("pub enum " + enum_def.name + " {")
        self.push_indent()
        
        for variant in enum_def.variants:
            if len(variant.fields) == 0:
                self.write_line(variant.name + ",")
            else:
                let fields = join(variant.fields, ", ")
                self.write_line(variant.name + "(" + fields + "),")
        
        self.pop_indent()
        self.write_line("}")
    
    /// Generate an impl block
    fn gen_impl(self, impl_def: ImplDef) -> Unit:
        self.write_line("impl " + impl_def.target + " {")
        self.push_indent()
        
        for method in impl_def.methods:
            // Add &self or &mut self as first param
            let params = []
            push(params, "&self")
            for param in method.params:
                let ty = "i64"
                match param.ty:
                    Some(t) => ty = self.map_type(t)
                    None => ty = "i64"
                push(params, param.name + ": " + ty)
            
            let params_str = join(params, ", ")
            let ret = ""
            match method.return_type:
                Some(ty) => ret = " -> " + self.map_type(ty)
                None => ret = ""
            
            let vis = ""
            if method.is_pub:
                vis = "pub "
            
            self.write_line(vis + "fn " + method.name + "(" + params_str + ")" + ret + " {")
            self.push_indent()
            
            for stmt in method.body:
                self.gen_stmt(stmt)
            
            self.pop_indent()
            self.write_line("}")
            self.write_blank()
        
        self.pop_indent()
        self.write_line("}")
    
    /// Generate a use statement
    fn gen_use(self, path: String) -> Unit:
        // Convert Kore path to Rust path
        let rust_path = replace(path, "/", "::")
        self.write_line("use " + rust_path + ";")
    
    // =========================================================================
    // Statement Generation
    // =========================================================================
    
    fn gen_stmt(self, stmt: Stmt) -> Unit:
        // Bootstrap workaround: use variant_of/variant_field instead of pattern matching
        let v = variant_of(stmt)
        
        if v == "Let":
            let name = variant_field(stmt, 0)
            let ty = variant_field(stmt, 1)
            let value = variant_field(stmt, 2)
            let ty_str = ""
            if ty != None:
                ty_str = ": " + self.map_type(ty)
            self.write_line("let " + name + ty_str + " = " + self.gen_expr(value) + ";")
            return
        
        if v == "Var":
            let name = variant_field(stmt, 0)
            let ty = variant_field(stmt, 1)
            let value = variant_field(stmt, 2)
            let ty_str = ""
            if ty != None:
                ty_str = ": " + self.map_type(ty)
            self.write_line("let mut " + name + ty_str + " = " + self.gen_expr(value) + ";")
            return
        
        if v == "Assign":
            let lhs = variant_field(stmt, 0)
            let rhs = variant_field(stmt, 1)
            self.write_line(self.gen_expr(lhs) + " = " + self.gen_expr(rhs) + ";")
            return
        
        if v == "Return":
            let maybe_expr = variant_field(stmt, 0)
            if maybe_expr != None:
                self.write_line("return " + self.gen_expr(maybe_expr) + ";")
            else:
                self.write_line("return;")
            return
        
        if v == "If":
            let cond = variant_field(stmt, 0)
            let then_block = variant_field(stmt, 1)
            let else_block = variant_field(stmt, 2)
            self.write_line("if " + self.gen_expr(cond) + " {")
            self.push_indent()
            for s in then_block:
                self.gen_stmt(s)
            self.pop_indent()
            if else_block != None:
                self.write_line("} else {")
                self.push_indent()
                for s in else_block:
                    self.gen_stmt(s)
                self.pop_indent()
                self.write_line("}")
            else:
                self.write_line("}")
            return
        
        if v == "While":
            let cond = variant_field(stmt, 0)
            let body = variant_field(stmt, 1)
            self.write_line("while " + self.gen_expr(cond) + " {")
            self.push_indent()
            for s in body:
                self.gen_stmt(s)
            self.pop_indent()
            self.write_line("}")
            return
        
        if v == "For":
            let var_name = variant_field(stmt, 0)
            let iter = variant_field(stmt, 1)
            let body = variant_field(stmt, 2)
            self.write_line("for " + var_name + " in " + self.gen_expr(iter) + " {")
            self.push_indent()
            for s in body:
                self.gen_stmt(s)
            self.pop_indent()
            self.write_line("}")
            return
        
        if v == "Loop":
            let body = variant_field(stmt, 0)
            self.write_line("loop {")
            self.push_indent()
            for s in body:
                self.gen_stmt(s)
            self.pop_indent()
            self.write_line("}")
            return
        
        if v == "Match":
            let scrutinee = variant_field(stmt, 0)
            let arms = variant_field(stmt, 1)
            self.write_line("match " + self.gen_expr(scrutinee) + " {")
            self.push_indent()
            for arm in arms:
                let pat = self.gen_pattern(arm.pattern)
                self.write_line(pat + " => {")
                self.push_indent()
                for s in arm.body:
                    self.gen_stmt(s)
                self.pop_indent()
                self.write_line("}")
            self.pop_indent()
            self.write_line("}")
            return
        
        if v == "Expr":
            let expr = variant_field(stmt, 0)
            self.write_line(self.gen_expr(expr) + ";")
            return
        
        if v == "Break":
            self.write_line("break;")
            return
        
        if v == "Continue":
            self.write_line("continue;")
            return
    
    // =========================================================================
    // Expression Generation
    // =========================================================================
    
    fn gen_expr(self, expr: Expr) -> String:
        // Bootstrap workaround: use variant_of/variant_field instead of pattern matching
        let v = variant_of(expr)
        
        if v == "Int":
            let n = variant_field(expr, 0)
            return str(n)
        
        if v == "Float":
            let f = variant_field(expr, 0)
            return str(f)
        
        if v == "String":
            let s = variant_field(expr, 0)
            return "\"" + self.escape_string(s) + "\".to_string()"
        
        if v == "Bool":
            let b = variant_field(expr, 0)
            if b:
                return "true"
            return "false"
        
        if v == "None":
            return "None"
        
        if v == "Ident":
            let name = variant_field(expr, 0)
            return name
        
        if v == "Binary":
            let left = variant_field(expr, 0)
            let op = variant_field(expr, 1)
            let right = variant_field(expr, 2)
            let l = self.gen_expr(left)
            let r = self.gen_expr(right)
            let rust_op = self.map_op(op)
            return "(" + l + " " + rust_op + " " + r + ")"
        
        if v == "Unary":
            let op = variant_field(expr, 0)
            let operand = variant_field(expr, 1)
            let o = self.gen_expr(operand)
            return "(" + op + o + ")"
        
        if v == "Call":
            let callee = variant_field(expr, 0)
            let args = variant_field(expr, 1)
            let fn_name = self.gen_expr(callee)
            
            // Convert Kore builtins to Rust macros with format strings
            if fn_name == "println" || fn_name == "print":
                let arg_strs = []
                let format_placeholders = []
                for arg in args:
                    push(arg_strs, self.gen_expr(arg))
                    push(format_placeholders, "{}")
                
                let format_str = "\"" + join(format_placeholders, " ") + "\""
                if len(arg_strs) > 0:
                    return fn_name + "!(" + format_str + ", " + join(arg_strs, ", ") + ")"
                return fn_name + "!()"
            
            let arg_strs = []
            for arg in args:
                push(arg_strs, self.gen_expr(arg))
            return fn_name + "(" + join(arg_strs, ", ") + ")"
        
        if v == "MethodCall":
            let receiver = variant_field(expr, 0)
            let method = variant_field(expr, 1)
            let args = variant_field(expr, 2)
            let recv = self.gen_expr(receiver)
            let arg_strs = []
            for arg in args:
                push(arg_strs, self.gen_expr(arg))
            return recv + "." + method + "(" + join(arg_strs, ", ") + ")"
        
        if v == "Index":
            let array = variant_field(expr, 0)
            let index = variant_field(expr, 1)
            return self.gen_expr(array) + "[" + self.gen_expr(index) + "]"
        
        if v == "Field":
            let obj = variant_field(expr, 0)
            let field = variant_field(expr, 1)
            return self.gen_expr(obj) + "." + field
        
        if v == "Array":
            let elements = variant_field(expr, 0)
            let elems = []
            for e in elements:
                push(elems, self.gen_expr(e))
            return "vec![" + join(elems, ", ") + "]"
        
        if v == "Struct":
            let name = variant_field(expr, 0)
            let field_inits = variant_field(expr, 1)
            let fields = []
            for fi in field_inits:
                push(fields, fi.name + ": " + self.gen_expr(fi.value))
            return name + " { " + join(fields, ", ") + " }"
        
        if v == "EnumVariant":
            let enum_name = variant_field(expr, 0)
            let variant_name = variant_field(expr, 1)
            let args = variant_field(expr, 2)
            if len(args) == 0:
                return enum_name + "::" + variant_name
            let arg_strs = []
            for arg in args:
                push(arg_strs, self.gen_expr(arg))
            return enum_name + "::" + variant_name + "(" + join(arg_strs, ", ") + ")"
        
        if v == "If":
            let cond = variant_field(expr, 0)
            let then_expr = variant_field(expr, 1)
            let else_expr = variant_field(expr, 2)
            let c = self.gen_expr(cond)
            let t = self.gen_expr(then_expr)
            if else_expr != None:
                return "(if " + c + " { " + t + " } else { " + self.gen_expr(else_expr) + " })"
            return "(if " + c + " { " + t + " } else { () })"
        
        if v == "Lambda":
            let params = variant_field(expr, 0)
            let body = variant_field(expr, 1)
            let p = join(params, ", ")
            return "|" + p + "| " + self.gen_expr(body)
        
        if v == "Await":
            let future = variant_field(expr, 0)
            return self.gen_expr(future) + ".await"
        
        // Fallback
        return "/* unsupported expr: " + v + " */"
    
    /// Generate a pattern for match arms
    fn gen_pattern(self, pattern: Pattern) -> String:
        // Bootstrap workaround: use variant_of/variant_field instead of pattern matching
        let v = variant_of(pattern)
        
        if v == "Wildcard":
            return "_"
        
        if v == "Ident":
            let name = variant_field(pattern, 0)
            return name
        
        if v == "Literal":
            let expr = variant_field(pattern, 0)
            return self.gen_expr(expr)
        
        if v == "Variant":
            let name = variant_field(pattern, 0)
            let fields = variant_field(pattern, 1)
            if len(fields) == 0:
                return name
            let field_pats = []
            for f in fields:
                push(field_pats, self.gen_pattern(f))
            return name + "(" + join(field_pats, ", ") + ")"
        
        return "/* unsupported pattern */"
    
    // =========================================================================
    // Type Mapping
    // =========================================================================
    
    fn map_type(self, ty: String) -> String:
        if ty == "Int":
            return "i64"
        if ty == "Float":
            return "f64"
        if ty == "Bool":
            return "bool"
        if ty == "String":
            return "String"
        if ty == "Unit":
            return "()"
        if ty == "Array":
            return "Vec<i64>"
        
        // Check for Array<T> pattern
        if starts_with(ty, "Array<"):
            let inner = substring(ty, 6, len(ty) - 1)
            return "Vec<" + self.map_type(inner) + ">"
        // Check for Option<T> pattern
        if starts_with(ty, "Option<"):
            let inner = substring(ty, 7, len(ty) - 1)
            return "Option<" + self.map_type(inner) + ">"
        // Assume it's a custom type
        return ty
    
    /// Map Kore operator to Rust operator
    fn map_op(self, op: String) -> String:
        if op == "and":
            return "&&"
        if op == "or":
            return "||"
        if op == "not":
            return "!"
        return op
    
    /// Escape special characters in strings
    fn escape_string(self, s: String) -> String:
        let result = ""
        let chars = split(s, "")
        for c in chars:
            if c == "\n":
                result = result + "\\n"
            else if c == "\t":
                result = result + "\\t"
            else if c == "\\":
                result = result + "\\\\"
            else if c == "\"":
                result = result + "\\\""
            else:
                result = result + c
        return result

// =============================================================================
// Cargo.toml Generator
// =============================================================================

fn gen_cargo_toml(name: String, deps: Array<String>) -> String:
    let sb = StringBuilder::new()
    
    sb.push_line("[package]")
    sb.push_line("name = \"" + name + "\"")
    sb.push_line("version = \"0.1.0\"")
    sb.push_line("edition = \"2021\"")
    sb.push_line("")
    sb.push_line("# Generated by KORE Compiler")
    sb.push_line("")
    sb.push_line("[dependencies]")
    
    for dep in deps:
        sb.push_line(dep + " = \"*\"")
    
    return sb.build()

// =============================================================================
// Entry Point
// =============================================================================

fn main():
    println("=== KORE â†’ Rust Transpiler ===")
    
    let source = "fn add(a: Int, b: Int) -> Int:
    return a + b

fn main():
    let result = add(1, 2)
    println(result)"
    
    println("Kore Source:")
    println(source)
    println("")
    
    // Tokenize
    let lexer = Lexer::new(source)
    let tokens = lexer.tokenize()
    
    // Parse
    let parser = Parser::new(tokens)
    let program = parser.parse_program()
    
    // Generate Rust
    let rustgen = RustGen::new()
    let rust_code = rustgen.gen_program(program)
    
    println("Generated Rust:")
    println("---")
    println(rust_code)
    println("---")
    
    // Generate Cargo.toml
    println("")
    println("Cargo.toml:")
    println("---")
    let cargo = gen_cargo_toml("kore_output", [])
    println(cargo)
    println("---")
    
    println("")
    println(" Rust transpilation complete!")
    println("Run: cd output && cargo build --release")
