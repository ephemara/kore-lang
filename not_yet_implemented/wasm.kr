// ============================================================================
// KORE WebAssembly Code Generator
// ============================================================================
// Ported from legacy_prototype/src/codegen/wasm.rs
//
// Generates WebAssembly bytecode from the Kore typed AST.
// Supports:
// - Functions, structs, enums
// - JSX/DOM rendering
// - Lambda functions (closures)
// - Memory management (bump allocator)
// ============================================================================

use std/collections

// =============================================================================
// Constants
// =============================================================================

// WASM Value Types
const WASM_I32: Int = 0x7F
const WASM_I64: Int = 0x7E
const WASM_F32: Int = 0x7D
const WASM_F64: Int = 0x7C

// WASM Section IDs
const SECTION_TYPE: Int = 1
const SECTION_IMPORT: Int = 2
const SECTION_FUNCTION: Int = 3
const SECTION_TABLE: Int = 4
const SECTION_MEMORY: Int = 5
const SECTION_GLOBAL: Int = 6
const SECTION_EXPORT: Int = 7
const SECTION_ELEMENT: Int = 9
const SECTION_CODE: Int = 10
const SECTION_DATA: Int = 11

// WASM Opcodes
const OP_UNREACHABLE: Int = 0x00
const OP_NOP: Int = 0x01
const OP_BLOCK: Int = 0x02
const OP_LOOP: Int = 0x03
const OP_IF: Int = 0x04
const OP_ELSE: Int = 0x05
const OP_END: Int = 0x0B
const OP_BR: Int = 0x0C
const OP_BR_IF: Int = 0x0D
const OP_RETURN: Int = 0x0F
const OP_CALL: Int = 0x10
const OP_CALL_INDIRECT: Int = 0x11
const OP_DROP: Int = 0x1A
const OP_SELECT: Int = 0x1B
const OP_LOCAL_GET: Int = 0x20
const OP_LOCAL_SET: Int = 0x21
const OP_LOCAL_TEE: Int = 0x22
const OP_GLOBAL_GET: Int = 0x23
const OP_GLOBAL_SET: Int = 0x24
const OP_I32_LOAD: Int = 0x28
const OP_I64_LOAD: Int = 0x29
const OP_F32_LOAD: Int = 0x2A
const OP_F64_LOAD: Int = 0x2B
const OP_I32_STORE: Int = 0x36
const OP_I64_STORE: Int = 0x37
const OP_F32_STORE: Int = 0x38
const OP_F64_STORE: Int = 0x39
const OP_I32_CONST: Int = 0x41
const OP_I64_CONST: Int = 0x42
const OP_F32_CONST: Int = 0x43
const OP_F64_CONST: Int = 0x44
const OP_I32_EQZ: Int = 0x45
const OP_I32_EQ: Int = 0x46
const OP_I32_NE: Int = 0x47
const OP_I32_LT_S: Int = 0x48
const OP_I32_GT_S: Int = 0x4A
const OP_I32_LE_S: Int = 0x4C
const OP_I32_GE_S: Int = 0x4E
const OP_I32_ADD: Int = 0x6A
const OP_I32_SUB: Int = 0x6B
const OP_I32_MUL: Int = 0x6C
const OP_I32_DIV_S: Int = 0x6D
const OP_I32_REM_S: Int = 0x6F
const OP_I32_AND: Int = 0x71
const OP_I32_OR: Int = 0x72
const OP_I32_XOR: Int = 0x73
const OP_I64_ADD: Int = 0x7C
const OP_I64_SUB: Int = 0x7D
const OP_I64_MUL: Int = 0x7E
const OP_I64_DIV_S: Int = 0x7F
const OP_F64_ADD: Int = 0xA0
const OP_F64_SUB: Int = 0xA1
const OP_F64_MUL: Int = 0xA2
const OP_F64_DIV: Int = 0xA3

// =============================================================================
// Compilation Context
// =============================================================================

/// Local variable mapping
struct LocalVar:
    id: Int
    ty: ValType

/// Function info
struct FuncInfo:
    index: Int
    params: Array<ValType>
    results: Array<ValType>

/// Struct layout
struct StructLayout:
    size: Int
    fields: Map<String, FieldLayout>

/// Field layout within struct
struct FieldLayout:
    offset: Int
    size: Int
    ty: ValType

/// Enum layout
struct EnumLayout:
    tag_size: Int
    max_payload_size: Int
    variants: Map<String, VariantLayout>

/// Variant layout
struct VariantLayout:
    tag: Int
    payload_size: Int
    fields: Array<ValType>

/// Compilation context for a function
struct CompilationContext:
    locals: Map<String, LocalVar>
    return_type: Option<ValType>
    loop_depth: Int
    block_depth: Int

// =============================================================================
// WASM Compiler
// =============================================================================

struct WasmCompiler:
    /// Output bytes
    output: Array<Int>
    
    /// Function registry
    functions: Map<String, FuncInfo>
    next_func_index: Int
    
    /// Import count (for function index offset)
    import_count: Int
    
    /// Struct layouts
    struct_layouts: Map<String, StructLayout>
    
    /// Enum layouts
    enum_layouts: Map<String, EnumLayout>
    
    /// String constants: string -> offset
    strings: Map<String, Int>
    next_string_offset: Int
    
    /// Lambda registry: id -> func_index
    lambdas: Map<Int, Int>
    next_lambda_id: Int
    
    /// Heap pointer global index
    heap_ptr_global: Int
    
    /// Data section bytes
    data_section: Array<Int>

impl WasmCompiler:
    pub fn new() -> WasmCompiler:
        return WasmCompiler {
            output: [],
            functions: Map::new(),
            next_func_index: 0,
            import_count: 0,
            struct_layouts: Map::new(),
            enum_layouts: Map::new(),
            strings: Map::new(),
            next_string_offset: 1024,  // Start strings after stack
            lambdas: Map::new(),
            next_lambda_id: 0,
            heap_ptr_global: 0,
            data_section: []
        }
    
    // =========================================================================
    // Main Entry Point
    // =========================================================================
    
    pub fn compile(self, program: TypedProgram) -> Result<Array<Int>, String>:
        // Phase 1: Declare imports
        self.declare_imports()
        
        // Phase 2: Collect struct/enum layouts
        for item in program.items:
            match item:
                TypedItem::Struct(s) => self.compute_struct_layout(s)
                TypedItem::Enum(e) => self.compute_enum_layout(e)
                TypedItem::Component(c) => self.compute_component_layout(c)
                _ => pass
        
        // Phase 3: Collect string constants and lambdas
        for item in program.items:
            match item:
                TypedItem::Function(f) =>
                    self.collect_strings_in_block(f.ast.body)
                    var lambdas: Array<(Int, Array<Param>, Expr)> = []
                    self.collect_lambdas_in_block(f.ast.body, lambdas)
                TypedItem::Component(c) =>
                    self.collect_strings_in_jsx(c.ast.render)
                _ => pass
        
        // Phase 4: Declare all functions
        for item in program.items:
            match item:
                TypedItem::Function(f) => self.declare_function(f)?
                _ => pass
        
        // Phase 5: Compile function bodies
        for item in program.items:
            match item:
                TypedItem::Function(f) => self.compile_function_body(f)?
                TypedItem::Component(c) => self.compile_component(c)?
                _ => pass
        
        // Phase 6: Emit module
        return Ok(self.emit_module())
    
    // =========================================================================
    // Imports
    // =========================================================================
    
    fn declare_imports(self) -> Unit:
        // Console logging
        self.add_import("env", "log_i32", [WASM_I32], [])
        self.add_import("env", "log_str", [WASM_I32, WASM_I32], [])
        
        // DOM operations (for JSX)
        self.add_import("dom", "createElement", [WASM_I32, WASM_I32], [WASM_I32])
        self.add_import("dom", "createTextNode", [WASM_I32, WASM_I32], [WASM_I32])
        self.add_import("dom", "appendChild", [WASM_I32, WASM_I32], [])
        self.add_import("dom", "setAttribute", [WASM_I32, WASM_I32, WASM_I32, WASM_I32, WASM_I32], [])
        self.add_import("dom", "addEventListener", [WASM_I32, WASM_I32, WASM_I32, WASM_I32], [])
        self.add_import("dom", "setTextContent", [WASM_I32, WASM_I32, WASM_I32], [])
        self.add_import("dom", "removeChild", [WASM_I32, WASM_I32], [])
        self.add_import("dom", "getRoot", [], [WASM_I32])
    
    fn add_import(self, module: String, name: String, params: Array<Int>, results: Array<Int>) -> Unit:
        let idx = self.next_func_index
        self.functions[name] = FuncInfo {
            index: idx,
            params: params,
            results: results
        }
        self.next_func_index = self.next_func_index + 1
        self.import_count = self.import_count + 1
    
    // =========================================================================
    // Layout Computation
    // =========================================================================
    
    fn compute_struct_layout(self, s: TypedStruct) -> Unit:
        var layout = StructLayout {
            size: 0,
            fields: Map::new()
        }
        
        var offset = 0
        for field in s.ast.fields:
            let field_ty = self.map_type(s.field_types[field.name])
            let field_size = self.type_size(field_ty)
            
            // Align offset
            offset = align_to(offset, field_size)
            
            layout.fields[field.name] = FieldLayout {
                offset: offset,
                size: field_size,
                ty: field_ty
            }
            
            offset = offset + field_size
        
        layout.size = align_to(offset, 8)  // 8-byte alignment
        self.struct_layouts[s.ast.name] = layout
    
    fn compute_enum_layout(self, e: TypedEnum) -> Unit:
        var layout = EnumLayout {
            tag_size: 4,  // i32 tag
            max_payload_size: 0,
            variants: Map::new()
        }
        
        var tag = 0
        for variant in e.ast.variants:
            var payload_size = 0
            var fields: Array<ValType> = []
            
            match variant.data:
                VariantData::Tuple(types) =>
                    for ty in types:
                        let vt = self.map_ast_type(ty)
                        push(fields, vt)
                        payload_size = payload_size + self.type_size(vt)
                VariantData::Struct(f) =>
                    for field in f:
                        let vt = self.map_ast_type(field.ty)
                        push(fields, vt)
                        payload_size = payload_size + self.type_size(vt)
                _ => pass
            
            layout.variants[variant.name] = VariantLayout {
                tag: tag,
                payload_size: payload_size,
                fields: fields
            }
            
            if payload_size > layout.max_payload_size:
                layout.max_payload_size = payload_size
            
            tag = tag + 1
        
        self.enum_layouts[e.ast.name] = layout
    
    fn compute_component_layout(self, c: TypedComponent) -> Unit:
        // Components are like structs with their props as fields
        var layout = StructLayout {
            size: 0,
            fields: Map::new()
        }
        
        var offset = 0
        for prop in c.ast.props:
            let prop_ty = self.map_ast_type(prop.ty)
            let prop_size = self.type_size(prop_ty)
            
            offset = align_to(offset, prop_size)
            
            layout.fields[prop.name] = FieldLayout {
                offset: offset,
                size: prop_size,
                ty: prop_ty
            }
            
            offset = offset + prop_size
        
        layout.size = align_to(offset, 8)
        self.struct_layouts[c.ast.name] = layout
    
    // =========================================================================
    // Type Mapping
    // =========================================================================
    
    fn map_type(self, ty: ResolvedType) -> Int:
        match ty:
            ResolvedType::Int(IntSize::I32) => WASM_I32
            ResolvedType::Int(IntSize::I64) => WASM_I64
            ResolvedType::Int(_) => WASM_I64  // Default to i64
            ResolvedType::Float(FloatSize::F32) => WASM_F32
            ResolvedType::Float(FloatSize::F64) => WASM_F64
            ResolvedType::Float(_) => WASM_F64
            ResolvedType::Bool => WASM_I32
            ResolvedType::String => WASM_I32  // Pointer
            ResolvedType::Unit => WASM_I32
            ResolvedType::Struct(_, _) => WASM_I32  // Pointer
            ResolvedType::Enum(_, _) => WASM_I32  // Pointer
            ResolvedType::Array(_, _) => WASM_I32  // Pointer
            ResolvedType::Function(_, _, _) => WASM_I32  // Table index
            _ => WASM_I32
    
    fn map_ast_type(self, ty: Type) -> Int:
        match ty:
            Type::Named(name, _, _) =>
                if name == "Int" or name == "i64": return WASM_I64
                if name == "i32": return WASM_I32
                if name == "Float" or name == "f64": return WASM_F64
                if name == "f32": return WASM_F32
                if name == "Bool": return WASM_I32
                if name == "String": return WASM_I32
                return WASM_I32  // Pointer for structs/enums
            Type::Unit(_) => WASM_I32
            _ => WASM_I32
    
    fn type_size(self, ty: Int) -> Int:
        match ty:
            WASM_I32 => 4
            WASM_I64 => 8
            WASM_F32 => 4
            WASM_F64 => 8
            _ => 4
    
    fn type_size_of(self, ty: ResolvedType) -> Int:
        match ty:
            ResolvedType::Int(IntSize::I64) => 8
            ResolvedType::Float(FloatSize::F64) => 8
            ResolvedType::Struct(name, _) =>
                if contains_key(self.struct_layouts, name):
                    return self.struct_layouts[name].size
                return 8
            _ => 4
    
    // =========================================================================
    // String Collection
    // =========================================================================
    
    fn collect_strings_in_block(self, block: Block) -> Unit:
        for stmt in block.stmts:
            self.collect_strings_in_stmt(stmt)
    
    fn collect_strings_in_stmt(self, stmt: Stmt) -> Unit:
        match stmt:
            Stmt::Expr(e, _) => self.collect_strings_in_expr(e)
            Stmt::Return(Some(e), _) => self.collect_strings_in_expr(e)
            Stmt::Let(_, _, Some(e), _) => self.collect_strings_in_expr(e)
            Stmt::For(_, iter, body, _) =>
                self.collect_strings_in_expr(iter)
                self.collect_strings_in_block(body)
            Stmt::While(cond, body, _) =>
                self.collect_strings_in_expr(cond)
                self.collect_strings_in_block(body)
            _ => pass
    
    fn collect_strings_in_expr(self, expr: Expr) -> Unit:
        match expr:
            Expr::String(s, _) =>
                if !contains_key(self.strings, s):
                    let offset = self.next_string_offset
                    self.strings[s] = offset
                    // Add to data section: length (4 bytes) + chars
                    self.add_string_to_data(s, offset)
                    self.next_string_offset = offset + 4 + len(s) + 1  // +1 for null term
            
            Expr::Binary(l, _, r, _) =>
                self.collect_strings_in_expr(l)
                self.collect_strings_in_expr(r)
            
            Expr::Call(callee, args, _) =>
                self.collect_strings_in_expr(callee)
                for arg in args:
                    self.collect_strings_in_expr(arg.value)
            
            Expr::If(cond, then_b, else_b, _) =>
                self.collect_strings_in_expr(cond)
                self.collect_strings_in_block(then_b)
                match else_b:
                    Some(ElseBranch::Else(b)) => self.collect_strings_in_block(b)
                    _ => pass
            
            Expr::Block(b, _) => self.collect_strings_in_block(b)
            
            Expr::Array(items, _) =>
                for item in items:
                    self.collect_strings_in_expr(item)
            
            Expr::Struct(_, fields, _) =>
                for (_, v) in fields:
                    self.collect_strings_in_expr(v)
            
            Expr::JSX(node, _) => self.collect_strings_in_jsx(node)
            
            _ => pass
    
    fn collect_strings_in_jsx(self, node: JSXNode) -> Unit:
        match node:
            JSXNode::Element(el) =>
                // Collect tag name
                if !contains_key(self.strings, el.name):
                    let offset = self.next_string_offset
                    self.strings[el.name] = offset
                    self.add_string_to_data(el.name, offset)
                    self.next_string_offset = offset + 4 + len(el.name) + 1
                
                // Collect attributes
                for attr in el.attributes:
                    if !contains_key(self.strings, attr.name):
                        let offset = self.next_string_offset
                        self.strings[attr.name] = offset
                        self.add_string_to_data(attr.name, offset)
                        self.next_string_offset = offset + 4 + len(attr.name) + 1
                    self.collect_strings_in_expr(attr.value)
                
                // Collect children
                for child in el.children:
                    self.collect_strings_in_jsx(child)
            
            JSXNode::Text(text) =>
                if !contains_key(self.strings, text):
                    let offset = self.next_string_offset
                    self.strings[text] = offset
                    self.add_string_to_data(text, offset)
                    self.next_string_offset = offset + 4 + len(text) + 1
            
            JSXNode::Expr(e) => self.collect_strings_in_expr(e)
            
            JSXNode::Fragment(children) =>
                for child in children:
                    self.collect_strings_in_jsx(child)
    
    fn add_string_to_data(self, s: String, offset: Int) -> Unit:
        // Store length as i32
        let len_bytes = int_to_bytes_i32(len(s))
        for b in len_bytes:
            push(self.data_section, b)
        
        // Store string bytes
        for ch in chars(s):
            push(self.data_section, char_code(ch))
        
        // Null terminator
        push(self.data_section, 0)
    
    // =========================================================================
    // Lambda Collection
    // =========================================================================
    
    fn collect_lambdas_in_block(self, block: Block, lambdas: Array<(Int, Array<Param>, Expr)>) -> Unit:
        for stmt in block.stmts:
            self.collect_lambdas_in_stmt(stmt, lambdas)
    
    fn collect_lambdas_in_stmt(self, stmt: Stmt, lambdas: Array<(Int, Array<Param>, Expr)>) -> Unit:
        match stmt:
            Stmt::Expr(e, _) => self.collect_lambdas_in_expr(e, lambdas)
            Stmt::Return(Some(e), _) => self.collect_lambdas_in_expr(e, lambdas)
            Stmt::Let(_, _, Some(e), _) => self.collect_lambdas_in_expr(e, lambdas)
            Stmt::For(_, iter, body, _) =>
                self.collect_lambdas_in_expr(iter, lambdas)
                self.collect_lambdas_in_block(body, lambdas)
            _ => pass
    
    fn collect_lambdas_in_expr(self, expr: Expr, lambdas: Array<(Int, Array<Param>, Expr)>) -> Unit:
        match expr:
            Expr::Lambda(params, body, _, _) =>
                let id = self.next_lambda_id
                self.next_lambda_id = self.next_lambda_id + 1
                push(lambdas, (id, params, body))
                self.collect_lambdas_in_expr(body, lambdas)
            
            Expr::Call(callee, args, _) =>
                self.collect_lambdas_in_expr(callee, lambdas)
                for arg in args:
                    self.collect_lambdas_in_expr(arg.value, lambdas)
            
            Expr::Binary(l, _, r, _) =>
                self.collect_lambdas_in_expr(l, lambdas)
                self.collect_lambdas_in_expr(r, lambdas)
            
            Expr::If(cond, then_b, else_b, _) =>
                self.collect_lambdas_in_expr(cond, lambdas)
                self.collect_lambdas_in_block(then_b, lambdas)
                match else_b:
                    Some(ElseBranch::Else(b)) => self.collect_lambdas_in_block(b, lambdas)
                    _ => pass
            
            Expr::Block(b, _) => self.collect_lambdas_in_block(b, lambdas)
            
            _ => pass
    
    // =========================================================================
    // Function Declaration
    // =========================================================================
    
    fn declare_function(self, func: TypedFunction) -> Result<Unit, String>:
        // Get parameter types
        var params: Array<Int> = []
        match func.resolved_type:
            ResolvedType::Function(p, _, _) =>
                for param_ty in p:
                    push(params, self.map_type(param_ty))
            _ =>
                for param in func.ast.params:
                    push(params, self.map_ast_type(param.ty))
        
        // Get return type
        var results: Array<Int> = []
        match func.resolved_type:
            ResolvedType::Function(_, ret, _) =>
                if ret != ResolvedType::Unit:
                    push(results, self.map_type(ret))
            _ =>
                match func.ast.return_type:
                    Some(ret) =>
                        let rt = self.map_ast_type(ret)
                        if rt != WASM_I32 or true:  // Include all returns
                            push(results, rt)
                    None => pass
        
        self.functions[func.ast.name] = FuncInfo {
            index: self.next_func_index,
            params: params,
            results: results
        }
        self.next_func_index = self.next_func_index + 1
        
        return Ok(())
    
    // =========================================================================
    // Function Compilation
    // =========================================================================
    
    fn compile_function_body(self, func: TypedFunction) -> Result<Unit, String>:
        let info = self.functions[func.ast.name]
        
        // Create context
        var ctx = CompilationContext {
            locals: Map::new(),
            return_type: if len(info.results) > 0: Some(info.results[0]) else: None,
            loop_depth: 0,
            block_depth: 0
        }
        
        // Register parameters as locals
        var local_idx = 0
        for param in func.ast.params:
            let ty = if local_idx < len(info.params): info.params[local_idx] else: WASM_I32
            ctx.locals[param.name] = LocalVar { id: local_idx, ty: ty }
            local_idx = local_idx + 1
        
        // Pre-allocate locals for let bindings
        self.preallocate_locals(func.ast.body, ctx.locals, local_idx)
        
        // Compile body
        var code: Array<Int> = []
        self.compile_block(ctx, code, func.ast.body)?
        
        // Add end opcode
        push(code, OP_END)
        
        // Store compiled code (would be added to code section later)
        return Ok(())
    
    fn preallocate_locals(self, block: Block, locals: Map<String, LocalVar>, start_idx: Int) -> Int:
        var idx = start_idx
        for stmt in block.stmts:
            match stmt:
                Stmt::Let(Pattern::Binding(name, _, _), ty, _, _) =>
                    let vt = match ty:
                        Some(t) => self.map_ast_type(t)
                        None => WASM_I64  // Default
                    locals[name] = LocalVar { id: idx, ty: vt }
                    idx = idx + 1
                
                Stmt::For(Pattern::Binding(name, _, _), _, body, _) =>
                    locals[name] = LocalVar { id: idx, ty: WASM_I64 }
                    idx = idx + 1
                    idx = self.preallocate_locals(body, locals, idx)
                
                Stmt::While(_, body, _) =>
                    idx = self.preallocate_locals(body, locals, idx)
                
                _ => pass
        return idx
    
    // =========================================================================
    // Block/Statement Compilation
    // =========================================================================
    
    fn compile_block(self, ctx: CompilationContext, code: Array<Int>, block: Block) -> Result<Unit, String>:
        for stmt in block.stmts:
            self.compile_stmt(ctx, code, stmt)?
        return Ok(())
    
    fn compile_stmt(self, ctx: CompilationContext, code: Array<Int>, stmt: Stmt) -> Result<Unit, String>:
        match stmt:
            Stmt::Let(Pattern::Binding(name, _, _), _, Some(value), _) =>
                // Compile value
                self.compile_expr(ctx, code, value)?
                // Store to local
                let local = ctx.locals[name]
                push(code, OP_LOCAL_SET)
                self.emit_uleb128(code, local.id)
            
            Stmt::Expr(e, _) =>
                self.compile_expr(ctx, code, e)?
                // Drop result if any (check expression type)
                push(code, OP_DROP)
            
            Stmt::Return(Some(e), _) =>
                self.compile_expr(ctx, code, e)?
                push(code, OP_RETURN)
            
            Stmt::Return(None, _) =>
                push(code, OP_RETURN)
            
            Stmt::For(Pattern::Binding(name, _, _), iter, body, _) =>
                // Compile iterator, assume it returns (ptr, len)
                self.compile_expr(ctx, code, iter)?
                
                // For now, simplified for loop over range
                // TODO: Full iterator support
                let idx_local = ctx.locals[name]
                
                // Initialize index to 0
                push(code, OP_I32_CONST)
                self.emit_sleb128(code, 0)
                push(code, OP_LOCAL_SET)
                self.emit_uleb128(code, idx_local.id)
                
                // Loop structure
                push(code, OP_BLOCK)
                push(code, 0x40)  // void block type
                push(code, OP_LOOP)
                push(code, 0x40)
                
                // Compile body
                self.compile_block(ctx, code, body)?
                
                // Increment index
                push(code, OP_LOCAL_GET)
                self.emit_uleb128(code, idx_local.id)
                push(code, OP_I32_CONST)
                self.emit_sleb128(code, 1)
                push(code, OP_I32_ADD)
                push(code, OP_LOCAL_SET)
                self.emit_uleb128(code, idx_local.id)
                
                // Branch back to loop
                push(code, OP_BR)
                self.emit_uleb128(code, 0)
                
                push(code, OP_END)  // End loop
                push(code, OP_END)  // End block
            
            Stmt::While(cond, body, _) =>
                push(code, OP_BLOCK)
                push(code, 0x40)
                push(code, OP_LOOP)
                push(code, 0x40)
                
                // Check condition
                self.compile_expr(ctx, code, cond)?
                push(code, OP_I32_EQZ)
                push(code, OP_BR_IF)
                self.emit_uleb128(code, 1)  // Break to outer block
                
                // Body
                self.compile_block(ctx, code, body)?
                
                // Continue
                push(code, OP_BR)
                self.emit_uleb128(code, 0)
                
                push(code, OP_END)
                push(code, OP_END)
            
            _ => pass
        
        return Ok(())
    
    // =========================================================================
    // Expression Compilation
    // =========================================================================
    
    fn compile_expr(self, ctx: CompilationContext, code: Array<Int>, expr: Expr) -> Result<Unit, String>:
        match expr:
            Expr::Int(n, _) =>
                push(code, OP_I64_CONST)
                self.emit_sleb128(code, n)
            
            Expr::Float(f, _) =>
                push(code, OP_F64_CONST)
                self.emit_f64(code, f)
            
            Expr::Bool(b, _) =>
                push(code, OP_I32_CONST)
                self.emit_sleb128(code, if b: 1 else: 0)
            
            Expr::String(s, _) =>
                // Push string pointer
                let offset = self.strings[s]
                push(code, OP_I32_CONST)
                self.emit_sleb128(code, offset)
            
            Expr::Ident(name, _) =>
                if contains_key(ctx.locals, name):
                    let local = ctx.locals[name]
                    push(code, OP_LOCAL_GET)
                    self.emit_uleb128(code, local.id)
                else:
                    // Could be global or function reference
                    return Err("Unknown identifier: " + name)
            
            Expr::Binary(left, op, right, _) =>
                self.compile_expr(ctx, code, left)?
                self.compile_expr(ctx, code, right)?
                self.compile_binop(code, op)
            
            Expr::Unary(op, operand, _) =>
                self.compile_expr(ctx, code, operand)?
                match op:
                    UnaryOp::Neg =>
                        // 0 - value for integers
                        push(code, OP_I64_CONST)
                        self.emit_sleb128(code, 0)
                        push(code, OP_I64_SUB)
                    UnaryOp::Not =>
                        push(code, OP_I32_EQZ)
                    _ => pass
            
            Expr::Call(Expr::Ident(name, _), args, _) =>
                // Compile arguments
                for arg in args:
                    self.compile_expr(ctx, code, arg.value)?
                
                // Call function
                if contains_key(self.functions, name):
                    let func = self.functions[name]
                    push(code, OP_CALL)
                    self.emit_uleb128(code, func.index)
                else:
                    return Err("Unknown function: " + name)
            
            Expr::If(cond, then_b, else_b, _) =>
                self.compile_expr(ctx, code, cond)?
                push(code, OP_IF)
                push(code, 0x40)  // void block type (TODO: handle result type)
                
                self.compile_block(ctx, code, then_b)?
                
                match else_b:
                    Some(ElseBranch::Else(b)) =>
                        push(code, OP_ELSE)
                        self.compile_block(ctx, code, b)?
                    None => pass
                
                push(code, OP_END)
            
            Expr::Block(b, _) =>
                self.compile_block(ctx, code, b)?
            
            Expr::Struct(name, fields, _) =>
                // Allocate struct
                let layout = self.struct_layouts[name]
                self.emit_alloc(code, layout.size)
                
                // Get pointer (duplicate for field stores)
                let ptr_local = len(ctx.locals)
                push(code, OP_LOCAL_TEE)
                self.emit_uleb128(code, ptr_local)
                
                // Store fields
                for (fname, fval) in fields:
                    if contains_key(layout.fields, fname):
                        let field = layout.fields[fname]
                        
                        // Duplicate pointer
                        push(code, OP_LOCAL_GET)
                        self.emit_uleb128(code, ptr_local)
                        
                        // Add field offset
                        push(code, OP_I32_CONST)
                        self.emit_sleb128(code, field.offset)
                        push(code, OP_I32_ADD)
                        
                        // Compile value
                        self.compile_expr(ctx, code, fval)?
                        
                        // Store
                        self.emit_store(code, field.ty)
                
                // Leave pointer on stack
                push(code, OP_LOCAL_GET)
                self.emit_uleb128(code, ptr_local)
            
            Expr::Field(object, field, _) =>
                self.compile_expr(ctx, code, object)?
                
                // TODO: Get struct type from expression, look up field offset
                // For now, assume offset is known statically
                push(code, OP_I32_CONST)
                self.emit_sleb128(code, 0)  // Placeholder offset
                push(code, OP_I32_ADD)
                push(code, OP_I64_LOAD)
                push(code, 0x03)  // align
                push(code, 0x00)  // offset
            
            Expr::Array(items, _) =>
                // Allocate array: [length (4), elem0, elem1, ...]
                let count = len(items)
                let elem_size = 8  // Assume i64 elements
                let total_size = 4 + (count * elem_size)
                
                self.emit_alloc(code, total_size)
                
                // Store length
                push(code, OP_LOCAL_TEE)
                self.emit_uleb128(code, 0)  // temp local
                push(code, OP_I32_CONST)
                self.emit_sleb128(code, count)
                push(code, OP_I32_STORE)
                push(code, 0x02)
                push(code, 0x00)
                
                // Store elements
                for i in range(0, count):
                    push(code, OP_LOCAL_GET)
                    self.emit_uleb128(code, 0)
                    push(code, OP_I32_CONST)
                    self.emit_sleb128(code, 4 + (i * elem_size))
                    push(code, OP_I32_ADD)
                    self.compile_expr(ctx, code, items[i])?
                    push(code, OP_I64_STORE)
                    push(code, 0x03)
                    push(code, 0x00)
                
                // Return pointer
                push(code, OP_LOCAL_GET)
                self.emit_uleb128(code, 0)
            
            Expr::Index(arr, idx, _) =>
                self.compile_expr(ctx, code, arr)?
                self.compile_expr(ctx, code, idx)?
                
                // ptr + 4 + (idx * 8)
                push(code, OP_I32_CONST)
                self.emit_sleb128(code, 8)
                push(code, OP_I32_MUL)
                push(code, OP_I32_CONST)
                self.emit_sleb128(code, 4)
                push(code, OP_I32_ADD)
                push(code, OP_I32_ADD)
                push(code, OP_I64_LOAD)
                push(code, 0x03)
                push(code, 0x00)
            
            Expr::JSX(node, _) =>
                self.compile_jsx_node(ctx, code, node)?
            
            _ =>
                // Default: push 0
                push(code, OP_I32_CONST)
                self.emit_sleb128(code, 0)
        
        return Ok(())
    
    fn compile_binop(self, code: Array<Int>, op: BinaryOp) -> Unit:
        match op:
            BinaryOp::Add => push(code, OP_I64_ADD)
            BinaryOp::Sub => push(code, OP_I64_SUB)
            BinaryOp::Mul => push(code, OP_I64_MUL)
            BinaryOp::Div => push(code, OP_I64_DIV_S)
            BinaryOp::Mod => push(code, OP_I32_REM_S)
            BinaryOp::Eq => push(code, OP_I32_EQ)
            BinaryOp::Ne => push(code, OP_I32_NE)
            BinaryOp::Lt => push(code, OP_I32_LT_S)
            BinaryOp::Gt => push(code, OP_I32_GT_S)
            BinaryOp::Le => push(code, OP_I32_LE_S)
            BinaryOp::Ge => push(code, OP_I32_GE_S)
            BinaryOp::And => push(code, OP_I32_AND)
            BinaryOp::Or => push(code, OP_I32_OR)
            BinaryOp::BitAnd => push(code, OP_I32_AND)
            BinaryOp::BitOr => push(code, OP_I32_OR)
            BinaryOp::BitXor => push(code, OP_I32_XOR)
            _ => pass
    
    // =========================================================================
    // JSX Compilation
    // =========================================================================
    
    fn compile_jsx_node(self, ctx: CompilationContext, code: Array<Int>, node: JSXNode) -> Result<Unit, String>:
        match node:
            JSXNode::Element(el) =>
                // createElement(tag_ptr, tag_len)
                let tag_offset = self.strings[el.name]
                push(code, OP_I32_CONST)
                self.emit_sleb128(code, tag_offset + 4)  // Skip length
                push(code, OP_I32_CONST)
                self.emit_sleb128(code, len(el.name))
                
                let create_fn = self.functions["createElement"]
                push(code, OP_CALL)
                self.emit_uleb128(code, create_fn.index)
                
                // Store element handle in temp
                push(code, OP_LOCAL_TEE)
                self.emit_uleb128(code, 0)  // temp
                
                // Set attributes
                for attr in el.attributes:
                    push(code, OP_LOCAL_GET)
                    self.emit_uleb128(code, 0)
                    
                    // Attribute name
                    let attr_offset = self.strings[attr.name]
                    push(code, OP_I32_CONST)
                    self.emit_sleb128(code, attr_offset + 4)
                    push(code, OP_I32_CONST)
                    self.emit_sleb128(code, len(attr.name))
                    
                    // Attribute value (compile expression, assume string)
                    self.compile_expr(ctx, code, attr.value)?
                    
                    // Call setAttribute(elem, name_ptr, name_len, val_ptr, val_len)
                    let set_attr = self.functions["setAttribute"]
                    push(code, OP_CALL)
                    self.emit_uleb128(code, set_attr.index)
                
                // Append children
                for child in el.children:
                    self.compile_jsx_node(ctx, code, child)?
                    
                    // appendChild(parent, child)
                    push(code, OP_LOCAL_GET)
                    self.emit_uleb128(code, 0)
                    // Stack already has child element
                    let append_fn = self.functions["appendChild"]
                    push(code, OP_CALL)
                    self.emit_uleb128(code, append_fn.index)
                
                // Leave element on stack
                push(code, OP_LOCAL_GET)
                self.emit_uleb128(code, 0)
            
            JSXNode::Text(text) =>
                let text_offset = self.strings[text]
                push(code, OP_I32_CONST)
                self.emit_sleb128(code, text_offset + 4)
                push(code, OP_I32_CONST)
                self.emit_sleb128(code, len(text))
                
                let create_text = self.functions["createTextNode"]
                push(code, OP_CALL)
                self.emit_uleb128(code, create_text.index)
            
            JSXNode::Expr(e) =>
                self.compile_expr(ctx, code, e)?
            
            JSXNode::Fragment(children) =>
                // Create a div container for fragments
                // TODO: Use DocumentFragment in DOM
                for child in children:
                    self.compile_jsx_node(ctx, code, child)?
        
        return Ok(())
    
    // =========================================================================
    // Component Compilation
    // =========================================================================
    
    fn compile_component(self, comp: TypedComponent) -> Result<Unit, String>:
        let render_name = comp.ast.name + "_render"
        
        // Declare render function
        self.functions[render_name] = FuncInfo {
            index: self.next_func_index,
            params: [WASM_I32],  // props pointer
            results: [WASM_I32]  // element handle
        }
        self.next_func_index = self.next_func_index + 1
        
        // Compile render function
        var ctx = CompilationContext {
            locals: Map::new(),
            return_type: Some(WASM_I32),
            loop_depth: 0,
            block_depth: 0
        }
        
        // Props pointer is local 0
        ctx.locals["props"] = LocalVar { id: 0, ty: WASM_I32 }
        
        // Add prop accessors
        let layout = self.struct_layouts[comp.ast.name]
        for prop in comp.ast.props:
            // Create accessor local
            // (would load from props struct)
            pass
        
        var code: Array<Int> = []
        self.compile_jsx_node(ctx, code, comp.ast.render)?
        push(code, OP_END)
        
        return Ok(())
    
    // =========================================================================
    // Memory Helpers
    // =========================================================================
    
    fn emit_alloc(self, code: Array<Int>, size: Int) -> Unit:
        // Bump allocator: heap_ptr += size, return old heap_ptr
        push(code, OP_GLOBAL_GET)
        self.emit_uleb128(code, self.heap_ptr_global)
        
        push(code, OP_GLOBAL_GET)
        self.emit_uleb128(code, self.heap_ptr_global)
        push(code, OP_I32_CONST)
        self.emit_sleb128(code, align_to(size, 8))
        push(code, OP_I32_ADD)
        push(code, OP_GLOBAL_SET)
        self.emit_uleb128(code, self.heap_ptr_global)
    
    fn emit_store(self, code: Array<Int>, ty: Int) -> Unit:
        match ty:
            WASM_I32 =>
                push(code, OP_I32_STORE)
                push(code, 0x02)
                push(code, 0x00)
            WASM_I64 =>
                push(code, OP_I64_STORE)
                push(code, 0x03)
                push(code, 0x00)
            WASM_F32 =>
                push(code, OP_F32_STORE)
                push(code, 0x02)
                push(code, 0x00)
            WASM_F64 =>
                push(code, OP_F64_STORE)
                push(code, 0x03)
                push(code, 0x00)
            _ => pass
    
    // =========================================================================
    // LEB128 Encoding
    // =========================================================================
    
    fn emit_uleb128(self, code: Array<Int>, value: Int) -> Unit:
        var n = value
        loop:
            let byte = n & 0x7F
            n = n >> 7
            if n == 0:
                push(code, byte)
                break
            else:
                push(code, byte | 0x80)
    
    fn emit_sleb128(self, code: Array<Int>, value: Int) -> Unit:
        var n = value
        var more = true
        while more:
            let byte = n & 0x7F
            n = n >> 7
            if (n == 0 and (byte & 0x40) == 0) or (n == -1 and (byte & 0x40) != 0):
                push(code, byte)
                more = false
            else:
                push(code, byte | 0x80)
    
    fn emit_f64(self, code: Array<Int>, value: Float) -> Unit:
        // Float to bytes (IEEE 754)
        let bits = float_to_bits(value)
        for i in range(0, 8):
            push(code, (bits >> (i * 8)) & 0xFF)
    
    // =========================================================================
    // Module Emission
    // =========================================================================
    
    fn emit_module(self) -> Array<Int>:
        var bytes: Array<Int> = []
        
        // Magic number
        push(bytes, 0x00)
        push(bytes, 0x61)
        push(bytes, 0x73)
        push(bytes, 0x6D)
        
        // Version
        push(bytes, 0x01)
        push(bytes, 0x00)
        push(bytes, 0x00)
        push(bytes, 0x00)
        
        // TODO: Emit all sections
        // - Type section
        // - Import section
        // - Function section
        // - Table section
        // - Memory section
        // - Global section
        // - Export section
        // - Element section
        // - Code section
        // - Data section
        
        return bytes

// =============================================================================
// Utility Functions
// =============================================================================

fn align_to(value: Int, alignment: Int) -> Int:
    return (value + alignment - 1) & ~(alignment - 1)

fn int_to_bytes_i32(n: Int) -> Array<Int>:
    return [
        n & 0xFF,
        (n >> 8) & 0xFF,
        (n >> 16) & 0xFF,
        (n >> 24) & 0xFF
    ]

fn chars(s: String) -> Array<String>:
    // Split string into characters
    var result: Array<String> = []
    for i in range(0, len(s)):
        push(result, char_at(s, i))
    return result

extern fn char_code(c: String) -> Int
extern fn float_to_bits(f: Float) -> Int
extern fn char_at(s: String, i: Int) -> String

// =============================================================================
// Type Aliases (stubs)
// =============================================================================

type ValType = Int
