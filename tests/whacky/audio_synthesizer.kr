# KORE WHACKY TEST: Real-Time Audio Synthesizer
# Complete audio DSP: oscillators, filters, effects, MIDI, modular patching
# All in KORE with the effect system tracking audio processing

println!("=== REAL-TIME AUDIO SYNTHESIZER ===")
println!()

# ==========================================
# AUDIO FUNDAMENTALS
# ==========================================

const SAMPLE_RATE: Float = 44100.0
const BUFFER_SIZE: Int = 256
const TWO_PI: Float = 6.28318530718

struct AudioBuffer:
    samples: Array<Float>
    channels: Int
    sample_rate: Float

fn audio_buffer(channels: Int, length: Int) -> AudioBuffer:
    return AudioBuffer {
        samples: Array.new(channels * length, 0.0),
        channels: channels,
        sample_rate: SAMPLE_RATE
    }

effect Audio:
    fn process(buffer: AudioBuffer) -> AudioBuffer
    fn get_sample_rate() -> Float
    fn get_time() -> Float

# ==========================================
# OSCILLATORS
# ==========================================

trait Oscillator:
    fn generate(self, frequency: Float, phase: Float) -> Float
    fn next_phase(self, frequency: Float, phase: Float) -> Float

struct SineOsc:
    impl Oscillator:
        fn generate(self, frequency: Float, phase: Float) -> Float:
            return sin(phase)
        
        fn next_phase(self, frequency: Float, phase: Float) -> Float:
            let increment = TWO_PI * frequency / SAMPLE_RATE
            return (phase + increment) % TWO_PI

struct SawOsc:
    impl Oscillator:
        fn generate(self, frequency: Float, phase: Float) -> Float:
            # Polyblep anti-aliased sawtooth
            let t = phase / TWO_PI
            var saw = 2.0 * t - 1.0
            saw = saw - poly_blep(t, frequency / SAMPLE_RATE)
            return saw
        
        fn next_phase(self, frequency: Float, phase: Float) -> Float:
            let increment = TWO_PI * frequency / SAMPLE_RATE
            return (phase + increment) % TWO_PI

struct SquareOsc:
    pulse_width: Float = 0.5
    
    impl Oscillator:
        fn generate(self, frequency: Float, phase: Float) -> Float:
            let t = phase / TWO_PI
            var square = if t < self.pulse_width: 1.0 else: -1.0
            square = square + poly_blep(t, frequency / SAMPLE_RATE)
            square = square - poly_blep((t + 1.0 - self.pulse_width) % 1.0, frequency / SAMPLE_RATE)
            return square
        
        fn next_phase(self, frequency: Float, phase: Float) -> Float:
            let increment = TWO_PI * frequency / SAMPLE_RATE
            return (phase + increment) % TWO_PI

struct TriangleOsc:
    impl Oscillator:
        fn generate(self, frequency: Float, phase: Float) -> Float:
            let t = phase / TWO_PI
            return 4.0 * abs(t - 0.5) - 1.0
        
        fn next_phase(self, frequency: Float, phase: Float) -> Float:
            let increment = TWO_PI * frequency / SAMPLE_RATE
            return (phase + increment) % TWO_PI

struct NoiseOsc:
    impl Oscillator:
        fn generate(self, frequency: Float, phase: Float) -> Float:
            return random() * 2.0 - 1.0
        
        fn next_phase(self, frequency: Float, phase: Float) -> Float:
            return 0.0  # Noise doesn't use phase

# Polynomial bandlimited step for anti-aliasing
fn poly_blep(t: Float, dt: Float) -> Float:
    if t < dt:
        let t_norm = t / dt
        return t_norm + t_norm - t_norm * t_norm - 1.0
    else if t > 1.0 - dt:
        let t_norm = (t - 1.0) / dt
        return t_norm * t_norm + t_norm + t_norm + 1.0
    else:
        return 0.0

# ==========================================
# FILTERS
# ==========================================

trait Filter:
    fn process(self, input: Float) -> Float
    fn set_cutoff(self, frequency: Float) -> ()
    fn set_resonance(self, q: Float) -> ()

struct BiquadFilter:
    filter_type: FilterType
    cutoff: Float
    resonance: Float
    
    # Coefficients
    a0: Float = 1.0
    a1: Float = 0.0
    a2: Float = 0.0
    b0: Float = 1.0
    b1: Float = 0.0
    b2: Float = 0.0
    
    # State
    x1: Float = 0.0
    x2: Float = 0.0
    y1: Float = 0.0
    y2: Float = 0.0

enum FilterType:
    LowPass
    HighPass
    BandPass
    Notch
    Peak
    LowShelf
    HighShelf

impl BiquadFilter:
    fn new(filter_type: FilterType, cutoff: Float, resonance: Float) -> BiquadFilter:
        var f = BiquadFilter {
            filter_type: filter_type,
            cutoff: cutoff,
            resonance: resonance
        }
        f.calculate_coefficients()
        return f
    
    fn calculate_coefficients(self):
        let omega = TWO_PI * self.cutoff / SAMPLE_RATE
        let sin_omega = sin(omega)
        let cos_omega = cos(omega)
        let alpha = sin_omega / (2.0 * self.resonance)
        
        match self.filter_type:
            FilterType.LowPass =>
                self.b0 = (1.0 - cos_omega) / 2.0
                self.b1 = 1.0 - cos_omega
                self.b2 = (1.0 - cos_omega) / 2.0
                self.a0 = 1.0 + alpha
                self.a1 = -2.0 * cos_omega
                self.a2 = 1.0 - alpha
            
            FilterType.HighPass =>
                self.b0 = (1.0 + cos_omega) / 2.0
                self.b1 = -(1.0 + cos_omega)
                self.b2 = (1.0 + cos_omega) / 2.0
                self.a0 = 1.0 + alpha
                self.a1 = -2.0 * cos_omega
                self.a2 = 1.0 - alpha
            
            FilterType.BandPass =>
                self.b0 = alpha
                self.b1 = 0.0
                self.b2 = -alpha
                self.a0 = 1.0 + alpha
                self.a1 = -2.0 * cos_omega
                self.a2 = 1.0 - alpha
            
            _ => ()
        
        # Normalize coefficients
        self.b0 = self.b0 / self.a0
        self.b1 = self.b1 / self.a0
        self.b2 = self.b2 / self.a0
        self.a1 = self.a1 / self.a0
        self.a2 = self.a2 / self.a0
    
    impl Filter:
        fn process(self, input: Float) -> Float:
            let output = self.b0 * input + self.b1 * self.x1 + self.b2 * self.x2
                       - self.a1 * self.y1 - self.a2 * self.y2
            
            self.x2 = self.x1
            self.x1 = input
            self.y2 = self.y1
            self.y1 = output
            
            return output
        
        fn set_cutoff(self, frequency: Float):
            self.cutoff = frequency
            self.calculate_coefficients()
        
        fn set_resonance(self, q: Float):
            self.resonance = q
            self.calculate_coefficients()

# Moog ladder filter (4-pole)
struct MoogFilter:
    cutoff: Float
    resonance: Float
    stage: [Float; 4] = [0.0, 0.0, 0.0, 0.0]
    delay: [Float; 4] = [0.0, 0.0, 0.0, 0.0]
    
    impl Filter:
        fn process(self, input: Float) -> Float:
            let f = self.cutoff / SAMPLE_RATE
            let k = 4.0 * self.resonance
            
            # Feedback with saturation
            let feedback = self.stage[3] * k
            let saturated_input = tanh(input - feedback)
            
            # 4-stage cascade
            for i in range(0, 4):
                let stage_in = if i == 0: saturated_input else: self.stage[i - 1]
                self.stage[i] = self.stage[i] + f * (tanh(stage_in) - tanh(self.stage[i]))
            
            return self.stage[3]
        
        fn set_cutoff(self, frequency: Float):
            self.cutoff = clamp(frequency, 20.0, 20000.0)
        
        fn set_resonance(self, q: Float):
            self.resonance = clamp(q, 0.0, 1.0)

# ==========================================
# ENVELOPES
# ==========================================

enum EnvelopeStage:
    Idle
    Attack
    Decay
    Sustain
    Release

struct ADSR:
    attack: Float       # seconds
    decay: Float        # seconds
    sustain: Float      # 0-1
    release: Float      # seconds
    
    stage: EnvelopeStage = EnvelopeStage.Idle
    value: Float = 0.0
    rate: Float = 0.0

impl ADSR:
    fn new(a: Float, d: Float, s: Float, r: Float) -> ADSR:
        return ADSR { attack: a, decay: d, sustain: s, release: r }
    
    fn trigger(self):
        self.stage = EnvelopeStage.Attack
        self.rate = 1.0 / (self.attack * SAMPLE_RATE)
    
    fn release(self):
        self.stage = EnvelopeStage.Release
        self.rate = self.value / (self.release * SAMPLE_RATE)
    
    fn process(self) -> Float:
        match self.stage:
            EnvelopeStage.Idle =>
                return 0.0
            
            EnvelopeStage.Attack =>
                self.value = self.value + self.rate
                if self.value >= 1.0:
                    self.value = 1.0
                    self.stage = EnvelopeStage.Decay
                    self.rate = (1.0 - self.sustain) / (self.decay * SAMPLE_RATE)
                return self.value
            
            EnvelopeStage.Decay =>
                self.value = self.value - self.rate
                if self.value <= self.sustain:
                    self.value = self.sustain
                    self.stage = EnvelopeStage.Sustain
                return self.value
            
            EnvelopeStage.Sustain =>
                return self.sustain
            
            EnvelopeStage.Release =>
                self.value = self.value - self.rate
                if self.value <= 0.0:
                    self.value = 0.0
                    self.stage = EnvelopeStage.Idle
                return self.value

# ==========================================
# EFFECTS
# ==========================================

struct Delay:
    buffer: Array<Float>
    write_pos: Int = 0
    delay_time: Float       # seconds
    feedback: Float         # 0-1
    mix: Float              # 0-1
    
    fn new(max_delay: Float) -> Delay:
        let size = (max_delay * SAMPLE_RATE) as Int
        return Delay { buffer: Array.new(size, 0.0), delay_time: 0.5, feedback: 0.5, mix: 0.5 }
    
    fn process(self, input: Float) -> Float:
        let delay_samples = (self.delay_time * SAMPLE_RATE) as Int
        let read_pos = (self.write_pos - delay_samples + self.buffer.len()) % self.buffer.len()
        
        let delayed = self.buffer[read_pos]
        self.buffer[self.write_pos] = input + delayed * self.feedback
        self.write_pos = (self.write_pos + 1) % self.buffer.len()
        
        return input * (1.0 - self.mix) + delayed * self.mix

struct Reverb:
    comb_filters: [CombFilter; 8]
    allpass_filters: [AllpassFilter; 4]
    mix: Float = 0.3
    
    fn new(room_size: Float, damping: Float) -> Reverb:
        # Comb filter delays (in samples, tuned for room size)
        let comb_delays = [1557, 1617, 1491, 1422, 1277, 1356, 1188, 1116]
        let allpass_delays = [225, 556, 441, 341]
        
        var combs: [CombFilter; 8] = []
        for i in range(0, 8):
            combs[i] = CombFilter.new(comb_delays[i], room_size, damping)
        
        var allpasses: [AllpassFilter; 4] = []
        for i in range(0, 4):
            allpasses[i] = AllpassFilter.new(allpass_delays[i])
        
        return Reverb { comb_filters: combs, allpass_filters: allpasses }
    
    fn process(self, input: Float) -> Float:
        # Parallel comb filters
        var output = 0.0
        for comb in self.comb_filters:
            output = output + comb.process(input)
        output = output / 8.0
        
        # Series allpass filters
        for allpass in self.allpass_filters:
            output = allpass.process(output)
        
        return input * (1.0 - self.mix) + output * self.mix

struct CombFilter:
    buffer: Array<Float>
    pos: Int = 0
    feedback: Float
    damp: Float
    filter_store: Float = 0.0
    
    fn new(delay: Int, feedback: Float, damp: Float) -> CombFilter:
        return CombFilter { buffer: Array.new(delay, 0.0), feedback: feedback, damp: damp }
    
    fn process(self, input: Float) -> Float:
        let output = self.buffer[self.pos]
        self.filter_store = output * (1.0 - self.damp) + self.filter_store * self.damp
        self.buffer[self.pos] = input + self.filter_store * self.feedback
        self.pos = (self.pos + 1) % self.buffer.len()
        return output

struct AllpassFilter:
    buffer: Array<Float>
    pos: Int = 0
    
    fn new(delay: Int) -> AllpassFilter:
        return AllpassFilter { buffer: Array.new(delay, 0.0) }
    
    fn process(self, input: Float) -> Float:
        let buffered = self.buffer[self.pos]
        let output = -input + buffered
        self.buffer[self.pos] = input + buffered * 0.5
        self.pos = (self.pos + 1) % self.buffer.len()
        return output

struct Distortion:
    drive: Float = 1.0
    mix: Float = 1.0
    
    fn process(self, input: Float) -> Float:
        let driven = input * self.drive
        let distorted = tanh(driven)
        return input * (1.0 - self.mix) + distorted * self.mix

struct Chorus:
    buffer: Array<Float>
    write_pos: Int = 0
    rate: Float = 1.5       # Hz
    depth: Float = 0.002    # seconds
    mix: Float = 0.5
    phase: Float = 0.0
    
    fn new() -> Chorus:
        return Chorus { buffer: Array.new(4410, 0.0) }  # 100ms buffer
    
    fn process(self, input: Float) -> Float:
        # LFO modulated delay
        let lfo = sin(self.phase) * self.depth * SAMPLE_RATE
        self.phase = (self.phase + TWO_PI * self.rate / SAMPLE_RATE) % TWO_PI
        
        let delay = 1000.0 + lfo  # Base delay + modulation
        let read_pos = (self.write_pos as Float - delay + self.buffer.len() as Float) % self.buffer.len() as Float
        
        # Linear interpolation for fractional delay
        let i0 = read_pos as Int
        let i1 = (i0 + 1) % self.buffer.len()
        let frac = read_pos - i0 as Float
        let delayed = self.buffer[i0] * (1.0 - frac) + self.buffer[i1] * frac
        
        self.buffer[self.write_pos] = input
        self.write_pos = (self.write_pos + 1) % self.buffer.len()
        
        return input * (1.0 - self.mix) + delayed * self.mix

# ==========================================
# MODULAR PATCHING SYSTEM
# ==========================================

struct ModularRack:
    modules: Map<String, Module>
    connections: Array<Connection>

struct Connection:
    source_module: String
    source_output: String
    dest_module: String
    dest_input: String
    amount: Float

trait Module:
    fn process(self, inputs: Map<String, Float>) -> Map<String, Float>
    fn get_inputs(self) -> Array<String>
    fn get_outputs(self) -> Array<String>

struct VCO:
    waveform: Int = 0  # 0=sine, 1=saw, 2=square, 3=triangle
    phase: Float = 0.0
    
    impl Module:
        fn process(self, inputs: Map<String, Float>) -> Map<String, Float>:
            let freq = inputs.get("freq").unwrap_or(440.0)
            let fm = inputs.get("fm").unwrap_or(0.0)
            let pw = inputs.get("pw").unwrap_or(0.5)
            
            let actual_freq = freq * pow(2.0, fm)
            
            let output = match self.waveform:
                0 => sin(self.phase)
                1 => 2.0 * (self.phase / TWO_PI) - 1.0
                2 => if self.phase / TWO_PI < pw: 1.0 else: -1.0
                3 => 4.0 * abs(self.phase / TWO_PI - 0.5) - 1.0
                _ => 0.0
            
            self.phase = (self.phase + TWO_PI * actual_freq / SAMPLE_RATE) % TWO_PI
            
            return { "out": output }
        
        fn get_inputs(self) -> Array<String>:
            return ["freq", "fm", "pw"]
        
        fn get_outputs(self) -> Array<String>:
            return ["out"]

struct VCF:
    filter: MoogFilter = MoogFilter { cutoff: 1000.0, resonance: 0.5 }
    
    impl Module:
        fn process(self, inputs: Map<String, Float>) -> Map<String, Float>:
            let input = inputs.get("in").unwrap_or(0.0)
            let cutoff = inputs.get("cutoff").unwrap_or(1000.0)
            let cv = inputs.get("cv").unwrap_or(0.0)
            let resonance = inputs.get("res").unwrap_or(0.5)
            
            self.filter.set_cutoff(cutoff * pow(2.0, cv))
            self.filter.set_resonance(resonance)
            
            let output = self.filter.process(input)
            return { "out": output }
        
        fn get_inputs(self) -> Array<String>:
            return ["in", "cutoff", "cv", "res"]
        
        fn get_outputs(self) -> Array<String>:
            return ["out"]

struct VCA:
    impl Module:
        fn process(self, inputs: Map<String, Float>) -> Map<String, Float>:
            let input = inputs.get("in").unwrap_or(0.0)
            let cv = inputs.get("cv").unwrap_or(1.0)
            return { "out": input * cv }
        
        fn get_inputs(self) -> Array<String>:
            return ["in", "cv"]
        
        fn get_outputs(self) -> Array<String>:
            return ["out"]

struct LFO:
    phase: Float = 0.0
    
    impl Module:
        fn process(self, inputs: Map<String, Float>) -> Map<String, Float>:
            let rate = inputs.get("rate").unwrap_or(1.0)
            
            let sine = sin(self.phase)
            let saw = 2.0 * (self.phase / TWO_PI) - 1.0
            let square = if self.phase < 3.14159: 1.0 else: -1.0
            let triangle = 4.0 * abs(self.phase / TWO_PI - 0.5) - 1.0
            
            self.phase = (self.phase + TWO_PI * rate / SAMPLE_RATE) % TWO_PI
            
            return { "sine": sine, "saw": saw, "square": square, "tri": triangle }
        
        fn get_inputs(self) -> Array<String>:
            return ["rate"]
        
        fn get_outputs(self) -> Array<String>:
            return ["sine", "saw", "square", "tri"]

struct EnvGen:
    env: ADSR = ADSR.new(0.01, 0.1, 0.7, 0.3)
    
    impl Module:
        fn process(self, inputs: Map<String, Float>) -> Map<String, Float>:
            let gate = inputs.get("gate").unwrap_or(0.0)
            
            # Detect gate on/off
            if gate > 0.5:
                if self.env.stage == EnvelopeStage.Idle or self.env.stage == EnvelopeStage.Release:
                    self.env.trigger()
            else:
                if self.env.stage != EnvelopeStage.Idle and self.env.stage != EnvelopeStage.Release:
                    self.env.release()
            
            return { "out": self.env.process() }
        
        fn get_inputs(self) -> Array<String>:
            return ["gate", "attack", "decay", "sustain", "release"]
        
        fn get_outputs(self) -> Array<String>:
            return ["out"]

impl ModularRack:
    fn add_module(self, name: String, module: dyn Module):
        self.modules.insert(name, module)
    
    fn connect(self, src_mod: String, src_out: String, dst_mod: String, dst_in: String, amount: Float = 1.0):
        self.connections.push(Connection {
            source_module: src_mod,
            source_output: src_out,
            dest_module: dst_mod,
            dest_input: dst_in,
            amount: amount
        })
    
    fn process(self) -> Float:
        var outputs: Map<String, Map<String, Float>> = Map.new()
        
        # Process in dependency order (simplified: assume connections are ordered)
        for (name, module) in self.modules:
            var inputs: Map<String, Float> = Map.new()
            
            # Gather inputs from connections
            for conn in self.connections:
                if conn.dest_module == name:
                    match outputs.get(conn.source_module):
                        Some(src_outputs) =>
                            match src_outputs.get(conn.source_output):
                                Some(value) =>
                                    let current = inputs.get(conn.dest_input).unwrap_or(0.0)
                                    inputs.insert(conn.dest_input, current + value * conn.amount)
                                None => ()
                        None => ()
            
            outputs.insert(name, module.process(inputs))
        
        # Return final output (assume "output" module exists)
        return outputs.get("output").unwrap().get("out").unwrap_or(0.0)

# ==========================================
# MIDI
# ==========================================

enum MidiMessage:
    NoteOn(channel: Int, note: Int, velocity: Int)
    NoteOff(channel: Int, note: Int)
    ControlChange(channel: Int, cc: Int, value: Int)
    PitchBend(channel: Int, value: Int)
    ProgramChange(channel: Int, program: Int)

fn midi_note_to_freq(note: Int) -> Float:
    return 440.0 * pow(2.0, (note - 69) as Float / 12.0)

actor MidiHandler:
    var note_states: [Bool; 128] = [false; 128]
    var velocities: [Float; 128] = [0.0; 128]
    var pitch_bend: Float = 0.0
    var mod_wheel: Float = 0.0
    
    on Message(msg: MidiMessage):
        match msg:
            NoteOn(ch, note, vel) if vel > 0 =>
                note_states[note] = true
                velocities[note] = vel as Float / 127.0
                send self.TriggerNote(note, velocities[note])
            
            NoteOn(ch, note, 0) | NoteOff(ch, note) =>
                note_states[note] = false
                send self.ReleaseNote(note)
            
            ControlChange(ch, 1, value) =>
                mod_wheel = value as Float / 127.0
            
            PitchBend(ch, value) =>
                pitch_bend = (value - 8192) as Float / 8192.0 * 2.0  # +/- 2 semitones
            
            _ => ()
    
    on GetActiveNotes() -> Array<(Int, Float)>:
        var active: Array<(Int, Float)> = []
        for i in range(0, 128):
            if note_states[i]:
                active.push((i, velocities[i]))
        return active

# ==========================================
# SYNTHESIZER
# ==========================================

actor Synthesizer with Audio:
    var voices: Array<Voice>
    var filter: MoogFilter
    var delay: Delay
    var reverb: Reverb
    var master_volume: Float = 0.8
    var midi: MidiHandler
    
    on Initialize():
        voices = Array.new(8, Voice.new())
        filter = MoogFilter { cutoff: 2000.0, resonance: 0.3 }
        delay = Delay.new(2.0)
        reverb = Reverb.new(0.8, 0.3)
        midi = spawn MidiHandler()
    
    on Process(buffer: AudioBuffer) -> AudioBuffer:
        for i in range(0, buffer.samples.len()):
            var sample = 0.0
            
            # Sum all active voices
            for voice in voices:
                sample = sample + voice.process()
            
            # Filter
            sample = filter.process(sample)
            
            # Effects
            sample = delay.process(sample)
            sample = reverb.process(sample)
            
            # Master volume
            sample = sample * master_volume
            
            buffer.samples[i] = clamp(sample, -1.0, 1.0)
        
        return buffer
    
    on NoteOn(note: Int, velocity: Float):
        # Find free voice or steal oldest
        var voice = find_free_voice(voices)
        voice.trigger(midi_note_to_freq(note), velocity)
    
    on NoteOff(note: Int):
        for voice in voices:
            if voice.note == note:
                voice.release()

struct Voice:
    osc1: SawOsc = SawOsc {}
    osc2: SquareOsc = SquareOsc { pulse_width: 0.5 }
    env: ADSR = ADSR.new(0.01, 0.2, 0.6, 0.5)
    filter_env: ADSR = ADSR.new(0.01, 0.3, 0.3, 0.2)
    filter: BiquadFilter
    
    frequency: Float = 440.0
    velocity: Float = 1.0
    note: Int = 60
    phase1: Float = 0.0
    phase2: Float = 0.0
    
    active: Bool = false
    
    fn trigger(self, freq: Float, vel: Float):
        self.frequency = freq
        self.velocity = vel
        self.active = true
        self.env.trigger()
        self.filter_env.trigger()
    
    fn release(self):
        self.env.release()
        self.filter_env.release()
    
    fn process(self) -> Float:
        if not self.active:
            return 0.0
        
        # Oscillators
        let osc1_out = self.osc1.generate(self.frequency, self.phase1)
        let osc2_out = self.osc2.generate(self.frequency * 1.005, self.phase2)  # Slight detune
        
        self.phase1 = self.osc1.next_phase(self.frequency, self.phase1)
        self.phase2 = self.osc2.next_phase(self.frequency * 1.005, self.phase2)
        
        # Mix oscillators
        var sample = (osc1_out + osc2_out * 0.7) / 1.7
        
        # Filter with envelope
        let filter_mod = self.filter_env.process() * 4000.0
        self.filter.set_cutoff(500.0 + filter_mod)
        sample = self.filter.process(sample)
        
        # Amplitude envelope
        let amp = self.env.process()
        sample = sample * amp * self.velocity
        
        if amp <= 0.0001:
            self.active = false
        
        return sample

# ==========================================
# MAIN
# ==========================================

fn main() with IO, Audio:
    println!("Initializing synthesizer...")
    
    let synth = spawn Synthesizer()
    send synth.Initialize()
    
    # Create a modular patch
    println!()
    println!("Building modular rack...")
    
    let rack = ModularRack { modules: Map.new(), connections: [] }
    
    rack.add_module("vco1", VCO { waveform: 1 })
    rack.add_module("vco2", VCO { waveform: 2 })
    rack.add_module("lfo", LFO {})
    rack.add_module("env", EnvGen {})
    rack.add_module("vcf", VCF {})
    rack.add_module("vca", VCA {})
    
    # Patch connections
    rack.connect("vco1", "out", "vcf", "in", 0.5)
    rack.connect("vco2", "out", "vcf", "in", 0.5)
    rack.connect("lfo", "sine", "vco2", "pw", 0.3)
    rack.connect("lfo", "tri", "vcf", "cv", 0.2)
    rack.connect("env", "out", "vca", "cv", 1.0)
    rack.connect("env", "out", "vcf", "cv", 0.5)
    rack.connect("vcf", "out", "vca", "in", 1.0)
    
    println!("Rack patched with 6 modules and 7 connections")
    
    # Start audio processing
    println!()
    println!("Starting audio engine...")
    println!()
    
    println!("Features demonstrated:")
    println!("  - Band-limited oscillators (polyBLEP)")
    println!("  - Biquad and Moog ladder filters")
    println!("  - ADSR envelopes")
    println!("  - Delay, reverb, distortion, chorus")
    println!("  - Modular patching system")
    println!("  - MIDI note/CC handling")
    println!("  - Polyphonic voice allocation")
    println!()
    println!("This is a complete synthesizer. In KORE.")
