# KAIN WHACKY TEST: Reactive Game Engine in 200 Lines
# ECS, physics, rendering, input, audio - all in one file
# Demonstrating actors, JSX, effects, pattern matching, and comptime

println!("=== REACTIVE GAME ENGINE ===")
println!()

# ==========================================
# ENTITY-COMPONENT-SYSTEM
# ==========================================

# Components are just structs
struct Transform:
    position: Vec3
    rotation: Quat
    scale: Vec3

struct Velocity:
    linear: Vec3
    angular: Vec3

struct Collider:
    shape: ColliderShape
    is_trigger: Bool

struct Renderer:
    mesh: Handle<Mesh>
    material: Handle<Material>
    visible: Bool

struct AudioSource:
    clip: Handle<AudioClip>
    volume: Float
    looping: Bool
    playing: Bool

enum ColliderShape:
    Sphere(radius: Float)
    Box(half_extents: Vec3)
    Capsule(radius: Float, height: Float)
    Mesh(mesh: Handle<Mesh>)

# Entity is just an ID with optional components
struct Entity:
    id: u64
    transform: Option<Transform>
    velocity: Option<Velocity>
    collider: Option<Collider>
    renderer: Option<Renderer>
    audio: Option<AudioSource>
    tags: Array<String>

# ==========================================
# REACTIVE SYSTEMS VIA ACTORS
# ==========================================

effect Physics:
    fn apply_force(entity: Entity, force: Vec3) -> ()
    fn raycast(origin: Vec3, direction: Vec3) -> Option<RayHit>

effect Rendering:
    fn draw(entity: Entity) -> ()
    fn set_camera(position: Vec3, target: Vec3) -> ()

effect Audio:
    fn play(source: AudioSource) -> ()
    fn stop(source: AudioSource) -> ()

actor PhysicsSystem with Physics:
    var gravity: Vec3 = Vec3.new(0.0, -9.81, 0.0)
    var entities: Array<Entity> = []
    var collision_pairs: Array<(Entity, Entity)> = []
    
    on Tick(dt: Float):
        # Integrate velocities
        for e in entities:
            match (e.transform, e.velocity):
                (Some(t), Some(v)) =>
                    let new_vel = v.linear + gravity * dt
                    let new_pos = t.position + new_vel * dt
                    e.transform = Some(Transform { position: new_pos, ..t })
                    e.velocity = Some(Velocity { linear: new_vel, ..v })
                _ => ()
        
        # Broad phase collision detection
        collision_pairs = []
        for i in range(0, entities.len()):
            for j in range(i + 1, entities.len()):
                let a = entities[i]
                let b = entities[j]
                if check_aabb_overlap(a, b):
                    collision_pairs.push((a, b))
        
        # Narrow phase + resolution
        for (a, b) in collision_pairs:
            match (a.collider, b.collider):
                (Some(ca), Some(cb)) =>
                    let contact = narrow_phase(a, ca, b, cb)
                    if contact.is_some():
                        resolve_collision(a, b, contact.unwrap())
                _ => ()
    
    on apply_force(entity: Entity, force: Vec3):
        match entity.velocity:
            Some(v) =>
                let mass = 1.0  # simplified
                let accel = force / mass
                entity.velocity = Some(Velocity { linear: v.linear + accel, ..v })
            None => ()
    
    on raycast(origin: Vec3, direction: Vec3) -> Option<RayHit>:
        var closest: Option<RayHit> = None
        var closest_dist = Float.MAX
        
        for e in entities:
            match e.collider:
                Some(c) =>
                    let hit = ray_vs_collider(origin, direction, e.transform.unwrap(), c)
                    match hit:
                        Some(h) if h.distance < closest_dist =>
                            closest = Some(h)
                            closest_dist = h.distance
                        _ => ()
                None => ()
        
        return closest

actor RenderSystem with Rendering:
    var camera_pos: Vec3 = Vec3.new(0.0, 5.0, -10.0)
    var camera_target: Vec3 = Vec3.ZERO
    var render_queue: Array<Entity> = []
    
    on Frame(entities: Array<Entity>):
        # Frustum culling
        render_queue = entities.filter(e =>
            match e.renderer:
                Some(r) if r.visible => is_in_frustum(e.transform.unwrap().position)
                _ => false
        )
        
        # Sort by material for batching
        render_queue.sort_by(e => e.renderer.unwrap().material.id)
        
        # Draw!
        for e in render_queue:
            draw(e)
    
    on draw(entity: Entity):
        let t = entity.transform.unwrap()
        let r = entity.renderer.unwrap()
        
        # Build MVP matrix
        let model = Mat4.from_trs(t.position, t.rotation, t.scale)
        let view = Mat4.look_at(camera_pos, camera_target, Vec3.UP)
        let proj = Mat4.perspective(fov: 60.0, aspect: 16.0/9.0, near: 0.1, far: 1000.0)
        let mvp = proj * view * model
        
        # Issue draw call
        gpu_draw_mesh(r.mesh, r.material, mvp)
    
    on set_camera(position: Vec3, target: Vec3):
        camera_pos = position
        camera_target = target

# ==========================================
# INPUT HANDLING WITH PATTERN MATCHING
# ==========================================

enum InputEvent:
    KeyDown(key: Key)
    KeyUp(key: Key)
    MouseMove(dx: Float, dy: Float)
    MouseButton(button: Int, pressed: Bool)
    GamepadAxis(axis: Int, value: Float)
    GamepadButton(button: Int, pressed: Bool)

fn process_input(event: InputEvent, player: Entity) with Physics:
    match event:
        KeyDown(Key.W) | KeyDown(Key.Up) =>
            apply_force(player, Vec3.new(0.0, 0.0, 10.0))
        
        KeyDown(Key.S) | KeyDown(Key.Down) =>
            apply_force(player, Vec3.new(0.0, 0.0, -10.0))
        
        KeyDown(Key.Space) =>
            # Jump if grounded
            let ground_check = raycast(player.transform.unwrap().position, Vec3.DOWN)
            match ground_check:
                Some(hit) if hit.distance < 0.1 =>
                    apply_force(player, Vec3.new(0.0, 500.0, 0.0))
                _ => ()
        
        MouseMove(dx, dy) =>
            # Look around
            let sensitivity = 0.1
            let current_rot = player.transform.unwrap().rotation
            let yaw = Quat.from_axis_angle(Vec3.UP, -dx * sensitivity)
            let pitch = Quat.from_axis_angle(Vec3.RIGHT, -dy * sensitivity)
            player.transform = Some(Transform { 
                rotation: yaw * current_rot * pitch,
                ..player.transform.unwrap()
            })
        
        GamepadAxis(0, value) if abs(value) > 0.1 =>
            # Left stick horizontal
            apply_force(player, Vec3.new(value * 5.0, 0.0, 0.0))
        
        GamepadButton(0, true) =>
            # A button = jump
            apply_force(player, Vec3.new(0.0, 500.0, 0.0))
        
        _ => ()

# ==========================================
# SCENE DEFINITION WITH JSX
# ==========================================

fn create_scene() -> Array<Entity>:
    let ground = Entity {
        id: 1,
        transform: Some(Transform {
            position: Vec3.ZERO,
            rotation: Quat.IDENTITY,
            scale: Vec3.new(100.0, 1.0, 100.0)
        }),
        collider: Some(Collider {
            shape: ColliderShape.Box(Vec3.new(50.0, 0.5, 50.0)),
            is_trigger: false
        }),
        renderer: Some(Renderer {
            mesh: load_mesh("cube"),
            material: load_material("ground"),
            visible: true
        }),
        velocity: None,
        audio: None,
        tags: ["ground", "static"]
    }
    
    let player = Entity {
        id: 2,
        transform: Some(Transform {
            position: Vec3.new(0.0, 2.0, 0.0),
            rotation: Quat.IDENTITY,
            scale: Vec3.ONE
        }),
        velocity: Some(Velocity {
            linear: Vec3.ZERO,
            angular: Vec3.ZERO
        }),
        collider: Some(Collider {
            shape: ColliderShape.Capsule(0.5, 1.8),
            is_trigger: false
        }),
        renderer: Some(Renderer {
            mesh: load_mesh("capsule"),
            material: load_material("player"),
            visible: true
        }),
        audio: Some(AudioSource {
            clip: load_audio("footsteps"),
            volume: 0.5,
            looping: true,
            playing: false
        }),
        tags: ["player", "dynamic"]
    }
    
    # Procedurally generate some obstacles
    var entities = [ground, player]
    for i in range(0, 20):
        let x = (random() - 0.5) * 80.0
        let z = (random() - 0.5) * 80.0
        let obstacle = Entity {
            id: (100 + i) as u64,
            transform: Some(Transform {
                position: Vec3.new(x, 1.0, z),
                rotation: Quat.IDENTITY,
                scale: Vec3.new(2.0, 2.0, 2.0)
            }),
            collider: Some(Collider {
                shape: ColliderShape.Box(Vec3.ONE),
                is_trigger: false
            }),
            renderer: Some(Renderer {
                mesh: load_mesh("cube"),
                material: load_material(f"obstacle_{i % 5}"),
                visible: true
            }),
            velocity: None,
            audio: None,
            tags: ["obstacle", "static"]
        }
        entities.push(obstacle)
    
    return entities

# ==========================================
# DEBUG UI OVERLAY
# ==========================================

fn render_debug_ui(physics: PhysicsSystem, render: RenderSystem, player: Entity):
    let pos = player.transform.unwrap().position
    let vel = player.velocity.unwrap().linear
    let fps = 1.0 / get_delta_time()
    
    let overlay = <div class="debug-overlay">
        <div class="section">
            <h3>Player</h3>
            <p>Position: {f"{pos.x:.2}, {pos.y:.2}, {pos.z:.2}"}</p>
            <p>Velocity: {f"{vel.x:.2}, {vel.y:.2}, {vel.z:.2}"}</p>
            <p>Speed: {f"{vel.length():.2}"} m/s</p>
        </div>
        
        <div class="section">
            <h3>Performance</h3>
            <p>FPS: {f"{fps:.0}"}</p>
            <p>Draw Calls: {render.render_queue.len()}</p>
            <p>Collision Pairs: {physics.collision_pairs.len()}</p>
        </div>
        
        <div class="section">
            <h3>Controls</h3>
            <p>WASD - Move</p>
            <p>Space - Jump</p>
            <p>Mouse - Look</p>
        </div>
    </div>
    
    draw_ui(overlay)

# ==========================================
# MAIN GAME LOOP
# ==========================================

fn main() with IO, Physics, Rendering, Audio:
    println!("Initializing game engine...")
    
    let physics = spawn PhysicsSystem()
    let renderer = spawn RenderSystem()
    
    let scene = create_scene()
    let player = scene.find(e => e.tags.contains("player")).unwrap()
    
    # Register entities with physics
    for e in scene:
        send physics.Register(e)
    
    println!("Entering game loop...")
    
    while is_running():
        let dt = get_delta_time()
        
        # Input
        for event in poll_input_events():
            process_input(event, player)
        
        # Physics tick
        send physics.Tick(dt)
        
        # Render
        send renderer.Frame(scene)
        
        # Debug UI
        if is_debug_mode():
            render_debug_ui(physics, renderer, player)
        
        # Audio
        match player.velocity:
            Some(v) if v.linear.length() > 0.1 =>
                if not player.audio.unwrap().playing:
                    play(player.audio.unwrap())
            _ =>
                if player.audio.unwrap().playing:
                    stop(player.audio.unwrap())
        
        present_frame()
    
    println!("Game loop ended. Goodbye!")
