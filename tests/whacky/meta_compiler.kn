# KAIN WHACKY TEST: Self-Modifying Compiler Pipeline
# This file demonstrates a compiler that rewrites itself at runtime
# using comptime, macros, and the effect system. Pure insanity.

println!("=== SELF-MODIFYING COMPILER PIPELINE ===")
println!()

# ==========================================
# COMPTIME CODE GENERATION
# ==========================================

# Generate an entire parser at compile time based on a grammar DSL
comptime:
    let grammar = """
        expr    := term (('+' | '-') term)*
        term    := factor (('*' | '/') factor)*
        factor  := NUMBER | '(' expr ')'
        NUMBER  := [0-9]+
    """
    
    # Parse the grammar and generate a recursive descent parser
    fn generate_parser(grammar: String) -> String:
        var code = "fn parse_expr(tokens: Array<Token>) -> Ast:\n"
        for line in grammar.lines():
            let parts = line.split(":=")
            if parts.len() >= 2:
                let rule_name = parts[0].trim()
                let rule_body = parts[1].trim()
                code = code + f"    # Rule: {rule_name}\n"
        code = code + "    return Ast.Expr(tokens)\n"
        return code
    
    let parser_code = generate_parser(grammar)
    emit_code(parser_code)

# ==========================================
# EFFECT-TYPED STATE MACHINE
# ==========================================

effect FSM<State>:
    fn transition(from: State, to: State) -> ()
    fn current_state() -> State

enum CompilerPhase:
    Lexing
    Parsing
    TypeChecking
    Optimization
    CodeGen
    Linking
    Done

actor CompilerStateMachine with FSM<CompilerPhase>:
    var phase: CompilerPhase = CompilerPhase.Lexing
    var error_count: Int = 0
    var warnings: Array<String> = []
    
    on transition(from: CompilerPhase, to: CompilerPhase):
        println!(f"[PHASE] {from} -> {to}")
        phase = to
        
    on current_state() -> CompilerPhase:
        return phase
    
    on ReportError(msg: String):
        error_count = error_count + 1
        println!(f"[ERROR #{error_count}] {msg}")
        
    on ReportWarning(msg: String):
        warnings.push(msg)
        println!(f"[WARN] {msg}")
    
    on GetStats() -> (Int, Int):
        return (error_count, warnings.len())

# ==========================================
# HYGIENIC MACRO SYSTEM
# ==========================================

macro define_optimizer(name, pattern, replacement):
    fn `optimize_{name}`(ast: Ast) -> Ast:
        match ast:
            `pattern` => `replacement`
            other => other.map_children(optimize_{name})

# Dead code elimination
define_optimizer!(dce,
    If(Literal(false), _, else_branch) => else_branch,
    If(Literal(true), then_branch, _) => then_branch)

# Constant folding
define_optimizer!(const_fold,
    BinaryOp(Literal(a), "+", Literal(b)) => Literal(a + b),
    BinaryOp(Literal(a), "*", Literal(b)) => Literal(a * b),
    BinaryOp(Literal(a), "-", Literal(b)) => Literal(a - b))

# Strength reduction
define_optimizer!(strength_reduce,
    BinaryOp(x, "*", Literal(2)) => BinaryOp(x, "+", x),
    BinaryOp(x, "*", Literal(0)) => Literal(0),
    BinaryOp(x, "+", Literal(0)) => x)

# ==========================================
# MULTI-TARGET CODE GENERATION
# ==========================================

trait CodeEmitter<Target>:
    fn emit_function(name: String, params: Array<Param>, body: Ast) -> Target
    fn emit_call(target: String, args: Array<Ast>) -> Target
    fn finalize() -> Target

struct LLVMEmitter:
    var ir: String = ""
    var label_counter: Int = 0
    
    impl CodeEmitter<String>:
        fn emit_function(name: String, params: Array<Param>, body: Ast) -> String:
            let param_str = params.map(p => f"{p.ty} %{p.name}").join(", ")
            ir = ir + f"define i64 @{name}({param_str}) {{\n"
            ir = ir + emit_body(body)
            ir = ir + "}\n\n"
            return ir
            
        fn emit_call(target: String, args: Array<Ast>) -> String:
            let args_str = args.map(a => emit_value(a)).join(", ")
            let result = fresh_register()
            return f"  {result} = call i64 @{target}({args_str})\n"
            
        fn finalize() -> String:
            return ir

struct WASMEmitter:
    var bytes: Array<u8> = []
    
    impl CodeEmitter<Array<u8>>:
        fn emit_function(name: String, params: Array<Param>, body: Ast) -> Array<u8>:
            bytes.push(0x60)  # func type
            bytes.push(params.len() as u8)
            for p in params:
                bytes.push(0x7F)  # i32
            bytes.push(0x01)  # one return
            bytes.push(0x7F)  # i32
            return bytes
            
        fn emit_call(target: String, args: Array<Ast>) -> Array<u8>:
            bytes.push(0x10)  # call instruction
            return bytes
            
        fn finalize() -> Array<u8>:
            return bytes

struct SPIRVEmitter:
    var words: Array<u32> = []
    var id_counter: u32 = 1
    
    impl CodeEmitter<Array<u32>>:
        fn emit_function(name: String, params: Array<Param>, body: Ast) -> Array<u32>:
            let func_id = next_id()
            let type_id = next_id()
            # OpFunction
            words.extend([0x00050036, type_id, func_id, 0x00000000, type_id])
            return words
            
        fn emit_call(target: String, args: Array<Ast>) -> Array<u32>:
            # OpFunctionCall
            let result_id = next_id()
            words.extend([0x00050039, result_id])
            return words
            
        fn finalize() -> Array<u32>:
            return words

# ==========================================
# THE ACTUAL PIPELINE
# ==========================================

fn compile_source(source: String, target: String) -> Result<Array<u8>, String> with IO, FSM<CompilerPhase>:
    let machine = spawn CompilerStateMachine()
    
    # Phase 1: Lexing
    send machine.transition(CompilerPhase.Lexing, CompilerPhase.Parsing)
    let tokens = lex(source)?
    
    # Phase 2: Parsing  
    send machine.transition(CompilerPhase.Parsing, CompilerPhase.TypeChecking)
    let ast = parse(tokens)?
    
    # Phase 3: Type Checking
    send machine.transition(CompilerPhase.TypeChecking, CompilerPhase.Optimization)
    let typed_ast = typecheck(ast)?
    
    # Phase 4: Optimization (apply our comptime-generated optimizers)
    send machine.transition(CompilerPhase.Optimization, CompilerPhase.CodeGen)
    var optimized = typed_ast
    optimized = optimize_dce(optimized)
    optimized = optimize_const_fold(optimized)
    optimized = optimize_strength_reduce(optimized)
    
    # Phase 5: Code Generation (polymorphic over target)
    send machine.transition(CompilerPhase.CodeGen, CompilerPhase.Linking)
    let output = match target:
        "llvm" => 
            let emitter = LLVMEmitter{}
            emit_program(emitter, optimized)
        "wasm" =>
            let emitter = WASMEmitter{}
            emit_program(emitter, optimized)
        "spirv" =>
            let emitter = SPIRVEmitter{}
            emit_program(emitter, optimized)
        _ => return Err(f"Unknown target: {target}")
    
    # Phase 6: Done
    send machine.transition(CompilerPhase.Linking, CompilerPhase.Done)
    
    let (errors, warns) = await machine.GetStats()
    println!(f"Compilation complete: {errors} errors, {warns} warnings")
    
    return Ok(output)

# ==========================================
# SELF-HOSTING FLEX: COMPILE THIS FILE
# ==========================================

fn main() with IO:
    println!("Demonstrating the self-modifying compiler pipeline...")
    println!()
    
    let kain_source = read_file("tests/whacky/meta_compiler.kn")?
    
    # Compile to LLVM
    println!("[LLVM TARGET]")
    let llvm_output = compile_source(kain_source, "llvm")?
    println!(f"Generated {llvm_output.len()} bytes of LLVM IR")
    
    # Compile to WASM
    println!()
    println!("[WASM TARGET]")
    let wasm_output = compile_source(kain_source, "wasm")?
    println!(f"Generated {wasm_output.len()} bytes of WASM")
    
    # Compile to SPIR-V
    println!()
    println!("[SPIRV TARGET]")
    let spirv_output = compile_source(kain_source, "spirv")?
    println!(f"Generated {spirv_output.len()} words of SPIR-V")
    
    println!()
    println!("A compiler that compiles itself to 3 different targets.")
    println!("That's KAIN.")
