// =============================================================================
// KAIN → Rust Transpiler Test
// =============================================================================
// This tests the core RustGen code generation WITHOUT needing the lexer/parser.
// We manually construct AST nodes and generate Rust code from them.
// =============================================================================

// Simple StringBuilder implementation
struct StringBuilder:
    lines: Array<String>

impl StringBuilder:
    pub fn new() -> StringBuilder:
        return StringBuilder { lines: [] }
    
    pub fn push(self, text: String) -> Unit:
        // For simplicity, we'll just accumulate in lines
        push(self.lines, text)
    
    pub fn push_line(self, text: String) -> Unit:
        push(self.lines, text + "\n")
    
    pub fn build(self) -> String:
        return join(self.lines, "")

// =============================================================================
// Code Generator Core
// =============================================================================

struct RustGen:
    output: StringBuilder
    indent: Int

impl RustGen:
    pub fn new() -> RustGen:
        return RustGen {
            output: StringBuilder::new(),
            indent: 0
        }
    
    fn push_indent(self) -> Unit:
        self.indent = self.indent + 1
    
    fn pop_indent(self) -> Unit:
        if self.indent > 0:
            self.indent = self.indent - 1
    
    fn indent_str(self) -> String:
        let s = ""
        for i in range(0, self.indent):
            s = s + "    "
        return s
    
    fn write_line(self, line: String) -> Unit:
        self.output.push(self.indent_str())
        self.output.push_line(line)
    
    fn write_blank(self) -> Unit:
        self.output.push_line("")
    
    pub fn build(self) -> String:
        return self.output.build()

    // =========================================================================
    // Generate a simple function
    // =========================================================================
    pub fn gen_simple_fn(self, name: String, params: String, ret_type: String, body: String) -> Unit:
        self.write_line("fn " + name + "(" + params + ") -> " + ret_type + " {")
        self.push_indent()
        self.write_line(body)
        self.pop_indent()
        self.write_line("}")

    // =========================================================================
    // Generate a struct
    // =========================================================================
    pub fn gen_struct(self, name: String, fields: Array<String>) -> Unit:
        self.write_line("#[derive(Debug, Clone)]")
        self.write_line("pub struct " + name + " {")
        self.push_indent()
        for field in fields:
            self.write_line("pub " + field + ",")
        self.pop_indent()
        self.write_line("}")

    // =========================================================================
    // Generate an impl block
    // =========================================================================
    pub fn gen_impl_start(self, name: String) -> Unit:
        self.write_line("impl " + name + " {")
        self.push_indent()
    
    pub fn gen_impl_end(self) -> Unit:
        self.pop_indent()
        self.write_line("}")

    // =========================================================================
    // Generate header
    // =========================================================================
    pub fn gen_header(self) -> Unit:
        self.write_line("// Generated by KAIN Compiler (Project Ouroboros)")
        self.write_line("// Do not edit - regenerate from .kn source")
        self.write_blank()
        self.write_line("#![allow(unused_variables)]")
        self.write_line("#![allow(unused_mut)]")
        self.write_line("#![allow(dead_code)]")
        self.write_blank()
        self.write_line("use std::collections::HashMap;")
        self.write_blank()

// =============================================================================
// Test the Generator
// =============================================================================

fn main():
    println("=== KAIN → Rust Code Generation Test ===")
    println("")
    
    let gen = RustGen::new()
    
    // Generate header
    gen.gen_header()
    
    // Generate a struct
    gen.gen_struct("Token", ["kind: TokenKind", "lexeme: String", "line: i64"])
    gen.write_blank()
    
    // Generate an enum (manual for now)
    gen.write_line("#[derive(Debug, Clone, PartialEq)]")
    gen.write_line("pub enum TokenKind {")
    gen.push_indent()
    gen.write_line("Ident(String),")
    gen.write_line("Int(i64),")
    gen.write_line("String(String),")
    gen.write_line("Plus,")
    gen.write_line("Minus,")
    gen.pop_indent()
    gen.write_line("}")
    gen.write_blank()
    
    // Generate a function
    gen.gen_simple_fn("add", "a: i64, b: i64", "i64", "a + b")
    gen.write_blank()
    
    // Generate impl block
    gen.gen_impl_start("Token")
    gen.gen_simple_fn("new", "kind: TokenKind, lexeme: String", "Self", "Self { kind, lexeme, line: 0 }")
    gen.gen_impl_end()
    gen.write_blank()
    
    // Generate main
    gen.write_line("fn main() {")
    gen.push_indent()
    gen.write_line("let x = add(1, 2);")
    gen.write_line("println!(\"{}\", x);")
    gen.pop_indent()
    gen.write_line("}")
    
    // Output the generated Rust
    let rust_code = gen.build()
    
    println("Generated Rust Code:")
    println("====================")
    println(rust_code)
    println("====================")
    println("")
    println(" Code generation test complete!")
    println("This Rust code could be written to a .rs file and compiled with rustc.")
