// Test 10: Impl blocks and methods
struct Counter:
    value: Int
    step: Int

impl Counter:
    pub fn new(start: Int) -> Counter:
        return Counter { value: start, step: 1 }
    
    pub fn with_step(start: Int, step: Int) -> Counter:
        return Counter { value: start, step: step }
    
    pub fn increment(self) -> Unit:
        self.value = self.value + self.step
    
    pub fn decrement(self) -> Unit:
        self.value = self.value - self.step
    
    pub fn get(self) -> Int:
        return self.value
    
    pub fn reset(self) -> Unit:
        self.value = 0

struct Vector2:
    x: Float
    y: Float

impl Vector2:
    pub fn new(x: Float, y: Float) -> Vector2:
        return Vector2 { x: x, y: y }
    
    pub fn add(self, other: Vector2) -> Vector2:
        return Vector2 { x: self.x + other.x, y: self.y + other.y }
    
    pub fn scale(self, factor: Float) -> Vector2:
        return Vector2 { x: self.x * factor, y: self.y * factor }

fn main():
    // Counter usage
    let counter = Counter::new(0)
    println("Initial: " + str(counter.get()))
    
    counter.increment()
    counter.increment()
    counter.increment()
    println("After 3 increments: " + str(counter.get()))
    
    counter.decrement()
    println("After decrement: " + str(counter.get()))
    
    // Counter with custom step
    let by_five = Counter::with_step(0, 5)
    by_five.increment()
    by_five.increment()
    println("Count by 5 (2x): " + str(by_five.get()))
