// ============================================================================
// KORE Bootstrap Compiler - Rust Code Generator
// ============================================================================
// Hand-translated from codegen_rust.kr for Project Ouroboros bootstrap
// This transpiles Kore AST to Rust source code.
// ============================================================================

use crate::compiler::parser::{
    Program, Item, FnDef, Param, StructDef, Field, EnumDef, Variant, ImplDef,
    Stmt, MatchArm, Pattern, Expr, FieldInit, ExternFnDef
};

// =============================================================================
// StringBuilder - Simple string accumulator
// =============================================================================

pub struct StringBuilder {
    lines: Vec<String>,
}

impl StringBuilder {
    pub fn new() -> StringBuilder {
        StringBuilder { lines: Vec::new() }
    }
    
    pub fn push(&mut self, text: &str) {
        self.lines.push(text.to_string());
    }
    
    pub fn push_line(&mut self, text: &str) {
        self.lines.push(format!("{}\n", text));
    }
    
    pub fn build(&self) -> String {
        self.lines.join("")
    }
}

// =============================================================================
// Rust Code Generator
// =============================================================================

pub struct RustGen {
    output: StringBuilder,
    indent: usize,
    use_statements: Vec<String>,
    struct_impls: StringBuilder,
}

impl RustGen {
    pub fn new() -> RustGen {
        RustGen {
            output: StringBuilder::new(),
            indent: 0,
            use_statements: Vec::new(),
            struct_impls: StringBuilder::new(),
        }
    }
    
    /// Increase indentation
    fn push_indent(&mut self) {
        self.indent += 1;
    }
    
    /// Decrease indentation
    fn pop_indent(&mut self) {
        if self.indent > 0 {
            self.indent -= 1;
        }
    }
    
    /// Get current indent string
    fn indent_str(&self) -> String {
        "    ".repeat(self.indent)
    }
    
    /// Emit a line with current indentation
    fn write_line(&mut self, line: &str) {
        let indented = format!("{}{}", self.indent_str(), line);
        self.output.push_line(&indented);
    }
    
    /// Emit raw text (no indent, no newline)
    fn write_raw(&mut self, text: &str) {
        self.output.push(text);
    }
    
    /// Emit a blank line
    fn write_blank(&mut self) {
        self.output.push_line("");
    }
    
    // =========================================================================
    // Program Generation
    // =========================================================================
    
    /// Generate Rust code for an entire program
    pub fn gen_program(&mut self, program: Program) -> String {
        // Header
        self.write_line("// Generated by KORE Compiler (Project Ouroboros)");
        self.write_line("// Do not edit - regenerate from .kr source");
        self.write_blank();
        self.write_line("#![allow(unused_variables)]");
        self.write_line("#![allow(unused_mut)]");
        self.write_line("#![allow(dead_code)]");
        self.write_line("#![allow(unused_parens)]");
        self.write_blank();
        
        // Standard imports
        self.write_line("use std::collections::HashMap;");
        self.write_line("use std::rc::Rc;");
        self.write_line("use std::cell::RefCell;");
        self.write_blank();
        
        // Generate each item
        for item in program.items {
            self.gen_item(item);
            self.write_blank();
        }
        
        // Emit collected impl blocks
        let impls = self.struct_impls.build();
        if !impls.is_empty() {
            self.output.push(&impls);
        }
        
        self.output.build()
    }
    
    // =========================================================================
    // Item Generation
    // =========================================================================
    
    fn gen_item(&mut self, item: Item) {
        match item {
            Item::Function(fn_def) => self.gen_function(fn_def),
            Item::Struct(struct_def) => self.gen_struct(struct_def),
            Item::Enum(enum_def) => self.gen_enum(enum_def),
            Item::Impl(impl_def) => self.gen_impl(impl_def),
            Item::Use(path) => self.gen_use(&path),
            Item::Extern(def) => self.gen_extern(def),
        }
    }
    
    fn gen_extern(&mut self, def: ExternFnDef) {
        self.write_line("extern \"C\" {");
        self.push_indent();
        
        let params: Vec<String> = def.params.iter().map(|param| {
            let ty = param.ty.as_ref()
                .map(|t| self.map_type(t))
                .unwrap_or_else(|| "i64".to_string());
            format!("{}: {}", param.name, ty)
        }).collect();
        let params_str = params.join(", ");
        
        let ret = if let Some(ty) = &def.return_type {
            format!(" -> {}", self.map_type(ty))
        } else {
            "".to_string()
        };
        
        self.write_line(&format!("fn {}({}){};", def.name, params_str, ret));
        
        self.pop_indent();
        self.write_line("}");
    }
    
    /// Generate a function definition
    fn gen_function(&mut self, fn_def: FnDef) {
        // Visibility
        let vis = if fn_def.is_pub { "pub " } else { "" };
        
        // Async modifier
        let async_mod = if fn_def.is_async { "async " } else { "" };
        
        // Parameters
        let params = self.gen_params(&fn_def.params);
        
        // Return type
        let ret = if let Some(ty) = &fn_def.return_type {
            format!(" -> {}", self.map_type(ty))
        } else if fn_def.name != "main" {
            String::new()
        } else {
            String::new()
        };
        
        // Function signature
        self.write_line(&format!("{}{}fn {}({}){}  {{", vis, async_mod, fn_def.name, params, ret));
        self.push_indent();
        
        // Body
        for stmt in fn_def.body {
            self.gen_stmt(stmt);
        }
        
        self.pop_indent();
        self.write_line("}");
    }
    
    /// Generate function parameters
    fn gen_params(&self, params: &[Param]) -> String {
        let parts: Vec<String> = params.iter().map(|param| {
            let ty = param.ty.as_ref()
                .map(|t| self.map_type(t))
                .unwrap_or_else(|| "i64".to_string());
            format!("{}: {}", param.name, ty)
        }).collect();
        parts.join(", ")
    }
    
    /// Generate a struct definition
    fn gen_struct(&mut self, struct_def: StructDef) {
        let vis = if struct_def.is_pub { "pub " } else { "" };
        
        self.write_line("#[derive(Debug, Clone)]");
        self.write_line(&format!("{}struct {} {{", vis, struct_def.name));
        self.push_indent();
        
        for field in struct_def.fields {
            self.write_line(&format!("pub {}: {},", field.name, self.map_type(&field.ty)));
        }
        
        self.pop_indent();
        self.write_line("}");
    }
    
    /// Generate an enum definition
    fn gen_enum(&mut self, enum_def: EnumDef) {
        self.write_line("#[derive(Debug, Clone, PartialEq)]");
        self.write_line(&format!("pub enum {} {{", enum_def.name));
        self.push_indent();
        
        for variant in enum_def.variants {
            if variant.fields.is_empty() {
                self.write_line(&format!("{},", variant.name));
            } else {
                let fields: Vec<String> = variant.fields.iter()
                    .map(|f| self.map_type(f))
                    .collect();
                self.write_line(&format!("{}({}),", variant.name, fields.join(", ")));
            }
        }
        
        self.pop_indent();
        self.write_line("}");
    }
    
    /// Generate an impl block
    fn gen_impl(&mut self, impl_def: ImplDef) {
        self.write_line(&format!("impl {} {{", impl_def.target));
        self.push_indent();
        
        for method in impl_def.methods {
            // Generate method parameters
            let mut params: Vec<String> = vec!["&self".to_string()];
            for param in &method.params {
                if param.name == "self" {
                    continue;
                }
                let ty = param.ty.as_ref()
                    .map(|t| self.map_type(t))
                    .unwrap_or_else(|| "i64".to_string());
                params.push(format!("{}: {}", param.name, ty));
            }
            
            let params_str = params.join(", ");
            let ret = method.return_type.as_ref()
                .map(|ty| format!(" -> {}", self.map_type(ty)))
                .unwrap_or_default();
            
            let vis = if method.is_pub { "pub " } else { "" };
            
            self.write_line(&format!("{}fn {}({}){}  {{", vis, method.name, params_str, ret));
            self.push_indent();
            
            for stmt in method.body {
                self.gen_stmt(stmt);
            }
            
            self.pop_indent();
            self.write_line("}");
            self.write_blank();
        }
        
        self.pop_indent();
        self.write_line("}");
    }
    
    /// Generate a use statement
    fn gen_use(&mut self, path: &str) {
        let rust_path = path.replace("/", "::");
        self.write_line(&format!("use {};", rust_path));
    }
    
    // =========================================================================
    // Statement Generation
    // =========================================================================
    
    fn gen_stmt(&mut self, stmt: Stmt) {
        match stmt {
            Stmt::Let(name, ty, value) => {
                let ty_str = ty.as_ref()
                    .map(|t| format!(": {}", self.map_type(t)))
                    .unwrap_or_default();
                self.write_line(&format!("let {}{} = {};", name, ty_str, self.gen_expr(value)));
            }
            
            Stmt::Var(name, ty, value) => {
                let ty_str = ty.as_ref()
                    .map(|t| format!(": {}", self.map_type(t)))
                    .unwrap_or_default();
                self.write_line(&format!("let mut {}{} = {};", name, ty_str, self.gen_expr(value)));
            }
            
            Stmt::Assign(lhs, rhs) => {
                self.write_line(&format!("{} = {};", self.gen_expr(lhs), self.gen_expr(rhs)));
            }
            
            Stmt::Return(maybe_expr) => {
                if let Some(expr) = maybe_expr {
                    self.write_line(&format!("return {};", self.gen_expr(expr)));
                } else {
                    self.write_line("return;");
                }
            }
            
            Stmt::If(cond, then_block, else_block) => {
                self.write_line(&format!("if {} {{", self.gen_expr(cond)));
                self.push_indent();
                for s in then_block {
                    self.gen_stmt(s);
                }
                self.pop_indent();
                if let Some(else_stmts) = else_block {
                    self.write_line("} else {");
                    self.push_indent();
                    for s in else_stmts {
                        self.gen_stmt(s);
                    }
                    self.pop_indent();
                    self.write_line("}");
                } else {
                    self.write_line("}");
                }
            }
            
            Stmt::While(cond, body) => {
                self.write_line(&format!("while {} {{", self.gen_expr(cond)));
                self.push_indent();
                for s in body {
                    self.gen_stmt(s);
                }
                self.pop_indent();
                self.write_line("}");
            }
            
            Stmt::For(var_name, iter, body) => {
                self.write_line(&format!("for {} in {} {{", var_name, self.gen_expr(iter)));
                self.push_indent();
                for s in body {
                    self.gen_stmt(s);
                }
                self.pop_indent();
                self.write_line("}");
            }
            
            Stmt::Loop(body) => {
                self.write_line("loop {");
                self.push_indent();
                for s in body {
                    self.gen_stmt(s);
                }
                self.pop_indent();
                self.write_line("}");
            }
            
            Stmt::Match(scrutinee, arms) => {
                self.write_line(&format!("match {} {{", self.gen_expr(scrutinee)));
                self.push_indent();
                for arm in arms {
                    let pat = self.gen_pattern(&arm.pattern);
                    self.write_line(&format!("{} => {{", pat));
                    self.push_indent();
                    for s in arm.body {
                        self.gen_stmt(s);
                    }
                    self.pop_indent();
                    self.write_line("}");
                }
                self.pop_indent();
                self.write_line("}");
            }
            
            Stmt::Expr(expr) => {
                self.write_line(&format!("{};", self.gen_expr(expr)));
            }
            
            Stmt::Break => {
                self.write_line("break;");
            }
            
            Stmt::Continue => {
                self.write_line("continue;");
            }
        }
    }
    
    // =========================================================================
    // Expression Generation
    // =========================================================================
    
    fn gen_expr(&self, expr: Expr) -> String {
        match expr {
            Expr::Int(n) => n.to_string(),
            
            Expr::Float(f) => f.to_string(),
            
            Expr::String(s) => format!("\"{}\".to_string()", self.escape_string(&s)),
            
            Expr::Bool(b) => if b { "true".to_string() } else { "false".to_string() },
            
            Expr::None => "None".to_string(),
            
            Expr::Ident(name) => name,
            
            Expr::Binary(left, op, right) => {
                let l = self.gen_expr(*left);
                let r = self.gen_expr(*right);
                let rust_op = self.map_op(&op);
                format!("({} {} {})", l, rust_op, r)
            }
            
            Expr::Unary(op, operand) => {
                let o = self.gen_expr(*operand);
                format!("({}{})", op, o)
            }
            
            Expr::Call(callee, args) => {
                let fn_name = self.gen_expr(*callee);
                
                // Convert Kore builtins to Rust macros
                if fn_name == "println" || fn_name == "print" {
                    let arg_strs: Vec<String> = args.into_iter()
                        .map(|a| self.gen_expr(a))
                        .collect();
                    let format_placeholders: Vec<&str> = arg_strs.iter()
                        .map(|_| "{}")
                        .collect();
                    
                    let format_str = format!("\"{}\"", format_placeholders.join(" "));
                    if !arg_strs.is_empty() {
                        return format!("{}!({}, {})", fn_name, format_str, arg_strs.join(", "));
                    }
                    return format!("{}!()", fn_name);
                }
                
                let arg_strs: Vec<String> = args.into_iter()
                    .map(|a| self.gen_expr(a))
                    .collect();
                format!("{}({})", fn_name, arg_strs.join(", "))
            }
            
            Expr::MethodCall(receiver, method, args) => {
                let recv = self.gen_expr(*receiver);
                let arg_strs: Vec<String> = args.into_iter()
                    .map(|a| self.gen_expr(a))
                    .collect();
                format!("{}.{}({})", recv, method, arg_strs.join(", "))
            }
            
            Expr::Index(array, index) => {
                format!("{}[{}]", self.gen_expr(*array), self.gen_expr(*index))
            }
            
            Expr::Field(obj, field) => {
                format!("{}.{}", self.gen_expr(*obj), field)
            }
            
            Expr::Array(elements) => {
                let elems: Vec<String> = elements.into_iter()
                    .map(|e| self.gen_expr(e))
                    .collect();
                format!("vec![{}]", elems.join(", "))
            }

             Expr::Tuple(elements) => {
                let elems: Vec<String> = elements.into_iter()
                    .map(|e| self.gen_expr(e))
                    .collect();
                if elems.len() == 1 {
                    format!("({},)", elems[0])
                } else {
                    format!("({})", elems.join(", "))
                }
            }
            
            Expr::Struct(name, field_inits) => {
                let fields: Vec<String> = field_inits.into_iter()
                    .map(|fi| format!("{}: {}", fi.name, self.gen_expr(fi.value)))
                    .collect();
                format!("{} {{ {} }}", name, fields.join(", "))
            }
            
            Expr::EnumVariant(enum_name, variant_name, args) => {
                if args.is_empty() {
                    format!("{}::{}", enum_name, variant_name)
                } else {
                    let arg_strs: Vec<String> = args.into_iter()
                        .map(|a| self.gen_expr(a))
                        .collect();
                    format!("{}::{}({})", enum_name, variant_name, arg_strs.join(", "))
                }
            }
            
            Expr::If(cond, then_expr, else_expr) => {
                let c = self.gen_expr(*cond);
                let t = self.gen_expr(*then_expr);
                if let Some(e) = else_expr {
                    format!("(if {} {{ {} }} else {{ {} }})", c, t, self.gen_expr(*e))
                } else {
                    format!("(if {} {{ {} }} else {{ () }})", c, t)
                }
            }
            
            Expr::Lambda(params, body) => {
                format!("|{}| {}", params.join(", "), self.gen_expr(*body))
            }
            
            Expr::Await(future) => {
                format!("{}.await", self.gen_expr(*future))
            }
        }
    }
    
    /// Generate a pattern for match arms
    fn gen_pattern(&self, pattern: &Pattern) -> String {
        match pattern {
            Pattern::Wildcard => "_".to_string(),
            Pattern::Ident(name) => name.clone(),
            Pattern::Literal(expr) => self.gen_expr(expr.clone()),
            Pattern::Variant(enum_prefix, name, fields) => {
                let full_name = if let Some(prefix) = enum_prefix {
                    format!("{}::{}", prefix, name)
                } else {
                    name.clone()
                };
                
                if fields.is_empty() {
                    full_name
                } else {
                    let field_pats: Vec<String> = fields.iter()
                        .map(|f| self.gen_pattern(f))
                        .collect();
                    format!("{}({})", full_name, field_pats.join(", "))
                }
            }
        }
    }
    
    // =========================================================================
    // Type Mapping
    // =========================================================================
    
    fn map_type(&self, ty: &str) -> String {
        match ty {
            "Int" => "i64".to_string(),
            "Float" => "f64".to_string(),
            "Bool" => "bool".to_string(),
            "String" => "String".to_string(),
            "Unit" => "()".to_string(),
            "Array" => "Vec<i64>".to_string(),
            _ => {
                // Check for Array<T> pattern
                if ty.starts_with("Array<") {
                    let inner = &ty[6..ty.len()-1];
                    return format!("Vec<{}>", self.map_type(inner));
                }
                // Check for Option<T> pattern
                if ty.starts_with("Option<") {
                    let inner = &ty[7..ty.len()-1];
                    return format!("Option<{}>", self.map_type(inner));
                }
                // Check for Box<T> pattern
                if ty.starts_with("Box<") {
                    let inner = &ty[4..ty.len()-1];
                    return format!("Box<{}>", self.map_type(inner));
                }
                // Assume it's a custom type
                ty.to_string()
            }
        }
    }
    
    /// Map Kore operator to Rust operator
    fn map_op(&self, op: &str) -> String {
        match op {
            "and" => "&&".to_string(),
            "or" => "||".to_string(),
            "not" => "!".to_string(),
            _ => op.to_string(),
        }
    }
    
    /// Escape special characters in strings
    fn escape_string(&self, s: &str) -> String {
        let mut result = String::new();
        for c in s.chars() {
            match c {
                '\n' => result.push_str("\\n"),
                '\t' => result.push_str("\\t"),
                '\\' => result.push_str("\\\\"),
                '"' => result.push_str("\\\""),
                _ => result.push(c),
            }
        }
        result
    }
}

// =============================================================================
// Cargo.toml Generator
// =============================================================================

pub fn gen_cargo_toml(name: &str, deps: &[&str]) -> String {
    let mut sb = StringBuilder::new();
    
    sb.push_line("[package]");
    sb.push_line(&format!("name = \"{}\"", name));
    sb.push_line("version = \"0.1.0\"");
    sb.push_line("edition = \"2021\"");
    sb.push_line("");
    sb.push_line("# Generated by KORE Compiler");
    sb.push_line("");
    sb.push_line("[dependencies]");
    
    for dep in deps {
        sb.push_line(&format!("{} = \"*\"", dep));
    }
    
    sb.build()
}

// =============================================================================
// Tests
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compiler::lexer::Lexer;
    use crate::compiler::parser::Parser;
    
    #[test]
    fn test_gen_simple_function() {
        let source = "fn main(): let x = 42";
        let mut lexer = Lexer::new(source.to_string());
        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let program = parser.parse_program();
        let mut gen = RustGen::new();
        let rust = gen.gen_program(program);
        assert!(rust.contains("fn main()"));
    }
}
