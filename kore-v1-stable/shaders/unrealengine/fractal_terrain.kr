// Fractal Brownian Motion Terrain - Procedural terrain with multi-octave noise
// Features: FBM, domain warping, erosion simulation, biome blending
shader fragment FractalTerrain(position: Vec4, uv: Vec2, world_pos: Vec3, normal: Vec3) -> Vec4:
    uniform time: Float @0
    uniform octaves: Float @1
    uniform lacunarity: Float @2
    uniform persistence: Float @3
    uniform warp_strength: Float @4
    uniform erosion_strength: Float @5
    uniform snow_height: Float @6
    uniform grass_height: Float @7
    uniform rock_slope: Float @8
    uniform water_level: Float @9
    uniform sun_dir: Vec3 @10
    uniform camera_pos: Vec3 @11
    
    uniform grass_color: Vec3 @12
    uniform rock_color: Vec3 @13
    uniform snow_color: Vec3 @14
    uniform sand_color: Vec3 @15
    uniform water_color: Vec3 @16
    
    // Hash function for pseudo-random
    let p1 = dot(uv * 127.1, vec2(1.0, 311.7))
    let hash_base = fract(sin(p1) * 43758.5453)
    
    // Domain warp
    let warp_p = uv * 4.0
    let wx1 = sin(warp_p.x * 1.7 + time * 0.1) * cos(warp_p.y * 2.3)
    let wy1 = sin(warp_p.y * 1.9 + time * 0.1) * cos(warp_p.x * 2.1)
    let wx2 = sin(warp_p.x * 3.3) * cos(warp_p.y * 3.7) * 0.5
    let wy2 = sin(warp_p.y * 2.9) * cos(warp_p.x * 3.1) * 0.5
    let warp_offset = vec2(wx1 + wx2, wy1 + wy2) * warp_strength
    let warped_uv = uv + warp_offset
    
    // FBM height computation
    var height = 0.0
    var amplitude = 1.0
    var frequency = 1.0
    var max_value = 0.0
    var oi = 0.0
    while oi < octaves:
        let sample_p = warped_uv * frequency
        
        // Layered sin noise
        let n1 = sin(sample_p.x * 12.9898 + sample_p.y * 78.233) * 0.5 + 0.5
        let n2 = sin((sample_p.x + 0.5) * 23.456 + sample_p.y * 45.678) * 0.5 + 0.5
        let n = (n1 + n2) * 0.5
        
        // Ridge noise for mountains
        let ridge = 1.0 - abs(n * 2.0 - 1.0)
        let ridge_sq = ridge * ridge
        
        // Blend based on accumulated height
        let blend_factor = height / max(max_value, 0.001)
        let smooth_blend = blend_factor * blend_factor * (3.0 - 2.0 * blend_factor)
        let octave_val = n * (1.0 - smooth_blend) + ridge_sq * smooth_blend
        
        height = height + octave_val * amplitude
        max_value = max_value + amplitude
        amplitude = amplitude * persistence
        frequency = frequency * lacunarity
        oi = oi + 1.0
    
    height = height / max_value
    
    // Erosion simulation
    let erosion_noise = sin(warped_uv.x * 47.3 + warped_uv.y * 83.7 + time * 0.01) * 0.5 + 0.5
    let dx = (sin((warped_uv.x + 0.01) * frequency * 12.9898) - sin(warped_uv.x * frequency * 12.9898)) / 0.01
    let dy = (sin((warped_uv.y + 0.01) * frequency * 78.233) - sin(warped_uv.y * frequency * 78.233)) / 0.01
    let slope = sqrt(dx * dx + dy * dy)
    let erosion = slope * erosion_strength * erosion_noise
    height = height - erosion * 0.1
    
    // Compute terrain normal
    let terrain_normal = normalize(vec3(-dx * 0.5, 1.0, -dy * 0.5))
    
    // Slope factor for biome blending
    let slope_factor = 1.0 - dot(terrain_normal, vec3(0.0, 1.0, 0.0))
    
    // Biome blending
    var terrain_color = vec3(0.0, 0.0, 0.0)
    
    // Water
    let water_blend = 1.0 - clamp((height - water_level + 0.05) / 0.05, 0.0, 1.0)
    terrain_color = water_color * water_blend + terrain_color * (1.0 - water_blend)
    
    // Sand/beach
    let above_water = clamp((height - water_level) / 0.05, 0.0, 1.0)
    let below_grass = 1.0 - clamp((height - water_level - 0.1) / 0.05, 0.0, 1.0)
    let sand_blend = above_water * below_grass
    terrain_color = sand_color * sand_blend + terrain_color * (1.0 - sand_blend)
    
    // Grass
    let grass_zone = clamp((height - grass_height + 0.1) / 0.1, 0.0, 1.0)
    let flat_enough = 1.0 - clamp((slope_factor - rock_slope + 0.1) / 0.1, 0.0, 1.0)
    let grass_blend = grass_zone * flat_enough
    terrain_color = grass_color * grass_blend + terrain_color * (1.0 - grass_blend)
    
    // Rock on steep slopes
    let rock_blend = clamp((slope_factor - rock_slope + 0.1) / 0.1, 0.0, 1.0)
    terrain_color = rock_color * rock_blend + terrain_color * (1.0 - rock_blend)
    
    // Snow
    let snow_zone = clamp((height - snow_height + 0.1) / 0.1, 0.0, 1.0)
    let not_cliff = 1.0 - clamp((slope_factor - 0.5) / 0.2, 0.0, 1.0)
    let snow_blend = snow_zone * not_cliff
    terrain_color = snow_color * snow_blend + terrain_color * (1.0 - snow_blend)
    
    // Lighting
    let NdotL = max(dot(terrain_normal, sun_dir), 0.0)
    let lit_color = terrain_color * (0.2 + NdotL * 0.8)
    
    // Atmospheric perspective
    let dist = length(camera_pos - world_pos)
    let fog_factor = 1.0 - exp(-dist * 0.0001)
    let final_color = lit_color * (1.0 - fog_factor * 0.5) + vec3(0.7, 0.8, 0.9) * fog_factor * 0.5
    
    return vec4(final_color, 1.0)
