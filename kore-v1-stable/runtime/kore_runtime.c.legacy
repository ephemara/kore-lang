#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <winsock2.h>
#include <windows.h>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")
#else
#include <pthread.h>
#include <unistd.h>
#endif

// --- Memory & Weak Refs ---

typedef struct {
    long long ref_count;
    long long weak_count; // Weak references
    long long type_tag; // 0=Raw, 1=String, 2=Array, 3=Map
    void (*destructor)(void*);
} RcHeader;

// [Header][User Data...]
//         ^ return pointer

void* kore_alloc_rc(size_t size, long long type_tag) {
    RcHeader* header = malloc(sizeof(RcHeader) + size);
    if (!header) return NULL;
    header->ref_count = 1;
    header->weak_count = 0;
    header->type_tag = type_tag;
    header->destructor = NULL;
    return (void*)(header + 1);
}

void* kore_alloc(size_t size) {
    return kore_alloc_rc(size, 0);
}

RcHeader* get_header(void* ptr) {
    return ((RcHeader*)ptr) - 1;
}

void rc_retain(void* ptr) {
    if (!ptr) return;
    get_header(ptr)->ref_count++;
}

void rc_weak_retain(void* ptr) {
    if (!ptr) return;
    get_header(ptr)->weak_count++;
}

void free_header(RcHeader* header) {
    free(header);
}

// Forward declaration
void array_free_elems(void* ptr);
void map_free_elems(void* ptr);

void rc_release(void* ptr) {
    if (!ptr) return;
    RcHeader* header = get_header(ptr);
    header->ref_count--;
    
    if (header->ref_count == 0) {
        // Destroy content
        if (header->type_tag == 2) {
             array_free_elems(ptr);
        } else if (header->type_tag == 3) {
             map_free_elems(ptr);
        }
        
        if (header->destructor) {
            header->destructor(ptr);
        }
        
        // If no weak refs, free header too
        if (header->weak_count == 0) {
            free(header);
        } else {
             // Just destroy the object but keep header for weak refs
             // In this simple implementation, the user data is still allocated but "invalid"
             // A real implementation might separate the control block from the data.
             // For now, we rely on ref_count check in weak_upgrade.
        }
    }
}

void rc_weak_release(void* ptr) {
    if (!ptr) return;
    RcHeader* header = get_header(ptr);
    header->weak_count--;
    
    if (header->weak_count == 0 && header->ref_count == 0) {
        free(header);
    }
}

void* weak_upgrade(void* ptr) {
    if (!ptr) return NULL;
    RcHeader* header = get_header(ptr);
    if (header->ref_count > 0) {
        header->ref_count++;
        return ptr;
    }
    return NULL;
}

void kore_set_destructor(void* ptr, void (*dtor)(void*)) {
    if (!ptr) return;
    get_header(ptr)->destructor = dtor;
}

// --- Concurrency ---

typedef struct {
    void (*func)(void*);
    void* arg;
} ThreadArgs;

#ifdef _WIN32
DWORD WINAPI thread_wrapper(LPVOID lpParam) {
    ThreadArgs* args = (ThreadArgs*)lpParam;
    args->func(args->arg);
    rc_release(args->arg); // Release actor reference held by thread
    free(args);
    return 0;
}
#else
void* thread_wrapper(void* arg) {
    ThreadArgs* args = (ThreadArgs*)arg;
    args->func(args->arg);
    rc_release(args->arg); // Release actor reference held by thread
    free(args);
    return NULL;
}
#endif

void kore_spawn(void (*func)(void*), void* arg) {
    ThreadArgs* args = malloc(sizeof(ThreadArgs));
    args->func = func;
    args->arg = arg;
    
    // Retain arg to ensure it lives across threads
    rc_retain(arg);
    
#ifdef _WIN32
    CreateThread(NULL, 0, thread_wrapper, args, 0, NULL);
#else
    pthread_t thread;
    pthread_create(&thread, NULL, thread_wrapper, args);
    pthread_detach(thread);
#endif
}

void default_actor_run(void* arg) {
    printf("Actor running (default wrapper)\n");
}

void kore_sleep(double seconds) {
#ifdef _WIN32
    Sleep((DWORD)(seconds * 1000));
#else
    usleep((useconds_t)(seconds * 1000000));
#endif
}

// --- Strings ---

char* string_new(char* src) {
    if (!src) return NULL;
    size_t len = strlen(src);
    char* buf = kore_alloc_rc(len + 1, 1);
    strcpy(buf, src);
    return buf;
}

void print_str(char* str, long long len) {
    if (str) printf("%s\n", str);
    else printf("(null)\n");
}

void print_i64(long long n) { printf("%lld\n", n); }
void print_f64(double n) { printf("%f\n", n); }
void print_bool(int n) { printf("%s\n", n ? "true" : "false"); }

char* to_string(long long n) {
    char* buf = kore_alloc_rc(32, 1);
    sprintf(buf, "%lld", n);
    return buf;
}

char* str_concat(char* s1, char* s2) {
    if (!s1 && !s2) return NULL;
    size_t l1 = s1 ? strlen(s1) : 0;
    size_t l2 = s2 ? strlen(s2) : 0;
    char* res = kore_alloc_rc(l1 + l2 + 1, 1);
    if (s1) strcpy(res, s1); else res[0] = 0;
    if (s2) strcat(res, s2);
    return res;
}

long long clock_wrapper() { return (long long)clock(); }

// --- Arrays ---

typedef struct {
    long long* data; 
    long long len;
    long long cap;
} KoreArray;

void array_free_elems(void* ptr) {
    KoreArray* arr = (KoreArray*)ptr;
    free(arr->data);
}

KoreArray* array_new(long long cap) {
    KoreArray* arr = kore_alloc_rc(sizeof(KoreArray), 2);
    arr->len = 0;
    arr->cap = cap < 4 ? 4 : cap;
    arr->data = malloc(arr->cap * sizeof(long long));
    return arr;
}

void array_push(KoreArray* arr, long long val) {
    if (arr->len >= arr->cap) {
        arr->cap *= 2;
        arr->data = realloc(arr->data, arr->cap * sizeof(long long));
    }
    arr->data[arr->len++] = val;
}

long long array_get(KoreArray* arr, long long index) {
    if (index < 0 || index >= arr->len) {
        printf("Panic: Index out of bounds %lld\n", index);
        exit(1);
    }
    return arr->data[index];
}

void array_set(KoreArray* arr, long long index, long long val) {
    if (index < 0 || index >= arr->len) {
        printf("Panic: Index out of bounds %lld\n", index);
        exit(1);
    }
    arr->data[index] = val;
}

long long array_len(KoreArray* arr) { return arr->len; }

// --- File I/O ---

char* file_read(char* path) {
    FILE* f = fopen(path, "rb");
    if (!f) return NULL;
    
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    char* buf = kore_alloc_rc(size + 1, 1);
    fread(buf, 1, size, f);
    buf[size] = 0;
    
    fclose(f);
    return buf;
}

void file_write(char* path, char* content) {
    FILE* f = fopen(path, "wb");
    if (!f) return;
    if (content) fprintf(f, "%s", content);
    fclose(f);
}

// --- Maps (HashMap) ---
// Simple open addressing for simplicity

typedef struct {
    char* key;
    long long value; // Using i64/ptr for value
    int occupied;
} MapEntry;

typedef struct {
    MapEntry* entries;
    long long capacity;
    long long count;
} KoreMap;

unsigned long hash_str(char* str) {
    unsigned long hash = 5381;
    int c;
    while ((c = *str++)) hash = ((hash << 5) + hash) + c;
    return hash;
}

void map_free_elems(void* ptr) {
    KoreMap* map = (KoreMap*)ptr;
    for(long long i=0; i<map->capacity; i++) {
        if (map->entries[i].occupied) {
             rc_release(map->entries[i].key);
             // Value might be primitive or RC, difficult to know without type info.
             // For now assume primitive/unmanaged or manually managed.
             // Ideally we need type info.
        }
    }
    free(map->entries);
}

KoreMap* map_new() {
    KoreMap* map = kore_alloc_rc(sizeof(KoreMap), 3);
    map->capacity = 16;
    map->count = 0;
    map->entries = calloc(16, sizeof(MapEntry));
    return map;
}

void map_set(KoreMap* map, char* key, long long value) {
    if (!key) return;
    
    // Resize if load factor > 0.75
    if (map->count >= map->capacity * 0.75) {
        long long old_cap = map->capacity;
        MapEntry* old_entries = map->entries;
        
        map->capacity *= 2;
        map->entries = calloc(map->capacity, sizeof(MapEntry));
        map->count = 0;
        
        for (long long i=0; i<old_cap; i++) {
            if (old_entries[i].occupied) {
                map_set(map, old_entries[i].key, old_entries[i].value);
                // Don't release key, we moved ownership
            }
        }
        free(old_entries);
    }
    
    unsigned long h = hash_str(key);
    long long idx = h % map->capacity;
    
    while (map->entries[idx].occupied) {
        if (strcmp(map->entries[idx].key, key) == 0) {
            // Update
            map->entries[idx].value = value;
            return;
        }
        idx = (idx + 1) % map->capacity;
    }
    
    // Insert
    rc_retain(key);
    map->entries[idx].key = key;
    map->entries[idx].value = value;
    map->entries[idx].occupied = 1;
    map->count++;
}

long long map_get(KoreMap* map, char* key) {
    if (!key) return 0;
    unsigned long h = hash_str(key);
    long long idx = h % map->capacity;
    
    for (long long i=0; i<map->capacity; i++) {
        if (!map->entries[idx].occupied) return 0; // Not found
        if (strcmp(map->entries[idx].key, key) == 0) return map->entries[idx].value;
        idx = (idx + 1) % map->capacity;
    }
    return 0;
}

// --- Actor Message Queue ---

typedef struct MessageNode {
    long long type_tag; // Matches the message type ID
    void* data; // Pointer to message payload (struct)
    struct MessageNode* next;
} MessageNode;

typedef struct {
    MessageNode* head;
    MessageNode* tail;
#ifdef _WIN32
    CRITICAL_SECTION lock;
#else
    pthread_mutex_t lock;
#endif
} MessageQueue;

void* mq_new() {
    MessageQueue* mq = malloc(sizeof(MessageQueue));
    mq->head = NULL;
    mq->tail = NULL;
#ifdef _WIN32
    InitializeCriticalSection(&mq->lock);
#else
    pthread_mutex_init(&mq->lock, NULL);
#endif
    return mq;
}

void mq_push(void* mq_ptr, long long type_tag, void* data) {
    MessageQueue* mq = (MessageQueue*)mq_ptr;
    MessageNode* node = malloc(sizeof(MessageNode));
    node->type_tag = type_tag;
    node->data = data;
    node->next = NULL;
    
#ifdef _WIN32
    EnterCriticalSection(&mq->lock);
#else
    pthread_mutex_lock(&mq->lock);
#endif

    if (mq->tail) {
        mq->tail->next = node;
        mq->tail = node;
    } else {
        mq->head = node;
        mq->tail = node;
    }

#ifdef _WIN32
    LeaveCriticalSection(&mq->lock);
#else
    pthread_mutex_unlock(&mq->lock);
#endif
}

// Returns 1 if got message, 0 if empty
int mq_pop(void* mq_ptr, long long* out_tag, void** out_data) {
    MessageQueue* mq = (MessageQueue*)mq_ptr;
    
#ifdef _WIN32
    EnterCriticalSection(&mq->lock);
#else
    pthread_mutex_lock(&mq->lock);
#endif

    if (!mq->head) {
#ifdef _WIN32
        LeaveCriticalSection(&mq->lock);
#else
        pthread_mutex_unlock(&mq->lock);
#endif
        return 0;
    }
    
    MessageNode* node = mq->head;
    mq->head = node->next;
    if (!mq->head) mq->tail = NULL;
    
#ifdef _WIN32
    LeaveCriticalSection(&mq->lock);
#else
    pthread_mutex_unlock(&mq->lock);
#endif

    *out_tag = node->type_tag;
    *out_data = node->data;
    free(node);
    return 1;
}

// --- Sockets (Networking) ---

#ifdef _WIN32
// Headers already included at top
void init_winsock() {
    static int initialized = 0;
    if (!initialized) {
        WSADATA wsaData;
        WSAStartup(MAKEWORD(2, 2), &wsaData);
        initialized = 1;
    }
}
#else
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <netdb.h>
#define SOCKET int
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#endif

long long socket_connect(char* host, long long port) {
#ifdef _WIN32
    init_winsock();
#endif
    SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET) return -1;
    
    struct sockaddr_in server;
    server.sin_family = AF_INET;
    server.sin_port = htons((unsigned short)port);
    server.sin_addr.s_addr = inet_addr(host);
    
    if (server.sin_addr.s_addr == INADDR_NONE) {
        struct hostent* he = gethostbyname(host);
        if (he) {
            memcpy(&server.sin_addr, he->h_addr_list[0], he->h_length);
        } else {
            return -1;
        }
    }

    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) < 0) {
        return -1;
    }
    
    return (long long)sock;
}

void socket_send(long long sock, char* data) {
    if (sock < 0 || !data) return;
    send((SOCKET)sock, data, strlen(data), 0);
}

char* socket_recv(long long sock) {
    if (sock < 0) return NULL;
    char buf[4096];
    int len = recv((SOCKET)sock, buf, sizeof(buf)-1, 0);
    if (len > 0) {
        buf[len] = 0;
        return string_new(buf);
    }
    return string_new("");
}

// --- KOS Bridge ---
int deep_eq(void* a, void* b) {
    if (a == b) return 1;
    if (!a || !b) return 0;
    
    // Check type tags from header
    // Note: This assumes a and b are valid RC objects.
    // Calling this on non-RC pointers or integers will crash.
    RcHeader* ha = get_header(a);
    RcHeader* hb = get_header(b);
    
    if (ha->type_tag != hb->type_tag) return 0;
    
    // String
    if (ha->type_tag == 1) {
        return strcmp((char*)a, (char*)b) == 0;
    }
    
    // Array
    if (ha->type_tag == 2) {
        KoreArray* arr_a = (KoreArray*)a;
        KoreArray* arr_b = (KoreArray*)b;
        if (arr_a->len != arr_b->len) return 0;
        
        // Shallow comparison of elements
        // For deep recursive comparison, we would need type info for elements
        for (long long i = 0; i < arr_a->len; i++) {
            if (arr_a->data[i] != arr_b->data[i]) return 0;
        }
        return 1;
    }
    
    return 0;
}

void spawn_cube(double x, double y) {
    printf(" [KOS Bridge] Spawning Cube at { x: %.2f, y: %.2f }\n", x, y);
}
