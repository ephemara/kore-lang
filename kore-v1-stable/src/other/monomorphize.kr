// ============================================================================
// KORE Monomorphization Pass
// ============================================================================
// Ported from legacy_prototype/src/monomorphize.rs
//
// Monomorphization is the process of specializing generic functions and types
// into concrete, non-generic versions. For example:
//
//   fn identity<T>(x: T) -> T: return x
//   
//   identity(42)      // Generates: identity_Int
//   identity("hello") // Generates: identity_String
//
// This pass also handles:
// - Method lowering (obj.method(args) -> Type_method(obj, args))
// - Async function transformation (async fn -> state machine)
// - Type inference for generic calls
// ============================================================================

use std/collections

// =============================================================================
// Result Types
// =============================================================================

/// Result of monomorphization
struct MonomorphizedProgram:
    items: Array<TypedItem>

// =============================================================================
// Context
// =============================================================================

/// Monomorphization context - tracks state during the pass
struct MonoContext:
    /// Generic functions by name
    generic_functions: Map<String, TypedFunction>
    /// Concrete (non-generic) items collected
    concrete_items: Array<TypedItem>
    /// Already instantiated generics: mangled_name -> mangled_name
    instantiated: Map<String, String>
    /// Methods: type_name -> method_name -> mangled_name
    methods: Map<String, Map<String, String>>
    /// Struct definitions: struct_name -> field_name -> type
    structs: Map<String, Map<String, ResolvedType>>
    /// Trait implementations: (trait_name, type_name) -> implemented
    trait_impls: Set<(String, String)>

impl MonoContext:
    pub fn new() -> MonoContext:
        return MonoContext {
            generic_functions: Map::new(),
            concrete_items: [],
            instantiated: Map::new(),
            methods: Map::new(),
            structs: Map::new(),
            trait_impls: Set::new()
        }
    
    /// Instantiate a generic function with specific type arguments
    pub fn instantiate(self, name: String, type_args: Array<ResolvedType>) -> Result<String, KoreError>:
        let mangled_name = name + "_" + mangle_types(type_args)
        
        // Already instantiated?
        if contains_key(self.instantiated, mangled_name):
            return Ok(mangled_name)
        
        // Find the generic function
        if !contains_key(self.generic_functions, name):
            return Err(KoreError::type_error("Generic function not found: " + name))
        
        let generic_func = self.generic_functions[name]
        
        // Check arg count
        if len(generic_func.ast.generics) != len(type_args):
            return Err(KoreError::type_error(
                "Generic arg count mismatch for " + name + 
                ": expected " + str(len(generic_func.ast.generics)) + 
                ", got " + str(len(type_args))
            ))
        
        // Build substitution mapping: T -> Int, U -> String, etc.
        var mapping: Map<String, ResolvedType> = Map::new()
        for i in range(0, len(generic_func.ast.generics)):
            let param = generic_func.ast.generics[i]
            mapping[param.name] = type_args[i]
        
        // Create new concrete function
        var new_func = clone(generic_func)
        new_func.ast.name = mangled_name
        new_func.ast.generics = []
        
        // Substitute types in function signature
        match new_func.resolved_type:
            ResolvedType::Function(params, ret, effects) =>
                var new_params: Array<ResolvedType> = []
                for p in params:
                    push(new_params, substitute_type(p, mapping))
                new_func.resolved_type = ResolvedType::Function(
                    new_params,
                    substitute_type(ret, mapping),
                    effects
                )
            _ => pass
        
        // Mark as instantiated
        self.instantiated[mangled_name] = mangled_name
        
        // Substitute types in function body
        substitute_ast_types(new_func.ast, mapping)
        
        // Add to concrete items
        push(self.concrete_items, TypedItem::Function(new_func))
        
        return Ok(mangled_name)

// =============================================================================
// Type Environment for Scanning
// =============================================================================

struct MonoTypeEnv:
    scopes: Array<Map<String, ResolvedType>>

impl MonoTypeEnv:
    pub fn new() -> MonoTypeEnv:
        return MonoTypeEnv { scopes: [Map::new()] }
    
    pub fn push(self) -> Unit:
        push(self.scopes, Map::new())
    
    pub fn pop(self) -> Unit:
        pop(self.scopes)
    
    pub fn define(self, name: String, ty: ResolvedType) -> Unit:
        if len(self.scopes) > 0:
            let last = len(self.scopes) - 1
            self.scopes[last][name] = ty
    
    pub fn get(self, name: String) -> ResolvedType:
        // Search from innermost to outermost scope
        var i = len(self.scopes) - 1
        while i >= 0:
            if contains_key(self.scopes[i], name):
                return self.scopes[i][name]
            i = i - 1
        return ResolvedType::Unknown

// =============================================================================
// Main Entry Point
// =============================================================================

/// Perform monomorphization on a typed program
pub fn monomorphize(program: TypedProgram) -> Result<MonomorphizedProgram, KoreError>:
    var ctx = MonoContext::new()
    
    // =========================================================================
    // Pass 1: Collect all global items
    // =========================================================================
    
    for item in program.items:
        match item:
            TypedItem::Function(func) =>
                if len(func.ast.generics) > 0:
                    // Generic function - store for later instantiation
                    ctx.generic_functions[func.ast.name] = func
                else:
                    // Concrete function
                    push(ctx.concrete_items, item)
            
            TypedItem::Struct(s) =>
                // Register struct fields
                var fields: Map<String, ResolvedType> = Map::new()
                for f in s.ast.fields:
                    match resolve_ast_type(f.ty):
                        Ok(ty) => fields[f.name] = ty
                        Err(_) => pass
                ctx.structs[s.ast.name] = fields
                push(ctx.concrete_items, item)
            
            TypedItem::Impl(imp) =>
                // Register methods from impl blocks
                let type_name = match imp.ast.target_type:
                    Type::Named(name, _, _) => name
                    _ => continue
                
                let target_ty = match resolve_ast_type(imp.ast.target_type):
                    Ok(t) => t
                    Err(_) => ResolvedType::Unknown
                
                // Register trait implementation
                match imp.ast.trait_name:
                    Some(trait_name) =>
                        let type_name_str = type_to_string(target_ty)
                        ctx.trait_impls.insert((trait_name, type_name_str))
                    None => pass
                
                // Process methods
                for method in imp.ast.methods:
                    let mangled_name = type_name + "_" + method.name
                    
                    // Create standalone function from method
                    var standalone_fn = clone(method)
                    standalone_fn.name = mangled_name
                    
                    // Build method type
                    var params: Array<ResolvedType> = []
                    for p in method.params:
                        if p.name == "self":
                            push(params, target_ty)
                        else:
                            match resolve_ast_type(p.ty):
                                Ok(t) => push(params, t)
                                Err(_) => push(params, ResolvedType::Unknown)
                    
                    let ret = match method.return_type:
                        Some(t) =>
                            match resolve_ast_type(t):
                                Ok(r) => r
                                Err(_) => ResolvedType::Unknown
                        None => ResolvedType::Unit
                    
                    let method_ty = ResolvedType::Function(params, ret, EffectSet::new())
                    
                    let typed_method = TypedFunction {
                        ast: standalone_fn,
                        resolved_type: method_ty,
                        effects: EffectSet::new()
                    }
                    
                    // Register in method map
                    if !contains_key(ctx.methods, type_name):
                        ctx.methods[type_name] = Map::new()
                    ctx.methods[type_name][method.name] = mangled_name
                    
                    push(ctx.concrete_items, TypedItem::Function(typed_method))
            
            _ =>
                push(ctx.concrete_items, item)
    
    // =========================================================================
    // Pass 2: Scan concrete items for generic calls and async functions
    // =========================================================================
    
    var i = 0
    while i < len(ctx.concrete_items):
        let item = ctx.concrete_items[i]
        
        match item:
            TypedItem::Function(func) =>
                // Check if async
                if func.effects.contains(Effect::Async):
                    // Lower async function to state machine
                    let entry_fn = lower_async_fn(ctx, func)?
                    ctx.concrete_items[i] = TypedItem::Function(entry_fn)
                else:
                    // Scan for generic calls and method calls
                    let new_func = scan_function(ctx, func)?
                    ctx.concrete_items[i] = TypedItem::Function(new_func)
            _ => pass
        
        i = i + 1
    
    return Ok(MonomorphizedProgram { items: ctx.concrete_items })

// =============================================================================
// Type Utilities
// =============================================================================

/// Convert a resolved type to a string (for mangling)
fn type_to_string(ty: ResolvedType) -> String:
    match ty:
        ResolvedType::Int(_) => "Int"
        ResolvedType::Float(_) => "Float"
        ResolvedType::String => "String"
        ResolvedType::Bool => "Bool"
        ResolvedType::Unit => "Unit"
        ResolvedType::Struct(name, _) => name
        ResolvedType::Enum(name, _) => name
        ResolvedType::Tuple(items) =>
            "(" + join(map(items, type_to_string), "_") + ")"
        ResolvedType::Array(inner, _) =>
            "Array_" + type_to_string(inner)
        ResolvedType::Generic(name) => name
        _ => "Any"

/// Mangle type arguments into a unique string
fn mangle_types(types: Array<ResolvedType>) -> String:
    return join(map(types, type_to_string), "_")

/// Resolve an AST type to a resolved type
fn resolve_ast_type(ty: Type) -> Result<ResolvedType, KoreError>:
    match ty:
        Type::Named(name, generics, _) =>
            if name == "Int": return Ok(ResolvedType::Int(IntSize::I64))
            if name == "Float": return Ok(ResolvedType::Float(FloatSize::F64))
            if name == "Bool": return Ok(ResolvedType::Bool)
            if name == "String": return Ok(ResolvedType::String)
            if name == "Unit" or name == "()": return Ok(ResolvedType::Unit)
            
            // Generic parameter
            if len(generics) == 0:
                // Could be a struct, enum, or generic parameter
                return Ok(ResolvedType::Struct(name, Map::new()))
            
            // Named type with generics
            var resolved_generics: Array<ResolvedType> = []
            for g in generics:
                match resolve_ast_type(g):
                    Ok(t) => push(resolved_generics, t)
                    Err(e) => return Err(e)
            return Ok(ResolvedType::Struct(name, Map::new()))
        
        Type::Tuple(items, _) =>
            var resolved: Array<ResolvedType> = []
            for item in items:
                match resolve_ast_type(item):
                    Ok(t) => push(resolved, t)
                    Err(e) => return Err(e)
            return Ok(ResolvedType::Tuple(resolved))
        
        Type::Array(inner, size, _) =>
            match resolve_ast_type(inner):
                Ok(t) => return Ok(ResolvedType::Array(t, size))
                Err(e) => return Err(e)
        
        Type::Function(params, ret, _, _) =>
            var resolved_params: Array<ResolvedType> = []
            for p in params:
                match resolve_ast_type(p):
                    Ok(t) => push(resolved_params, t)
                    Err(e) => return Err(e)
            match resolve_ast_type(ret):
                Ok(r) => return Ok(ResolvedType::Function(resolved_params, r, EffectSet::new()))
                Err(e) => return Err(e)
        
        Type::Unit(_) => return Ok(ResolvedType::Unit)
        Type::Infer(_) => return Ok(ResolvedType::Unknown)
        Type::Never(_) => return Ok(ResolvedType::Never)
        _ => return Ok(ResolvedType::Unknown)

// =============================================================================
// Type Substitution
// =============================================================================

/// Substitute generic types with concrete types
fn substitute_type(ty: ResolvedType, mapping: Map<String, ResolvedType>) -> ResolvedType:
    match ty:
        ResolvedType::Generic(name) =>
            if contains_key(mapping, name):
                return mapping[name]
            return ty
        
        ResolvedType::Function(params, ret, effects) =>
            var new_params: Array<ResolvedType> = []
            for p in params:
                push(new_params, substitute_type(p, mapping))
            return ResolvedType::Function(
                new_params,
                substitute_type(ret, mapping),
                effects
            )
        
        ResolvedType::Array(inner, n) =>
            return ResolvedType::Array(substitute_type(inner, mapping), n)
        
        ResolvedType::Tuple(items) =>
            var new_items: Array<ResolvedType> = []
            for item in items:
                push(new_items, substitute_type(item, mapping))
            return ResolvedType::Tuple(new_items)
        
        _ => return ty

/// Substitute types in AST (modifies in place)
fn substitute_ast_types(func: Function, mapping: Map<String, ResolvedType>) -> Unit:
    // 1. Substitute param types
    for param in func.params:
        substitute_type_ast(param.ty, mapping)
    
    // 2. Substitute return type
    match func.return_type:
        Some(ret) => substitute_type_ast(ret, mapping)
        None => pass
    
    // 3. Substitute body
    substitute_block(func.body, mapping)

fn substitute_block(block: Block, mapping: Map<String, ResolvedType>) -> Unit:
    for stmt in block.stmts:
        substitute_stmt(stmt, mapping)

fn substitute_stmt(stmt: Stmt, mapping: Map<String, ResolvedType>) -> Unit:
    match stmt:
        Stmt::Let(pattern, ty, value, _) =>
            match ty:
                Some(t) => substitute_type_ast(t, mapping)
                None => pass
            match value:
                Some(v) => substitute_expr(v, mapping)
                None => pass
        
        Stmt::Expr(e, _) => substitute_expr(e, mapping)
        
        Stmt::Return(Some(e), _) => substitute_expr(e, mapping)
        
        Stmt::For(binding, iter, body, _) =>
            substitute_expr(iter, mapping)
            substitute_block(body, mapping)
        
        Stmt::While(condition, body, _) =>
            substitute_expr(condition, mapping)
            substitute_block(body, mapping)
        
        _ => pass

fn substitute_expr(expr: Expr, mapping: Map<String, ResolvedType>) -> Unit:
    match expr:
        Expr::Cast(value, target, _) =>
            substitute_expr(value, mapping)
            substitute_type_ast(target, mapping)
        
        Expr::Binary(left, op, right, _) =>
            substitute_expr(left, mapping)
            substitute_expr(right, mapping)
        
        Expr::Unary(op, operand, _) =>
            substitute_expr(operand, mapping)
        
        Expr::Call(callee, args, _) =>
            substitute_expr(callee, mapping)
            for arg in args:
                substitute_expr(arg.value, mapping)
        
        Expr::MethodCall(receiver, method, args, _) =>
            substitute_expr(receiver, mapping)
            for arg in args:
                substitute_expr(arg.value, mapping)
        
        Expr::Field(object, field, _) =>
            substitute_expr(object, mapping)
        
        Expr::Index(object, index, _) =>
            substitute_expr(object, mapping)
            substitute_expr(index, mapping)
        
        Expr::Struct(name, fields, _) =>
            for (fname, fval) in fields:
                substitute_expr(fval, mapping)
        
        Expr::Array(items, _) =>
            for item in items:
                substitute_expr(item, mapping)
        
        Expr::Tuple(items, _) =>
            for item in items:
                substitute_expr(item, mapping)
        
        Expr::Block(block, _) =>
            substitute_block(block, mapping)
        
        Expr::If(condition, then_branch, else_branch, _) =>
            substitute_expr(condition, mapping)
            substitute_block(then_branch, mapping)
            match else_branch:
                Some(ElseBranch::Else(b)) => substitute_block(b, mapping)
                Some(ElseBranch::ElseIf(cond, then_b, _)) =>
                    substitute_expr(cond, mapping)
                    substitute_block(then_b, mapping)
                None => pass
        
        Expr::Match(scrutinee, arms, _) =>
            substitute_expr(scrutinee, mapping)
            for arm in arms:
                substitute_expr(arm.body, mapping)
        
        Expr::Lambda(params, body, return_type, _) =>
            for p in params:
                substitute_type_ast(p.ty, mapping)
            match return_type:
                Some(ret) => substitute_type_ast(ret, mapping)
                None => pass
            substitute_expr(body, mapping)
        
        Expr::Await(inner, _) =>
            substitute_expr(inner, mapping)
        
        _ => pass

fn substitute_type_ast(ty: Type, mapping: Map<String, ResolvedType>) -> Unit:
    match ty:
        Type::Named(name, generics, span) =>
            if contains_key(mapping, name):
                // Replace with concrete type (would need to convert back to AST)
                let concrete = mapping[name]
                // For now, we just update generics
            for g in generics:
                substitute_type_ast(g, mapping)
        
        Type::Tuple(types, _) =>
            for t in types:
                substitute_type_ast(t, mapping)
        
        Type::Function(params, return_type, _, _) =>
            for p in params:
                substitute_type_ast(p, mapping)
            substitute_type_ast(return_type, mapping)
        
        Type::Array(inner, _, _) =>
            substitute_type_ast(inner, mapping)
        
        Type::Slice(inner, _) =>
            substitute_type_ast(inner, mapping)
        
        _ => pass

// =============================================================================
// Type Unification (for generic inference)
// =============================================================================

/// Unify a parameter type with an argument type to extract generic bindings
fn unify(param_type: ResolvedType, arg_type: ResolvedType, bindings: Map<String, ResolvedType>) -> Unit:
    match (param_type, arg_type):
        // If parameter is generic, bind it
        (ResolvedType::Generic(name), concrete) =>
            if !contains_key(bindings, name):
                bindings[name] = concrete
        
        // Recursively unify function types
        (ResolvedType::Function(p_params, p_ret, _), ResolvedType::Function(a_params, a_ret, _)) =>
            for i in range(0, min(len(p_params), len(a_params))):
                unify(p_params[i], a_params[i], bindings)
            unify(p_ret, a_ret, bindings)
        
        // Recursively unify array types
        (ResolvedType::Array(p_inner, _), ResolvedType::Array(a_inner, _)) =>
            unify(p_inner, a_inner, bindings)
        
        // Recursively unify tuple types
        (ResolvedType::Tuple(p_elems), ResolvedType::Tuple(a_elems)) =>
            for i in range(0, min(len(p_elems), len(a_elems))):
                unify(p_elems[i], a_elems[i], bindings)
        
        _ => pass

/// Infer type arguments for a generic function call
fn infer_type_args(ctx: MonoContext, generic_func: TypedFunction, arg_types: Array<ResolvedType>) -> Result<Array<ResolvedType>, KoreError>:
    var bindings: Map<String, ResolvedType> = Map::new()
    
    // Get parameter types from function signature
    var param_types: Array<ResolvedType> = []
    match generic_func.resolved_type:
        ResolvedType::Function(params, _, _) =>
            param_types = params
        _ =>
            // Fallback: resolve from AST
            for p in generic_func.ast.params:
                match resolve_ast_type(p.ty):
                    Ok(t) => push(param_types, t)
                    Err(_) => push(param_types, ResolvedType::Unknown)
    
    // Unify each parameter with corresponding argument
    for i in range(0, min(len(param_types), len(arg_types))):
        unify(param_types[i], arg_types[i], bindings)
    
    // Extract inferred types in order of generic parameters
    var inferred: Array<ResolvedType> = []
    for generic in generic_func.ast.generics:
        if contains_key(bindings, generic.name):
            let ty = bindings[generic.name]
            
            // Check trait bounds
            for bound in generic.bounds:
                let type_str = type_to_string(ty)
                if !ctx.trait_impls.contains((bound.trait_name, type_str)):
                    return Err(KoreError::type_error(
                        "Type '" + type_str + "' does not satisfy bound '" + bound.trait_name + "'"
                    ))
            
            push(inferred, ty)
        else:
            // Generic wasn't inferred
            push(inferred, ResolvedType::Unknown)
    
    return Ok(inferred)

// =============================================================================
// Function Scanning (for generic call instantiation)
// =============================================================================

fn scan_function(ctx: MonoContext, func: TypedFunction) -> Result<TypedFunction, KoreError>:
    var new_func = clone(func)
    var env = MonoTypeEnv::new()
    
    // Register parameter types
    match func.resolved_type:
        ResolvedType::Function(params, _, _) =>
            for i in range(0, min(len(params), len(func.ast.params))):
                env.define(func.ast.params[i].name, params[i])
        _ => pass
    
    scan_block(ctx, env, new_func.ast.body)?
    return Ok(new_func)

fn scan_block(ctx: MonoContext, env: MonoTypeEnv, block: Block) -> Result<Unit, KoreError>:
    env.push()
    for stmt in block.stmts:
        scan_stmt(ctx, env, stmt)?
    env.pop()
    return Ok(())

fn scan_stmt(ctx: MonoContext, env: MonoTypeEnv, stmt: Stmt) -> Result<Unit, KoreError>:
    match stmt:
        Stmt::Expr(e, _) =>
            scan_expr(ctx, env, e)?
        
        Stmt::Return(Some(e), _) =>
            scan_expr(ctx, env, e)?
        
        Stmt::Let(pattern, ty, Some(value), _) =>
            let val_ty = scan_expr(ctx, env, value)?
            match pattern:
                Pattern::Binding(name, _, _) => env.define(name, val_ty)
                _ => pass
        
        Stmt::For(binding, iter, body, _) =>
            let iter_ty = scan_expr(ctx, env, iter)?
            let elem_ty = match iter_ty:
                ResolvedType::Array(inner, _) => inner
                _ => ResolvedType::Int(IntSize::I64)
            
            env.push()
            match binding:
                Pattern::Binding(name, _, _) => env.define(name, elem_ty)
                _ => pass
            scan_block(ctx, env, body)?
            env.pop()
        
        Stmt::While(condition, body, _) =>
            scan_expr(ctx, env, condition)?
            scan_block(ctx, env, body)?
        
        _ => pass
    
    return Ok(())

fn scan_expr(ctx: MonoContext, env: MonoTypeEnv, expr: Expr) -> Result<ResolvedType, KoreError>:
    match expr:
        Expr::Int(_, _) => Ok(ResolvedType::Int(IntSize::I64))
        Expr::Float(_, _) => Ok(ResolvedType::Float(FloatSize::F64))
        Expr::String(_, _) => Ok(ResolvedType::String)
        Expr::Bool(_, _) => Ok(ResolvedType::Bool)
        Expr::Ident(name, _) => Ok(env.get(name))
        
        Expr::Struct(name, fields, _) =>
            for (_, val) in fields:
                scan_expr(ctx, env, val)?
            Ok(ResolvedType::Struct(name, Map::new()))
        
        Expr::Field(object, field, _) =>
            let obj_ty = scan_expr(ctx, env, object)?
            match obj_ty:
                ResolvedType::Struct(name, _) =>
                    if contains_key(ctx.structs, name):
                        let struct_fields = ctx.structs[name]
                        if contains_key(struct_fields, field):
                            return Ok(struct_fields[field])
                    Ok(ResolvedType::Unknown)
                _ => Ok(ResolvedType::Unknown)
        
        Expr::MethodCall(receiver, method, args, span) =>
            let receiver_ty = scan_expr(ctx, env, receiver)?
            
            let type_name = match receiver_ty:
                ResolvedType::Struct(name, _) => name
                ResolvedType::Int(_) => "Int"
                ResolvedType::Float(_) => "Float"
                ResolvedType::String => "String"
                _ => return Ok(ResolvedType::Unknown)
            
            // Look up mangled method name
            if contains_key(ctx.methods, type_name):
                let method_map = ctx.methods[type_name]
                if contains_key(method_map, method):
                    let mangled_name = method_map[method]
                    
                    // Build new args with receiver prepended
                    var new_args: Array<CallArg> = []
                    push(new_args, CallArg { name: None, value: receiver, span: span })
                    for arg in args:
                        scan_expr(ctx, env, arg.value)?
                        push(new_args, arg)
                    
                    // Rewrite to regular call
                    expr = Expr::Call(
                        Expr::Ident(mangled_name, span),
                        new_args,
                        span
                    )
                    return Ok(ResolvedType::Unknown)
            
            Ok(ResolvedType::Unknown)
        
        Expr::Call(callee, args, span) =>
            match callee:
                Expr::Ident(name, _) =>
                    if contains_key(ctx.generic_functions, name):
                        let generic_func = ctx.generic_functions[name]
                        
                        // Get arg types
                        var arg_types: Array<ResolvedType> = []
                        for arg in args:
                            push(arg_types, scan_expr(ctx, env, arg.value)?)
                        
                        // Infer type arguments
                        let inferred = infer_type_args(ctx, generic_func, arg_types)?
                        
                        // Instantiate
                        let new_name = ctx.instantiate(name, inferred)?
                        expr = Expr::Call(Expr::Ident(new_name, span), args, span)
                        return Ok(ResolvedType::Unknown)
                _ => pass
            
            for arg in args:
                scan_expr(ctx, env, arg.value)?
            Ok(ResolvedType::Unknown)
        
        Expr::Binary(left, op, right, _) =>
            let t = scan_expr(ctx, env, left)?
            scan_expr(ctx, env, right)?
            Ok(t)
        
        Expr::Assign(target, value, _) =>
            scan_expr(ctx, env, value)
        
        Expr::Block(block, _) =>
            scan_block(ctx, env, block)?
            Ok(ResolvedType::Unknown)
        
        Expr::If(condition, then_branch, else_branch, _) =>
            scan_expr(ctx, env, condition)?
            scan_block(ctx, env, then_branch)?
            match else_branch:
                Some(ElseBranch::Else(block)) => scan_block(ctx, env, block)?
                _ => pass
            Ok(ResolvedType::Unknown)
        
        Expr::Await(inner, _) =>
            scan_expr(ctx, env, inner)
        
        _ => Ok(ResolvedType::Unknown)

// =============================================================================
// Async Function Lowering (State Machine Transformation)
// =============================================================================

/// Await point in async function
struct AwaitPoint:
    awaited_expr: Expr
    result_binding: Option<String>
    index: Int

/// Code segment between await points
struct CodeSegment:
    stmts_before: Array<Stmt>
    await_point: Option<AwaitPoint>
    ends_with_return: Bool

/// Lower an async function to a state machine
fn lower_async_fn(ctx: MonoContext, func: TypedFunction) -> Result<TypedFunction, KoreError>:
    let state_machine_name = func.ast.name + "_Future"
    
    // 1. Create state machine struct
    var fields: Map<String, ResolvedType> = Map::new()
    fields["state"] = ResolvedType::Int(IntSize::I64)
    
    // Capture function arguments
    for param in func.ast.params:
        match resolve_ast_type(param.ty):
            Ok(t) => fields[param.name] = t
            Err(_) => fields[param.name] = ResolvedType::Unknown
    
    // Capture local variables
    let locals = collect_locals(func.ast.body)
    for (name, ty) in locals:
        if !contains_key(fields, name):
            fields[name] = ty
    
    // Register struct
    ctx.structs[state_machine_name] = fields
    
    // Emit struct definition
    var struct_fields: Array<Field> = []
    for (name, ty) in fields:
        push(struct_fields, Field {
            name: name,
            ty: resolved_to_ast_type(ty, func.ast.span),
            visibility: Visibility::Public,
            default: None,
            weak: false,
            span: func.ast.span
        })
    
    let struct_def = TypedItem::Struct(TypedStruct {
        ast: Struct {
            name: state_machine_name,
            generics: [],
            fields: struct_fields,
            visibility: Visibility::Public,
            span: func.ast.span
        },
        field_types: fields
    })
    push(ctx.concrete_items, struct_def)
    
    // 2. Collect await points
    let await_points = collect_await_points(func.ast.body)
    
    // Add storage fields for await futures
    for await_pt in await_points:
        let field_name = "_await_" + str(await_pt.index)
        fields[field_name] = ResolvedType::Unknown
        let res_name = "_await_" + str(await_pt.index) + "_result"
        fields[res_name] = ResolvedType::Unknown
    
    ctx.structs[state_machine_name] = fields
    
    // 3. Generate poll function
    let poll_name = state_machine_name + "_poll"
    let self_type = ResolvedType::Struct(state_machine_name, fields)
    
    let self_param = Param {
        name: "self",
        ty: resolved_to_ast_type(self_type, func.ast.span),
        mutable: true,
        default: None,
        span: func.ast.span
    }
    
    // Generate match arms for each state
    var arms: Array<MatchArm> = []
    
    if len(await_points) == 0:
        // No awaits - execute everything in state 0
        var rewritten_body = clone(func.ast.body)
        rewrite_access_to_self(rewritten_body, fields)
        let body_with_ready = wrap_return_in_poll_ready(rewritten_body, func.ast.span)
        
        push(arms, MatchArm {
            pattern: Pattern::Literal(Expr::Int(0, func.ast.span)),
            guard: None,
            body: body_with_ready,
            span: func.ast.span
        })
    else:
        // Has awaits - generate state machine
        let segments = split_at_awaits(func.ast.body, await_points)
        
        for i in range(0, len(segments)):
            let arm = generate_state_arm(i, segments[i], await_points, fields, state_machine_name, func.ast.span)
            push(arms, arm)
    
    // Wildcard arm for invalid states
    push(arms, MatchArm {
        pattern: Pattern::Wildcard(func.ast.span),
        guard: None,
        body: Expr::Call(
            Expr::Ident("panic", func.ast.span),
            [CallArg { name: None, value: Expr::String("polled after completion", func.ast.span), span: func.ast.span }],
            func.ast.span
        ),
        span: func.ast.span
    })
    
    // Build poll body
    let match_expr = Expr::Match(
        Expr::Field(Expr::Ident("self", func.ast.span), "state", func.ast.span),
        arms,
        func.ast.span
    )
    
    let poll_body = Block {
        stmts: [Stmt::Expr(match_expr, func.ast.span)],
        span: func.ast.span
    }
    
    let poll_fn = TypedItem::Function(TypedFunction {
        ast: Function {
            name: poll_name,
            generics: [],
            params: [self_param],
            return_type: None,
            effects: [],
            body: poll_body,
            visibility: Visibility::Public,
            span: func.ast.span
        },
        resolved_type: ResolvedType::Function([self_type], ResolvedType::Unit, EffectSet::new()),
        effects: EffectSet::new()
    })
    push(ctx.concrete_items, poll_fn)
    
    // 4. Rewrite original function to return Future struct
    var entry_fn = clone(func)
    
    // Build struct initialization
    var init_fields: Array<(String, Expr)> = []
    push(init_fields, ("state", Expr::Int(0, func.ast.span)))
    
    for param in func.ast.params:
        push(init_fields, (param.name, Expr::Ident(param.name, func.ast.span)))
    
    for await_pt in await_points:
        push(init_fields, ("_await_" + str(await_pt.index), Expr::None(func.ast.span)))
        push(init_fields, ("_await_" + str(await_pt.index) + "_result", Expr::None(func.ast.span)))
    
    for (name, _) in locals:
        if !any(func.ast.params, |p| p.name == name):
            push(init_fields, (name, Expr::None(func.ast.span)))
    
    let struct_init = Expr::Struct(state_machine_name, init_fields, func.ast.span)
    
    entry_fn.ast.body = Block {
        stmts: [Stmt::Return(Some(struct_init), func.ast.span)],
        span: func.ast.span
    }
    
    // Update return type
    match func.resolved_type:
        ResolvedType::Function(params, _, _) =>
            entry_fn.resolved_type = ResolvedType::Function(
                params,
                ResolvedType::Struct(state_machine_name, fields),
                EffectSet::new()
            )
        _ => pass
    
    // Clear async effect
    entry_fn.effects = EffectSet::new()
    
    return Ok(entry_fn)

// =============================================================================
// Async Helpers
// =============================================================================

fn collect_await_points(block: Block) -> Array<AwaitPoint>:
    var points: Array<AwaitPoint> = []
    collect_awaits_from_block(block, points)
    return points

fn collect_awaits_from_block(block: Block, points: Array<AwaitPoint>) -> Unit:
    for stmt in block.stmts:
        collect_awaits_from_stmt(stmt, points)

fn collect_awaits_from_stmt(stmt: Stmt, points: Array<AwaitPoint>) -> Unit:
    match stmt:
        Stmt::Let(Pattern::Binding(name, _, _), _, Some(Expr::Await(inner, _)), _) =>
            push(points, AwaitPoint {
                awaited_expr: inner,
                result_binding: Some(name),
                index: len(points)
            })
        
        Stmt::Expr(Expr::Await(inner, _), _) =>
            push(points, AwaitPoint {
                awaited_expr: inner,
                result_binding: None,
                index: len(points)
            })
        
        Stmt::Return(Some(Expr::Await(inner, _)), _) =>
            push(points, AwaitPoint {
                awaited_expr: inner,
                result_binding: None,
                index: len(points)
            })
        
        Stmt::While(_, body, _) => collect_awaits_from_block(body, points)
        Stmt::For(_, _, body, _) => collect_awaits_from_block(body, points)
        Stmt::Expr(Expr::Block(block, _), _) => collect_awaits_from_block(block, points)
        
        _ => pass

fn split_at_awaits(block: Block, await_points: Array<AwaitPoint>) -> Array<CodeSegment>:
    var segments: Array<CodeSegment> = []
    var current_stmts: Array<Stmt> = []
    var await_idx = 0
    
    for stmt in block.stmts:
        let contains_await = match stmt:
            Stmt::Let(_, _, Some(Expr::Await(_, _)), _) => true
            Stmt::Expr(Expr::Await(_, _), _) => true
            Stmt::Return(Some(Expr::Await(_, _)), _) => true
            _ => false
        
        if contains_await and await_idx < len(await_points):
            push(segments, CodeSegment {
                stmts_before: current_stmts,
                await_point: Some(await_points[await_idx]),
                ends_with_return: match stmt: Stmt::Return(_, _) => true, _ => false
            })
            current_stmts = []
            await_idx = await_idx + 1
        else:
            push(current_stmts, stmt)
    
    // Final segment
    if len(current_stmts) > 0 or len(segments) == 0:
        let ends_with_return = if len(current_stmts) > 0:
            match current_stmts[len(current_stmts) - 1]:
                Stmt::Return(_, _) => true
                _ => false
        else:
            false
        
        push(segments, CodeSegment {
            stmts_before: current_stmts,
            await_point: None,
            ends_with_return: ends_with_return
        })
    
    return segments

fn generate_state_arm(
    state_idx: Int,
    segment: CodeSegment,
    await_points: Array<AwaitPoint>,
    fields: Map<String, ResolvedType>,
    state_machine_name: String,
    span: Span
) -> MatchArm:
    var body_stmts: Array<Stmt> = []
    
    // If continuation state, poll the previous future
    if state_idx > 0 and state_idx <= len(await_points):
        let prev_await = await_points[state_idx - 1]
        let poll_field = "_await_" + str(prev_await.index)
        let res_field = "_await_" + str(prev_await.index) + "_result"
        
        // Build poll match
        let pending_arm = MatchArm {
            pattern: Pattern::Variant(Some("Poll"), "Pending", VariantPatternFields::Unit, span),
            guard: None,
            body: Expr::Return(Some(Expr::EnumVariant("Poll", "Pending", EnumVariantFields::Unit, span)), span),
            span: span
        }
        
        let ready_arm = MatchArm {
            pattern: Pattern::Variant(Some("Poll"), "Ready", VariantPatternFields::Tuple([Pattern::Binding("val", false, span)]), span),
            guard: None,
            body: Expr::Assign(
                Expr::Field(Expr::Ident("self", span), res_field, span),
                Expr::Ident("val", span),
                span
            ),
            span: span
        }
        
        let poll_call = Expr::MethodCall(
            Expr::Field(Expr::Ident("self", span), poll_field, span),
            "poll",
            [],
            span
        )
        
        let poll_match = Expr::Match(poll_call, [pending_arm, ready_arm], span)
        push(body_stmts, Stmt::Expr(poll_match, span))
        
        // Bind result if needed
        match prev_await.result_binding:
            Some(binding) =>
                if contains_key(fields, binding):
                    push(body_stmts, Stmt::Expr(Expr::Assign(
                        Expr::Field(Expr::Ident("self", span), binding, span),
                        Expr::Field(Expr::Ident("self", span), res_field, span),
                        span
                    ), span))
            None => pass
    
    // Add segment's statements (rewritten)
    for stmt in segment.stmts_before:
        var rewritten = clone(stmt)
        rewrite_stmt(rewritten, fields)
        push(body_stmts, rewritten)
    
    // Handle await point
    match segment.await_point:
        Some(await_point) =>
            let store_field = "_await_" + str(await_point.index)
            var awaited_expr = clone(await_point.awaited_expr)
            rewrite_expr(awaited_expr, fields)
            
            // Store the future
            push(body_stmts, Stmt::Expr(Expr::Assign(
                Expr::Field(Expr::Ident("self", span), store_field, span),
                awaited_expr,
                span
            ), span))
            
            // Increment state
            push(body_stmts, Stmt::Expr(Expr::Assign(
                Expr::Field(Expr::Ident("self", span), "state", span),
                Expr::Int(state_idx + 1, span),
                span
            ), span))
            
            // Return Pending
            push(body_stmts, Stmt::Return(
                Some(Expr::EnumVariant("Poll", "Pending", EnumVariantFields::Unit, span)),
                span
            ))
        
        None =>
            // Final state - return Ready
            if state_idx == len(await_points):
                push(body_stmts, Stmt::Return(
                    Some(Expr::EnumVariant("Poll", "Ready", EnumVariantFields::Tuple([Expr::None(span)]), span)),
                    span
                ))
    
    return MatchArm {
        pattern: Pattern::Literal(Expr::Int(state_idx, span)),
        guard: None,
        body: Expr::Block(Block { stmts: body_stmts, span: span }, span),
        span: span
    }

fn rewrite_access_to_self(block: Block, fields: Map<String, ResolvedType>) -> Unit:
    for stmt in block.stmts:
        rewrite_stmt(stmt, fields)

fn rewrite_stmt(stmt: Stmt, fields: Map<String, ResolvedType>) -> Unit:
    match stmt:
        Stmt::Expr(e, _) => rewrite_expr(e, fields)
        Stmt::Return(Some(e), _) => rewrite_expr(e, fields)
        Stmt::Let(_, _, Some(e), _) => rewrite_expr(e, fields)
        Stmt::For(_, iter, body, _) =>
            rewrite_expr(iter, fields)
            rewrite_access_to_self(body, fields)
        Stmt::While(cond, body, _) =>
            rewrite_expr(cond, fields)
            rewrite_access_to_self(body, fields)
        _ => pass

fn rewrite_expr(expr: Expr, fields: Map<String, ResolvedType>) -> Unit:
    match expr:
        Expr::Ident(name, span) =>
            if contains_key(fields, name):
                expr = Expr::Field(Expr::Ident("self", span), name, span)
        
        Expr::Binary(left, _, right, _) =>
            rewrite_expr(left, fields)
            rewrite_expr(right, fields)
        
        Expr::Call(callee, args, _) =>
            rewrite_expr(callee, fields)
            for arg in args:
                rewrite_expr(arg.value, fields)
        
        Expr::Field(object, _, _) =>
            rewrite_expr(object, fields)
        
        Expr::Await(inner, _) =>
            rewrite_expr(inner, fields)
        
        Expr::Block(b, _) =>
            rewrite_access_to_self(b, fields)
        
        _ => pass

fn wrap_return_in_poll_ready(block: Block, span: Span) -> Expr:
    for stmt in block.stmts:
        wrap_stmt_returns(stmt, span)
    return Expr::Block(block, span)

fn wrap_stmt_returns(stmt: Stmt, span: Span) -> Unit:
    match stmt:
        Stmt::Return(Some(e), s) =>
            stmt = Stmt::Return(
                Some(Expr::EnumVariant("Poll", "Ready", EnumVariantFields::Tuple([e]), span)),
                s
            )
        
        Stmt::Return(None, s) =>
            stmt = Stmt::Return(
                Some(Expr::EnumVariant("Poll", "Ready", EnumVariantFields::Tuple([Expr::None(span)]), span)),
                s
            )
        
        Stmt::While(_, body, _) =>
            for s in body.stmts:
                wrap_stmt_returns(s, span)
        
        Stmt::For(_, _, body, _) =>
            for s in body.stmts:
                wrap_stmt_returns(s, span)
        
        _ => pass

fn collect_locals(block: Block) -> Map<String, ResolvedType>:
    var locals: Map<String, ResolvedType> = Map::new()
    collect_locals_recursive(block, locals)
    return locals

fn collect_locals_recursive(block: Block, locals: Map<String, ResolvedType>) -> Unit:
    for stmt in block.stmts:
        match stmt:
            Stmt::Let(pattern, _, _, _) =>
                collect_from_pattern(pattern, locals)
            Stmt::For(_, _, body, _) =>
                collect_locals_recursive(body, locals)
            Stmt::While(_, body, _) =>
                collect_locals_recursive(body, locals)
            Stmt::Expr(Expr::Block(b, _), _) =>
                collect_locals_recursive(b, locals)
            Stmt::Expr(Expr::If(_, then_b, else_b, _), _) =>
                collect_locals_recursive(then_b, locals)
                match else_b:
                    Some(ElseBranch::Else(b)) => collect_locals_recursive(b, locals)
                    _ => pass
            _ => pass

fn collect_from_pattern(pattern: Pattern, locals: Map<String, ResolvedType>) -> Unit:
    match pattern:
        Pattern::Binding(name, _, _) =>
            locals[name] = ResolvedType::Unknown
        Pattern::Tuple(pats, _) =>
            for p in pats:
                collect_from_pattern(p, locals)
        Pattern::Struct(_, fields, _) =>
            for (_, p) in fields:
                collect_from_pattern(p, locals)
        Pattern::Variant(_, _, fields, _) =>
            match fields:
                VariantPatternFields::Tuple(pats) =>
                    for p in pats:
                        collect_from_pattern(p, locals)
                VariantPatternFields::Struct(pats) =>
                    for (_, p) in pats:
                        collect_from_pattern(p, locals)
                _ => pass
        _ => pass

fn resolved_to_ast_type(ty: ResolvedType, span: Span) -> Type:
    match ty:
        ResolvedType::Int(_) => Type::Named("Int", [], span)
        ResolvedType::Float(_) => Type::Named("Float", [], span)
        ResolvedType::Bool => Type::Named("Bool", [], span)
        ResolvedType::String => Type::Named("String", [], span)
        ResolvedType::Unit => Type::Unit(span)
        ResolvedType::Struct(name, _) => Type::Named(name, [], span)
        ResolvedType::Enum(name, _) => Type::Named(name, [], span)
        _ => Type::Named("Any", [], span)

// =============================================================================
// Placeholder Types (would be imported from other modules)
// =============================================================================

// These are stubs - real implementation imports from ast.kr, types.kr, etc.

struct Span:
    start: Int
    end: Int

struct KoreError:
    message: String
    kind: String

impl KoreError:
    pub fn type_error(msg: String) -> KoreError:
        return KoreError { message: msg, kind: "Type" }

enum ResolvedType:
    Int(IntSize)
    Float(FloatSize)
    Bool
    String
    Unit
    Unknown
    Never
    Generic(String)
    Struct(String, Map<String, ResolvedType>)
    Enum(String, Map<String, Array<ResolvedType>>)
    Array(ResolvedType, Int)
    Tuple(Array<ResolvedType>)
    Function(Array<ResolvedType>, ResolvedType, EffectSet)

enum IntSize:
    I8
    I16
    I32
    I64

enum FloatSize:
    F32
    F64

struct EffectSet:
    effects: Set<Effect>

impl EffectSet:
    pub fn new() -> EffectSet:
        return EffectSet { effects: Set::new() }
    
    pub fn contains(self, effect: Effect) -> Bool:
        return self.effects.contains(effect)

enum Effect:
    IO
    Async
    GPU

// Additional stubs for TypedItem, TypedFunction, etc...
// (Would import from types module)
