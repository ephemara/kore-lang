//! USF Code Generation - KORE to Unreal Shader Format
//! Generates UE5-compatible .usf/.ush files for compute and pixel shaders
//! 
//! Key UE5 patterns supported:
//! - #include "/Engine/Public/Platform.ush" headers
//! - RWTexture2D UAV bindings for compute outputs
//! - [numthreads] compute dispatch
//! - SHADER_PARAMETER_STRUCT compatible parameter layout

use crate::types::{TypedProgram, TypedItem, TypedShader};
use crate::error::{KoreResult, KoreError};
use crate::ast::{Type, ShaderStage, Expr, Stmt, Block, BinaryOp, Pattern};
use std::collections::HashMap;

/// Generate USF code from typed KORE program
pub fn generate(program: &TypedProgram) -> KoreResult<String> {
    let mut output = String::new();
    
    // UE5 header
    output.push_str("// Generated by KORE Compiler - Unreal Shader Format\n");
    output.push_str("// Compatible with UE5 SHADER_PARAMETER_STRUCT bindings\n\n");
    output.push_str("#include \"/Engine/Public/Platform.ush\"\n\n");
    
    for item in &program.items {
        if let TypedItem::Shader(shader) = item {
            output.push_str(&emit_shader(shader)?);
        }
    }
    
    Ok(output)
}

struct USFContext {
    vars: HashMap<String, String>,
    indent_level: usize,
    uniform_bindings: Vec<(String, String, u32)>,
}

impl USFContext {
    fn new() -> Self {
        Self {
            vars: HashMap::new(),
            indent_level: 0,
            uniform_bindings: Vec::new(),
        }
    }
    
    fn indent(&self) -> String {
        "    ".repeat(self.indent_level)
    }
    
    fn push_indent(&mut self) {
        self.indent_level += 1;
    }
    
    fn pop_indent(&mut self) {
        if self.indent_level > 0 {
            self.indent_level -= 1;
        }
    }
}

fn emit_shader(shader: &TypedShader) -> KoreResult<String> {
    let mut output = String::new();
    let mut ctx = USFContext::new();
    
    // Collect uniforms 
    for uniform in &shader.ast.uniforms {
        let usf_type = map_type_to_usf(&uniform.ty);
        ctx.uniform_bindings.push((uniform.name.clone(), usf_type, uniform.binding));
    }
    
    // Categorize uniform types
    let mut texture_inputs = Vec::new();
    let mut uav_outputs = Vec::new();
    let mut scalar_params = Vec::new();
    
    for (name, ty, binding) in &ctx.uniform_bindings {
        if ty.starts_with("RWTexture") || ty.starts_with("RWBuffer") || ty.starts_with("RWStructuredBuffer") {
            uav_outputs.push((name.clone(), ty.clone(), *binding));
        } else if ty.contains("Texture") {
            texture_inputs.push((name.clone(), ty.clone(), *binding));
        } else {
            scalar_params.push((name.clone(), ty.clone(), *binding));
        }
    }
    
    // Emit scalar parameters (C++ bindable via SHADER_PARAMETER)
    if !scalar_params.is_empty() {
        output.push_str("// Scalar Parameters - Bind via SHADER_PARAMETER_STRUCT\n");
        for (name, ty, _) in &scalar_params {
            output.push_str(&format!("{} {};\n", ty, name));
        }
        output.push_str("\n");
    }
    
    // Emit texture inputs with samplers
    if !texture_inputs.is_empty() {
        output.push_str("// Texture Inputs\n");
        for (name, ty, binding) in &texture_inputs {
            output.push_str(&format!("{} {} : register(t{});\n", ty, name, binding));
            output.push_str(&format!("SamplerState {}Sampler : register(s{});\n", name, binding));
        }
        output.push_str("\n");
    }
    
    // Emit UAV outputs
    if !uav_outputs.is_empty() {
        output.push_str("// UAV Outputs\n");
        for (name, ty, binding) in &uav_outputs {
            output.push_str(&format!("{} {} : register(u{});\n", ty, name, binding));
        }
        output.push_str("\n");
    }
    
    match shader.ast.stage {
        ShaderStage::Compute => {
            // Compute shader with UE5 conventions
            output.push_str("[numthreads(8, 8, 1)]\n");
            output.push_str(&format!("void {}CS(uint3 ThreadId : SV_DispatchThreadID)\n{{\n", 
                capitalize_first(&shader.ast.name)));
            ctx.push_indent();
            
            // UE5 convention: early-out for out-of-bounds threads
            output.push_str(&format!("{}// Early-out for bounds check\n", ctx.indent()));
            
            // Add compute builtins to context
            ctx.vars.insert("thread_id".to_string(), "ThreadId".to_string());
            ctx.vars.insert("dispatch_thread_id".to_string(), "ThreadId".to_string());
            
            let body_code = emit_block(&mut ctx, &shader.ast.body)?;
            output.push_str(&body_code);
            
            ctx.pop_indent();
            output.push_str("}\n");
        },
        ShaderStage::Fragment => {
            // Pixel shader for UE5
            output.push_str("struct FPSInput\n{\n");
            for (i, param) in shader.ast.inputs.iter().enumerate() {
                let usf_type = map_type_to_usf(&param.ty);
                output.push_str(&format!("    {} {} : TEXCOORD{};\n", usf_type, param.name, i));
            }
            output.push_str("};\n\n");
            
            // Output struct
            let out_type = map_type_to_usf(&shader.ast.outputs);
            output.push_str("struct FPSOutput\n{\n");
            output.push_str(&format!("    {} Color : SV_Target0;\n", out_type));
            output.push_str("};\n\n");
            
            // Main function
            output.push_str(&format!("FPSOutput {}PS(FPSInput Input)\n{{\n", 
                capitalize_first(&shader.ast.name)));
            ctx.push_indent();
            
            for param in &shader.ast.inputs {
                ctx.vars.insert(param.name.clone(), format!("Input.{}", param.name));
            }
            
            let body_code = emit_block(&mut ctx, &shader.ast.body)?;
            output.push_str(&body_code);
            
            ctx.pop_indent();
            output.push_str("}\n");
        },
        ShaderStage::Vertex => {
            // Vertex shader
            output.push_str("struct FVSInput\n{\n");
            for (i, param) in shader.ast.inputs.iter().enumerate() {
                let usf_type = map_type_to_usf(&param.ty);
                let semantic = match param.name.as_str() {
                    "position" => "POSITION",
                    "normal" => "NORMAL",
                    "tangent" => "TANGENT",
                    "color" => "COLOR",
                    _ => "TEXCOORD",
                };
                let idx = if semantic == "TEXCOORD" { i.to_string() } else { String::new() };
                output.push_str(&format!("    {} {} : {}{};\n", usf_type, param.name, semantic, idx));
            }
            output.push_str("};\n\n");
            
            output.push_str("struct FVSOutput\n{\n");
            output.push_str("    float4 Position : SV_Position;\n");
            output.push_str("};\n\n");
            
            output.push_str(&format!("FVSOutput {}VS(FVSInput Input)\n{{\n", 
                capitalize_first(&shader.ast.name)));
            ctx.push_indent();
            
            for param in &shader.ast.inputs {
                ctx.vars.insert(param.name.clone(), format!("Input.{}", param.name));
            }
            
            let body_code = emit_block(&mut ctx, &shader.ast.body)?;
            output.push_str(&body_code);
            
            ctx.pop_indent();
            output.push_str("}\n");
        },
    }
    
    Ok(output)
}

fn emit_block(ctx: &mut USFContext, block: &Block) -> KoreResult<String> {
    let mut output = String::new();
    for stmt in &block.stmts {
        output.push_str(&emit_stmt(ctx, stmt)?);
    }
    Ok(output)
}

fn emit_stmt(ctx: &mut USFContext, stmt: &Stmt) -> KoreResult<String> {
    let mut output = String::new();
    
    match stmt {
        Stmt::Let { pattern, value, .. } => {
            if let Some(value) = value {
                if let Pattern::Binding { name, .. } = pattern {
                    let (expr_code, expr_type) = emit_expr(ctx, value)?;
                    output.push_str(&format!("{}{} {} = {};\n", ctx.indent(), expr_type, name, expr_code));
                    ctx.vars.insert(name.clone(), name.clone());
                }
            }
        },
        Stmt::Return(Some(expr), _) => {
            let (expr_code, _) = emit_expr(ctx, expr)?;
            output.push_str(&format!("{}FPSOutput _Result;\n", ctx.indent()));
            output.push_str(&format!("{}_Result.Color = {};\n", ctx.indent(), expr_code));
            output.push_str(&format!("{}return _Result;\n", ctx.indent()));
        },
        Stmt::Return(None, _) => {
            output.push_str(&format!("{}return;\n", ctx.indent()));
        },
        Stmt::Expr(expr) => {
            let (expr_code, _) = emit_expr(ctx, expr)?;
            output.push_str(&format!("{}{};\n", ctx.indent(), expr_code));
        },
        Stmt::While { condition, body, .. } => {
            let (cond_code, _) = emit_expr(ctx, condition)?;
            output.push_str(&format!("{}while ({})\n", ctx.indent(), cond_code));
            output.push_str(&format!("{}{{\n", ctx.indent()));
            ctx.push_indent();
            output.push_str(&emit_block(ctx, body)?);
            ctx.pop_indent();
            output.push_str(&format!("{}}}\n", ctx.indent()));
        },
        Stmt::For { binding, iter: _, body, .. } => {
            if let Pattern::Binding { name, .. } = binding {
                output.push_str(&format!("{}for (int {} = 0; {} < 10; {}++)\n", 
                    ctx.indent(), name, name, name));
                output.push_str(&format!("{}{{\n", ctx.indent()));
                ctx.push_indent();
                ctx.vars.insert(name.clone(), name.clone());
                output.push_str(&emit_block(ctx, body)?);
                ctx.pop_indent();
                output.push_str(&format!("{}}}\n", ctx.indent()));
            }
        },
        Stmt::Break(_, _) => {
            output.push_str(&format!("{}break;\n", ctx.indent()));
        },
        Stmt::Continue(_) => {
            output.push_str(&format!("{}continue;\n", ctx.indent()));
        },
        _ => {}
    }
    
    Ok(output)
}

fn emit_expr(ctx: &mut USFContext, expr: &Expr) -> KoreResult<(String, String)> {
    match expr {
        Expr::Ident(name, _) => {
            if let Some(mapped) = ctx.vars.get(name) {
                Ok((mapped.clone(), "float4".to_string()))
            } else {
                Ok((name.clone(), "float4".to_string()))
            }
        },
        Expr::Float(f, _) => {
            Ok((format!("{:.6}", f), "float".to_string()))
        },
        Expr::Int(i, _) => {
            Ok((format!("{}", i), "int".to_string()))
        },
        Expr::Bool(b, _) => {
            Ok((format!("{}", b), "bool".to_string()))
        },
        Expr::String(s, _) => {
            Ok((format!("\"{}\"", s), "string".to_string()))
        },
        Expr::Binary { left, op, right, .. } => {
            let (left_code, left_ty) = emit_expr(ctx, left)?;
            let (right_code, _) = emit_expr(ctx, right)?;
            
            let op_str = match op {
                BinaryOp::Add => "+",
                BinaryOp::Sub => "-",
                BinaryOp::Mul => "*",
                BinaryOp::Div => "/",
                BinaryOp::Mod => "%",
                BinaryOp::Eq => "==",
                BinaryOp::Ne => "!=",
                BinaryOp::Lt => "<",
                BinaryOp::Le => "<=",
                BinaryOp::Gt => ">",
                BinaryOp::Ge => ">=",
                BinaryOp::And => "&&",
                BinaryOp::Or => "||",
                BinaryOp::BitAnd => "&",
                BinaryOp::BitOr => "|",
                BinaryOp::BitXor => "^",
                BinaryOp::Shl => "<<",
                BinaryOp::Shr => ">>",
                _ => return Err(KoreError::codegen("Unsupported binary op in USF", expr.span())),
            };
            
            let result_ty = match op {
                BinaryOp::Eq | BinaryOp::Ne | BinaryOp::Lt | BinaryOp::Le | 
                BinaryOp::Gt | BinaryOp::Ge | BinaryOp::And | BinaryOp::Or => "bool".to_string(),
                _ => left_ty,
            };
            
            Ok((format!("({} {} {})", left_code, op_str, right_code), result_ty))
        },
        Expr::Unary { op, operand, .. } => {
            let (operand_code, ty) = emit_expr(ctx, operand)?;
            let op_str = match op {
                crate::ast::UnaryOp::Neg => "-",
                crate::ast::UnaryOp::Not => "!",
                crate::ast::UnaryOp::BitNot => "~",
                crate::ast::UnaryOp::Ref | crate::ast::UnaryOp::RefMut => {
                    return Ok((operand_code, ty));
                },
                crate::ast::UnaryOp::Deref => {
                    return Ok((operand_code, ty));
                },
            };
            Ok((format!("({}{})", op_str, operand_code), ty))
        },
        Expr::Call { callee, args, .. } => {
            if let Expr::Ident(name, _) = &**callee {
                emit_function_call(ctx, name, args)
            } else {
                Err(KoreError::codegen("Complex callee not supported in USF", expr.span()))
            }
        },
        Expr::Field { object, field, .. } => {
            let (obj_code, _) = emit_expr(ctx, object)?;
            Ok((format!("{}.{}", obj_code, field), infer_swizzle_type(field)))
        },
        Expr::Index { object, index, .. } => {
            let (obj_code, obj_ty) = emit_expr(ctx, object)?;
            let (idx_code, _) = emit_expr(ctx, index)?;
            let elem_ty = if obj_ty.starts_with("float") { "float".to_string() } else { obj_ty };
            Ok((format!("{}[{}]", obj_code, idx_code), elem_ty))
        },
        Expr::If { condition, then_branch, else_branch, .. } => {
            let (cond_code, _) = emit_expr(ctx, condition)?;
            
            if then_branch.stmts.len() == 1 && else_branch.is_some() {
                if let Stmt::Expr(then_expr) = &then_branch.stmts[0] {
                    let (then_code, then_ty) = emit_expr(ctx, then_expr)?;
                    
                    if let Some(crate::ast::ElseBranch::Else(else_block)) = else_branch.as_ref().map(|b| b.as_ref()) {
                        if else_block.stmts.len() == 1 {
                            if let Stmt::Expr(else_expr) = &else_block.stmts[0] {
                                let (else_code, _) = emit_expr(ctx, else_expr)?;
                                return Ok((format!("({} ? {} : {})", cond_code, then_code, else_code), then_ty));
                            }
                        }
                    }
                }
            }
            
            Err(KoreError::codegen("Complex if not yet supported in USF", expr.span()))
        },
        Expr::Paren(inner, _) => {
            let (inner_code, ty) = emit_expr(ctx, inner)?;
            Ok((format!("({})", inner_code), ty))
        },
        _ => Err(KoreError::codegen("Unsupported expression in USF", expr.span())),
    }
}

fn emit_function_call(ctx: &mut USFContext, name: &str, args: &[crate::ast::CallArg]) -> KoreResult<(String, String)> {
    match name {
        // Vector constructors
        "vec2" | "Vec2" => {
            let mut arg_codes = Vec::new();
            for arg in args {
                let (code, _) = emit_expr(ctx, &arg.value)?;
                arg_codes.push(code);
            }
            Ok((format!("float2({})", arg_codes.join(", ")), "float2".to_string()))
        },
        "vec3" | "Vec3" => {
            let mut arg_codes = Vec::new();
            for arg in args {
                let (code, _) = emit_expr(ctx, &arg.value)?;
                arg_codes.push(code);
            }
            Ok((format!("float3({})", arg_codes.join(", ")), "float3".to_string()))
        },
        "vec4" | "Vec4" => {
            let mut arg_codes = Vec::new();
            for arg in args {
                let (code, _) = emit_expr(ctx, &arg.value)?;
                arg_codes.push(code);
            }
            Ok((format!("float4({})", arg_codes.join(", ")), "float4".to_string()))
        },
        
        // Math intrinsics - direct pass-through
        "sin" | "cos" | "tan" | "asin" | "acos" | "atan" | 
        "abs" | "floor" | "ceil" | "round" | "trunc" | "sqrt" | "rsqrt" |
        "exp" | "exp2" | "log" | "log2" | "log10" | "sign" | "saturate" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("{}({})", name, arg_code), ty))
        },
        "fract" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("frac({})", arg_code), ty))
        },
        
        // Two-arg math
        "pow" | "min" | "max" | "fmod" | "step" | "atan2" | "distance" => {
            let (arg1, ty) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            let ret_ty = if name == "distance" { "float".to_string() } else { ty };
            Ok((format!("{}({}, {})", name, arg1, arg2), ret_ty))
        },
        
        // Three-arg math
        "clamp" | "smoothstep" | "mad" => {
            let (arg1, ty) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            let (arg3, _) = emit_expr(ctx, &args[2].value)?;
            Ok((format!("{}({}, {}, {})", name, arg1, arg2, arg3), ty))
        },
        "mix" | "lerp" => {
            let (arg1, ty) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            let (arg3, _) = emit_expr(ctx, &args[2].value)?;
            Ok((format!("lerp({}, {}, {})", arg1, arg2, arg3), ty))
        },
        
        // Vector ops
        "length" => {
            let (arg_code, _) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("length({})", arg_code), "float".to_string()))
        },
        "normalize" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("normalize({})", arg_code), ty))
        },
        "dot" => {
            let (arg1, _) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("dot({}, {})", arg1, arg2), "float".to_string()))
        },
        "cross" => {
            let (arg1, ty) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("cross({}, {})", arg1, arg2), ty))
        },
        "reflect" | "refract" => {
            let (arg1, ty) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            if name == "refract" && args.len() > 2 {
                let (arg3, _) = emit_expr(ctx, &args[2].value)?;
                Ok((format!("refract({}, {}, {})", arg1, arg2, arg3), ty))
            } else {
                Ok((format!("{}({}, {})", name, arg1, arg2), ty))
            }
        },
        
        // Texture sampling - UE5 style with separate sampler
        "sample" => {
            let (texture, _) = emit_expr(ctx, &args[0].value)?;
            let (coords, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("{}.Sample({}Sampler, {})", texture, texture, coords), "float4".to_string()))
        },
        "sample_lod" | "SampleLevel" => {
            let (texture, _) = emit_expr(ctx, &args[0].value)?;
            let (coords, _) = emit_expr(ctx, &args[1].value)?;
            let (lod, _) = emit_expr(ctx, &args[2].value)?;
            Ok((format!("{}.SampleLevel({}Sampler, {}, {})", texture, texture, coords, lod), "float4".to_string()))
        },
        "load" | "Load" => {
            let (texture, _) = emit_expr(ctx, &args[0].value)?;
            let (location, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("{}.Load(int3({}, 0))", texture, location), "float4".to_string()))
        },
        
        // UAV store operations (compute shaders)
        "store" => {
            let (uav, _) = emit_expr(ctx, &args[0].value)?;
            let (coord, _) = emit_expr(ctx, &args[1].value)?;
            let (value, _) = emit_expr(ctx, &args[2].value)?;
            Ok((format!("{}[{}] = {}", uav, coord, value), "void".to_string()))
        },
        
        // Atomics for compute
        "atomic_add" => {
            let (uav, _) = emit_expr(ctx, &args[0].value)?;
            let (value, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("InterlockedAdd({}, {})", uav, value), "void".to_string()))
        },
        "atomic_min" | "atomic_max" => {
            let hlsl_name = if name == "atomic_min" { "InterlockedMin" } else { "InterlockedMax" };
            let (uav, _) = emit_expr(ctx, &args[0].value)?;
            let (value, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("{}({}, {})", hlsl_name, uav, value), "void".to_string()))
        },
        
        // Barrier for compute
        "barrier" | "GroupMemoryBarrierWithGroupSync" => {
            Ok(("GroupMemoryBarrierWithGroupSync()".to_string(), "void".to_string()))
        },
        "device_barrier" | "DeviceMemoryBarrier" => {
            Ok(("DeviceMemoryBarrier()".to_string(), "void".to_string()))
        },
        
        // UE5 luminance helper
        "GetLuminance" | "luminance" => {
            let (arg_code, _) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("dot({}, float3(0.299, 0.587, 0.114))", arg_code), "float".to_string()))
        },
        
        // Fallback for unknown functions
        _ => {
            let mut arg_codes = Vec::new();
            for arg in args {
                let (code, _) = emit_expr(ctx, &arg.value)?;
                arg_codes.push(code);
            }
            Ok((format!("{}({})", name, arg_codes.join(", ")), "float4".to_string()))
        },
    }
}

fn map_type_to_usf(ty: &Type) -> String {
    match ty {
        Type::Named { name, .. } => match name.as_str() {
            "Float" | "f32" => "float".to_string(),
            "Double" | "f64" => "double".to_string(),
            "Int" | "i32" => "int".to_string(),
            "UInt" | "u32" => "uint".to_string(),
            "Bool" => "bool".to_string(),
            "Vec2" => "float2".to_string(),
            "Vec3" => "float3".to_string(),
            "Vec4" => "float4".to_string(),
            "IVec2" => "int2".to_string(),
            "IVec3" => "int3".to_string(),
            "IVec4" => "int4".to_string(),
            "UVec2" => "uint2".to_string(),
            "UVec3" => "uint3".to_string(),
            "UVec4" => "uint4".to_string(),
            "Mat2" => "float2x2".to_string(),
            "Mat3" => "float3x3".to_string(),
            "Mat4" => "float4x4".to_string(),
            "Sampler2D" => "Texture2D<float4>".to_string(),
            "Sampler3D" => "Texture3D<float4>".to_string(),
            "SamplerCube" => "TextureCube<float4>".to_string(),
            "Image2D" => "RWTexture2D<float4>".to_string(),
            "Image3D" => "RWTexture3D<float4>".to_string(),
            "RWTexture2D" => "RWTexture2D<float4>".to_string(),
            "RWTexture2D_Float" => "RWTexture2D<float>".to_string(),
            "RWTexture2D_Float2" => "RWTexture2D<float2>".to_string(),
            "RWTexture2D_Float3" => "RWTexture2D<float3>".to_string(),
            "RWTexture2D_Int" => "RWTexture2D<int>".to_string(),
            "RWTexture2D_UInt" => "RWTexture2D<uint>".to_string(),
            "StructuredBuffer" => "StructuredBuffer<float4>".to_string(),
            "RWStructuredBuffer" => "RWStructuredBuffer<float4>".to_string(),
            _ => name.clone(),
        },
        _ => "float4".to_string(),
    }
}

fn infer_swizzle_type(swizzle: &str) -> String {
    match swizzle.len() {
        1 => "float".to_string(),
        2 => "float2".to_string(),
        3 => "float3".to_string(),
        4 => "float4".to_string(),
        _ => "float".to_string(),
    }
}

fn capitalize_first(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
    }
}
