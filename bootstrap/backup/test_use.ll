; KORE Compiler Output - LLVM IR
; Generated by Project Ouroboros
; Compile with: clang output.ll kore_runtime.o -o output

target triple = "x86_64-pc-windows-msvc"

; External Runtime Functions
declare i8* @malloc(i64)
declare void @free(i8*)
declare i32 @printf(i8*, ...)
declare i32 @puts(i8*)

; Kore Runtime
declare void @kore_print_i64(i64)
declare void @kore_print_str(i8*)
declare void @kore_println_str(i8*)
declare i8* @kore_str_concat(i8*, i8*)
declare i64 @kore_array_new()
declare i64 @kore_array_push(i64, i64)
declare i64 @kore_array_pop(i64)
declare i64 @kore_array_get(i64, i64)
declare i64 @kore_array_len(i64)

; Kore Stdlib
declare i64 @kore_len(i64)
declare i64 @kore_str_len(i64)
declare i64 @kore_split(i64, i64)
declare i64 @kore_contains(i64, i64)
declare i64 @kore_ord(i64)
declare i64 @kore_to_int(i64)
declare i64 @kore_to_float(i64)
declare i64 @kore_to_string(i64)
declare i64 @kore_range(i64, i64)
declare i64 @kore_slice(i64, i64, i64)
declare i64 @kore_char_at(i64, i64)
declare i64 @kore_substring(i64, i64, i64)
declare i64 @kore_str_eq(i64, i64)
declare i64 @kore_append(i64, i64)
declare i64 @kore_add_op(i64, i64)

; Direct Main Wrappers
declare i64 @args()
declare void @exit(i64)
declare i64 @read_file(i64)
declare i64 @write_file(i64, i64)
declare i64 @substring(i64, i64, i64)
declare i64 @replace(i64, i64, i64)
declare i64 @starts_with(i64, i64)

; Built-in generic types (used as opaque pointers)
%Box = type { i64, i64 }
%Array = type { i64 }
%Option = type { i64, i8*, i8* }
%Vec = type { i64 }
%StringBuilder = type { i64 }
%Result = type { i64, i8*, i8* }
%HashMap = type { i64 }
%HashSet = type { i64 }
%Map = type { i64 }
%Set = type { i64 }

; Option/Box helpers
declare i64 @kore_some(i64)
declare i64 @kore_none()
declare i64 @kore_box(i64)
declare i64 @kore_unwrap(i64)
declare void @kore_panic(i64)

; Map/Variant helpers
declare i64 @kore_contains_key(i64, i64)
declare i64 @kore_join(i64, i64)
declare i64 @kore_peek(i64)
declare i64 @kore_peek_offset(i64, i64)
declare i64 @kore_variant_of(i64)
declare i64 @kore_variant_field(i64, i64)
declare i64 @Map_new()
declare void @kore_map_set(i64, i64, i64)
declare i64 @kore_map_get(i64, i64)

define i64 @main_kore() {
  entry:
  ; enum variant: Span::new
  %t0 = call i8* @malloc(i64 24)
  %t1 = bitcast i8* %t0 to %Span*
  %t2 = getelementptr %Span, %Span* %t1, i32 0, i32 0
  store i64 0, i64* %t2
  %t3 = call i8* @malloc(i64 16)
  %t4 = bitcast i8* %t3 to i64*
  %t5 = getelementptr i64, i64* %t4, i32 0
  store i64 0, i64* %t5
  %t6 = getelementptr i64, i64* %t4, i32 1
  store i64 10, i64* %t6
  %t7 = getelementptr %Span, %Span* %t1, i32 0, i32 1
  store i8* %t3, i8** %t7
  %t8 = getelementptr %Span, %Span* %t1, i32 0, i32 2
  %t9 = getelementptr [4 x i8], [4 x i8]* @.str.0, i64 0, i64 0
  store i8* %t9, i8** %t8
  %t10 = ptrtoint %Span* %t1 to i64
  %t11 = alloca i64
  store i64 %t10, i64* %t11
  %t12 = load i64, i64* %t11
  %t13 = inttoptr i64 %t12 to %Span*
  ; field access failed for .start
  call void @kore_print_i64(i64 0)
  ret i64 0
}

; String Constants
@.str.0 = private unnamed_addr constant [4 x i8] c"new\00"
