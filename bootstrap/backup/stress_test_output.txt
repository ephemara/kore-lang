.\kore_native.exe : Starting...\nCalling main_kore()...\n[array_len] ptr=3012880811472 len=4
At line:1 char:1
+ .\kore_native.exe ..\examples\stress_test.kr -o stress_test.ll 2>&1 | ...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (Starting...\nCa...880811472 len=4:String) [], RemoteException
    + FullyQualifiedErrorId : NativeCommandError
 
[array_len] ptr=3012880811632 len=4
[array_len] ptr=3012880811632 len=4
[array_len] ptr=3012880811632 len=4
[array_len] ptr=3012880811632 len=4
[array_len] ptr=3012880811632 len=4
[array_len] ptr=3012880811632 len=4
[array_len] ptr=3012880811632 len=4
[array_len] ptr=3012880811632 len=4
[array_len] ptr=3012880811632 len=4
[array_len] ptr=3012880811632 len=4
[file_read] Reading '..\examples\stress_test.kr'
[file_read] Size: 4342
debug: calling new
debug: created parser
3012880774304
debug: creating lexer
[file_read] Read 4342 bytes
debug: Lexer::new start
[str_concat] 'debug: read file done. source len: ' + '4342'
[split] str_ptr=3012880822048 delim_ptr=140696752175192
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0
debug: Lexer::new split done
debug: tokenizing...
debug: looping tokenize...
debug: next_token start

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880811696
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880811088
[array_len] ptr=3012880811088 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:
debug: got token

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

debug: got token
    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880810384
[array_len] ptr=3012880810384 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880811216
[array_len] ptr=3012880811216 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880811440
[array_len] ptr=3012880811440 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880811504
[array_len] ptr=3012880811504 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880857568
[array_len] ptr=3012880857568 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880858208
[array_len] ptr=3012880858208 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880858656
[array_len] ptr=3012880858656 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880857024
[array_len] ptr=3012880857024 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880857856
[array_len] ptr=3012880857856 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int
debug: got token
debug: looping tokenize...
debug: next_token start



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880857728
[array_len] ptr=3012880857728 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880857664
[array_len] ptr=3012880857664 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880857216
[array_len] ptr=3012880857216 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880857504
[array_len] ptr=3012880857504 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

debug: got token
fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175566
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880858688
[array_len] ptr=3012880858688 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880858016
[array_len] ptr=3012880858016 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880858080
[array_len] ptr=3012880858080 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175686
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012880857280
[array_len] ptr=3012880857280 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '{' vs ' ' -> 0
  bytes a: 123, 0
  bytes b: 32, 0
[str_eq check] '{' vs '
' -> 0
  bytes a: 123, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '{' vs '#' -> 0
  bytes a: 123, 0
  bytes b: 35, 0
[str_eq check] '{' vs '/' -> 0
  bytes a: 123, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '{' vs '
' -> 0
  bytes a: 123, 0
  bytes b: 13, 0
[str_eq check] '{' vs '
' -> 0
  bytes a: 123, 0
  bytes b: 10, 0
[str_eq check] '{' vs '' -> 0
  bytes a: 123, 0
  bytes b: 0, 0
[str_eq check] '{' vs '' -> 0
  bytes a: 123, 0
  bytes b: 0, 43
[str_eq check] '{' vs '_' -> 0
  bytes a: 123, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '{' vs '
' -> 0
  bytes a: 123, 0
  bytes b: 10, 0
[str_eq check] '{' vs '+' -> 0
  bytes a: 123, 0
  bytes b: 43, 0
[str_eq check] '{' vs '-' -> 0
  bytes a: 123, 0
  bytes b: 45, 0
[str_eq check] '{' vs '*' -> 0
  bytes a: 123, 0
  bytes b: 42, 0
[str_eq check] '{' vs '/' -> 0
  bytes a: 123, 0
  bytes b: 47, 0
[str_eq check] '{' vs '%' -> 0
  bytes a: 123, 0
  bytes b: 37, 0
[str_eq check] '{' vs '=' -> 0
  bytes a: 123, 0
  bytes b: 61, 0
[str_eq check] '{' vs '!' -> 0
  bytes a: 123, 0
  bytes b: 33, 0
[str_eq check] '{' vs '<' -> 0
  bytes a: 123, 0
  bytes b: 60, 0
[str_eq check] '{' vs '>' -> 0
  bytes a: 123, 0
  bytes b: 62, 0
[str_eq check] '{' vs '&' -> 0
  bytes a: 123, 0
  bytes b: 38, 0
[str_eq check] '{' vs '|' -> 0
  bytes a: 123, 0
  bytes b: 124, 0
[str_eq check] '{' vs '.' -> 0
  bytes a: 123, 0
  bytes b: 46, 0
[str_eq check] '{' vs ':' -> 0
  bytes a: 123, 0
  bytes b: 58, 0
[str_eq check] '{' vs ',' -> 0
  bytes a: 123, 0
  bytes b: 44, 0
[str_eq check] '{' vs ';' -> 0
  bytes a: 123, 0
  bytes b: 59, 0
[str_eq check] '{' vs '(' -> 0
  bytes a: 123, 0
  bytes b: 40, 0
[str_eq check] '{' vs ')' -> 0
  bytes a: 123, 0
  bytes b: 41, 0
[str_eq check] '{' vs '[' -> 0
  bytes a: 123, 0
  bytes b: 91, 0
[str_eq check] '{' vs ']' -> 0
  bytes a: 123, 0
  bytes b: 93, 0
[str_eq check] '{' vs '{' -> 1
  bytes a: 123, 0
  bytes b: 123, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012886390784
[array_len] ptr=3012886390784 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

debug: got token
    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: got token
debug: looping tokenize...
debug: next_token start
    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012886390208
[array_len] ptr=3012886390208 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012886390336
[array_len] ptr=3012886390336 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175690
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012886390048
[array_len] ptr=3012886390048 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '}' vs '(' -> 0
  bytes a: 125, 0
  bytes b: 40, 0
[str_eq check] '}' vs '{' -> 0
  bytes a: 125, 0
  bytes b: 123, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012886390624
[array_len] ptr=3012886390624 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations
debug: got token
debug: looping tokenize...
debug: next_token start

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012886389344
[array_len] ptr=3012886389344 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012886389504
[array_len] ptr=3012886389504 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space


impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012886389664
[array_len] ptr=3012886389664 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012886390304
[array_len] ptr=3012886390304 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175566
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012886389376
[array_len] ptr=3012886389376 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012886389152
[array_len] ptr=3012886389152 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space


// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881732976
[array_len] ptr=3012881732976 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

debug: make_token
140696752175686
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881733008
[array_len] ptr=3012881733008 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '{' vs ' ' -> 0
  bytes a: 123, 0
  bytes b: 32, 0
[str_eq check] '{' vs '
' -> 0
  bytes a: 123, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '{' vs '#' -> 0
  bytes a: 123, 0
  bytes b: 35, 0
[str_eq check] '{' vs '/' -> 0
  bytes a: 123, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '{' vs '
' -> 0
  bytes a: 123, 0
  bytes b: 13, 0
[str_eq check] '{' vs '
' -> 0
  bytes a: 123, 0
  bytes b: 10, 0
[str_eq check] '{' vs '' -> 0
  bytes a: 123, 0
  bytes b: 0, 0
[str_eq check] '{' vs '' -> 0
  bytes a: 123, 0
  bytes b: 0, 43
[str_eq check] '{' vs '_' -> 0
  bytes a: 123, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '{' vs '
' -> 0
  bytes a: 123, 0
  bytes b: 10, 0
[str_eq check] '{' vs '+' -> 0
  bytes a: 123, 0
  bytes b: 43, 0
[str_eq check] '{' vs '-' -> 0
  bytes a: 123, 0
  bytes b: 45, 0
[str_eq check] '{' vs '*' -> 0
  bytes a: 123, 0
  bytes b: 42, 0
[str_eq check] '{' vs '/' -> 0
  bytes a: 123, 0
  bytes b: 47, 0
[str_eq check] '{' vs '%' -> 0
  bytes a: 123, 0
  bytes b: 37, 0
[str_eq check] '{' vs '=' -> 0
  bytes a: 123, 0
  bytes b: 61, 0
[str_eq check] '{' vs '!' -> 0
  bytes a: 123, 0
  bytes b: 33, 0
[str_eq check] '{' vs '<' -> 0
  bytes a: 123, 0
  bytes b: 60, 0
[str_eq check] '{' vs '>' -> 0
  bytes a: 123, 0
  bytes b: 62, 0
[str_eq check] '{' vs '&' -> 0
  bytes a: 123, 0
  bytes b: 38, 0
[str_eq check] '{' vs '|' -> 0
  bytes a: 123, 0
  bytes b: 124, 0
[str_eq check] '{' vs '.' -> 0
  bytes a: 123, 0
  bytes b: 46, 0
[str_eq check] '{' vs ':' -> 0
  bytes a: 123, 0
  bytes b: 58, 0
[str_eq check] '{' vs ',' -> 0
  bytes a: 123, 0
  bytes b: 44, 0
[str_eq check] '{' vs ';' -> 0
  bytes a: 123, 0
  bytes b: 59, 0
[str_eq check] '{' vs '(' -> 0
  bytes a: 123, 0
  bytes b: 40, 0
[str_eq check] '{' vs ')' -> 0
  bytes a: 123, 0
  bytes b: 41, 0
[str_eq check] '{' vs '[' -> 0
  bytes a: 123, 0
  bytes b: 91, 0
[str_eq check] '{' vs ']' -> 0
  bytes a: 123, 0
  bytes b: 93, 0
[str_eq check] '{' vs '{' -> 1
  bytes a: 123, 0
  bytes b: 123, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881733040
[array_len] ptr=3012881733040 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881732848
[array_len] ptr=3012881732848 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881733584
[array_len] ptr=3012881733584 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881731696
[array_len] ptr=3012881731696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881732784
[array_len] ptr=3012881732784 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881731824
[array_len] ptr=3012881731824 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881731888
[array_len] ptr=3012881731888 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start
    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881731952
[array_len] ptr=3012881731952 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

debug: got token
    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881732816
[array_len] ptr=3012881732816 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175690
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881732016
[array_len] ptr=3012881732016 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '}' vs '(' -> 0
  bytes a: 125, 0
  bytes b: 40, 0
[str_eq check] '}' vs '{' -> 0
  bytes a: 125, 0
  bytes b: 123, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881736096
[array_len] ptr=3012881736096 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881736224
[array_len] ptr=3012881736224 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



debug: make_token
fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881737600
[array_len] ptr=3012881737600 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175566
debug: got token
debug: looping tokenize...
debug: next_token start

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2
debug: skipping space



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881736512
[array_len] ptr=3012881736512 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space


fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881736960
[array_len] ptr=3012881736960 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881735904
[array_len] ptr=3012881735904 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start
// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881737664
[array_len] ptr=3012881737664 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881737376
[array_len] ptr=3012881737376 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start
    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881736832
[array_len] ptr=3012881736832 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881737280
[array_len] ptr=3012881737280 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881736896
[array_len] ptr=3012881736896 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)
debug: got token
debug: looping tokenize...
debug: next_token start

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881737024
[array_len] ptr=3012881737024 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

debug: make_token
    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start
    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012881737248
[array_len] ptr=3012881737248 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888203408
[array_len] ptr=3012888203408 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888203312
[array_len] ptr=3012888203312 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888204208
[array_len] ptr=3012888204208 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888202736
[array_len] ptr=3012888202736 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888203376
[array_len] ptr=3012888203376 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888203184
[array_len] ptr=3012888203184 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

debug: skipping space
    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888202672
[array_len] ptr=3012888202672 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

debug: got token
    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888203632
[array_len] ptr=3012888203632 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888203760
[array_len] ptr=3012888203760 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888202384
[array_len] ptr=3012888202384 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888204048
[array_len] ptr=3012888204048 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887824880
[array_len] ptr=3012887824880 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887825904
[array_len] ptr=3012887825904 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887825648
[array_len] ptr=3012887825648 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887825072
[array_len] ptr=3012887825072 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

debug: got token
debug: looping tokenize...
debug: next_token start
    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887825040
[array_len] ptr=3012887825040 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887824912
[array_len] ptr=3012887824912 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887825584
[array_len] ptr=3012887825584 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887826128
[array_len] ptr=3012887826128 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

debug: got token
    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175566
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887825168
[array_len] ptr=3012887825168 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:
debug: got token

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887825200
[array_len] ptr=3012887825200 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887825296
[array_len] ptr=3012887825296 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175686
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887826256
[array_len] ptr=3012887826256 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '{' vs ' ' -> 0
  bytes a: 123, 0
  bytes b: 32, 0
[str_eq check] '{' vs '
' -> 0
  bytes a: 123, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '{' vs '#' -> 0
  bytes a: 123, 0
  bytes b: 35, 0
[str_eq check] '{' vs '/' -> 0
  bytes a: 123, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '{' vs '
' -> 0
  bytes a: 123, 0
  bytes b: 13, 0
[str_eq check] '{' vs '
' -> 0
  bytes a: 123, 0
  bytes b: 10, 0
[str_eq check] '{' vs '' -> 0
  bytes a: 123, 0
  bytes b: 0, 0
[str_eq check] '{' vs '' -> 0
  bytes a: 123, 0
  bytes b: 0, 43
[str_eq check] '{' vs '_' -> 0
  bytes a: 123, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '{' vs '
' -> 0
  bytes a: 123, 0
  bytes b: 10, 0
[str_eq check] '{' vs '+' -> 0
  bytes a: 123, 0
  bytes b: 43, 0
[str_eq check] '{' vs '-' -> 0
  bytes a: 123, 0
  bytes b: 45, 0
[str_eq check] '{' vs '*' -> 0
  bytes a: 123, 0
  bytes b: 42, 0
[str_eq check] '{' vs '/' -> 0
  bytes a: 123, 0
  bytes b: 47, 0
[str_eq check] '{' vs '%' -> 0
  bytes a: 123, 0
  bytes b: 37, 0
[str_eq check] '{' vs '=' -> 0
  bytes a: 123, 0
  bytes b: 61, 0
[str_eq check] '{' vs '!' -> 0
  bytes a: 123, 0
  bytes b: 33, 0
[str_eq check] '{' vs '<' -> 0
  bytes a: 123, 0
  bytes b: 60, 0
[str_eq check] '{' vs '>' -> 0
  bytes a: 123, 0
  bytes b: 62, 0
[str_eq check] '{' vs '&' -> 0
  bytes a: 123, 0
  bytes b: 38, 0
[str_eq check] '{' vs '|' -> 0
  bytes a: 123, 0
  bytes b: 124, 0
[str_eq check] '{' vs '.' -> 0
  bytes a: 123, 0
  bytes b: 46, 0
[str_eq check] '{' vs ':' -> 0
  bytes a: 123, 0
  bytes b: 58, 0
[str_eq check] '{' vs ',' -> 0
  bytes a: 123, 0
  bytes b: 44, 0
[str_eq check] '{' vs ';' -> 0
  bytes a: 123, 0
  bytes b: 59, 0
[str_eq check] '{' vs '(' -> 0
  bytes a: 123, 0
  bytes b: 40, 0
[str_eq check] '{' vs ')' -> 0
  bytes a: 123, 0
  bytes b: 41, 0
[str_eq check] '{' vs '[' -> 0
  bytes a: 123, 0
  bytes b: 91, 0
[str_eq check] '{' vs ']' -> 0
  bytes a: 123, 0
  bytes b: 93, 0
[str_eq check] '{' vs '{' -> 1
  bytes a: 123, 0
  bytes b: 123, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================
debug: got token
debug: looping tokenize...
debug: next_token start

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887826384
[array_len] ptr=3012887826384 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887829920
[array_len] ptr=3012887829920 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887829568
[array_len] ptr=3012887829568 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887828928
[array_len] ptr=3012887828928 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887830432
[array_len] ptr=3012887830432 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175690
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887830496
[array_len] ptr=3012887830496 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '}' vs '(' -> 0
  bytes a: 125, 0
  bytes b: 40, 0
[str_eq check] '}' vs '{' -> 0
  bytes a: 125, 0
  bytes b: 123, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

debug: got token
debug: looping tokenize...
debug: next_token start
    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887828800
[array_len] ptr=3012887828800 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---
debug: skipping space

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887829792
[array_len] ptr=3012887829792 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z


debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887828832
[array_len] ptr=3012887828832 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887830048
[array_len] ptr=3012887830048 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887829056
[array_len] ptr=3012887829056 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175566
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887830304
[array_len] ptr=3012887830304 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012887829280
[array_len] ptr=3012887829280 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space


fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

debug: got token
debug: looping tokenize...
debug: next_token start
    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897487248
[array_len] ptr=3012897487248 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start
    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897487152
[array_len] ptr=3012897487152 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start
    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897488848
[array_len] ptr=3012897488848 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897487440
[array_len] ptr=3012897487440 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space


fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897487984
[array_len] ptr=3012897487984 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897488464
[array_len] ptr=3012897488464 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897487632
[array_len] ptr=3012897487632 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897487408
[array_len] ptr=3012897487408 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897487536
[array_len] ptr=3012897487536 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897487568
[array_len] ptr=3012897487568 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

debug: got token
    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total


debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897487856
[array_len] ptr=3012897487856 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897488400
[array_len] ptr=3012897488400 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y


debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897486928
[array_len] ptr=3012897486928 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897485040
[array_len] ptr=3012897485040 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897485808
[array_len] ptr=3012897485808 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897485712
[array_len] ptr=3012897485712 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
debug: got token
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total


debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175566
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897485552
[array_len] ptr=3012897485552 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897485744
[array_len] ptr=3012897485744 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897485872
[array_len] ptr=3012897485872 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897485232
[array_len] ptr=3012897485232 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897486160
[array_len] ptr=3012897486160 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897485264
[array_len] ptr=3012897485264 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897486416
[array_len] ptr=3012897486416 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start


fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897486768
[array_len] ptr=3012897486768 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space


impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012897485392
[array_len] ptr=3012897485392 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893605776
[array_len] ptr=3012893605776 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

debug: got token
debug: looping tokenize...
debug: next_token start
    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893604304
[array_len] ptr=3012893604304 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2


debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start

// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893604496
[array_len] ptr=3012893604496 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893604784
[array_len] ptr=3012893604784 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893604240
[array_len] ptr=3012893604240 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893604848
[array_len] ptr=3012893604848 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893605872
[array_len] ptr=3012893605872 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

debug: got token
debug: looping tokenize...
debug: next_token start
// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893604016
[array_len] ptr=3012893604016 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check
debug: got token

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893604944
[array_len] ptr=3012893604944 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

debug: skipping space
        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893604208
[array_len] ptr=3012893604208 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893604368
[array_len] ptr=3012893604368 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int
debug: got token



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175566
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893605328
[array_len] ptr=3012893605328 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893602192
[array_len] ptr=3012893602192 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893603504
[array_len] ptr=3012893603504 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break
debug: got token

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175587
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893603920
[array_len] ptr=3012893603920 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893602576
[array_len] ptr=3012893602576 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893603440
[array_len] ptr=3012893603440 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893603312
[array_len] ptr=3012893603312 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

debug: got token
debug: looping tokenize...
debug: next_token start
    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893603088
[array_len] ptr=3012893603088 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

debug: make_token
    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893602384
[array_len] ptr=3012893602384 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893602480
[array_len] ptr=3012893602480 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

debug: got token
// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175581
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893603152
[array_len] ptr=3012893603152 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0
debug: got token

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893602640
[array_len] ptr=3012893602640 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012893603184
[array_len] ptr=3012893603184 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900389872
[array_len] ptr=3012900389872 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900390128
[array_len] ptr=3012900390128 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900389008
[array_len] ptr=3012900389008 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900390736
[array_len] ptr=3012900390736 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175566
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space


fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900389552
[array_len] ptr=3012900389552 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker
debug: skipping space
debug: skipping space

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900389808
[array_len] ptr=3012900389808 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space


// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900390256
[array_len] ptr=3012900390256 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175587
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900390512
[array_len] ptr=3012900390512 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space


fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900389328
[array_len] ptr=3012900389328 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900389840
[array_len] ptr=3012900389840 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900390000
[array_len] ptr=3012900390000 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900390288
[array_len] ptr=3012900390288 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175587
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900390576
[array_len] ptr=3012900390576 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space


// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900390352
[array_len] ptr=3012900390352 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900392048
[array_len] ptr=3012900392048 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900392112
[array_len] ptr=3012900392112 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:
debug: got token

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

debug: looping tokenize...
debug: next_token start
debug: skipping space
        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900392144
[array_len] ptr=3012900392144 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900392176
[array_len] ptr=3012900392176 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900391344
[array_len] ptr=3012900391344 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
debug: got token
debug: looping tokenize...
debug: next_token start
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900391184
[array_len] ptr=3012900391184 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175577
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900391216
[array_len] ptr=3012900391216 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900392528
[array_len] ptr=3012900392528 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900391568
[array_len] ptr=3012900391568 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175581
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900391248
[array_len] ptr=3012900391248 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y


debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175587
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900392304
[array_len] ptr=3012900392304 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900391600
[array_len] ptr=3012900391600 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900391824
[array_len] ptr=3012900391824 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900407072
[array_len] ptr=3012900407072 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900407040
[array_len] ptr=3012900407040 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900407008
[array_len] ptr=3012900407008 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900407232
[array_len] ptr=3012900407232 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900405632
[array_len] ptr=3012900405632 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

debug: got token
    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900406272
[array_len] ptr=3012900406272 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900407328
[array_len] ptr=3012900407328 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900405728
[array_len] ptr=3012900405728 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
debug: got token
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900406784
[array_len] ptr=3012900406784 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175566
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900405888
[array_len] ptr=3012900405888 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900407392
[array_len] ptr=3012900407392 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175613
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900406624
[array_len] ptr=3012900406624 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900409376
[array_len] ptr=3012900409376 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900409312
[array_len] ptr=3012900409312 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

debug: looping tokenize...
debug: next_token start
debug: skipping space
    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900409344
[array_len] ptr=3012900409344 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900408128
[array_len] ptr=3012900408128 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900409280
[array_len] ptr=3012900409280 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

debug: got token
    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175587
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900409216
[array_len] ptr=3012900409216 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space


// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900407488
[array_len] ptr=3012900407488 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900407936
[array_len] ptr=3012900407936 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

debug: got token
// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900407584
[array_len] ptr=3012900407584 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175581
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900409184
[array_len] ptr=3012900409184 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175587
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900408576
[array_len] ptr=3012900408576 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900407840
[array_len] ptr=3012900407840 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900408640
[array_len] ptr=3012900408640 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012900408768
[array_len] ptr=3012900408768 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)


debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910632736
[array_len] ptr=3012910632736 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910631840
[array_len] ptr=3012910631840 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910631424
[array_len] ptr=3012910631424 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910632224
[array_len] ptr=3012910632224 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910631968
[array_len] ptr=3012910631968 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910631168
[array_len] ptr=3012910631168 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910632800
[array_len] ptr=3012910632800 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175622
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910631232
[array_len] ptr=3012910631232 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910632832
[array_len] ptr=3012910632832 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int


debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space

impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910631552
[array_len] ptr=3012910631552 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910632640
[array_len] ptr=3012910632640 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175581
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910632672
[array_len] ptr=3012910632672 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175587
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910631360
[array_len] ptr=3012910631360 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

debug: skipping space
debug: skipping space
debug: skipping space
    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910626752
[array_len] ptr=3012910626752 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910626048
[array_len] ptr=3012910626048 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910626848
[array_len] ptr=3012910626848 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910625536
[array_len] ptr=3012910625536 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910625248
[array_len] ptr=3012910625248 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910626496
[array_len] ptr=3012910626496 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910626816
[array_len] ptr=3012910626816 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910625184
[array_len] ptr=3012910625184 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910625920
[array_len] ptr=3012910625920 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910625472
[array_len] ptr=3012910625472 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910624992
[array_len] ptr=3012910624992 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175566
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910626560
[array_len] ptr=3012910626560 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1

debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space


fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910626656
[array_len] ptr=3012910626656 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910627968
[array_len] ptr=3012910627968 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910628352
[array_len] ptr=3012910628352 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space


fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910628064
[array_len] ptr=3012910628064 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910628512
[array_len] ptr=3012910628512 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910628096
[array_len] ptr=3012910628096 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910627776
[array_len] ptr=3012910627776 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910628928
[array_len] ptr=3012910628928 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910628480
[array_len] ptr=3012910628480 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910627808
[array_len] ptr=3012910627808 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token


fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910627936
[array_len] ptr=3012910627936 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910628224
[array_len] ptr=3012910628224 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910628256
[array_len] ptr=3012910628256 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910627040
[array_len] ptr=3012910627040 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space


struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910627360
[array_len] ptr=3012910627360 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910629120
[array_len] ptr=3012910629120 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910629472
[array_len] ptr=3012910629472 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910629280
[array_len] ptr=3012910629280 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175566
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910629184
[array_len] ptr=3012910629184 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910629344
[array_len] ptr=3012910629344 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910630144
[array_len] ptr=3012910630144 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910630688
[array_len] ptr=3012910630688 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910630176
[array_len] ptr=3012910630176 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910630400
[array_len] ptr=3012910630400 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175577
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910630560
[array_len] ptr=3012910630560 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

debug: make_token
    println(10 - 4)  // 6

    println(7 * 8)   // 56

140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910630944
[array_len] ptr=3012910630944 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012910629792
[array_len] ptr=3012910629792 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888317216
[array_len] ptr=3012888317216 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base


debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888317792
[array_len] ptr=3012888317792 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888316096
[array_len] ptr=3012888316096 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base


debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888316384
[array_len] ptr=3012888316384 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888317312
[array_len] ptr=3012888317312 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888317376
[array_len] ptr=3012888317376 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888316992
[array_len] ptr=3012888316992 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
debug: skipping space
[split] done returning 3012888317504
[array_len] ptr=3012888317504 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start


// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888316544
[array_len] ptr=3012888316544 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175569
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888316896
[array_len] ptr=3012888316896 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888317600
[array_len] ptr=3012888317600 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

debug: looping tokenize...
debug: next_token start
    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888316256
[array_len] ptr=3012888316256 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888319616
[array_len] ptr=3012888319616 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888319648
[array_len] ptr=3012888319648 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int


debug: got token
debug: looping tokenize...
debug: next_token start

impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888318496
[array_len] ptr=3012888318496 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175577
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888319520
[array_len] ptr=3012888319520 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:
debug: next_token start
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888320096
[array_len] ptr=3012888320096 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888319488
[array_len] ptr=3012888319488 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
debug: got token
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

debug: looping tokenize...
debug: next_token start
debug: skipping space
// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math
debug: make_token
140696752175581
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888319456
[array_len] ptr=3012888319456 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888318272
[array_len] ptr=3012888318272 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: skipping space
debug: skipping space
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888319872
[array_len] ptr=3012888319872 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888318144
[array_len] ptr=3012888318144 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:
debug: got token

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20
debug: looping tokenize...
debug: next_token start
debug: skipping space

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888319776
[array_len] ptr=3012888319776 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

debug: got token
// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175622
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888319712
[array_len] ptr=3012888319712 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888318176
[array_len] ptr=3012888318176 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int

debug: got token
debug: looping tokenize...
debug: next_token start


impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888321120
[array_len] ptr=3012888321120 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888320384
[array_len] ptr=3012888320384 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

debug: skipping space
    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888320512
[array_len] ptr=3012888320512 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175613
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888320544
[array_len] ptr=3012888320544 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888320576
[array_len] ptr=3012888320576 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

debug: got token
debug: looping tokenize...
debug: next_token start
    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888322016
[array_len] ptr=3012888322016 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888321856
[array_len] ptr=3012888321856 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

debug: got token
    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888320704
[array_len] ptr=3012888320704 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    
debug: looping tokenize...
debug: next_token start
debug: skipping space

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

debug: make_token
140696752175587
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888321024
[array_len] ptr=3012888321024 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)


debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888320992
[array_len] ptr=3012888320992 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888321088
[array_len] ptr=3012888321088 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
debug: got token
debug: looping tokenize...
debug: next_token start
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total

debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space


fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888320256
[array_len] ptr=3012888320256 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space


struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888321952
[array_len] ptr=3012888321952 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175601
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)
debug: got token
debug: looping tokenize...
debug: next_token start

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888314208
[array_len] ptr=3012888314208 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888315456
[array_len] ptr=3012888315456 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

debug: got token
debug: looping tokenize...
debug: next_token start
    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888314144
[array_len] ptr=3012888314144 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888314624
[array_len] ptr=3012888314624 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

debug: got token
    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888314336
[array_len] ptr=3012888314336 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888314720
[array_len] ptr=3012888314720 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888315232
[array_len] ptr=3012888315232 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888314496
[array_len] ptr=3012888314496 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:
debug: make_token

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888314112
[array_len] ptr=3012888314112 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888314528
[array_len] ptr=3012888314528 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888314880
[array_len] ptr=3012888314880 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888315712
[array_len] ptr=3012888315712 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888315840
[array_len] ptr=3012888315840 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1

debug: got token


fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3012888315872
[array_len] ptr=3012888315872 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776052784
[array_len] ptr=3010776052784 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776052080
[array_len] ptr=3010776052080 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776053808
[array_len] ptr=3010776053808 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776053456
[array_len] ptr=3010776053456 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int


debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776053584
[array_len] ptr=3010776053584 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int

debug: got token
debug: looping tokenize...
debug: next_token start


impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776053680
[array_len] ptr=3010776053680 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776053872
[array_len] ptr=3010776053872 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776052528
[array_len] ptr=3010776052528 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776052144
[array_len] ptr=3010776052144 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776052560
[array_len] ptr=3010776052560 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

debug: skipping space
    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776052592
[array_len] ptr=3010776052592 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776052944
[array_len] ptr=3010776052944 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776055664
[array_len] ptr=3010776055664 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:
debug: got token
debug: looping tokenize...
debug: next_token start

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776055568
[array_len] ptr=3010776055568 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776055056
[array_len] ptr=3010776055056 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z


debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175573
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776055696
[array_len] ptr=3010776055696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776055504
[array_len] ptr=3010776055504 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776054032
[array_len] ptr=3010776054032 len=4342
[array_len] ptr=3012880811696 len=4342
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776054000
[array_len] ptr=3010776054000 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776054064
[array_len] ptr=3010776054064 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776054640
[array_len] ptr=3010776054640 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776054768
[array_len] ptr=3010776054768 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base


debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776055248
[array_len] ptr=3010776055248 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776055536
[array_len] ptr=3010776055536 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776056208
[array_len] ptr=3010776056208 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3
debug: got token
debug: looping tokenize...
debug: next_token start

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776056848
[array_len] ptr=3010776056848 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776056528
[array_len] ptr=3010776056528 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776056880
[array_len] ptr=3010776056880 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776057552
[array_len] ptr=3010776057552 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space


// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776056944
[array_len] ptr=3010776056944 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776057520
[array_len] ptr=3010776057520 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776056976
[array_len] ptr=3010776056976 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776057712
[array_len] ptr=3010776057712 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

debug: got token
    if n % 2 == 0:

        return 0

    let i = 3

    loop:

debug: looping tokenize...
debug: next_token start
debug: make_token
        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776057072
[array_len] ptr=3010776057072 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: make_token
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:
debug: got token
debug: looping tokenize...
debug: next_token start

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776057200
[array_len] ptr=3010776057200 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776057232
[array_len] ptr=3010776057232 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776051824
[array_len] ptr=3010776051824 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776050384
[array_len] ptr=3010776050384 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776050960
[array_len] ptr=3010776050960 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776050576
[array_len] ptr=3010776050576 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776050448
[array_len] ptr=3010776050448 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776049808
[array_len] ptr=3010776049808 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776050480
[array_len] ptr=3010776050480 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776050768
[array_len] ptr=3010776050768 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776051248
[array_len] ptr=3010776051248 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776051472
[array_len] ptr=3010776051472 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776051440
[array_len] ptr=3010776051440 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776051600
[array_len] ptr=3010776051600 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776049904
[array_len] ptr=3010776049904 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776050128
[array_len] ptr=3010776050128 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175658
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010776050256
[array_len] ptr=3010776050256 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175560
debug: got token
debug: looping tokenize...
debug: next_token start
    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783865456
[array_len] ptr=3010783865456 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    
debug: skipping space

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783864784
[array_len] ptr=3010783864784 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

debug: got token
debug: looping tokenize...
debug: next_token start
    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783864304
[array_len] ptr=3010783864304 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783864816
[array_len] ptr=3010783864816 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783864080
[array_len] ptr=3010783864080 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783865488
[array_len] ptr=3010783865488 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783864624
[array_len] ptr=3010783864624 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)
debug: got token
debug: looping tokenize...
debug: next_token start



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3
debug: make_token

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783864656
[array_len] ptr=3010783864656 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783864752
[array_len] ptr=3010783864752 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: next_token start
    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783865424
[array_len] ptr=3010783865424 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

debug: got token
debug: looping tokenize...
debug: next_token start
        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783865776
[array_len] ptr=3010783865776 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
debug: got token
debug: looping tokenize...
debug: next_token start
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math
debug: make_token

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783867696
[array_len] ptr=3010783867696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783866160
[array_len] ptr=3010783866160 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:
debug: got token
debug: looping tokenize...
debug: next_token start

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783866800
[array_len] ptr=3010783866800 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

debug: got token
debug: looping tokenize...
debug: next_token start
    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783866576
[array_len] ptr=3010783866576 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783866416
[array_len] ptr=3010783866416 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

debug: skipping space
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783866512
[array_len] ptr=3010783866512 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783866544
[array_len] ptr=3010783866544 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:
debug: got token
debug: looping tokenize...
debug: next_token start

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783867152
[array_len] ptr=3010783867152 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783867280
[array_len] ptr=3010783867280 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:
debug: got token

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base


debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783867664
[array_len] ptr=3010783867664 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783866000
[array_len] ptr=3010783866000 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783866480
[array_len] ptr=3010783866480 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783860400
[array_len] ptr=3010783860400 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783860176
[array_len] ptr=3010783860176 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783861520
[array_len] ptr=3010783861520 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start


fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783861840
[array_len] ptr=3010783861840 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783861872
[array_len] ptr=3010783861872 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783859952
[array_len] ptr=3010783859952 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783860144
[array_len] ptr=3010783860144 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783861424
[array_len] ptr=3010783861424 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
debug: got token
debug: looping tokenize...
debug: next_token start
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783860304
[array_len] ptr=3010783860304 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783859888
[array_len] ptr=3010783859888 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

debug: got token
// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783860880
[array_len] ptr=3010783860880 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783863600
[array_len] ptr=3010783863600 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783863920
[array_len] ptr=3010783863920 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783862832
[array_len] ptr=3010783862832 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783862960
[array_len] ptr=3010783862960 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783863792
[array_len] ptr=3010783863792 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175655
debug: got token
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }
debug: looping tokenize...
debug: next_token start

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783863184
[array_len] ptr=3010783863184 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783863856
[array_len] ptr=3010783863856 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783863408
[array_len] ptr=3010783863408 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783862992
[array_len] ptr=3010783862992 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783863472
[array_len] ptr=3010783863472 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start
    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783862000
[array_len] ptr=3010783862000 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base


debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010783862128
[array_len] ptr=3010783862128 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791787376
[array_len] ptr=3010791787376 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start
// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791788624
[array_len] ptr=3010791788624 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791788688
[array_len] ptr=3010791788688 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:
debug: got token
debug: looping tokenize...
debug: next_token start

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791788432
[array_len] ptr=3010791788432 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791788272
[array_len] ptr=3010791788272 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791786672
[array_len] ptr=3010791786672 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791787632
[array_len] ptr=3010791787632 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175655
debug: got token
debug: looping tokenize...
debug: next_token start
    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

debug: got token
debug: looping tokenize...
debug: next_token start
    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791787248
[array_len] ptr=3010791787248 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791786704
[array_len] ptr=3010791786704 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

debug: skipping space
        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791787920
[array_len] ptr=3010791787920 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791787184
[array_len] ptr=3010791787184 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



debug: got token
impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():
debug: looping tokenize...
debug: next_token start
debug: skipping space

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791786960
[array_len] ptr=3010791786960 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791787312
[array_len] ptr=3010791787312 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start


impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791788752
[array_len] ptr=3010791788752 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1
debug: got token

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791790416
[array_len] ptr=3010791790416 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
debug: skipping space
debug: skipping space
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:
debug: got token
debug: looping tokenize...
debug: next_token start

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791790672
[array_len] ptr=3010791790672 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



debug: got token
fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791790640
[array_len] ptr=3010791790640 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base


debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791789136
[array_len] ptr=3010791789136 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791789744
[array_len] ptr=3010791789744 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791789168
[array_len] ptr=3010791789168 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791790224
debug: got token
[array_len] ptr=3010791790224 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175655
debug: got token
debug: looping tokenize...
debug: next_token start
impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791790320
[array_len] ptr=3010791790320 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791789808
[array_len] ptr=3010791789808 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791789488
[array_len] ptr=3010791789488 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791789584
[array_len] ptr=3010791789584 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791791888
[array_len] ptr=3010791791888 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791791920
[array_len] ptr=3010791791920 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791792240
[array_len] ptr=3010791792240 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)


debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175655
debug: got token
debug: looping tokenize...
debug: next_token start

fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791791312
[array_len] ptr=3010791791312 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791791440
[array_len] ptr=3010791791440 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

debug: got token
debug: looping tokenize...
debug: next_token start
    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791791472
[array_len] ptr=3010791791472 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

debug: make_token
140696752175662
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791792272
[array_len] ptr=3010791792272 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791792304
[array_len] ptr=3010791792304 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================
debug: looping tokenize...
debug: next_token start
debug: skipping space

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791791632
[array_len] ptr=3010791791632 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y


debug: got token

struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

debug: got token
debug: looping tokenize...
debug: next_token start
    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791792752
[array_len] ptr=3010791792752 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2
debug: make_token
140696752175649
debug: got token



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check
debug: looping tokenize...
debug: next_token start

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791791696
[array_len] ptr=3010791791696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791791760
[array_len] ptr=3010791791760 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

debug: got token
debug: looping tokenize...
debug: next_token start
    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791790832
[array_len] ptr=3010791790832 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2


debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791791280
[array_len] ptr=3010791791280 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================
debug: got token
debug: looping tokenize...
debug: next_token start



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2


debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791794576
[array_len] ptr=3010791794576 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z


debug: skipping space
debug: skipping space
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175595
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791793840
[array_len] ptr=3010791793840 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791793616
[array_len] ptr=3010791793616 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175649
debug: got token
debug: looping tokenize...
debug: next_token start
    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791793072
[array_len] ptr=3010791793072 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2

debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space


// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791794064
[array_len] ptr=3010791794064 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791794224
[array_len] ptr=3010791794224 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:
debug: got token

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791794672
[array_len] ptr=3010791794672 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: skipping space
debug: skipping space
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
debug: next_token start
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:
debug: got token

        return 0

    let i = 3

    loop:

        if i * i > n:

            break
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175670
debug: got token
debug: looping tokenize...
debug: next_token start

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791793360
[array_len] ptr=3010791793360 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs ' ' -> 0
  bytes a: 40, 0
  bytes b: 32, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '#' -> 0
  bytes a: 40, 0
  bytes b: 35, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 13, 0
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 0
[str_eq check] '(' vs '' -> 0
  bytes a: 40, 0
  bytes b: 0, 43
[str_eq check] '(' vs '_' -> 0
  bytes a: 40, 0
  bytes b: 95, 0
[array_len] ptr=3012880811696 len=4342
[str_eq check] '(' vs '
' -> 0
  bytes a: 40, 0
  bytes b: 10, 0
[str_eq check] '(' vs '+' -> 0
  bytes a: 40, 0
  bytes b: 43, 0
[str_eq check] '(' vs '-' -> 0
  bytes a: 40, 0
  bytes b: 45, 0
[str_eq check] '(' vs '*' -> 0
  bytes a: 40, 0
  bytes b: 42, 0
[str_eq check] '(' vs '/' -> 0
  bytes a: 40, 0
  bytes b: 47, 0
[str_eq check] '(' vs '%' -> 0
  bytes a: 40, 0
  bytes b: 37, 0
[str_eq check] '(' vs '=' -> 0
  bytes a: 40, 0
  bytes b: 61, 0
[str_eq check] '(' vs '!' -> 0
  bytes a: 40, 0
  bytes b: 33, 0
[str_eq check] '(' vs '<' -> 0
  bytes a: 40, 0
  bytes b: 60, 0
[str_eq check] '(' vs '>' -> 0
  bytes a: 40, 0
  bytes b: 62, 0
[str_eq check] '(' vs '&' -> 0
  bytes a: 40, 0
  bytes b: 38, 0
[str_eq check] '(' vs '|' -> 0
  bytes a: 40, 0
  bytes b: 124, 0
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[str_eq check] '(' vs ',' -> 0
  bytes a: 40, 0
  bytes b: 44, 0
[str_eq check] '(' vs ';' -> 0
  bytes a: 40, 0
  bytes b: 59, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0
debug: got token
debug: looping tokenize...
debug: next_token start
debug: make_token
140696752175674
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: skipping space
debug: skipping space
debug: skipping space

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791794032
[array_len] ptr=3010791794032 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
debug: got token
debug: looping tokenize...
debug: next_token start
debug: skipping space
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791794480
[array_len] ptr=3010791794480 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[split] str_ptr=3012880822048 delim_ptr=140696752173892
[split] str='// ============================================================================

// KORE STRESS TEST - Maximum Complexity for Native Compiler

// ============================================================================

// Testing: Structs, impl blocks, methods, loops, conditionals, math

// ============================================================================



// --- Data Structure ---

struct Point:

    x: Int

    y: Int



impl Point:

    pub fn new(x: Int, y: Int) -> Point:

debug: got token
        return Point { x: x, y: y }

    

    pub fn add(self, other: Point) -> Point:

        return Point { x: self.x + other.x, y: self.y + other.y }

    

    pub fn distance_squared(self) -> Int:

        return self.x * self.x + self.y * self.y



struct Vector3:

    x: Int

    y: Int

    z: Int



impl Vector3:

    pub fn new(x: Int, y: Int, z: Int) -> Vector3:

        return Vector3 { x: x, y: y, z: z }

    

    pub fn dot(self, other: Vector3) -> Int:

        return self.x * other.x + self.y * other.y + self.z * other.z

    

    pub fn length_squared(self) -> Int:

        return self.x * self.x + self.y * self.y + self.z * self.z



// --- Algorithms ---

fn gcd(a: Int, b: Int) -> Int:

    if b == 0:

        return a

    return gcd(b, a % b)



fn power(base: Int, exp: Int) -> Int:

    if exp == 0:

        return 1

    if exp == 1:

        return base

    let half = power(base, exp / 2)

    if exp % 2 == 0:

        return half * half

    return half * half * base



fn is_prime(n: Int) -> Int:

    if n < 2:

        return 0

    if n == 2:

        return 1

    if n % 2 == 0:

        return 0

    let i = 3

    loop:

        if i * i > n:

            break

        if n % i == 0:

            return 0

        i = i + 2

    return 1



fn sum_to_n(n: Int) -> Int:

    let total = 0

    for i in range(1, n + 1):

        total = total + i

    return total
debug: looping tokenize...
debug: next_token start
debug: skipping space
debug: make_token
140696752175554
debug: got token
debug: tokenized



fn triangle_number(n: Int) -> Int:

    return n * (n + 1) / 2



// --- Main Test ---

fn main():

    // Header

    println(11111111)

    

    // Test 1: Basic Math

    println(100001)  // Marker

    println(2 + 3)   // 5

    println(10 - 4)  // 6

    println(7 * 8)   // 56

    println(100 / 5) // 20

    println(17 % 5)  // 2

    

    // Test 2: Comparisons

    println(100002)  // Marker

    if 5 > 3:

        println(1)   // Should print 1

    if 3 < 5:

        println(2)   // Should print 2

    if 5 == 5:

        println(3)   // Should print 3

    if 4 != 5:

        println(4)   // Should print 4

    

    // Test 3: Nested Arithmetic

    println(100003)  // Marker

    let a = 10

    let b = 20

    let c = 30

    println(a + b + c)       // 60

    println((a + b) * 2)     // 60

    println(a * b + c)       // 230

    println((a + b) * (b + c)) // 1500

    

    // Test 4: Loop with accumulator

    println(100004)  // Marker

    let sum = 0

    for i in range(1, 11):

        sum = sum + i

    println(sum)  // 55 (sum of 1 to 10)

    

    // Test 5: Nested loops

    println(100005)  // Marker

    let product = 1

    for i in range(1, 5):

        for j in range(1, 3):

            product = product + 1

    println(product)  // 1 + (4 * 2) = 9

    

    // Test 6: Function calls

    println(100006)  // Marker

    println(sum_to_n(10))     // 55

    println(triangle_number(10)) // 55

    println(power(2, 8))      // 256

    println(gcd(48, 18))      // 6

    

    // Test 7: Prime check

    println(100007)  // Marker

    println(is_prime(2))   // 1

    println(is_prime(17))  // 1

    println(is_prime(18))  // 0

    println(is_prime(97))  // 1

    

    // Test 8: Struct creation

    println(100008)  // Marker

    let p1 = Point::new(3, 4)

    println(p1.x)  // 3

    println(p1.y)  // 4

    

    // Test 9: Struct methods

    println(100009)  // Marker

    let p2 = Point::new(1, 2)

    let dist = p1.distance_squared()

    println(dist)  // 3*3 + 4*4 = 25

    

    // Test 10: Vector3 operations

    println(100010)  // Marker

    let v1 = Vector3::new(1, 2, 3)

    let v2 = Vector3::new(4, 5, 6)

    let dot_product = v1.dot(v2)

    println(dot_product)  // 1*4 + 2*5 + 3*6 = 32

    let len_sq = v1.length_squared()

    println(len_sq)  // 1 + 4 + 9 = 14

    

    // Footer

    println(99999999)

    return 0

' delim=''
[split] splitting chars...
[split] len=4342
[split] done returning 3010791794832
[array_len] ptr=3010791794832 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880811696 len=4342
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010791797744 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'Point' vs '(' -> 0
  bytes a: 80, 111
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012886601840 delim_ptr=140696752176285
[split] str='Point' delim=''
[split] splitting chars...
[split] len=5
[split] done returning 3010791797840
[array_len] ptr=3012880810992 len=970
[str_eq check] '{' vs ':' -> 0
  bytes a: 123, 0
  bytes b: 58, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '{' vs '{' -> 1
  bytes a: 123, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'x' vs '(' -> 0
  bytes a: 120, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012886905408 delim_ptr=140696752176285
[split] str='x' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010791797200
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ',' vs '{' -> 0
  bytes a: 44, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] ',' vs '(' -> 0
  bytes a: 44, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'y' vs '(' -> 0
  bytes a: 121, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012887261728 delim_ptr=140696752176285
[split] str='y' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010791798800
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '}' vs '{' -> 0
  bytes a: 125, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '}' vs '(' -> 0
  bytes a: 125, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010791797744 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010791797744 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010791797744 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010791798128 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'Point' vs '(' -> 0
  bytes a: 80, 111
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012888495936 delim_ptr=140696752176285
[split] str='Point' delim=''
[split] splitting chars...
[split] len=5
[split] done returning 3010791799504
[array_len] ptr=3012880810992 len=970
[str_eq check] '{' vs ':' -> 0
  bytes a: 123, 0
  bytes b: 58, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '{' vs '{' -> 1
  bytes a: 123, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012889251312 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010791799312
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '+' vs '(' -> 0
  bytes a: 43, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '+' vs '(' -> 0
  bytes a: 43, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'other' vs '(' -> 0
  bytes a: 111, 116
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012889536000 delim_ptr=140696752176285
[split] str='other' delim=''
[split] splitting chars...
[split] len=5
[split] done returning 3010791799920
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '.' vs '{' -> 0
  bytes a: 46, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ',' vs '(' -> 0
  bytes a: 44, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] ',' vs '(' -> 0
  bytes a: 44, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012889968848 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010791799760
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '+' vs '(' -> 0
  bytes a: 43, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '+' vs '(' -> 0
  bytes a: 43, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'other' vs '(' -> 0
  bytes a: 111, 116
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012890321744 delim_ptr=140696752176285
[split] str='other' delim=''
[split] splitting chars...
[split] len=5
[split] done returning 3010791799120
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '.' vs '{' -> 0
  bytes a: 46, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '}' vs '(' -> 0
  bytes a: 125, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '}' vs '(' -> 0
  bytes a: 125, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010791798128 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010791798128 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010791798128 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010791786544 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012891397824 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010791784720
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012891684176 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010791784848
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '+' vs '(' -> 0
  bytes a: 43, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '+' vs '(' -> 0
  bytes a: 43, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012892053616 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010791785104
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012892343088 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010791785200
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010791786544 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010791786544 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010791786544 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803481264 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'Vector3' vs '(' -> 0
  bytes a: 86, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012895605136 delim_ptr=140696752176285
[split] str='Vector3' delim=''
[split] splitting chars...
[split] len=7
[split] done returning 3010803482128
[array_len] ptr=3012880810992 len=970
[str_eq check] '{' vs ':' -> 0
  bytes a: 123, 0
  bytes b: 58, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '{' vs '{' -> 1
  bytes a: 123, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'x' vs '(' -> 0
  bytes a: 120, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012895892448 delim_ptr=140696752176285
[split] str='x' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010803481776
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ',' vs '{' -> 0
  bytes a: 44, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] ',' vs '(' -> 0
  bytes a: 44, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'y' vs '(' -> 0
  bytes a: 121, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012896160784 delim_ptr=140696752176285
[split] str='y' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010803480848
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ',' vs '{' -> 0
  bytes a: 44, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] ',' vs '(' -> 0
  bytes a: 44, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'z' vs '(' -> 0
  bytes a: 122, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012896420320 delim_ptr=140696752176285
[split] str='z' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010803480784
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '}' vs '{' -> 0
  bytes a: 125, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '}' vs '(' -> 0
  bytes a: 125, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803481264 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803481264 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803481264 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803484176 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012897708544 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803482864
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'other' vs '(' -> 0
  bytes a: 111, 116
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012897997520 delim_ptr=140696752176285
[split] str='other' delim=''
[split] splitting chars...
[split] len=5
[split] done returning 3010803483248
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '.' vs '{' -> 0
  bytes a: 46, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '+' vs '(' -> 0
  bytes a: 43, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '+' vs '(' -> 0
  bytes a: 43, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012898285312 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803484304
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'other' vs '(' -> 0
  bytes a: 111, 116
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012898565968 delim_ptr=140696752176285
[split] str='other' delim=''
[split] splitting chars...
[split] len=5
[split] done returning 3010803483184
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '.' vs '{' -> 0
  bytes a: 46, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '+' vs '(' -> 0
  bytes a: 43, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '+' vs '(' -> 0
  bytes a: 43, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012898856800 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803483504
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'other' vs '(' -> 0
  bytes a: 111, 116
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012899138736 delim_ptr=140696752176285
[split] str='other' delim=''
[split] splitting chars...
[split] len=5
[split] done returning 3010803483728
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '.' vs '{' -> 0
  bytes a: 46, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803484176 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803484176 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803484176 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803486352 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012900255728 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803486640
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012900608240 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803486736
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '+' vs '(' -> 0
  bytes a: 43, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '+' vs '(' -> 0
  bytes a: 43, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012900892240 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803485360
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012901177776 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803486000
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '+' vs '(' -> 0
  bytes a: 43, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '+' vs '(' -> 0
  bytes a: 43, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012901466736 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803486064
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'self' vs '(' -> 0
  bytes a: 115, 101
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012901755936 delim_ptr=140696752176285
[split] str='self' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803486800
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803486352 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803486352 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803486352 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803486352 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803488496 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'b' vs '(' -> 0
  bytes a: 98, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012903192592 delim_ptr=140696752176285
[split] str='b' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010803488112
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '==' vs '{' -> 0
  bytes a: 61, 61
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '==' vs '(' -> 0
  bytes a: 61, 61
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '0' vs '(' -> 0
  bytes a: 48, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ':' vs '(' -> 0
  bytes a: 58, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803488400 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'a' vs '(' -> 0
  bytes a: 97, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012903624224 delim_ptr=140696752176285
[split] str='a' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010803487280
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '{' -> 0
  bytes a: 10, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803488400 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803488400 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'gcd' vs '(' -> 0
  bytes a: 103, 99
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012903977536 delim_ptr=140696752176285
[split] str='gcd' delim=''
[split] splitting chars...
[split] len=3
[split] done returning 3010803489328
[array_len] ptr=3012880810992 len=970
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '(' vs '{' -> 0
  bytes a: 40, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs '[' -> 0
  bytes a: 40, 0
  bytes b: 91, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'b' vs '(' -> 0
  bytes a: 98, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012904014512 delim_ptr=140696752176285
[split] str='b' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010803489072
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ',' vs '{' -> 0
  bytes a: 44, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] ',' vs '(' -> 0
  bytes a: 44, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'a' vs '(' -> 0
  bytes a: 97, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012904193408 delim_ptr=140696752176285
[split] str='a' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010803489360
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '%' vs '{' -> 0
  bytes a: 37, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '%' vs '(' -> 0
  bytes a: 37, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'b' vs '(' -> 0
  bytes a: 98, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012904338192 delim_ptr=140696752176285
[split] str='b' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010803489040
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ')' vs '{' -> 0
  bytes a: 41, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803488400 len=2
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803488400 len=2
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803488400 len=2
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803488496 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803488976 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'exp' vs '(' -> 0
  bytes a: 101, 120
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012905703008 delim_ptr=140696752176285
[split] str='exp' delim=''
[split] splitting chars...
[split] len=3
[split] done returning 3010803474768
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '==' vs '{' -> 0
  bytes a: 61, 61
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '==' vs '(' -> 0
  bytes a: 61, 61
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '0' vs '(' -> 0
  bytes a: 48, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ':' vs '(' -> 0
  bytes a: 58, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803475760 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '1' vs '(' -> 0
  bytes a: 49, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803475760 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803475760 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'exp' vs '(' -> 0
  bytes a: 101, 120
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012906355552 delim_ptr=140696752176285
[split] str='exp' delim=''
[split] splitting chars...
[split] len=3
[split] done returning 3010803476624
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '==' vs '{' -> 0
  bytes a: 61, 61
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '==' vs '(' -> 0
  bytes a: 61, 61
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '1' vs '(' -> 0
  bytes a: 49, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ':' vs '(' -> 0
  bytes a: 58, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803475952 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'base' vs '(' -> 0
  bytes a: 98, 97
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012906785088 delim_ptr=140696752176285
[split] str='base' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803474736
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '{' -> 0
  bytes a: 10, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803475952 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803475952 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'power' vs '(' -> 0
  bytes a: 112, 111
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012907213664 delim_ptr=140696752176285
[split] str='power' delim=''
[split] splitting chars...
[split] len=5
[split] done returning 3010803478384
[array_len] ptr=3012880810992 len=970
[str_eq check] '(' vs ':' -> 0
  bytes a: 40, 0
  bytes b: 58, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '(' vs '{' -> 0
  bytes a: 40, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '(' vs '.' -> 0
  bytes a: 40, 0
  bytes b: 46, 0
[str_eq check] '(' vs '[' -> 0
  bytes a: 40, 0
  bytes b: 91, 0
[str_eq check] '(' vs '(' -> 1
  bytes a: 40, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'base' vs '(' -> 0
  bytes a: 98, 97
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012907423760 delim_ptr=140696752176285
[split] str='base' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803478224
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ',' vs '{' -> 0
  bytes a: 44, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] ',' vs '(' -> 0
  bytes a: 44, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'exp' vs '(' -> 0
  bytes a: 101, 120
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012907463776 delim_ptr=140696752176285
[split] str='exp' delim=''
[split] splitting chars...
[split] len=3
[split] done returning 3010803476848
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '/' vs '{' -> 0
  bytes a: 47, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '/' vs '(' -> 0
  bytes a: 47, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '2' vs '(' -> 0
  bytes a: 50, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ')' vs '(' -> 0
  bytes a: 41, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803475952 len=2
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803475952 len=2
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'exp' vs '(' -> 0
  bytes a: 101, 120
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012907932976 delim_ptr=140696752176285
[split] str='exp' delim=''
[split] splitting chars...
[split] len=3
[split] done returning 3010803477072
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '%' vs '{' -> 0
  bytes a: 37, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '%' vs '(' -> 0
  bytes a: 37, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '2' vs '(' -> 0
  bytes a: 50, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '==' vs '(' -> 0
  bytes a: 61, 61
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '0' vs '(' -> 0
  bytes a: 48, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ':' vs '(' -> 0
  bytes a: 58, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803476912 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'half' vs '(' -> 0
  bytes a: 104, 97
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012908471232 delim_ptr=140696752176285
[split] str='half' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803478544
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '{' -> 0
  bytes a: 42, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'half' vs '(' -> 0
  bytes a: 104, 97
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012908647728 delim_ptr=140696752176285
[split] str='half' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803477776
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '{' -> 0
  bytes a: 10, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803476912 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803476912 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'half' vs '(' -> 0
  bytes a: 104, 97
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012908998208 delim_ptr=140696752176285
[split] str='half' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803559264
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '{' -> 0
  bytes a: 42, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'half' vs '(' -> 0
  bytes a: 104, 97
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012909143552 delim_ptr=140696752176285
[split] str='half' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803560672
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '{' -> 0
  bytes a: 42, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'base' vs '(' -> 0
  bytes a: 98, 97
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012909217840 delim_ptr=140696752176285
[split] str='base' delim=''
[split] splitting chars...
[split] len=4
[split] done returning 3010803560192
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '{' -> 0
  bytes a: 10, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803476912 len=2
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803476912 len=2
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803476912 len=2
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803475952 len=3
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803475760 len=2
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803488976 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803561184 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'n' vs '(' -> 0
  bytes a: 110, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012910232448 delim_ptr=140696752176285
[split] str='n' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010803562368
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '<' vs '{' -> 0
  bytes a: 60, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '<' vs '(' -> 0
  bytes a: 60, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '2' vs '(' -> 0
  bytes a: 50, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ':' vs '(' -> 0
  bytes a: 58, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803561984 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '0' vs '(' -> 0
  bytes a: 48, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803561984 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803561984 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'n' vs '(' -> 0
  bytes a: 110, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012910943760 delim_ptr=140696752176285
[split] str='n' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010803562432
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '==' vs '{' -> 0
  bytes a: 61, 61
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '==' vs '(' -> 0
  bytes a: 61, 61
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '2' vs '(' -> 0
  bytes a: 50, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ':' vs '(' -> 0
  bytes a: 58, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803561728 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '1' vs '(' -> 0
  bytes a: 49, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803561728 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803561728 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'n' vs '(' -> 0
  bytes a: 110, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012911667152 delim_ptr=140696752176285
[split] str='n' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010803563136
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '%' vs '{' -> 0
  bytes a: 37, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '%' vs '(' -> 0
  bytes a: 37, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '2' vs '(' -> 0
  bytes a: 50, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '==' vs '(' -> 0
  bytes a: 61, 61
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '0' vs '(' -> 0
  bytes a: 48, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] ':' vs '(' -> 0
  bytes a: 58, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803564704 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '0' vs '(' -> 0
  bytes a: 48, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803564704 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803564704 len=1
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '3' vs '(' -> 0
  bytes a: 51, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '
' vs '(' -> 0
  bytes a: 10, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803564704 len=2
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803564704 len=2
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3010803565792 len=0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'i' vs '(' -> 0
  bytes a: 105, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012913130624 delim_ptr=140696752176285
[split] str='i' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010803566304
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '{' -> 0
  bytes a: 42, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '*' vs '(' -> 0
  bytes a: 42, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'i' vs '(' -> 0
  bytes a: 105, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012913275088 delim_ptr=140696752176285
[split] str='i' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010803565632
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] '>' vs '{' -> 0
  bytes a: 62, 0
  bytes b: 123, 0
[array_len] ptr=3012880810992 len=970
[str_eq check] '>' vs '(' -> 0
  bytes a: 62, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[array_len] ptr=3012880810992 len=970
[str_eq check] 'n' vs '(' -> 0
  bytes a: 110, 0
  bytes b: 40, 0
[array_len] ptr=3012880810992 len=970
[split] str_ptr=3012913417712 delim_ptr=140696752176285
[split] str='n' delim=''
[split] splitting chars...
[split] len=1
[split] done returning 3010803566144
[array_len] ptr=3012880810992 len=970
