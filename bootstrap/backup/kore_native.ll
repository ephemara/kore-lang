; KORE Compiler Output - LLVM IR
; Generated by Project Ouroboros
; Compile with: clang output.ll kore_runtime.o -o output

target triple = "x86_64-pc-windows-msvc"

; External Runtime Functions
declare i8* @malloc(i64)
declare void @free(i8*)
declare i32 @printf(i8*, ...)
declare i32 @puts(i8*)

; Kore Runtime
declare void @kore_print_i64(i64)
declare void @kore_print_str(i8*)
declare void @kore_println_str(i8*)
declare i8* @kore_str_concat(i8*, i8*)
declare i64 @kore_array_new()
declare i64 @kore_array_push(i64, i64)
declare i64 @kore_array_pop(i64)
declare i64 @kore_array_get(i64, i64)
declare i64 @kore_array_len(i64)

; Kore Stdlib
declare i64 @kore_len(i64)
declare i64 @kore_str_len(i64)
declare i64 @kore_split(i64, i64)
declare i64 @kore_contains(i64, i64)
declare i64 @kore_ord(i64)
declare i64 @kore_to_int(i64)
declare i64 @kore_to_float(i64)
declare i64 @kore_to_string(i64)
declare i64 @kore_range(i64, i64)
declare i64 @kore_slice(i64, i64, i64)
declare i64 @kore_char_at(i64, i64)
declare i64 @kore_substring(i64, i64, i64)
declare i64 @kore_str_eq(i64, i64)
declare i64 @kore_append(i64, i64)
declare i64 @kore_add_op(i64, i64)

; Direct Main Wrappers
declare i64 @args()
declare void @exit(i64)
declare i64 @read_file(i64)
declare i64 @write_file(i64, i64)
declare i64 @substring(i64, i64, i64)
declare i64 @replace(i64, i64, i64)
declare i64 @starts_with(i64, i64)

; Built-in generic types (used as opaque pointers)
%Box = type { i64, i64 }
%Array = type { i64 }
%Option = type { i64, i8*, i8* }
%Vec = type { i64 }
%StringBuilder = type { i64 }
%Result = type { i64, i8*, i8* }
%HashMap = type { i64 }
%HashSet = type { i64 }
%Map = type { i64 }
%Set = type { i64 }

; Option/Box helpers
declare i64 @kore_some(i64)
declare i64 @kore_none()
declare i64 @kore_box(i64)
declare i64 @kore_unwrap(i64)
declare void @kore_panic(i64)

; Map/Variant helpers
declare i64 @kore_contains_key(i64, i64)
declare i64 @kore_join(i64, i64)
declare i64 @kore_peek(i64)
declare i64 @kore_peek_offset(i64, i64)
declare i64 @kore_variant_of(i64)
declare i64 @kore_variant_field(i64, i64)
declare i64 @Map_new()
declare void @kore_map_set(i64, i64, i64)
declare i64 @kore_map_get(i64, i64)

; enum TokenKind
%TokenKind = type { i64, i8*, i8* }

; struct Token
%Token = type { i64, i64, i64, i64 }

; struct Lexer
%Lexer = type { i64, i64, i64, i64, i64, i64 }

; struct Program
%Program = type { i64 }

; enum Item
%Item = type { i64, i8*, i8* }

; struct FnDef
%FnDef = type { i64, i64, i64, i64, i64, i64 }

; struct Param
%Param = type { i64, i64 }

; struct StructDef
%StructDef = type { i64, i64, i64 }

; struct Field
%Field = type { i64, i64 }

; struct EnumDef
%EnumDef = type { i64, i64 }

; struct Variant
%Variant = type { i64, i64 }

; struct ImplDef
%ImplDef = type { i64, i64 }

; enum Stmt
%Stmt = type { i64, i8*, i8* }

; struct MatchArm
%MatchArm = type { i64, i64 }

; enum Pattern
%Pattern = type { i64, i8*, i8* }

; enum Expr
%Expr = type { i64, i8*, i8* }

; struct FieldInit
%FieldInit = type { i64, i64 }

; struct Parser
%Parser = type { i64, i64 }

; struct CodeGen
%CodeGen = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }

; struct StringBuilder

; struct RustGen
%RustGen = type { i64, i64, i64, i64 }

; struct Path
%Path = type { i64 }

; struct ArgParser
%ArgParser = type { i64 }

; enum Target
%Target = type { i64, i8*, i8* }

; struct CompilerConfig
%CompilerConfig = type { i64, i64, i64, i64 }

; struct Compiler
%Compiler = type { i64 }

define i64 @is_digit(i64 %c) {
  entry:
  %t0 = alloca i64
  store i64 %c, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @kore_str_len(i64 %t1)
  %t3 = call i64 @kore_str_eq(i64 %t2, i64 0)
  %t4 = icmp ne i64 %t3, 0
  br i1 %t4, label %then0, label %endif2
  then0:
  ret i64 0
  endif2:
  %t5 = load i64, i64* %t0
  %t6 = call i64 @kore_ord(i64 %t5)
  %t7 = alloca i64
  store i64 %t6, i64* %t7
  %t8 = load i64, i64* %t7
  %t10 = icmp sge i64 %t8, 48
  %t9 = zext i1 %t10 to i64
  %t11 = load i64, i64* %t7
  %t13 = icmp sle i64 %t11, 57
  %t12 = zext i1 %t13 to i64
  %t14 = and i64 %t9, %t12
  ret i64 %t14
}

define i64 @is_alpha(i64 %c) {
  entry:
  %t0 = alloca i64
  store i64 %c, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @kore_str_len(i64 %t1)
  %t3 = call i64 @kore_str_eq(i64 %t2, i64 0)
  %t4 = icmp ne i64 %t3, 0
  br i1 %t4, label %then3, label %endif5
  then3:
  ret i64 0
  endif5:
  %t5 = load i64, i64* %t0
  %t6 = call i64 @kore_ord(i64 %t5)
  %t7 = alloca i64
  store i64 %t6, i64* %t7
  %t8 = load i64, i64* %t7
  %t10 = icmp sge i64 %t8, 97
  %t9 = zext i1 %t10 to i64
  %t11 = load i64, i64* %t7
  %t13 = icmp sle i64 %t11, 122
  %t12 = zext i1 %t13 to i64
  %t14 = and i64 %t9, %t12
  %t15 = load i64, i64* %t7
  %t17 = icmp sge i64 %t15, 65
  %t16 = zext i1 %t17 to i64
  %t18 = load i64, i64* %t7
  %t20 = icmp sle i64 %t18, 90
  %t19 = zext i1 %t20 to i64
  %t21 = and i64 %t16, %t19
  %t22 = or i64 %t14, %t21
  ret i64 %t22
}

define i64 @is_ident_start(i64 %c) {
  entry:
  %t0 = alloca i64
  store i64 %c, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @is_alpha(i64 %t1)
  %t3 = load i64, i64* %t0
  %t4 = getelementptr [2 x i8], [2 x i8]* @.str.0, i64 0, i64 0
  %t5 = ptrtoint i8* %t4 to i64
  %t6 = call i64 @kore_str_eq(i64 %t3, i64 %t5)
  %t7 = or i64 %t2, %t6
  ret i64 %t7
}

define i64 @is_ident_char(i64 %c) {
  entry:
  %t0 = alloca i64
  store i64 %c, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @is_alpha(i64 %t1)
  %t3 = load i64, i64* %t0
  %t4 = call i64 @is_digit(i64 %t3)
  %t5 = or i64 %t2, %t4
  %t6 = load i64, i64* %t0
  %t7 = getelementptr [2 x i8], [2 x i8]* @.str.1, i64 0, i64 0
  %t8 = ptrtoint i8* %t7 to i64
  %t9 = call i64 @kore_str_eq(i64 %t6, i64 %t8)
  %t10 = or i64 %t5, %t9
  ret i64 %t10
}

define i64 @substring_range(i64 %s, i64 %start, i64 %end) {
  entry:
  %t0 = alloca i64
  store i64 %s, i64* %t0
  %t1 = alloca i64
  store i64 %start, i64* %t1
  %t2 = alloca i64
  store i64 %end, i64* %t2
  %t3 = load i64, i64* %t0
  %t4 = getelementptr [1 x i8], [1 x i8]* @.str.2, i64 0, i64 0
  %t5 = ptrtoint i8* %t4 to i64
  %t6 = call i64 @kore_split(i64 %t3, i64 %t5)
  %t7 = alloca i64
  store i64 %t6, i64* %t7
  %t8 = call i64 @kore_array_new()
  %t9 = alloca i64
  store i64 %t8, i64* %t9
  %t10 = load i64, i64* %t1
  %t11 = alloca i64
  store i64 %t10, i64* %t11
  %t12 = load i64, i64* %t7
  %t13 = call i64 @kore_array_len(i64 %t12)
  %t14 = alloca i64
  store i64 %t13, i64* %t14
  br label %while_cond6
  while_cond6:
  %t15 = load i64, i64* %t11
  %t16 = load i64, i64* %t2
  %t18 = icmp slt i64 %t15, %t16
  %t17 = zext i1 %t18 to i64
  %t19 = icmp ne i64 %t17, 0
  br i1 %t19, label %while_body7, label %while_end8
  while_body7:
  %t20 = load i64, i64* %t11
  %t21 = load i64, i64* %t14
  %t23 = icmp slt i64 %t20, %t21
  %t22 = zext i1 %t23 to i64
  %t24 = icmp ne i64 %t22, 0
  br i1 %t24, label %then9, label %endif11
  then9:
  %t25 = load i64, i64* %t9
  %t26 = load i64, i64* %t7
  %t27 = load i64, i64* %t11
  %t28 = call i64 @kore_array_get(i64 %t26, i64 %t27)
  %t29 = call i64 @kore_array_push(i64 %t25, i64 %t28)
  br label %endif11
  endif11:
  %t30 = load i64, i64* %t11
  %t31 = add i64 %t30, 1
  store i64 %t31, i64* %t11
  br label %while_cond6
  while_end8:
  %t32 = load i64, i64* %t9
  %t33 = getelementptr [1 x i8], [1 x i8]* @.str.3, i64 0, i64 0
  %t34 = ptrtoint i8* %t33 to i64
  %t35 = call i64 @kore_join(i64 %t32, i64 %t34)
  ret i64 %t35
}

define i64 @gen_cargo_toml(i64 %name, i64 %deps) {
  entry:
  %t0 = alloca i64
  store i64 %name, i64* %t0
  %t1 = alloca i64
  store i64 %deps, i64* %t1
  %t2 = call i64 @StringBuilder_new()
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  %t4 = load i64, i64* %t3
  %t5 = getelementptr [10 x i8], [10 x i8]* @.str.4, i64 0, i64 0
  %t6 = ptrtoint i8* %t5 to i64
  %t7 = call i64 @StringBuilder_push_line(i64 %t4, i64 %t6)
  %t8 = load i64, i64* %t3
  %t9 = getelementptr [8 x i8], [8 x i8]* @.str.5, i64 0, i64 0
  %t10 = ptrtoint i8* %t9 to i64
  %t11 = load i64, i64* %t0
  %t12 = call i64 @kore_str_concat(i64 %t10, i64 %t11)
  %t13 = getelementptr [1 x i8], [1 x i8]* @.str.6, i64 0, i64 0
  %t14 = ptrtoint i8* %t13 to i64
  %t15 = call i64 @kore_str_concat(i64 %t12, i64 %t14)
  %t16 = call i64 @StringBuilder_push_line(i64 %t8, i64 %t15)
  %t17 = load i64, i64* %t3
  %t18 = getelementptr [17 x i8], [17 x i8]* @.str.7, i64 0, i64 0
  %t19 = ptrtoint i8* %t18 to i64
  %t20 = call i64 @StringBuilder_push_line(i64 %t17, i64 %t19)
  %t21 = load i64, i64* %t3
  %t22 = getelementptr [16 x i8], [16 x i8]* @.str.8, i64 0, i64 0
  %t23 = ptrtoint i8* %t22 to i64
  %t24 = call i64 @StringBuilder_push_line(i64 %t21, i64 %t23)
  %t25 = load i64, i64* %t3
  %t26 = getelementptr [1 x i8], [1 x i8]* @.str.9, i64 0, i64 0
  %t27 = ptrtoint i8* %t26 to i64
  %t28 = call i64 @StringBuilder_push_line(i64 %t25, i64 %t27)
  %t29 = load i64, i64* %t3
  %t30 = getelementptr [29 x i8], [29 x i8]* @.str.10, i64 0, i64 0
  %t31 = ptrtoint i8* %t30 to i64
  %t32 = call i64 @StringBuilder_push_line(i64 %t29, i64 %t31)
  %t33 = load i64, i64* %t3
  %t34 = getelementptr [1 x i8], [1 x i8]* @.str.11, i64 0, i64 0
  %t35 = ptrtoint i8* %t34 to i64
  %t36 = call i64 @StringBuilder_push_line(i64 %t33, i64 %t35)
  %t37 = load i64, i64* %t3
  %t38 = getelementptr [15 x i8], [15 x i8]* @.str.12, i64 0, i64 0
  %t39 = ptrtoint i8* %t38 to i64
  %t40 = call i64 @StringBuilder_push_line(i64 %t37, i64 %t39)
  ; for dep in ...
  %t41 = load i64, i64* %t1
  %t42 = call i64 @kore_array_len(i64 %t41)
  %t43 = alloca i64
  store i64 0, i64* %t43
  br label %for_cond12
  for_cond12:
  %t44 = load i64, i64* %t43
  %t45 = icmp slt i64 %t44, %t42
  br i1 %t45, label %for_body13, label %for_end15
  for_body13:
  %t46 = call i64 @kore_array_get(i64 %t41, i64 %t44)
  %t47 = alloca i64
  store i64 %t46, i64* %t47
  %t48 = load i64, i64* %t3
  %t49 = load i64, i64* %t47
  %t50 = getelementptr [6 x i8], [6 x i8]* @.str.13, i64 0, i64 0
  %t51 = ptrtoint i8* %t50 to i64
  %t52 = call i64 @kore_str_concat(i64 %t49, i64 %t51)
  %t53 = call i64 @StringBuilder_push_line(i64 %t48, i64 %t52)
  br label %for_update14
  for_update14:
  %t54 = load i64, i64* %t43
  %t55 = add i64 %t54, 1
  store i64 %t55, i64* %t43
  br label %for_cond12
  for_end15:
  %t56 = load i64, i64* %t3
  %t57 = call i64 @StringBuilder_build(i64 %t56)
  ret i64 %t57
}

define i64 @main_kore() {
  entry:
  %t0 = call i64 @args()
  %t1 = alloca i64
  store i64 %t0, i64* %t1
  %t2 = load i64, i64* %t1
  %t3 = call i64 @kore_array_len(i64 %t2)
  %t5 = icmp slt i64 %t3, 2
  %t4 = zext i1 %t5 to i64
  %t6 = icmp ne i64 %t4, 0
  br i1 %t6, label %then16, label %endif18
  then16:
  %t7 = call i64 @print_help()
  %t8 = call i64 @exit(i64 0)
  br label %endif18
  endif18:
  %t9 = load i64, i64* %t1
  %t10 = getelementptr [7 x i8], [7 x i8]* @.str.14, i64 0, i64 0
  %t11 = ptrtoint i8* %t10 to i64
  %t12 = call i64 @kore_contains(i64 %t9, i64 %t11)
  %t13 = load i64, i64* %t1
  %t14 = getelementptr [3 x i8], [3 x i8]* @.str.15, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  %t16 = call i64 @kore_contains(i64 %t13, i64 %t15)
  %t17 = or i64 %t12, %t16
  %t18 = icmp ne i64 %t17, 0
  br i1 %t18, label %then19, label %endif21
  then19:
  %t19 = call i64 @print_help()
  %t20 = call i64 @exit(i64 0)
  br label %endif21
  endif21:
  %t21 = call i64 @CompilerConfig_from_args()
  %t22 = alloca i64
  store i64 %t21, i64* %t22
  %t23 = load i64, i64* %t22
  %t24 = call i64 @Compiler_new(i64 %t23)
  %t25 = alloca i64
  store i64 %t24, i64* %t25
  %t26 = load i64, i64* %t25
  %t27 = call i64 @Compiler_compile(i64 %t26)
  %t28 = icmp ne i64 %t27, 0
  br i1 %t28, label %then22, label %else23
  then22:
  %t29 = call i64 @exit(i64 0)
  br label %endif24
  else23:
  %t30 = call i64 @exit(i64 1)
  br label %endif24
  endif24:
  ret i64 0
}

define i64 @print_help() {
  entry:
  %t0 = getelementptr [52 x i8], [52 x i8]* @.str.16, i64 0, i64 0
  %t1 = ptrtoint i8* %t0 to i64
  %t2 = inttoptr i64 %t1 to i8*
  call void @kore_println_str(i8* %t2)
  %t3 = getelementptr [1 x i8], [1 x i8]* @.str.17, i64 0, i64 0
  %t4 = ptrtoint i8* %t3 to i64
  %t5 = inttoptr i64 %t4 to i8*
  call void @kore_println_str(i8* %t5)
  %t6 = getelementptr [7 x i8], [7 x i8]* @.str.18, i64 0, i64 0
  %t7 = ptrtoint i8* %t6 to i64
  %t8 = inttoptr i64 %t7 to i8*
  call void @kore_println_str(i8* %t8)
  %t9 = getelementptr [31 x i8], [31 x i8]* @.str.19, i64 0, i64 0
  %t10 = ptrtoint i8* %t9 to i64
  %t11 = inttoptr i64 %t10 to i8*
  call void @kore_println_str(i8* %t11)
  %t12 = getelementptr [1 x i8], [1 x i8]* @.str.20, i64 0, i64 0
  %t13 = ptrtoint i8* %t12 to i64
  %t14 = inttoptr i64 %t13 to i8*
  call void @kore_println_str(i8* %t14)
  %t15 = getelementptr [9 x i8], [9 x i8]* @.str.21, i64 0, i64 0
  %t16 = ptrtoint i8* %t15 to i64
  %t17 = inttoptr i64 %t16 to i8*
  call void @kore_println_str(i8* %t17)
  %t18 = getelementptr [48 x i8], [48 x i8]* @.str.22, i64 0, i64 0
  %t19 = ptrtoint i8* %t18 to i64
  %t20 = inttoptr i64 %t19 to i8*
  call void @kore_println_str(i8* %t20)
  %t21 = getelementptr [52 x i8], [52 x i8]* @.str.23, i64 0, i64 0
  %t22 = ptrtoint i8* %t21 to i64
  %t23 = inttoptr i64 %t22 to i8*
  call void @kore_println_str(i8* %t23)
  %t24 = getelementptr [51 x i8], [51 x i8]* @.str.24, i64 0, i64 0
  %t25 = ptrtoint i8* %t24 to i64
  %t26 = inttoptr i64 %t25 to i8*
  call void @kore_println_str(i8* %t26)
  %t27 = getelementptr [46 x i8], [46 x i8]* @.str.25, i64 0, i64 0
  %t28 = ptrtoint i8* %t27 to i64
  %t29 = inttoptr i64 %t28 to i8*
  call void @kore_println_str(i8* %t29)
  %t30 = getelementptr [41 x i8], [41 x i8]* @.str.26, i64 0, i64 0
  %t31 = ptrtoint i8* %t30 to i64
  %t32 = inttoptr i64 %t31 to i8*
  call void @kore_println_str(i8* %t32)
  %t33 = getelementptr [39 x i8], [39 x i8]* @.str.27, i64 0, i64 0
  %t34 = ptrtoint i8* %t33 to i64
  %t35 = inttoptr i64 %t34 to i8*
  call void @kore_println_str(i8* %t35)
  %t36 = getelementptr [39 x i8], [39 x i8]* @.str.28, i64 0, i64 0
  %t37 = ptrtoint i8* %t36 to i64
  %t38 = inttoptr i64 %t37 to i8*
  call void @kore_println_str(i8* %t38)
  %t39 = getelementptr [1 x i8], [1 x i8]* @.str.29, i64 0, i64 0
  %t40 = ptrtoint i8* %t39 to i64
  %t41 = inttoptr i64 %t40 to i8*
  call void @kore_println_str(i8* %t41)
  %t42 = getelementptr [10 x i8], [10 x i8]* @.str.30, i64 0, i64 0
  %t43 = ptrtoint i8* %t42 to i64
  %t44 = inttoptr i64 %t43 to i8*
  call void @kore_println_str(i8* %t44)
  %t45 = getelementptr [59 x i8], [59 x i8]* @.str.31, i64 0, i64 0
  %t46 = ptrtoint i8* %t45 to i64
  %t47 = inttoptr i64 %t46 to i8*
  call void @kore_println_str(i8* %t47)
  %t48 = getelementptr [58 x i8], [58 x i8]* @.str.32, i64 0, i64 0
  %t49 = ptrtoint i8* %t48 to i64
  %t50 = inttoptr i64 %t49 to i8*
  call void @kore_println_str(i8* %t50)
  %t51 = getelementptr [55 x i8], [55 x i8]* @.str.33, i64 0, i64 0
  %t52 = ptrtoint i8* %t51 to i64
  %t53 = inttoptr i64 %t52 to i8*
  call void @kore_println_str(i8* %t53)
  %t54 = getelementptr [1 x i8], [1 x i8]* @.str.34, i64 0, i64 0
  %t55 = ptrtoint i8* %t54 to i64
  %t56 = inttoptr i64 %t55 to i8*
  call void @kore_println_str(i8* %t56)
  %t57 = getelementptr [18 x i8], [18 x i8]* @.str.35, i64 0, i64 0
  %t58 = ptrtoint i8* %t57 to i64
  %t59 = inttoptr i64 %t58 to i8*
  call void @kore_println_str(i8* %t59)
  %t60 = getelementptr [45 x i8], [45 x i8]* @.str.36, i64 0, i64 0
  %t61 = ptrtoint i8* %t60 to i64
  %t62 = inttoptr i64 %t61 to i8*
  call void @kore_println_str(i8* %t62)
  %t63 = getelementptr [29 x i8], [29 x i8]* @.str.37, i64 0, i64 0
  %t64 = ptrtoint i8* %t63 to i64
  %t65 = inttoptr i64 %t64 to i8*
  call void @kore_println_str(i8* %t65)
  ret i64 0
}

; impl Token
define i64 @Token_new(i64 %kind, i64 %line, i64 %column, i64 %lexeme) {
  entry:
  %t0 = alloca i64
  store i64 %kind, i64* %t0
  %t1 = alloca i64
  store i64 %line, i64* %t1
  %t2 = alloca i64
  store i64 %column, i64* %t2
  %t3 = alloca i64
  store i64 %lexeme, i64* %t3
  ; struct literal: Token
  %t4 = call i8* @malloc(i64 32)
  %t5 = bitcast i8* %t4 to %Token*
  %t6 = load i64, i64* %t0
  %t7 = getelementptr %Token, %Token* %t5, i32 0, i32 0
  store i64 %t6, i64* %t7
  %t8 = load i64, i64* %t1
  %t9 = getelementptr %Token, %Token* %t5, i32 0, i32 1
  store i64 %t8, i64* %t9
  %t10 = load i64, i64* %t2
  %t11 = getelementptr %Token, %Token* %t5, i32 0, i32 2
  store i64 %t10, i64* %t11
  %t12 = load i64, i64* %t3
  %t13 = getelementptr %Token, %Token* %t5, i32 0, i32 3
  store i64 %t12, i64* %t13
  %t14 = ptrtoint %Token* %t5 to i64
  ret i64 %t14
}
define i64 @Token_is_keyword(i64 %self, i64 %kw) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %kw, i64* %t1
  %t2 = call i64 @kore_array_new()
  %t3 = getelementptr [3 x i8], [3 x i8]* @.str.38, i64 0, i64 0
  %t4 = ptrtoint i8* %t3 to i64
  %t5 = call i64 @kore_array_push(i64 %t2, i64 %t4)
  %t6 = getelementptr [4 x i8], [4 x i8]* @.str.39, i64 0, i64 0
  %t7 = ptrtoint i8* %t6 to i64
  %t8 = call i64 @kore_array_push(i64 %t2, i64 %t7)
  %t9 = getelementptr [4 x i8], [4 x i8]* @.str.40, i64 0, i64 0
  %t10 = ptrtoint i8* %t9 to i64
  %t11 = call i64 @kore_array_push(i64 %t2, i64 %t10)
  %t12 = getelementptr [3 x i8], [3 x i8]* @.str.41, i64 0, i64 0
  %t13 = ptrtoint i8* %t12 to i64
  %t14 = call i64 @kore_array_push(i64 %t2, i64 %t13)
  %t15 = getelementptr [5 x i8], [5 x i8]* @.str.42, i64 0, i64 0
  %t16 = ptrtoint i8* %t15 to i64
  %t17 = call i64 @kore_array_push(i64 %t2, i64 %t16)
  %t18 = getelementptr [6 x i8], [6 x i8]* @.str.43, i64 0, i64 0
  %t19 = ptrtoint i8* %t18 to i64
  %t20 = call i64 @kore_array_push(i64 %t2, i64 %t19)
  %t21 = getelementptr [4 x i8], [4 x i8]* @.str.44, i64 0, i64 0
  %t22 = ptrtoint i8* %t21 to i64
  %t23 = call i64 @kore_array_push(i64 %t2, i64 %t22)
  %t24 = getelementptr [3 x i8], [3 x i8]* @.str.45, i64 0, i64 0
  %t25 = ptrtoint i8* %t24 to i64
  %t26 = call i64 @kore_array_push(i64 %t2, i64 %t25)
  %t27 = getelementptr [7 x i8], [7 x i8]* @.str.46, i64 0, i64 0
  %t28 = ptrtoint i8* %t27 to i64
  %t29 = call i64 @kore_array_push(i64 %t2, i64 %t28)
  %t30 = getelementptr [6 x i8], [6 x i8]* @.str.47, i64 0, i64 0
  %t31 = ptrtoint i8* %t30 to i64
  %t32 = call i64 @kore_array_push(i64 %t2, i64 %t31)
  %t33 = getelementptr [7 x i8], [7 x i8]* @.str.48, i64 0, i64 0
  %t34 = ptrtoint i8* %t33 to i64
  %t35 = call i64 @kore_array_push(i64 %t2, i64 %t34)
  %t36 = getelementptr [5 x i8], [5 x i8]* @.str.49, i64 0, i64 0
  %t37 = ptrtoint i8* %t36 to i64
  %t38 = call i64 @kore_array_push(i64 %t2, i64 %t37)
  %t39 = getelementptr [5 x i8], [5 x i8]* @.str.50, i64 0, i64 0
  %t40 = ptrtoint i8* %t39 to i64
  %t41 = call i64 @kore_array_push(i64 %t2, i64 %t40)
  %t42 = getelementptr [4 x i8], [4 x i8]* @.str.51, i64 0, i64 0
  %t43 = ptrtoint i8* %t42 to i64
  %t44 = call i64 @kore_array_push(i64 %t2, i64 %t43)
  %t45 = getelementptr [4 x i8], [4 x i8]* @.str.52, i64 0, i64 0
  %t46 = ptrtoint i8* %t45 to i64
  %t47 = call i64 @kore_array_push(i64 %t2, i64 %t46)
  %t48 = getelementptr [6 x i8], [6 x i8]* @.str.53, i64 0, i64 0
  %t49 = ptrtoint i8* %t48 to i64
  %t50 = call i64 @kore_array_push(i64 %t2, i64 %t49)
  %t51 = getelementptr [6 x i8], [6 x i8]* @.str.54, i64 0, i64 0
  %t52 = ptrtoint i8* %t51 to i64
  %t53 = call i64 @kore_array_push(i64 %t2, i64 %t52)
  %t54 = getelementptr [6 x i8], [6 x i8]* @.str.55, i64 0, i64 0
  %t55 = ptrtoint i8* %t54 to i64
  %t56 = call i64 @kore_array_push(i64 %t2, i64 %t55)
  %t57 = getelementptr [6 x i8], [6 x i8]* @.str.56, i64 0, i64 0
  %t58 = ptrtoint i8* %t57 to i64
  %t59 = call i64 @kore_array_push(i64 %t2, i64 %t58)
  %t60 = getelementptr [3 x i8], [3 x i8]* @.str.57, i64 0, i64 0
  %t61 = ptrtoint i8* %t60 to i64
  %t62 = call i64 @kore_array_push(i64 %t2, i64 %t61)
  %t63 = getelementptr [5 x i8], [5 x i8]* @.str.58, i64 0, i64 0
  %t64 = ptrtoint i8* %t63 to i64
  %t65 = call i64 @kore_array_push(i64 %t2, i64 %t64)
  %t66 = getelementptr [5 x i8], [5 x i8]* @.str.59, i64 0, i64 0
  %t67 = ptrtoint i8* %t66 to i64
  %t68 = call i64 @kore_array_push(i64 %t2, i64 %t67)
  %t69 = getelementptr [6 x i8], [6 x i8]* @.str.60, i64 0, i64 0
  %t70 = ptrtoint i8* %t69 to i64
  %t71 = call i64 @kore_array_push(i64 %t2, i64 %t70)
  %t72 = getelementptr [5 x i8], [5 x i8]* @.str.61, i64 0, i64 0
  %t73 = ptrtoint i8* %t72 to i64
  %t74 = call i64 @kore_array_push(i64 %t2, i64 %t73)
  %t75 = getelementptr [5 x i8], [5 x i8]* @.str.62, i64 0, i64 0
  %t76 = ptrtoint i8* %t75 to i64
  %t77 = call i64 @kore_array_push(i64 %t2, i64 %t76)
  %t78 = getelementptr [5 x i8], [5 x i8]* @.str.63, i64 0, i64 0
  %t79 = ptrtoint i8* %t78 to i64
  %t80 = call i64 @kore_array_push(i64 %t2, i64 %t79)
  %t81 = getelementptr [9 x i8], [9 x i8]* @.str.64, i64 0, i64 0
  %t82 = ptrtoint i8* %t81 to i64
  %t83 = call i64 @kore_array_push(i64 %t2, i64 %t82)
  %t84 = getelementptr [5 x i8], [5 x i8]* @.str.65, i64 0, i64 0
  %t85 = ptrtoint i8* %t84 to i64
  %t86 = call i64 @kore_array_push(i64 %t2, i64 %t85)
  %t87 = getelementptr [6 x i8], [6 x i8]* @.str.66, i64 0, i64 0
  %t88 = ptrtoint i8* %t87 to i64
  %t89 = call i64 @kore_array_push(i64 %t2, i64 %t88)
  %t90 = getelementptr [9 x i8], [9 x i8]* @.str.67, i64 0, i64 0
  %t91 = ptrtoint i8* %t90 to i64
  %t92 = call i64 @kore_array_push(i64 %t2, i64 %t91)
  %t93 = getelementptr [5 x i8], [5 x i8]* @.str.68, i64 0, i64 0
  %t94 = ptrtoint i8* %t93 to i64
  %t95 = call i64 @kore_array_push(i64 %t2, i64 %t94)
  %t96 = alloca i64
  store i64 %t2, i64* %t96
  %t97 = load i64, i64* %t0
  %t98 = inttoptr i64 %t97 to %Token*
  %t99 = getelementptr %Token, %Token* %t98, i32 0, i32 3
  %t100 = load i64, i64* %t99
  %t101 = load i64, i64* %t1
  %t102 = call i64 @kore_str_eq(i64 %t100, i64 %t101)
  %t103 = load i64, i64* %t96
  %t104 = load i64, i64* %t0
  %t105 = inttoptr i64 %t104 to %Token*
  %t106 = getelementptr %Token, %Token* %t105, i32 0, i32 3
  %t107 = load i64, i64* %t106
  %t108 = call i64 @kore_contains(i64 %t103, i64 %t107)
  %t109 = and i64 %t102, %t108
  ret i64 %t109
}
define i64 @Token_is_ident(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = call i64 @kore_array_new()
  %t2 = getelementptr [3 x i8], [3 x i8]* @.str.69, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = call i64 @kore_array_push(i64 %t1, i64 %t3)
  %t5 = getelementptr [4 x i8], [4 x i8]* @.str.70, i64 0, i64 0
  %t6 = ptrtoint i8* %t5 to i64
  %t7 = call i64 @kore_array_push(i64 %t1, i64 %t6)
  %t8 = getelementptr [4 x i8], [4 x i8]* @.str.71, i64 0, i64 0
  %t9 = ptrtoint i8* %t8 to i64
  %t10 = call i64 @kore_array_push(i64 %t1, i64 %t9)
  %t11 = getelementptr [3 x i8], [3 x i8]* @.str.72, i64 0, i64 0
  %t12 = ptrtoint i8* %t11 to i64
  %t13 = call i64 @kore_array_push(i64 %t1, i64 %t12)
  %t14 = getelementptr [5 x i8], [5 x i8]* @.str.73, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  %t16 = call i64 @kore_array_push(i64 %t1, i64 %t15)
  %t17 = getelementptr [6 x i8], [6 x i8]* @.str.74, i64 0, i64 0
  %t18 = ptrtoint i8* %t17 to i64
  %t19 = call i64 @kore_array_push(i64 %t1, i64 %t18)
  %t20 = getelementptr [4 x i8], [4 x i8]* @.str.75, i64 0, i64 0
  %t21 = ptrtoint i8* %t20 to i64
  %t22 = call i64 @kore_array_push(i64 %t1, i64 %t21)
  %t23 = getelementptr [3 x i8], [3 x i8]* @.str.76, i64 0, i64 0
  %t24 = ptrtoint i8* %t23 to i64
  %t25 = call i64 @kore_array_push(i64 %t1, i64 %t24)
  %t26 = getelementptr [7 x i8], [7 x i8]* @.str.77, i64 0, i64 0
  %t27 = ptrtoint i8* %t26 to i64
  %t28 = call i64 @kore_array_push(i64 %t1, i64 %t27)
  %t29 = getelementptr [6 x i8], [6 x i8]* @.str.78, i64 0, i64 0
  %t30 = ptrtoint i8* %t29 to i64
  %t31 = call i64 @kore_array_push(i64 %t1, i64 %t30)
  %t32 = getelementptr [7 x i8], [7 x i8]* @.str.79, i64 0, i64 0
  %t33 = ptrtoint i8* %t32 to i64
  %t34 = call i64 @kore_array_push(i64 %t1, i64 %t33)
  %t35 = getelementptr [5 x i8], [5 x i8]* @.str.80, i64 0, i64 0
  %t36 = ptrtoint i8* %t35 to i64
  %t37 = call i64 @kore_array_push(i64 %t1, i64 %t36)
  %t38 = getelementptr [5 x i8], [5 x i8]* @.str.81, i64 0, i64 0
  %t39 = ptrtoint i8* %t38 to i64
  %t40 = call i64 @kore_array_push(i64 %t1, i64 %t39)
  %t41 = getelementptr [4 x i8], [4 x i8]* @.str.82, i64 0, i64 0
  %t42 = ptrtoint i8* %t41 to i64
  %t43 = call i64 @kore_array_push(i64 %t1, i64 %t42)
  %t44 = getelementptr [4 x i8], [4 x i8]* @.str.83, i64 0, i64 0
  %t45 = ptrtoint i8* %t44 to i64
  %t46 = call i64 @kore_array_push(i64 %t1, i64 %t45)
  %t47 = getelementptr [6 x i8], [6 x i8]* @.str.84, i64 0, i64 0
  %t48 = ptrtoint i8* %t47 to i64
  %t49 = call i64 @kore_array_push(i64 %t1, i64 %t48)
  %t50 = getelementptr [6 x i8], [6 x i8]* @.str.85, i64 0, i64 0
  %t51 = ptrtoint i8* %t50 to i64
  %t52 = call i64 @kore_array_push(i64 %t1, i64 %t51)
  %t53 = getelementptr [6 x i8], [6 x i8]* @.str.86, i64 0, i64 0
  %t54 = ptrtoint i8* %t53 to i64
  %t55 = call i64 @kore_array_push(i64 %t1, i64 %t54)
  %t56 = getelementptr [6 x i8], [6 x i8]* @.str.87, i64 0, i64 0
  %t57 = ptrtoint i8* %t56 to i64
  %t58 = call i64 @kore_array_push(i64 %t1, i64 %t57)
  %t59 = getelementptr [3 x i8], [3 x i8]* @.str.88, i64 0, i64 0
  %t60 = ptrtoint i8* %t59 to i64
  %t61 = call i64 @kore_array_push(i64 %t1, i64 %t60)
  %t62 = getelementptr [5 x i8], [5 x i8]* @.str.89, i64 0, i64 0
  %t63 = ptrtoint i8* %t62 to i64
  %t64 = call i64 @kore_array_push(i64 %t1, i64 %t63)
  %t65 = getelementptr [5 x i8], [5 x i8]* @.str.90, i64 0, i64 0
  %t66 = ptrtoint i8* %t65 to i64
  %t67 = call i64 @kore_array_push(i64 %t1, i64 %t66)
  %t68 = getelementptr [6 x i8], [6 x i8]* @.str.91, i64 0, i64 0
  %t69 = ptrtoint i8* %t68 to i64
  %t70 = call i64 @kore_array_push(i64 %t1, i64 %t69)
  %t71 = getelementptr [5 x i8], [5 x i8]* @.str.92, i64 0, i64 0
  %t72 = ptrtoint i8* %t71 to i64
  %t73 = call i64 @kore_array_push(i64 %t1, i64 %t72)
  %t74 = getelementptr [5 x i8], [5 x i8]* @.str.93, i64 0, i64 0
  %t75 = ptrtoint i8* %t74 to i64
  %t76 = call i64 @kore_array_push(i64 %t1, i64 %t75)
  %t77 = getelementptr [5 x i8], [5 x i8]* @.str.94, i64 0, i64 0
  %t78 = ptrtoint i8* %t77 to i64
  %t79 = call i64 @kore_array_push(i64 %t1, i64 %t78)
  %t80 = getelementptr [9 x i8], [9 x i8]* @.str.95, i64 0, i64 0
  %t81 = ptrtoint i8* %t80 to i64
  %t82 = call i64 @kore_array_push(i64 %t1, i64 %t81)
  %t83 = getelementptr [5 x i8], [5 x i8]* @.str.96, i64 0, i64 0
  %t84 = ptrtoint i8* %t83 to i64
  %t85 = call i64 @kore_array_push(i64 %t1, i64 %t84)
  %t86 = getelementptr [6 x i8], [6 x i8]* @.str.97, i64 0, i64 0
  %t87 = ptrtoint i8* %t86 to i64
  %t88 = call i64 @kore_array_push(i64 %t1, i64 %t87)
  %t89 = getelementptr [9 x i8], [9 x i8]* @.str.98, i64 0, i64 0
  %t90 = ptrtoint i8* %t89 to i64
  %t91 = call i64 @kore_array_push(i64 %t1, i64 %t90)
  %t92 = getelementptr [5 x i8], [5 x i8]* @.str.99, i64 0, i64 0
  %t93 = ptrtoint i8* %t92 to i64
  %t94 = call i64 @kore_array_push(i64 %t1, i64 %t93)
  %t95 = alloca i64
  store i64 %t1, i64* %t95
  %t96 = load i64, i64* %t0
  %t97 = inttoptr i64 %t96 to %Token*
  %t98 = getelementptr %Token, %Token* %t97, i32 0, i32 3
  %t99 = load i64, i64* %t98
  %t100 = call i64 @kore_str_len(i64 %t99)
  %t101 = call i64 @kore_str_eq(i64 %t100, i64 0)
  %t102 = icmp ne i64 %t101, 0
  br i1 %t102, label %then25, label %endif27
  then25:
  ret i64 0
  endif27:
  %t103 = load i64, i64* %t0
  %t104 = inttoptr i64 %t103 to %Token*
  %t105 = getelementptr %Token, %Token* %t104, i32 0, i32 3
  %t106 = load i64, i64* %t105
  %t107 = call i64 @kore_ord(i64 %t106)
  %t108 = alloca i64
  store i64 %t107, i64* %t108
  %t109 = load i64, i64* %t108
  %t111 = icmp sge i64 %t109, 97
  %t110 = zext i1 %t111 to i64
  %t112 = load i64, i64* %t108
  %t114 = icmp sle i64 %t112, 122
  %t113 = zext i1 %t114 to i64
  %t115 = and i64 %t110, %t113
  %t116 = load i64, i64* %t108
  %t118 = icmp sge i64 %t116, 65
  %t117 = zext i1 %t118 to i64
  %t119 = load i64, i64* %t108
  %t121 = icmp sle i64 %t119, 90
  %t120 = zext i1 %t121 to i64
  %t122 = and i64 %t117, %t120
  %t123 = or i64 %t115, %t122
  %t124 = load i64, i64* %t108
  %t125 = call i64 @kore_str_eq(i64 %t124, i64 95)
  %t126 = or i64 %t123, %t125
  %t127 = alloca i64
  store i64 %t126, i64* %t127
  %t128 = load i64, i64* %t127
  %t129 = load i64, i64* %t95
  %t130 = load i64, i64* %t0
  %t131 = inttoptr i64 %t130 to %Token*
  %t132 = getelementptr %Token, %Token* %t131, i32 0, i32 3
  %t133 = load i64, i64* %t132
  %t134 = call i64 @kore_contains(i64 %t129, i64 %t133)
  %t136 = icmp eq i64 %t134, 0
  %t135 = zext i1 %t136 to i64
  %t137 = and i64 %t128, %t135
  ret i64 %t137
}
define i64 @Token_is_error(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  ret i64 0
}
define i64 @Token_is_indent(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %Token*
  %t3 = getelementptr %Token, %Token* %t2, i32 0, i32 3
  %t4 = load i64, i64* %t3
  %t5 = getelementptr [5 x i8], [5 x i8]* @.str.100, i64 0, i64 0
  %t6 = ptrtoint i8* %t5 to i64
  %t7 = call i64 @kore_str_eq(i64 %t4, i64 %t6)
  %t8 = load i64, i64* %t0
  %t9 = inttoptr i64 %t8 to %Token*
  %t10 = getelementptr %Token, %Token* %t9, i32 0, i32 3
  %t11 = load i64, i64* %t10
  %t12 = getelementptr [7 x i8], [7 x i8]* @.str.101, i64 0, i64 0
  %t13 = ptrtoint i8* %t12 to i64
  %t14 = call i64 @kore_str_eq(i64 %t11, i64 %t13)
  %t15 = or i64 %t7, %t14
  ret i64 %t15
}
define i64 @Token_is_dedent(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %Token*
  %t3 = getelementptr %Token, %Token* %t2, i32 0, i32 3
  %t4 = load i64, i64* %t3
  %t5 = getelementptr [7 x i8], [7 x i8]* @.str.102, i64 0, i64 0
  %t6 = ptrtoint i8* %t5 to i64
  %t7 = call i64 @kore_str_eq(i64 %t4, i64 %t6)
  ret i64 %t7
}
define i64 @Token_is_newline(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %Token*
  %t3 = getelementptr %Token, %Token* %t2, i32 0, i32 3
  %t4 = load i64, i64* %t3
  %t5 = getelementptr [2 x i8], [2 x i8]* @.str.103, i64 0, i64 0
  %t6 = ptrtoint i8* %t5 to i64
  %t7 = call i64 @kore_str_eq(i64 %t4, i64 %t6)
  %t8 = load i64, i64* %t0
  %t9 = inttoptr i64 %t8 to %Token*
  %t10 = getelementptr %Token, %Token* %t9, i32 0, i32 3
  %t11 = load i64, i64* %t10
  %t12 = getelementptr [3 x i8], [3 x i8]* @.str.104, i64 0, i64 0
  %t13 = ptrtoint i8* %t12 to i64
  %t14 = call i64 @kore_str_eq(i64 %t11, i64 %t13)
  %t15 = or i64 %t7, %t14
  ret i64 %t15
}

; impl Lexer
define i64 @Lexer_new(i64 %source) {
  entry:
  %t0 = alloca i64
  store i64 %source, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = getelementptr [1 x i8], [1 x i8]* @.str.105, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = call i64 @kore_split(i64 %t1, i64 %t3)
  %t5 = alloca i64
  store i64 %t4, i64* %t5
  ; struct literal: Lexer
  %t6 = call i8* @malloc(i64 48)
  %t7 = bitcast i8* %t6 to %Lexer*
  %t8 = load i64, i64* %t0
  %t9 = getelementptr %Lexer, %Lexer* %t7, i32 0, i32 0
  store i64 %t8, i64* %t9
  %t10 = load i64, i64* %t5
  %t11 = getelementptr %Lexer, %Lexer* %t7, i32 0, i32 1
  store i64 %t10, i64* %t11
  %t12 = getelementptr %Lexer, %Lexer* %t7, i32 0, i32 2
  store i64 0, i64* %t12
  %t13 = getelementptr %Lexer, %Lexer* %t7, i32 0, i32 3
  store i64 1, i64* %t13
  %t14 = getelementptr %Lexer, %Lexer* %t7, i32 0, i32 4
  store i64 1, i64* %t14
  %t15 = call i64 @kore_array_new()
  %t16 = call i64 @kore_array_push(i64 %t15, i64 0)
  %t17 = getelementptr %Lexer, %Lexer* %t7, i32 0, i32 5
  store i64 %t15, i64* %t17
  %t18 = ptrtoint %Lexer* %t7 to i64
  ret i64 %t18
}
define i64 @Lexer_is_eof(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %Lexer*
  %t3 = getelementptr %Lexer, %Lexer* %t2, i32 0, i32 2
  %t4 = load i64, i64* %t3
  %t5 = load i64, i64* %t0
  %t6 = inttoptr i64 %t5 to %Lexer*
  %t7 = getelementptr %Lexer, %Lexer* %t6, i32 0, i32 1
  %t8 = load i64, i64* %t7
  %t9 = call i64 @kore_array_len(i64 %t8)
  %t11 = icmp sge i64 %t4, %t9
  %t10 = zext i1 %t11 to i64
  ret i64 %t10
}
define i64 @Lexer_peek(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Lexer_is_eof(i64 %t1)
  %t3 = icmp ne i64 %t2, 0
  br i1 %t3, label %then28, label %endif30
  then28:
  %t4 = getelementptr [1 x i8], [1 x i8]* @.str.106, i64 0, i64 0
  %t5 = ptrtoint i8* %t4 to i64
  ret i64 %t5
  endif30:
  %t6 = load i64, i64* %t0
  %t7 = inttoptr i64 %t6 to %Lexer*
  %t8 = getelementptr %Lexer, %Lexer* %t7, i32 0, i32 1
  %t9 = load i64, i64* %t8
  %t10 = load i64, i64* %t0
  %t11 = inttoptr i64 %t10 to %Lexer*
  %t12 = getelementptr %Lexer, %Lexer* %t11, i32 0, i32 2
  %t13 = load i64, i64* %t12
  %t14 = call i64 @kore_array_get(i64 %t9, i64 %t13)
  ret i64 %t14
}
define i64 @Lexer_peek_n(i64 %self, i64 %n) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %n, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = inttoptr i64 %t2 to %Lexer*
  %t4 = getelementptr %Lexer, %Lexer* %t3, i32 0, i32 2
  %t5 = load i64, i64* %t4
  %t6 = load i64, i64* %t1
  %t7 = add i64 %t5, %t6
  %t8 = alloca i64
  store i64 %t7, i64* %t8
  %t9 = load i64, i64* %t8
  %t10 = load i64, i64* %t0
  %t11 = inttoptr i64 %t10 to %Lexer*
  %t12 = getelementptr %Lexer, %Lexer* %t11, i32 0, i32 1
  %t13 = load i64, i64* %t12
  %t14 = call i64 @kore_array_len(i64 %t13)
  %t16 = icmp sge i64 %t9, %t14
  %t15 = zext i1 %t16 to i64
  %t17 = icmp ne i64 %t15, 0
  br i1 %t17, label %then31, label %endif33
  then31:
  %t18 = getelementptr [1 x i8], [1 x i8]* @.str.107, i64 0, i64 0
  %t19 = ptrtoint i8* %t18 to i64
  ret i64 %t19
  endif33:
  %t20 = load i64, i64* %t0
  %t21 = inttoptr i64 %t20 to %Lexer*
  %t22 = getelementptr %Lexer, %Lexer* %t21, i32 0, i32 1
  %t23 = load i64, i64* %t22
  %t24 = load i64, i64* %t8
  %t25 = call i64 @kore_array_get(i64 %t23, i64 %t24)
  ret i64 %t25
}
define i64 @Lexer_advance(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Lexer_is_eof(i64 %t1)
  %t3 = icmp ne i64 %t2, 0
  br i1 %t3, label %then34, label %endif36
  then34:
  %t4 = getelementptr [1 x i8], [1 x i8]* @.str.108, i64 0, i64 0
  %t5 = ptrtoint i8* %t4 to i64
  ret i64 %t5
  endif36:
  %t6 = load i64, i64* %t0
  %t7 = inttoptr i64 %t6 to %Lexer*
  %t8 = getelementptr %Lexer, %Lexer* %t7, i32 0, i32 1
  %t9 = load i64, i64* %t8
  %t10 = load i64, i64* %t0
  %t11 = inttoptr i64 %t10 to %Lexer*
  %t12 = getelementptr %Lexer, %Lexer* %t11, i32 0, i32 2
  %t13 = load i64, i64* %t12
  %t14 = call i64 @kore_array_get(i64 %t9, i64 %t13)
  %t15 = alloca i64
  store i64 %t14, i64* %t15
  %t16 = load i64, i64* %t0
  %t17 = inttoptr i64 %t16 to %Lexer*
  %t18 = getelementptr %Lexer, %Lexer* %t17, i32 0, i32 2
  %t19 = load i64, i64* %t18
  %t20 = add i64 %t19, 1
  %t21 = load i64, i64* %t0
  %t22 = inttoptr i64 %t21 to %Lexer*
  %t23 = getelementptr %Lexer, %Lexer* %t22, i32 0, i32 2
  store i64 %t20, i64* %t23
  %t24 = load i64, i64* %t15
  %t25 = getelementptr [2 x i8], [2 x i8]* @.str.109, i64 0, i64 0
  %t26 = ptrtoint i8* %t25 to i64
  %t27 = call i64 @kore_str_eq(i64 %t24, i64 %t26)
  %t28 = icmp ne i64 %t27, 0
  br i1 %t28, label %then37, label %else38
  then37:
  %t29 = load i64, i64* %t0
  %t30 = inttoptr i64 %t29 to %Lexer*
  %t31 = getelementptr %Lexer, %Lexer* %t30, i32 0, i32 3
  %t32 = load i64, i64* %t31
  %t33 = add i64 %t32, 1
  %t34 = load i64, i64* %t0
  %t35 = inttoptr i64 %t34 to %Lexer*
  %t36 = getelementptr %Lexer, %Lexer* %t35, i32 0, i32 3
  store i64 %t33, i64* %t36
  %t37 = load i64, i64* %t0
  %t38 = inttoptr i64 %t37 to %Lexer*
  %t39 = getelementptr %Lexer, %Lexer* %t38, i32 0, i32 4
  store i64 1, i64* %t39
  br label %endif39
  else38:
  %t40 = load i64, i64* %t0
  %t41 = inttoptr i64 %t40 to %Lexer*
  %t42 = getelementptr %Lexer, %Lexer* %t41, i32 0, i32 4
  %t43 = load i64, i64* %t42
  %t44 = add i64 %t43, 1
  %t45 = load i64, i64* %t0
  %t46 = inttoptr i64 %t45 to %Lexer*
  %t47 = getelementptr %Lexer, %Lexer* %t46, i32 0, i32 4
  store i64 %t44, i64* %t47
  br label %endif39
  endif39:
  %t48 = load i64, i64* %t15
  ret i64 %t48
}
define i64 @Lexer_skip_spaces(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  br label %while_cond40
  while_cond40:
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Lexer_is_eof(i64 %t1)
  %t4 = icmp eq i64 %t2, 0
  %t3 = zext i1 %t4 to i64
  %t5 = icmp ne i64 %t3, 0
  br i1 %t5, label %while_body41, label %while_end42
  while_body41:
  %t6 = load i64, i64* %t0
  %t7 = call i64 @Lexer_peek(i64 %t6)
  %t8 = alloca i64
  store i64 %t7, i64* %t8
  %t9 = load i64, i64* %t8
  %t10 = getelementptr [2 x i8], [2 x i8]* @.str.110, i64 0, i64 0
  %t11 = ptrtoint i8* %t10 to i64
  %t12 = call i64 @kore_str_eq(i64 %t9, i64 %t11)
  %t13 = load i64, i64* %t8
  %t14 = getelementptr [2 x i8], [2 x i8]* @.str.111, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  %t16 = call i64 @kore_str_eq(i64 %t13, i64 %t15)
  %t17 = or i64 %t12, %t16
  %t18 = icmp ne i64 %t17, 0
  br i1 %t18, label %then43, label %else44
  then43:
  %t19 = load i64, i64* %t0
  %t20 = call i64 @Lexer_advance(i64 %t19)
  br label %endif45
  else44:
  br label %while_end42
  endif45:
  br label %while_cond40
  while_end42:
  ret i64 0
}
define i64 @Lexer_make_token(i64 %self, i64 %kind, i64 %lexeme) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %kind, i64* %t1
  %t2 = alloca i64
  store i64 %lexeme, i64* %t2
  %t3 = load i64, i64* %t1
  %t4 = load i64, i64* %t0
  %t5 = inttoptr i64 %t4 to %Lexer*
  %t6 = getelementptr %Lexer, %Lexer* %t5, i32 0, i32 3
  %t7 = load i64, i64* %t6
  %t8 = load i64, i64* %t0
  %t9 = inttoptr i64 %t8 to %Lexer*
  %t10 = getelementptr %Lexer, %Lexer* %t9, i32 0, i32 4
  %t11 = load i64, i64* %t10
  %t12 = load i64, i64* %t2
  %t13 = call i64 @Token_new(i64 %t3, i64 %t7, i64 %t11, i64 %t12)
  ret i64 %t13
}
define i64 @Lexer_lex_number(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %Lexer*
  %t3 = getelementptr %Lexer, %Lexer* %t2, i32 0, i32 2
  %t4 = load i64, i64* %t3
  %t5 = alloca i64
  store i64 %t4, i64* %t5
  %t6 = load i64, i64* %t0
  %t7 = inttoptr i64 %t6 to %Lexer*
  %t8 = getelementptr %Lexer, %Lexer* %t7, i32 0, i32 4
  %t9 = load i64, i64* %t8
  %t10 = alloca i64
  store i64 %t9, i64* %t10
  br label %while_cond46
  while_cond46:
  %t11 = load i64, i64* %t0
  %t12 = call i64 @Lexer_is_eof(i64 %t11)
  %t14 = icmp eq i64 %t12, 0
  %t13 = zext i1 %t14 to i64
  %t15 = load i64, i64* %t0
  %t16 = call i64 @Lexer_peek(i64 %t15)
  %t17 = call i64 @is_digit(i64 %t16)
  %t18 = and i64 %t13, %t17
  %t19 = icmp ne i64 %t18, 0
  br i1 %t19, label %while_body47, label %while_end48
  while_body47:
  %t20 = load i64, i64* %t0
  %t21 = call i64 @Lexer_advance(i64 %t20)
  br label %while_cond46
  while_end48:
  %t22 = load i64, i64* %t0
  %t23 = call i64 @Lexer_peek(i64 %t22)
  %t24 = getelementptr [2 x i8], [2 x i8]* @.str.112, i64 0, i64 0
  %t25 = ptrtoint i8* %t24 to i64
  %t26 = call i64 @kore_str_eq(i64 %t23, i64 %t25)
  %t27 = load i64, i64* %t0
  %t28 = call i64 @Lexer_peek_n(i64 %t27, i64 1)
  %t29 = call i64 @is_digit(i64 %t28)
  %t30 = and i64 %t26, %t29
  %t31 = icmp ne i64 %t30, 0
  br i1 %t31, label %then49, label %endif51
  then49:
  %t32 = load i64, i64* %t0
  %t33 = call i64 @Lexer_advance(i64 %t32)
  br label %while_cond52
  while_cond52:
  %t34 = load i64, i64* %t0
  %t35 = call i64 @Lexer_is_eof(i64 %t34)
  %t37 = icmp eq i64 %t35, 0
  %t36 = zext i1 %t37 to i64
  %t38 = load i64, i64* %t0
  %t39 = call i64 @Lexer_peek(i64 %t38)
  %t40 = call i64 @is_digit(i64 %t39)
  %t41 = and i64 %t36, %t40
  %t42 = icmp ne i64 %t41, 0
  br i1 %t42, label %while_body53, label %while_end54
  while_body53:
  %t43 = load i64, i64* %t0
  %t44 = call i64 @Lexer_advance(i64 %t43)
  br label %while_cond52
  while_end54:
  %t45 = load i64, i64* %t0
  %t46 = inttoptr i64 %t45 to %Lexer*
  %t47 = getelementptr %Lexer, %Lexer* %t46, i32 0, i32 0
  %t48 = load i64, i64* %t47
  %t49 = load i64, i64* %t5
  %t50 = load i64, i64* %t0
  %t51 = inttoptr i64 %t50 to %Lexer*
  %t52 = getelementptr %Lexer, %Lexer* %t51, i32 0, i32 2
  %t53 = load i64, i64* %t52
  %t54 = call i64 @substring_range(i64 %t48, i64 %t49, i64 %t53)
  %t55 = alloca i64
  store i64 %t54, i64* %t55
  ; enum variant: TokenKind::Float
  %t56 = call i8* @malloc(i64 24)
  %t57 = bitcast i8* %t56 to %TokenKind*
  %t58 = getelementptr %TokenKind, %TokenKind* %t57, i32 0, i32 0
  store i64 1, i64* %t58
  %t59 = call i8* @malloc(i64 8)
  %t60 = bitcast i8* %t59 to i64*
  %t61 = load i64, i64* %t55
  %t62 = call i64 @kore_to_float(i64 %t61)
  %t63 = getelementptr i64, i64* %t60, i32 0
  store i64 %t62, i64* %t63
  %t64 = getelementptr %TokenKind, %TokenKind* %t57, i32 0, i32 1
  store i8* %t59, i8** %t64
  %t65 = getelementptr %TokenKind, %TokenKind* %t57, i32 0, i32 2
  %t66 = getelementptr [6 x i8], [6 x i8]* @.str.113, i64 0, i64 0
  store i8* %t66, i8** %t65
  %t67 = ptrtoint %TokenKind* %t57 to i64
  %t68 = load i64, i64* %t0
  %t69 = inttoptr i64 %t68 to %Lexer*
  %t70 = getelementptr %Lexer, %Lexer* %t69, i32 0, i32 3
  %t71 = load i64, i64* %t70
  %t72 = load i64, i64* %t10
  %t73 = load i64, i64* %t55
  %t74 = call i64 @Token_new(i64 %t67, i64 %t71, i64 %t72, i64 %t73)
  ret i64 %t74
  endif51:
  %t75 = load i64, i64* %t0
  %t76 = inttoptr i64 %t75 to %Lexer*
  %t77 = getelementptr %Lexer, %Lexer* %t76, i32 0, i32 0
  %t78 = load i64, i64* %t77
  %t79 = load i64, i64* %t5
  %t80 = load i64, i64* %t0
  %t81 = inttoptr i64 %t80 to %Lexer*
  %t82 = getelementptr %Lexer, %Lexer* %t81, i32 0, i32 2
  %t83 = load i64, i64* %t82
  %t84 = call i64 @substring_range(i64 %t78, i64 %t79, i64 %t83)
  %t85 = alloca i64
  store i64 %t84, i64* %t85
  ; enum variant: TokenKind::Int
  %t86 = call i8* @malloc(i64 24)
  %t87 = bitcast i8* %t86 to %TokenKind*
  %t88 = getelementptr %TokenKind, %TokenKind* %t87, i32 0, i32 0
  store i64 0, i64* %t88
  %t89 = call i8* @malloc(i64 8)
  %t90 = bitcast i8* %t89 to i64*
  %t91 = load i64, i64* %t85
  %t92 = call i64 @kore_to_int(i64 %t91)
  %t93 = getelementptr i64, i64* %t90, i32 0
  store i64 %t92, i64* %t93
  %t94 = getelementptr %TokenKind, %TokenKind* %t87, i32 0, i32 1
  store i8* %t89, i8** %t94
  %t95 = getelementptr %TokenKind, %TokenKind* %t87, i32 0, i32 2
  %t96 = getelementptr [4 x i8], [4 x i8]* @.str.114, i64 0, i64 0
  store i8* %t96, i8** %t95
  %t97 = ptrtoint %TokenKind* %t87 to i64
  %t98 = load i64, i64* %t0
  %t99 = inttoptr i64 %t98 to %Lexer*
  %t100 = getelementptr %Lexer, %Lexer* %t99, i32 0, i32 3
  %t101 = load i64, i64* %t100
  %t102 = load i64, i64* %t10
  %t103 = load i64, i64* %t85
  %t104 = call i64 @Token_new(i64 %t97, i64 %t101, i64 %t102, i64 %t103)
  ret i64 %t104
}
define i64 @Lexer_lex_string(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %Lexer*
  %t3 = getelementptr %Lexer, %Lexer* %t2, i32 0, i32 4
  %t4 = load i64, i64* %t3
  %t5 = alloca i64
  store i64 %t4, i64* %t5
  %t6 = load i64, i64* %t0
  %t7 = call i64 @Lexer_advance(i64 %t6)
  %t8 = alloca i64
  store i64 %t7, i64* %t8
  %t9 = call i64 @kore_array_new()
  %t10 = alloca i64
  store i64 %t9, i64* %t10
  br label %while_cond55
  while_cond55:
  %t11 = load i64, i64* %t0
  %t12 = call i64 @Lexer_is_eof(i64 %t11)
  %t14 = icmp eq i64 %t12, 0
  %t13 = zext i1 %t14 to i64
  %t15 = load i64, i64* %t0
  %t16 = call i64 @Lexer_peek(i64 %t15)
  %t17 = load i64, i64* %t8
  %t19 = call i64 @kore_str_eq(i64 %t16, i64 %t17)
  %t20 = icmp eq i64 %t19, 0
  %t18 = zext i1 %t20 to i64
  %t21 = and i64 %t13, %t18
  %t22 = icmp ne i64 %t21, 0
  br i1 %t22, label %while_body56, label %while_end57
  while_body56:
  %t23 = load i64, i64* %t0
  %t24 = call i64 @Lexer_advance(i64 %t23)
  %t25 = alloca i64
  store i64 %t24, i64* %t25
  %t26 = load i64, i64* %t25
  %t27 = getelementptr [2 x i8], [2 x i8]* @.str.115, i64 0, i64 0
  %t28 = ptrtoint i8* %t27 to i64
  %t29 = call i64 @kore_str_eq(i64 %t26, i64 %t28)
  %t30 = icmp ne i64 %t29, 0
  br i1 %t30, label %then58, label %else59
  then58:
  %t31 = load i64, i64* %t0
  %t32 = call i64 @Lexer_advance(i64 %t31)
  %t33 = alloca i64
  store i64 %t32, i64* %t33
  %t34 = load i64, i64* %t33
  %t35 = getelementptr [2 x i8], [2 x i8]* @.str.116, i64 0, i64 0
  %t36 = ptrtoint i8* %t35 to i64
  %t37 = call i64 @kore_str_eq(i64 %t34, i64 %t36)
  %t38 = icmp ne i64 %t37, 0
  br i1 %t38, label %then61, label %else62
  then61:
  %t39 = load i64, i64* %t10
  %t40 = getelementptr [2 x i8], [2 x i8]* @.str.117, i64 0, i64 0
  %t41 = ptrtoint i8* %t40 to i64
  %t42 = call i64 @kore_array_push(i64 %t39, i64 %t41)
  br label %endif63
  else62:
  %t43 = load i64, i64* %t33
  %t44 = getelementptr [2 x i8], [2 x i8]* @.str.118, i64 0, i64 0
  %t45 = ptrtoint i8* %t44 to i64
  %t46 = call i64 @kore_str_eq(i64 %t43, i64 %t45)
  %t47 = icmp ne i64 %t46, 0
  br i1 %t47, label %then64, label %else65
  then64:
  %t48 = load i64, i64* %t10
  %t49 = getelementptr [2 x i8], [2 x i8]* @.str.119, i64 0, i64 0
  %t50 = ptrtoint i8* %t49 to i64
  %t51 = call i64 @kore_array_push(i64 %t48, i64 %t50)
  br label %endif66
  else65:
  %t52 = load i64, i64* %t33
  %t53 = getelementptr [2 x i8], [2 x i8]* @.str.120, i64 0, i64 0
  %t54 = ptrtoint i8* %t53 to i64
  %t55 = call i64 @kore_str_eq(i64 %t52, i64 %t54)
  %t56 = icmp ne i64 %t55, 0
  br i1 %t56, label %then67, label %else68
  then67:
  %t57 = load i64, i64* %t10
  %t58 = getelementptr [2 x i8], [2 x i8]* @.str.121, i64 0, i64 0
  %t59 = ptrtoint i8* %t58 to i64
  %t60 = call i64 @kore_array_push(i64 %t57, i64 %t59)
  br label %endif69
  else68:
  %t61 = load i64, i64* %t33
  %t62 = getelementptr [1 x i8], [1 x i8]* @.str.122, i64 0, i64 0
  %t63 = ptrtoint i8* %t62 to i64
  %t64 = call i64 @kore_str_eq(i64 %t61, i64 %t63)
  %t65 = icmp ne i64 %t64, 0
  br i1 %t65, label %then70, label %else71
  then70:
  %t66 = load i64, i64* %t10
  %t67 = getelementptr [1 x i8], [1 x i8]* @.str.123, i64 0, i64 0
  %t68 = ptrtoint i8* %t67 to i64
  %t69 = call i64 @kore_array_push(i64 %t66, i64 %t68)
  br label %endif72
  else71:
  %t70 = load i64, i64* %t10
  %t71 = load i64, i64* %t33
  %t72 = call i64 @kore_array_push(i64 %t70, i64 %t71)
  br label %endif72
  endif72:
  br label %endif69
  endif69:
  br label %endif66
  endif66:
  br label %endif63
  endif63:
  br label %endif60
  else59:
  %t73 = load i64, i64* %t10
  %t74 = load i64, i64* %t25
  %t75 = call i64 @kore_array_push(i64 %t73, i64 %t74)
  br label %endif60
  endif60:
  br label %while_cond55
  while_end57:
  %t76 = load i64, i64* %t10
  %t77 = getelementptr [1 x i8], [1 x i8]* @.str.124, i64 0, i64 0
  %t78 = ptrtoint i8* %t77 to i64
  %t79 = call i64 @kore_join(i64 %t76, i64 %t78)
  %t80 = alloca i64
  store i64 %t79, i64* %t80
  %t81 = load i64, i64* %t0
  %t82 = call i64 @Lexer_advance(i64 %t81)
  %t83 = call i64 @kore_array_new()
  %t84 = getelementptr [1 x i8], [1 x i8]* @.str.125, i64 0, i64 0
  %t85 = ptrtoint i8* %t84 to i64
  %t86 = call i64 @kore_array_push(i64 %t83, i64 %t85)
  %t87 = load i64, i64* %t80
  %t88 = call i64 @kore_array_push(i64 %t83, i64 %t87)
  %t89 = getelementptr [1 x i8], [1 x i8]* @.str.126, i64 0, i64 0
  %t90 = ptrtoint i8* %t89 to i64
  %t91 = call i64 @kore_array_push(i64 %t83, i64 %t90)
  %t92 = alloca i64
  store i64 %t83, i64* %t92
  %t93 = load i64, i64* %t92
  %t94 = getelementptr [1 x i8], [1 x i8]* @.str.127, i64 0, i64 0
  %t95 = ptrtoint i8* %t94 to i64
  %t96 = call i64 @kore_join(i64 %t93, i64 %t95)
  %t97 = alloca i64
  store i64 %t96, i64* %t97
  ; enum variant: TokenKind::String
  %t98 = call i8* @malloc(i64 24)
  %t99 = bitcast i8* %t98 to %TokenKind*
  %t100 = getelementptr %TokenKind, %TokenKind* %t99, i32 0, i32 0
  store i64 2, i64* %t100
  %t101 = call i8* @malloc(i64 8)
  %t102 = bitcast i8* %t101 to i64*
  %t103 = load i64, i64* %t80
  %t104 = getelementptr i64, i64* %t102, i32 0
  store i64 %t103, i64* %t104
  %t105 = getelementptr %TokenKind, %TokenKind* %t99, i32 0, i32 1
  store i8* %t101, i8** %t105
  %t106 = getelementptr %TokenKind, %TokenKind* %t99, i32 0, i32 2
  %t107 = getelementptr [7 x i8], [7 x i8]* @.str.128, i64 0, i64 0
  store i8* %t107, i8** %t106
  %t108 = ptrtoint %TokenKind* %t99 to i64
  %t109 = load i64, i64* %t0
  %t110 = inttoptr i64 %t109 to %Lexer*
  %t111 = getelementptr %Lexer, %Lexer* %t110, i32 0, i32 3
  %t112 = load i64, i64* %t111
  %t113 = load i64, i64* %t5
  %t114 = load i64, i64* %t97
  %t115 = call i64 @Token_new(i64 %t108, i64 %t112, i64 %t113, i64 %t114)
  ret i64 %t115
}
define i64 @Lexer_lex_ident(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %Lexer*
  %t3 = getelementptr %Lexer, %Lexer* %t2, i32 0, i32 2
  %t4 = load i64, i64* %t3
  %t5 = alloca i64
  store i64 %t4, i64* %t5
  %t6 = load i64, i64* %t0
  %t7 = inttoptr i64 %t6 to %Lexer*
  %t8 = getelementptr %Lexer, %Lexer* %t7, i32 0, i32 4
  %t9 = load i64, i64* %t8
  %t10 = alloca i64
  store i64 %t9, i64* %t10
  br label %while_cond73
  while_cond73:
  %t11 = load i64, i64* %t0
  %t12 = call i64 @Lexer_is_eof(i64 %t11)
  %t14 = icmp eq i64 %t12, 0
  %t13 = zext i1 %t14 to i64
  %t15 = load i64, i64* %t0
  %t16 = call i64 @Lexer_peek(i64 %t15)
  %t17 = call i64 @is_ident_char(i64 %t16)
  %t18 = and i64 %t13, %t17
  %t19 = icmp ne i64 %t18, 0
  br i1 %t19, label %while_body74, label %while_end75
  while_body74:
  %t20 = load i64, i64* %t0
  %t21 = call i64 @Lexer_advance(i64 %t20)
  br label %while_cond73
  while_end75:
  %t22 = load i64, i64* %t0
  %t23 = inttoptr i64 %t22 to %Lexer*
  %t24 = getelementptr %Lexer, %Lexer* %t23, i32 0, i32 0
  %t25 = load i64, i64* %t24
  %t26 = load i64, i64* %t5
  %t27 = load i64, i64* %t0
  %t28 = inttoptr i64 %t27 to %Lexer*
  %t29 = getelementptr %Lexer, %Lexer* %t28, i32 0, i32 2
  %t30 = load i64, i64* %t29
  %t31 = call i64 @substring_range(i64 %t25, i64 %t26, i64 %t30)
  %t32 = alloca i64
  store i64 %t31, i64* %t32
  %t33 = call i64 @kore_array_new()
  %t34 = getelementptr [3 x i8], [3 x i8]* @.str.129, i64 0, i64 0
  %t35 = ptrtoint i8* %t34 to i64
  %t36 = call i64 @kore_array_push(i64 %t33, i64 %t35)
  %t37 = getelementptr [4 x i8], [4 x i8]* @.str.130, i64 0, i64 0
  %t38 = ptrtoint i8* %t37 to i64
  %t39 = call i64 @kore_array_push(i64 %t33, i64 %t38)
  %t40 = getelementptr [4 x i8], [4 x i8]* @.str.131, i64 0, i64 0
  %t41 = ptrtoint i8* %t40 to i64
  %t42 = call i64 @kore_array_push(i64 %t33, i64 %t41)
  %t43 = getelementptr [3 x i8], [3 x i8]* @.str.132, i64 0, i64 0
  %t44 = ptrtoint i8* %t43 to i64
  %t45 = call i64 @kore_array_push(i64 %t33, i64 %t44)
  %t46 = getelementptr [5 x i8], [5 x i8]* @.str.133, i64 0, i64 0
  %t47 = ptrtoint i8* %t46 to i64
  %t48 = call i64 @kore_array_push(i64 %t33, i64 %t47)
  %t49 = getelementptr [6 x i8], [6 x i8]* @.str.134, i64 0, i64 0
  %t50 = ptrtoint i8* %t49 to i64
  %t51 = call i64 @kore_array_push(i64 %t33, i64 %t50)
  %t52 = getelementptr [4 x i8], [4 x i8]* @.str.135, i64 0, i64 0
  %t53 = ptrtoint i8* %t52 to i64
  %t54 = call i64 @kore_array_push(i64 %t33, i64 %t53)
  %t55 = getelementptr [3 x i8], [3 x i8]* @.str.136, i64 0, i64 0
  %t56 = ptrtoint i8* %t55 to i64
  %t57 = call i64 @kore_array_push(i64 %t33, i64 %t56)
  %t58 = getelementptr [7 x i8], [7 x i8]* @.str.137, i64 0, i64 0
  %t59 = ptrtoint i8* %t58 to i64
  %t60 = call i64 @kore_array_push(i64 %t33, i64 %t59)
  %t61 = getelementptr [6 x i8], [6 x i8]* @.str.138, i64 0, i64 0
  %t62 = ptrtoint i8* %t61 to i64
  %t63 = call i64 @kore_array_push(i64 %t33, i64 %t62)
  %t64 = getelementptr [7 x i8], [7 x i8]* @.str.139, i64 0, i64 0
  %t65 = ptrtoint i8* %t64 to i64
  %t66 = call i64 @kore_array_push(i64 %t33, i64 %t65)
  %t67 = getelementptr [5 x i8], [5 x i8]* @.str.140, i64 0, i64 0
  %t68 = ptrtoint i8* %t67 to i64
  %t69 = call i64 @kore_array_push(i64 %t33, i64 %t68)
  %t70 = getelementptr [5 x i8], [5 x i8]* @.str.141, i64 0, i64 0
  %t71 = ptrtoint i8* %t70 to i64
  %t72 = call i64 @kore_array_push(i64 %t33, i64 %t71)
  %t73 = getelementptr [4 x i8], [4 x i8]* @.str.142, i64 0, i64 0
  %t74 = ptrtoint i8* %t73 to i64
  %t75 = call i64 @kore_array_push(i64 %t33, i64 %t74)
  %t76 = getelementptr [4 x i8], [4 x i8]* @.str.143, i64 0, i64 0
  %t77 = ptrtoint i8* %t76 to i64
  %t78 = call i64 @kore_array_push(i64 %t33, i64 %t77)
  %t79 = getelementptr [6 x i8], [6 x i8]* @.str.144, i64 0, i64 0
  %t80 = ptrtoint i8* %t79 to i64
  %t81 = call i64 @kore_array_push(i64 %t33, i64 %t80)
  %t82 = getelementptr [6 x i8], [6 x i8]* @.str.145, i64 0, i64 0
  %t83 = ptrtoint i8* %t82 to i64
  %t84 = call i64 @kore_array_push(i64 %t33, i64 %t83)
  %t85 = getelementptr [6 x i8], [6 x i8]* @.str.146, i64 0, i64 0
  %t86 = ptrtoint i8* %t85 to i64
  %t87 = call i64 @kore_array_push(i64 %t33, i64 %t86)
  %t88 = getelementptr [6 x i8], [6 x i8]* @.str.147, i64 0, i64 0
  %t89 = ptrtoint i8* %t88 to i64
  %t90 = call i64 @kore_array_push(i64 %t33, i64 %t89)
  %t91 = getelementptr [3 x i8], [3 x i8]* @.str.148, i64 0, i64 0
  %t92 = ptrtoint i8* %t91 to i64
  %t93 = call i64 @kore_array_push(i64 %t33, i64 %t92)
  %t94 = getelementptr [5 x i8], [5 x i8]* @.str.149, i64 0, i64 0
  %t95 = ptrtoint i8* %t94 to i64
  %t96 = call i64 @kore_array_push(i64 %t33, i64 %t95)
  %t97 = getelementptr [5 x i8], [5 x i8]* @.str.150, i64 0, i64 0
  %t98 = ptrtoint i8* %t97 to i64
  %t99 = call i64 @kore_array_push(i64 %t33, i64 %t98)
  %t100 = getelementptr [6 x i8], [6 x i8]* @.str.151, i64 0, i64 0
  %t101 = ptrtoint i8* %t100 to i64
  %t102 = call i64 @kore_array_push(i64 %t33, i64 %t101)
  %t103 = getelementptr [5 x i8], [5 x i8]* @.str.152, i64 0, i64 0
  %t104 = ptrtoint i8* %t103 to i64
  %t105 = call i64 @kore_array_push(i64 %t33, i64 %t104)
  %t106 = getelementptr [5 x i8], [5 x i8]* @.str.153, i64 0, i64 0
  %t107 = ptrtoint i8* %t106 to i64
  %t108 = call i64 @kore_array_push(i64 %t33, i64 %t107)
  %t109 = getelementptr [5 x i8], [5 x i8]* @.str.154, i64 0, i64 0
  %t110 = ptrtoint i8* %t109 to i64
  %t111 = call i64 @kore_array_push(i64 %t33, i64 %t110)
  %t112 = getelementptr [9 x i8], [9 x i8]* @.str.155, i64 0, i64 0
  %t113 = ptrtoint i8* %t112 to i64
  %t114 = call i64 @kore_array_push(i64 %t33, i64 %t113)
  %t115 = getelementptr [5 x i8], [5 x i8]* @.str.156, i64 0, i64 0
  %t116 = ptrtoint i8* %t115 to i64
  %t117 = call i64 @kore_array_push(i64 %t33, i64 %t116)
  %t118 = alloca i64
  store i64 %t33, i64* %t118
  %t119 = load i64, i64* %t118
  %t120 = load i64, i64* %t32
  %t121 = call i64 @kore_contains(i64 %t119, i64 %t120)
  %t122 = icmp ne i64 %t121, 0
  br i1 %t122, label %then76, label %endif78
  then76:
  %t123 = load i64, i64* %t32
  %t124 = getelementptr [5 x i8], [5 x i8]* @.str.157, i64 0, i64 0
  %t125 = ptrtoint i8* %t124 to i64
  %t126 = call i64 @kore_str_eq(i64 %t123, i64 %t125)
  %t127 = icmp ne i64 %t126, 0
  br i1 %t127, label %then79, label %else80
  then79:
  ; enum variant: TokenKind::Bool
  %t128 = call i8* @malloc(i64 24)
  %t129 = bitcast i8* %t128 to %TokenKind*
  %t130 = getelementptr %TokenKind, %TokenKind* %t129, i32 0, i32 0
  store i64 3, i64* %t130
  %t131 = call i8* @malloc(i64 8)
  %t132 = bitcast i8* %t131 to i64*
  %t133 = getelementptr i64, i64* %t132, i32 0
  store i64 1, i64* %t133
  %t134 = getelementptr %TokenKind, %TokenKind* %t129, i32 0, i32 1
  store i8* %t131, i8** %t134
  %t135 = getelementptr %TokenKind, %TokenKind* %t129, i32 0, i32 2
  %t136 = getelementptr [5 x i8], [5 x i8]* @.str.158, i64 0, i64 0
  store i8* %t136, i8** %t135
  %t137 = ptrtoint %TokenKind* %t129 to i64
  %t138 = load i64, i64* %t0
  %t139 = inttoptr i64 %t138 to %Lexer*
  %t140 = getelementptr %Lexer, %Lexer* %t139, i32 0, i32 3
  %t141 = load i64, i64* %t140
  %t142 = load i64, i64* %t10
  %t143 = load i64, i64* %t32
  %t144 = call i64 @Token_new(i64 %t137, i64 %t141, i64 %t142, i64 %t143)
  ret i64 %t144
  else80:
  %t145 = load i64, i64* %t32
  %t146 = getelementptr [6 x i8], [6 x i8]* @.str.159, i64 0, i64 0
  %t147 = ptrtoint i8* %t146 to i64
  %t148 = call i64 @kore_str_eq(i64 %t145, i64 %t147)
  %t149 = icmp ne i64 %t148, 0
  br i1 %t149, label %then82, label %endif84
  then82:
  ; enum variant: TokenKind::Bool
  %t150 = call i8* @malloc(i64 24)
  %t151 = bitcast i8* %t150 to %TokenKind*
  %t152 = getelementptr %TokenKind, %TokenKind* %t151, i32 0, i32 0
  store i64 3, i64* %t152
  %t153 = call i8* @malloc(i64 8)
  %t154 = bitcast i8* %t153 to i64*
  %t155 = getelementptr i64, i64* %t154, i32 0
  store i64 0, i64* %t155
  %t156 = getelementptr %TokenKind, %TokenKind* %t151, i32 0, i32 1
  store i8* %t153, i8** %t156
  %t157 = getelementptr %TokenKind, %TokenKind* %t151, i32 0, i32 2
  %t158 = getelementptr [5 x i8], [5 x i8]* @.str.160, i64 0, i64 0
  store i8* %t158, i8** %t157
  %t159 = ptrtoint %TokenKind* %t151 to i64
  %t160 = load i64, i64* %t0
  %t161 = inttoptr i64 %t160 to %Lexer*
  %t162 = getelementptr %Lexer, %Lexer* %t161, i32 0, i32 3
  %t163 = load i64, i64* %t162
  %t164 = load i64, i64* %t10
  %t165 = load i64, i64* %t32
  %t166 = call i64 @Token_new(i64 %t159, i64 %t163, i64 %t164, i64 %t165)
  ret i64 %t166
  endif84:
  br label %endif81
  endif81:
  ; enum variant: TokenKind::Keyword
  %t167 = call i8* @malloc(i64 24)
  %t168 = bitcast i8* %t167 to %TokenKind*
  %t169 = getelementptr %TokenKind, %TokenKind* %t168, i32 0, i32 0
  store i64 5, i64* %t169
  %t170 = call i8* @malloc(i64 8)
  %t171 = bitcast i8* %t170 to i64*
  %t172 = load i64, i64* %t32
  %t173 = getelementptr i64, i64* %t171, i32 0
  store i64 %t172, i64* %t173
  %t174 = getelementptr %TokenKind, %TokenKind* %t168, i32 0, i32 1
  store i8* %t170, i8** %t174
  %t175 = getelementptr %TokenKind, %TokenKind* %t168, i32 0, i32 2
  %t176 = getelementptr [8 x i8], [8 x i8]* @.str.161, i64 0, i64 0
  store i8* %t176, i8** %t175
  %t177 = ptrtoint %TokenKind* %t168 to i64
  %t178 = load i64, i64* %t0
  %t179 = inttoptr i64 %t178 to %Lexer*
  %t180 = getelementptr %Lexer, %Lexer* %t179, i32 0, i32 3
  %t181 = load i64, i64* %t180
  %t182 = load i64, i64* %t10
  %t183 = load i64, i64* %t32
  %t184 = call i64 @Token_new(i64 %t177, i64 %t181, i64 %t182, i64 %t183)
  ret i64 %t184
  endif78:
  ; enum variant: TokenKind::Ident
  %t185 = call i8* @malloc(i64 24)
  %t186 = bitcast i8* %t185 to %TokenKind*
  %t187 = getelementptr %TokenKind, %TokenKind* %t186, i32 0, i32 0
  store i64 4, i64* %t187
  %t188 = call i8* @malloc(i64 8)
  %t189 = bitcast i8* %t188 to i64*
  %t190 = load i64, i64* %t32
  %t191 = getelementptr i64, i64* %t189, i32 0
  store i64 %t190, i64* %t191
  %t192 = getelementptr %TokenKind, %TokenKind* %t186, i32 0, i32 1
  store i8* %t188, i8** %t192
  %t193 = getelementptr %TokenKind, %TokenKind* %t186, i32 0, i32 2
  %t194 = getelementptr [6 x i8], [6 x i8]* @.str.162, i64 0, i64 0
  store i8* %t194, i8** %t193
  %t195 = ptrtoint %TokenKind* %t186 to i64
  %t196 = load i64, i64* %t0
  %t197 = inttoptr i64 %t196 to %Lexer*
  %t198 = getelementptr %Lexer, %Lexer* %t197, i32 0, i32 3
  %t199 = load i64, i64* %t198
  %t200 = load i64, i64* %t10
  %t201 = load i64, i64* %t32
  %t202 = call i64 @Token_new(i64 %t195, i64 %t199, i64 %t200, i64 %t201)
  ret i64 %t202
}
define i64 @Lexer_next_token(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Lexer_skip_spaces(i64 %t1)
  %t3 = load i64, i64* %t0
  %t4 = call i64 @Lexer_is_eof(i64 %t3)
  %t5 = icmp ne i64 %t4, 0
  br i1 %t5, label %then85, label %endif87
  then85:
  %t6 = load i64, i64* %t0
  ; enum variant: TokenKind::Eof
  %t7 = call i8* @malloc(i64 24)
  %t8 = bitcast i8* %t7 to %TokenKind*
  %t9 = getelementptr %TokenKind, %TokenKind* %t8, i32 0, i32 0
  store i64 42, i64* %t9
  %t10 = getelementptr %TokenKind, %TokenKind* %t8, i32 0, i32 1
  store i8* null, i8** %t10
  %t11 = getelementptr %TokenKind, %TokenKind* %t8, i32 0, i32 2
  %t12 = getelementptr [4 x i8], [4 x i8]* @.str.163, i64 0, i64 0
  store i8* %t12, i8** %t11
  %t13 = ptrtoint %TokenKind* %t8 to i64
  %t14 = getelementptr [1 x i8], [1 x i8]* @.str.164, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  %t16 = call i64 @Lexer_make_token(i64 %t6, i64 %t13, i64 %t15)
  ret i64 %t16
  endif87:
  %t17 = load i64, i64* %t0
  %t18 = call i64 @Lexer_peek(i64 %t17)
  %t19 = alloca i64
  store i64 %t18, i64* %t19
  %t20 = load i64, i64* %t19
  %t21 = getelementptr [2 x i8], [2 x i8]* @.str.165, i64 0, i64 0
  %t22 = ptrtoint i8* %t21 to i64
  %t23 = call i64 @kore_str_eq(i64 %t20, i64 %t22)
  %t24 = load i64, i64* %t19
  %t25 = getelementptr [2 x i8], [2 x i8]* @.str.166, i64 0, i64 0
  %t26 = ptrtoint i8* %t25 to i64
  %t27 = call i64 @kore_str_eq(i64 %t24, i64 %t26)
  %t28 = load i64, i64* %t0
  %t29 = call i64 @Lexer_peek_n(i64 %t28, i64 1)
  %t30 = getelementptr [2 x i8], [2 x i8]* @.str.167, i64 0, i64 0
  %t31 = ptrtoint i8* %t30 to i64
  %t32 = call i64 @kore_str_eq(i64 %t29, i64 %t31)
  %t33 = and i64 %t27, %t32
  %t34 = or i64 %t23, %t33
  %t35 = icmp ne i64 %t34, 0
  br i1 %t35, label %then88, label %endif90
  then88:
  br label %while_cond91
  while_cond91:
  %t36 = load i64, i64* %t0
  %t37 = call i64 @Lexer_is_eof(i64 %t36)
  %t39 = icmp eq i64 %t37, 0
  %t38 = zext i1 %t39 to i64
  %t40 = load i64, i64* %t0
  %t41 = call i64 @Lexer_peek(i64 %t40)
  %t42 = getelementptr [2 x i8], [2 x i8]* @.str.168, i64 0, i64 0
  %t43 = ptrtoint i8* %t42 to i64
  %t45 = call i64 @kore_str_eq(i64 %t41, i64 %t43)
  %t46 = icmp eq i64 %t45, 0
  %t44 = zext i1 %t46 to i64
  %t47 = and i64 %t38, %t44
  %t48 = icmp ne i64 %t47, 0
  br i1 %t48, label %while_body92, label %while_end93
  while_body92:
  %t49 = load i64, i64* %t0
  %t50 = call i64 @Lexer_advance(i64 %t49)
  br label %while_cond91
  while_end93:
  %t51 = load i64, i64* %t0
  %t52 = call i64 @Lexer_next_token(i64 %t51)
  ret i64 %t52
  endif90:
  %t53 = load i64, i64* %t19
  %t54 = getelementptr [2 x i8], [2 x i8]* @.str.169, i64 0, i64 0
  %t55 = ptrtoint i8* %t54 to i64
  %t56 = call i64 @kore_str_eq(i64 %t53, i64 %t55)
  %t57 = icmp ne i64 %t56, 0
  br i1 %t57, label %then94, label %endif96
  then94:
  %t58 = load i64, i64* %t0
  %t59 = call i64 @Lexer_advance(i64 %t58)
  %t60 = load i64, i64* %t0
  %t61 = call i64 @Lexer_next_token(i64 %t60)
  ret i64 %t61
  endif96:
  %t62 = load i64, i64* %t19
  %t63 = getelementptr [2 x i8], [2 x i8]* @.str.170, i64 0, i64 0
  %t64 = ptrtoint i8* %t63 to i64
  %t65 = call i64 @kore_str_eq(i64 %t62, i64 %t64)
  %t66 = icmp ne i64 %t65, 0
  br i1 %t66, label %then97, label %endif99
  then97:
  %t67 = load i64, i64* %t0
  %t68 = call i64 @Lexer_advance(i64 %t67)
  %t69 = load i64, i64* %t0
  ; enum variant: TokenKind::Newline
  %t70 = call i8* @malloc(i64 24)
  %t71 = bitcast i8* %t70 to %TokenKind*
  %t72 = getelementptr %TokenKind, %TokenKind* %t71, i32 0, i32 0
  store i64 39, i64* %t72
  %t73 = getelementptr %TokenKind, %TokenKind* %t71, i32 0, i32 1
  store i8* null, i8** %t73
  %t74 = getelementptr %TokenKind, %TokenKind* %t71, i32 0, i32 2
  %t75 = getelementptr [8 x i8], [8 x i8]* @.str.171, i64 0, i64 0
  store i8* %t75, i8** %t74
  %t76 = ptrtoint %TokenKind* %t71 to i64
  %t77 = getelementptr [2 x i8], [2 x i8]* @.str.172, i64 0, i64 0
  %t78 = ptrtoint i8* %t77 to i64
  %t79 = call i64 @Lexer_make_token(i64 %t69, i64 %t76, i64 %t78)
  ret i64 %t79
  endif99:
  %t80 = load i64, i64* %t19
  %t81 = call i64 @is_digit(i64 %t80)
  %t82 = icmp ne i64 %t81, 0
  br i1 %t82, label %then100, label %endif102
  then100:
  %t83 = load i64, i64* %t0
  %t84 = call i64 @Lexer_lex_number(i64 %t83)
  ret i64 %t84
  endif102:
  %t85 = load i64, i64* %t19
  %t86 = call i64 @kore_ord(i64 %t85)
  %t87 = alloca i64
  store i64 %t86, i64* %t87
  %t88 = load i64, i64* %t87
  %t89 = call i64 @kore_str_eq(i64 %t88, i64 34)
  %t90 = load i64, i64* %t87
  %t91 = call i64 @kore_str_eq(i64 %t90, i64 39)
  %t92 = or i64 %t89, %t91
  %t93 = icmp ne i64 %t92, 0
  br i1 %t93, label %then103, label %endif105
  then103:
  %t94 = load i64, i64* %t0
  %t95 = call i64 @Lexer_lex_string(i64 %t94)
  ret i64 %t95
  endif105:
  %t96 = load i64, i64* %t19
  %t97 = call i64 @is_ident_start(i64 %t96)
  %t98 = icmp ne i64 %t97, 0
  br i1 %t98, label %then106, label %endif108
  then106:
  %t99 = load i64, i64* %t0
  %t100 = call i64 @Lexer_lex_ident(i64 %t99)
  ret i64 %t100
  endif108:
  %t101 = load i64, i64* %t0
  %t102 = call i64 @Lexer_advance(i64 %t101)
  ; match
  %t103 = load i64, i64* %t19
  %t104 = getelementptr [2 x i8], [2 x i8]* @.str.173, i64 0, i64 0
  %t105 = ptrtoint i8* %t104 to i64
  %t106 = call i64 @kore_str_eq(i64 %t103, i64 %t105)
  %t107 = icmp ne i64 %t106, 0
  br i1 %t107, label %match_body111, label %match_next110
  match_body111:
  %t108 = load i64, i64* %t0
  ; enum variant: TokenKind::Plus
  %t109 = call i8* @malloc(i64 24)
  %t110 = bitcast i8* %t109 to %TokenKind*
  %t111 = getelementptr %TokenKind, %TokenKind* %t110, i32 0, i32 0
  store i64 6, i64* %t111
  %t112 = getelementptr %TokenKind, %TokenKind* %t110, i32 0, i32 1
  store i8* null, i8** %t112
  %t113 = getelementptr %TokenKind, %TokenKind* %t110, i32 0, i32 2
  %t114 = getelementptr [5 x i8], [5 x i8]* @.str.174, i64 0, i64 0
  store i8* %t114, i8** %t113
  %t115 = ptrtoint %TokenKind* %t110 to i64
  %t116 = getelementptr [2 x i8], [2 x i8]* @.str.175, i64 0, i64 0
  %t117 = ptrtoint i8* %t116 to i64
  %t118 = call i64 @Lexer_make_token(i64 %t108, i64 %t115, i64 %t117)
  ret i64 %t118
  match_next110:
  %t119 = getelementptr [2 x i8], [2 x i8]* @.str.176, i64 0, i64 0
  %t120 = ptrtoint i8* %t119 to i64
  %t121 = call i64 @kore_str_eq(i64 %t103, i64 %t120)
  %t122 = icmp ne i64 %t121, 0
  br i1 %t122, label %match_body113, label %match_next112
  match_body113:
  %t123 = load i64, i64* %t0
  %t124 = call i64 @Lexer_peek(i64 %t123)
  %t125 = getelementptr [2 x i8], [2 x i8]* @.str.177, i64 0, i64 0
  %t126 = ptrtoint i8* %t125 to i64
  %t127 = call i64 @kore_str_eq(i64 %t124, i64 %t126)
  %t128 = icmp ne i64 %t127, 0
  br i1 %t128, label %then114, label %endif116
  then114:
  %t129 = load i64, i64* %t0
  %t130 = call i64 @Lexer_advance(i64 %t129)
  %t131 = load i64, i64* %t0
  ; enum variant: TokenKind::Arrow
  %t132 = call i8* @malloc(i64 24)
  %t133 = bitcast i8* %t132 to %TokenKind*
  %t134 = getelementptr %TokenKind, %TokenKind* %t133, i32 0, i32 0
  store i64 21, i64* %t134
  %t135 = getelementptr %TokenKind, %TokenKind* %t133, i32 0, i32 1
  store i8* null, i8** %t135
  %t136 = getelementptr %TokenKind, %TokenKind* %t133, i32 0, i32 2
  %t137 = getelementptr [6 x i8], [6 x i8]* @.str.178, i64 0, i64 0
  store i8* %t137, i8** %t136
  %t138 = ptrtoint %TokenKind* %t133 to i64
  %t139 = getelementptr [3 x i8], [3 x i8]* @.str.179, i64 0, i64 0
  %t140 = ptrtoint i8* %t139 to i64
  %t141 = call i64 @Lexer_make_token(i64 %t131, i64 %t138, i64 %t140)
  ret i64 %t141
  endif116:
  %t142 = load i64, i64* %t0
  ; enum variant: TokenKind::Minus
  %t143 = call i8* @malloc(i64 24)
  %t144 = bitcast i8* %t143 to %TokenKind*
  %t145 = getelementptr %TokenKind, %TokenKind* %t144, i32 0, i32 0
  store i64 7, i64* %t145
  %t146 = getelementptr %TokenKind, %TokenKind* %t144, i32 0, i32 1
  store i8* null, i8** %t146
  %t147 = getelementptr %TokenKind, %TokenKind* %t144, i32 0, i32 2
  %t148 = getelementptr [6 x i8], [6 x i8]* @.str.180, i64 0, i64 0
  store i8* %t148, i8** %t147
  %t149 = ptrtoint %TokenKind* %t144 to i64
  %t150 = getelementptr [2 x i8], [2 x i8]* @.str.181, i64 0, i64 0
  %t151 = ptrtoint i8* %t150 to i64
  %t152 = call i64 @Lexer_make_token(i64 %t142, i64 %t149, i64 %t151)
  ret i64 %t152
  match_next112:
  %t153 = getelementptr [2 x i8], [2 x i8]* @.str.182, i64 0, i64 0
  %t154 = ptrtoint i8* %t153 to i64
  %t155 = call i64 @kore_str_eq(i64 %t103, i64 %t154)
  %t156 = icmp ne i64 %t155, 0
  br i1 %t156, label %match_body118, label %match_next117
  match_body118:
  %t157 = load i64, i64* %t0
  ; enum variant: TokenKind::Star
  %t158 = call i8* @malloc(i64 24)
  %t159 = bitcast i8* %t158 to %TokenKind*
  %t160 = getelementptr %TokenKind, %TokenKind* %t159, i32 0, i32 0
  store i64 8, i64* %t160
  %t161 = getelementptr %TokenKind, %TokenKind* %t159, i32 0, i32 1
  store i8* null, i8** %t161
  %t162 = getelementptr %TokenKind, %TokenKind* %t159, i32 0, i32 2
  %t163 = getelementptr [5 x i8], [5 x i8]* @.str.183, i64 0, i64 0
  store i8* %t163, i8** %t162
  %t164 = ptrtoint %TokenKind* %t159 to i64
  %t165 = getelementptr [2 x i8], [2 x i8]* @.str.184, i64 0, i64 0
  %t166 = ptrtoint i8* %t165 to i64
  %t167 = call i64 @Lexer_make_token(i64 %t157, i64 %t164, i64 %t166)
  ret i64 %t167
  match_next117:
  %t168 = getelementptr [2 x i8], [2 x i8]* @.str.185, i64 0, i64 0
  %t169 = ptrtoint i8* %t168 to i64
  %t170 = call i64 @kore_str_eq(i64 %t103, i64 %t169)
  %t171 = icmp ne i64 %t170, 0
  br i1 %t171, label %match_body120, label %match_next119
  match_body120:
  %t172 = load i64, i64* %t0
  ; enum variant: TokenKind::Slash
  %t173 = call i8* @malloc(i64 24)
  %t174 = bitcast i8* %t173 to %TokenKind*
  %t175 = getelementptr %TokenKind, %TokenKind* %t174, i32 0, i32 0
  store i64 9, i64* %t175
  %t176 = getelementptr %TokenKind, %TokenKind* %t174, i32 0, i32 1
  store i8* null, i8** %t176
  %t177 = getelementptr %TokenKind, %TokenKind* %t174, i32 0, i32 2
  %t178 = getelementptr [6 x i8], [6 x i8]* @.str.186, i64 0, i64 0
  store i8* %t178, i8** %t177
  %t179 = ptrtoint %TokenKind* %t174 to i64
  %t180 = getelementptr [2 x i8], [2 x i8]* @.str.187, i64 0, i64 0
  %t181 = ptrtoint i8* %t180 to i64
  %t182 = call i64 @Lexer_make_token(i64 %t172, i64 %t179, i64 %t181)
  ret i64 %t182
  match_next119:
  %t183 = getelementptr [2 x i8], [2 x i8]* @.str.188, i64 0, i64 0
  %t184 = ptrtoint i8* %t183 to i64
  %t185 = call i64 @kore_str_eq(i64 %t103, i64 %t184)
  %t186 = icmp ne i64 %t185, 0
  br i1 %t186, label %match_body122, label %match_next121
  match_body122:
  %t187 = load i64, i64* %t0
  ; enum variant: TokenKind::Percent
  %t188 = call i8* @malloc(i64 24)
  %t189 = bitcast i8* %t188 to %TokenKind*
  %t190 = getelementptr %TokenKind, %TokenKind* %t189, i32 0, i32 0
  store i64 10, i64* %t190
  %t191 = getelementptr %TokenKind, %TokenKind* %t189, i32 0, i32 1
  store i8* null, i8** %t191
  %t192 = getelementptr %TokenKind, %TokenKind* %t189, i32 0, i32 2
  %t193 = getelementptr [8 x i8], [8 x i8]* @.str.189, i64 0, i64 0
  store i8* %t193, i8** %t192
  %t194 = ptrtoint %TokenKind* %t189 to i64
  %t195 = getelementptr [2 x i8], [2 x i8]* @.str.190, i64 0, i64 0
  %t196 = ptrtoint i8* %t195 to i64
  %t197 = call i64 @Lexer_make_token(i64 %t187, i64 %t194, i64 %t196)
  ret i64 %t197
  match_next121:
  %t198 = getelementptr [2 x i8], [2 x i8]* @.str.191, i64 0, i64 0
  %t199 = ptrtoint i8* %t198 to i64
  %t200 = call i64 @kore_str_eq(i64 %t103, i64 %t199)
  %t201 = icmp ne i64 %t200, 0
  br i1 %t201, label %match_body124, label %match_next123
  match_body124:
  %t202 = load i64, i64* %t0
  %t203 = call i64 @Lexer_peek(i64 %t202)
  %t204 = getelementptr [2 x i8], [2 x i8]* @.str.192, i64 0, i64 0
  %t205 = ptrtoint i8* %t204 to i64
  %t206 = call i64 @kore_str_eq(i64 %t203, i64 %t205)
  %t207 = icmp ne i64 %t206, 0
  br i1 %t207, label %then125, label %endif127
  then125:
  %t208 = load i64, i64* %t0
  %t209 = call i64 @Lexer_advance(i64 %t208)
  %t210 = load i64, i64* %t0
  ; enum variant: TokenKind::EqEq
  %t211 = call i8* @malloc(i64 24)
  %t212 = bitcast i8* %t211 to %TokenKind*
  %t213 = getelementptr %TokenKind, %TokenKind* %t212, i32 0, i32 0
  store i64 12, i64* %t213
  %t214 = getelementptr %TokenKind, %TokenKind* %t212, i32 0, i32 1
  store i8* null, i8** %t214
  %t215 = getelementptr %TokenKind, %TokenKind* %t212, i32 0, i32 2
  %t216 = getelementptr [5 x i8], [5 x i8]* @.str.193, i64 0, i64 0
  store i8* %t216, i8** %t215
  %t217 = ptrtoint %TokenKind* %t212 to i64
  %t218 = getelementptr [3 x i8], [3 x i8]* @.str.194, i64 0, i64 0
  %t219 = ptrtoint i8* %t218 to i64
  %t220 = call i64 @Lexer_make_token(i64 %t210, i64 %t217, i64 %t219)
  ret i64 %t220
  endif127:
  %t221 = load i64, i64* %t0
  %t222 = call i64 @Lexer_peek(i64 %t221)
  %t223 = getelementptr [2 x i8], [2 x i8]* @.str.195, i64 0, i64 0
  %t224 = ptrtoint i8* %t223 to i64
  %t225 = call i64 @kore_str_eq(i64 %t222, i64 %t224)
  %t226 = icmp ne i64 %t225, 0
  br i1 %t226, label %then128, label %endif130
  then128:
  %t227 = load i64, i64* %t0
  %t228 = call i64 @Lexer_advance(i64 %t227)
  %t229 = load i64, i64* %t0
  ; enum variant: TokenKind::FatArrow
  %t230 = call i8* @malloc(i64 24)
  %t231 = bitcast i8* %t230 to %TokenKind*
  %t232 = getelementptr %TokenKind, %TokenKind* %t231, i32 0, i32 0
  store i64 22, i64* %t232
  %t233 = getelementptr %TokenKind, %TokenKind* %t231, i32 0, i32 1
  store i8* null, i8** %t233
  %t234 = getelementptr %TokenKind, %TokenKind* %t231, i32 0, i32 2
  %t235 = getelementptr [9 x i8], [9 x i8]* @.str.196, i64 0, i64 0
  store i8* %t235, i8** %t234
  %t236 = ptrtoint %TokenKind* %t231 to i64
  %t237 = getelementptr [3 x i8], [3 x i8]* @.str.197, i64 0, i64 0
  %t238 = ptrtoint i8* %t237 to i64
  %t239 = call i64 @Lexer_make_token(i64 %t229, i64 %t236, i64 %t238)
  ret i64 %t239
  endif130:
  %t240 = load i64, i64* %t0
  ; enum variant: TokenKind::Eq
  %t241 = call i8* @malloc(i64 24)
  %t242 = bitcast i8* %t241 to %TokenKind*
  %t243 = getelementptr %TokenKind, %TokenKind* %t242, i32 0, i32 0
  store i64 11, i64* %t243
  %t244 = getelementptr %TokenKind, %TokenKind* %t242, i32 0, i32 1
  store i8* null, i8** %t244
  %t245 = getelementptr %TokenKind, %TokenKind* %t242, i32 0, i32 2
  %t246 = getelementptr [3 x i8], [3 x i8]* @.str.198, i64 0, i64 0
  store i8* %t246, i8** %t245
  %t247 = ptrtoint %TokenKind* %t242 to i64
  %t248 = getelementptr [2 x i8], [2 x i8]* @.str.199, i64 0, i64 0
  %t249 = ptrtoint i8* %t248 to i64
  %t250 = call i64 @Lexer_make_token(i64 %t240, i64 %t247, i64 %t249)
  ret i64 %t250
  match_next123:
  %t251 = getelementptr [2 x i8], [2 x i8]* @.str.200, i64 0, i64 0
  %t252 = ptrtoint i8* %t251 to i64
  %t253 = call i64 @kore_str_eq(i64 %t103, i64 %t252)
  %t254 = icmp ne i64 %t253, 0
  br i1 %t254, label %match_body132, label %match_next131
  match_body132:
  %t255 = load i64, i64* %t0
  %t256 = call i64 @Lexer_peek(i64 %t255)
  %t257 = getelementptr [2 x i8], [2 x i8]* @.str.201, i64 0, i64 0
  %t258 = ptrtoint i8* %t257 to i64
  %t259 = call i64 @kore_str_eq(i64 %t256, i64 %t258)
  %t260 = icmp ne i64 %t259, 0
  br i1 %t260, label %then133, label %endif135
  then133:
  %t261 = load i64, i64* %t0
  %t262 = call i64 @Lexer_advance(i64 %t261)
  %t263 = load i64, i64* %t0
  ; enum variant: TokenKind::NotEq
  %t264 = call i8* @malloc(i64 24)
  %t265 = bitcast i8* %t264 to %TokenKind*
  %t266 = getelementptr %TokenKind, %TokenKind* %t265, i32 0, i32 0
  store i64 13, i64* %t266
  %t267 = getelementptr %TokenKind, %TokenKind* %t265, i32 0, i32 1
  store i8* null, i8** %t267
  %t268 = getelementptr %TokenKind, %TokenKind* %t265, i32 0, i32 2
  %t269 = getelementptr [6 x i8], [6 x i8]* @.str.202, i64 0, i64 0
  store i8* %t269, i8** %t268
  %t270 = ptrtoint %TokenKind* %t265 to i64
  %t271 = getelementptr [3 x i8], [3 x i8]* @.str.203, i64 0, i64 0
  %t272 = ptrtoint i8* %t271 to i64
  %t273 = call i64 @Lexer_make_token(i64 %t263, i64 %t270, i64 %t272)
  ret i64 %t273
  endif135:
  %t274 = load i64, i64* %t0
  ; enum variant: TokenKind::Not
  %t275 = call i8* @malloc(i64 24)
  %t276 = bitcast i8* %t275 to %TokenKind*
  %t277 = getelementptr %TokenKind, %TokenKind* %t276, i32 0, i32 0
  store i64 20, i64* %t277
  %t278 = getelementptr %TokenKind, %TokenKind* %t276, i32 0, i32 1
  store i8* null, i8** %t278
  %t279 = getelementptr %TokenKind, %TokenKind* %t276, i32 0, i32 2
  %t280 = getelementptr [4 x i8], [4 x i8]* @.str.204, i64 0, i64 0
  store i8* %t280, i8** %t279
  %t281 = ptrtoint %TokenKind* %t276 to i64
  %t282 = getelementptr [2 x i8], [2 x i8]* @.str.205, i64 0, i64 0
  %t283 = ptrtoint i8* %t282 to i64
  %t284 = call i64 @Lexer_make_token(i64 %t274, i64 %t281, i64 %t283)
  ret i64 %t284
  match_next131:
  %t285 = getelementptr [2 x i8], [2 x i8]* @.str.206, i64 0, i64 0
  %t286 = ptrtoint i8* %t285 to i64
  %t287 = call i64 @kore_str_eq(i64 %t103, i64 %t286)
  %t288 = icmp ne i64 %t287, 0
  br i1 %t288, label %match_body137, label %match_next136
  match_body137:
  %t289 = load i64, i64* %t0
  %t290 = call i64 @Lexer_peek(i64 %t289)
  %t291 = getelementptr [2 x i8], [2 x i8]* @.str.207, i64 0, i64 0
  %t292 = ptrtoint i8* %t291 to i64
  %t293 = call i64 @kore_str_eq(i64 %t290, i64 %t292)
  %t294 = icmp ne i64 %t293, 0
  br i1 %t294, label %then138, label %endif140
  then138:
  %t295 = load i64, i64* %t0
  %t296 = call i64 @Lexer_advance(i64 %t295)
  %t297 = load i64, i64* %t0
  ; enum variant: TokenKind::LtEq
  %t298 = call i8* @malloc(i64 24)
  %t299 = bitcast i8* %t298 to %TokenKind*
  %t300 = getelementptr %TokenKind, %TokenKind* %t299, i32 0, i32 0
  store i64 15, i64* %t300
  %t301 = getelementptr %TokenKind, %TokenKind* %t299, i32 0, i32 1
  store i8* null, i8** %t301
  %t302 = getelementptr %TokenKind, %TokenKind* %t299, i32 0, i32 2
  %t303 = getelementptr [5 x i8], [5 x i8]* @.str.208, i64 0, i64 0
  store i8* %t303, i8** %t302
  %t304 = ptrtoint %TokenKind* %t299 to i64
  %t305 = getelementptr [3 x i8], [3 x i8]* @.str.209, i64 0, i64 0
  %t306 = ptrtoint i8* %t305 to i64
  %t307 = call i64 @Lexer_make_token(i64 %t297, i64 %t304, i64 %t306)
  ret i64 %t307
  endif140:
  %t308 = load i64, i64* %t0
  ; enum variant: TokenKind::Lt
  %t309 = call i8* @malloc(i64 24)
  %t310 = bitcast i8* %t309 to %TokenKind*
  %t311 = getelementptr %TokenKind, %TokenKind* %t310, i32 0, i32 0
  store i64 14, i64* %t311
  %t312 = getelementptr %TokenKind, %TokenKind* %t310, i32 0, i32 1
  store i8* null, i8** %t312
  %t313 = getelementptr %TokenKind, %TokenKind* %t310, i32 0, i32 2
  %t314 = getelementptr [3 x i8], [3 x i8]* @.str.210, i64 0, i64 0
  store i8* %t314, i8** %t313
  %t315 = ptrtoint %TokenKind* %t310 to i64
  %t316 = getelementptr [2 x i8], [2 x i8]* @.str.211, i64 0, i64 0
  %t317 = ptrtoint i8* %t316 to i64
  %t318 = call i64 @Lexer_make_token(i64 %t308, i64 %t315, i64 %t317)
  ret i64 %t318
  match_next136:
  %t319 = getelementptr [2 x i8], [2 x i8]* @.str.212, i64 0, i64 0
  %t320 = ptrtoint i8* %t319 to i64
  %t321 = call i64 @kore_str_eq(i64 %t103, i64 %t320)
  %t322 = icmp ne i64 %t321, 0
  br i1 %t322, label %match_body142, label %match_next141
  match_body142:
  %t323 = load i64, i64* %t0
  %t324 = call i64 @Lexer_peek(i64 %t323)
  %t325 = getelementptr [2 x i8], [2 x i8]* @.str.213, i64 0, i64 0
  %t326 = ptrtoint i8* %t325 to i64
  %t327 = call i64 @kore_str_eq(i64 %t324, i64 %t326)
  %t328 = icmp ne i64 %t327, 0
  br i1 %t328, label %then143, label %endif145
  then143:
  %t329 = load i64, i64* %t0
  %t330 = call i64 @Lexer_advance(i64 %t329)
  %t331 = load i64, i64* %t0
  ; enum variant: TokenKind::GtEq
  %t332 = call i8* @malloc(i64 24)
  %t333 = bitcast i8* %t332 to %TokenKind*
  %t334 = getelementptr %TokenKind, %TokenKind* %t333, i32 0, i32 0
  store i64 17, i64* %t334
  %t335 = getelementptr %TokenKind, %TokenKind* %t333, i32 0, i32 1
  store i8* null, i8** %t335
  %t336 = getelementptr %TokenKind, %TokenKind* %t333, i32 0, i32 2
  %t337 = getelementptr [5 x i8], [5 x i8]* @.str.214, i64 0, i64 0
  store i8* %t337, i8** %t336
  %t338 = ptrtoint %TokenKind* %t333 to i64
  %t339 = getelementptr [3 x i8], [3 x i8]* @.str.215, i64 0, i64 0
  %t340 = ptrtoint i8* %t339 to i64
  %t341 = call i64 @Lexer_make_token(i64 %t331, i64 %t338, i64 %t340)
  ret i64 %t341
  endif145:
  %t342 = load i64, i64* %t0
  ; enum variant: TokenKind::Gt
  %t343 = call i8* @malloc(i64 24)
  %t344 = bitcast i8* %t343 to %TokenKind*
  %t345 = getelementptr %TokenKind, %TokenKind* %t344, i32 0, i32 0
  store i64 16, i64* %t345
  %t346 = getelementptr %TokenKind, %TokenKind* %t344, i32 0, i32 1
  store i8* null, i8** %t346
  %t347 = getelementptr %TokenKind, %TokenKind* %t344, i32 0, i32 2
  %t348 = getelementptr [3 x i8], [3 x i8]* @.str.216, i64 0, i64 0
  store i8* %t348, i8** %t347
  %t349 = ptrtoint %TokenKind* %t344 to i64
  %t350 = getelementptr [2 x i8], [2 x i8]* @.str.217, i64 0, i64 0
  %t351 = ptrtoint i8* %t350 to i64
  %t352 = call i64 @Lexer_make_token(i64 %t342, i64 %t349, i64 %t351)
  ret i64 %t352
  match_next141:
  %t353 = getelementptr [2 x i8], [2 x i8]* @.str.218, i64 0, i64 0
  %t354 = ptrtoint i8* %t353 to i64
  %t355 = call i64 @kore_str_eq(i64 %t103, i64 %t354)
  %t356 = icmp ne i64 %t355, 0
  br i1 %t356, label %match_body147, label %match_next146
  match_body147:
  %t357 = load i64, i64* %t0
  %t358 = call i64 @Lexer_peek(i64 %t357)
  %t359 = getelementptr [2 x i8], [2 x i8]* @.str.219, i64 0, i64 0
  %t360 = ptrtoint i8* %t359 to i64
  %t361 = call i64 @kore_str_eq(i64 %t358, i64 %t360)
  %t362 = icmp ne i64 %t361, 0
  br i1 %t362, label %then148, label %endif150
  then148:
  %t363 = load i64, i64* %t0
  %t364 = call i64 @Lexer_advance(i64 %t363)
  %t365 = load i64, i64* %t0
  ; enum variant: TokenKind::And
  %t366 = call i8* @malloc(i64 24)
  %t367 = bitcast i8* %t366 to %TokenKind*
  %t368 = getelementptr %TokenKind, %TokenKind* %t367, i32 0, i32 0
  store i64 18, i64* %t368
  %t369 = getelementptr %TokenKind, %TokenKind* %t367, i32 0, i32 1
  store i8* null, i8** %t369
  %t370 = getelementptr %TokenKind, %TokenKind* %t367, i32 0, i32 2
  %t371 = getelementptr [4 x i8], [4 x i8]* @.str.220, i64 0, i64 0
  store i8* %t371, i8** %t370
  %t372 = ptrtoint %TokenKind* %t367 to i64
  %t373 = getelementptr [3 x i8], [3 x i8]* @.str.221, i64 0, i64 0
  %t374 = ptrtoint i8* %t373 to i64
  %t375 = call i64 @Lexer_make_token(i64 %t365, i64 %t372, i64 %t374)
  ret i64 %t375
  endif150:
  %t376 = load i64, i64* %t0
  ; enum variant: TokenKind::Ampersand
  %t377 = call i8* @malloc(i64 24)
  %t378 = bitcast i8* %t377 to %TokenKind*
  %t379 = getelementptr %TokenKind, %TokenKind* %t378, i32 0, i32 0
  store i64 30, i64* %t379
  %t380 = getelementptr %TokenKind, %TokenKind* %t378, i32 0, i32 1
  store i8* null, i8** %t380
  %t381 = getelementptr %TokenKind, %TokenKind* %t378, i32 0, i32 2
  %t382 = getelementptr [10 x i8], [10 x i8]* @.str.222, i64 0, i64 0
  store i8* %t382, i8** %t381
  %t383 = ptrtoint %TokenKind* %t378 to i64
  %t384 = getelementptr [2 x i8], [2 x i8]* @.str.223, i64 0, i64 0
  %t385 = ptrtoint i8* %t384 to i64
  %t386 = call i64 @Lexer_make_token(i64 %t376, i64 %t383, i64 %t385)
  ret i64 %t386
  match_next146:
  %t387 = getelementptr [2 x i8], [2 x i8]* @.str.224, i64 0, i64 0
  %t388 = ptrtoint i8* %t387 to i64
  %t389 = call i64 @kore_str_eq(i64 %t103, i64 %t388)
  %t390 = icmp ne i64 %t389, 0
  br i1 %t390, label %match_body152, label %match_next151
  match_body152:
  %t391 = load i64, i64* %t0
  %t392 = call i64 @Lexer_peek(i64 %t391)
  %t393 = getelementptr [2 x i8], [2 x i8]* @.str.225, i64 0, i64 0
  %t394 = ptrtoint i8* %t393 to i64
  %t395 = call i64 @kore_str_eq(i64 %t392, i64 %t394)
  %t396 = icmp ne i64 %t395, 0
  br i1 %t396, label %then153, label %endif155
  then153:
  %t397 = load i64, i64* %t0
  %t398 = call i64 @Lexer_advance(i64 %t397)
  %t399 = load i64, i64* %t0
  ; enum variant: TokenKind::Or
  %t400 = call i8* @malloc(i64 24)
  %t401 = bitcast i8* %t400 to %TokenKind*
  %t402 = getelementptr %TokenKind, %TokenKind* %t401, i32 0, i32 0
  store i64 19, i64* %t402
  %t403 = getelementptr %TokenKind, %TokenKind* %t401, i32 0, i32 1
  store i8* null, i8** %t403
  %t404 = getelementptr %TokenKind, %TokenKind* %t401, i32 0, i32 2
  %t405 = getelementptr [3 x i8], [3 x i8]* @.str.226, i64 0, i64 0
  store i8* %t405, i8** %t404
  %t406 = ptrtoint %TokenKind* %t401 to i64
  %t407 = getelementptr [3 x i8], [3 x i8]* @.str.227, i64 0, i64 0
  %t408 = ptrtoint i8* %t407 to i64
  %t409 = call i64 @Lexer_make_token(i64 %t399, i64 %t406, i64 %t408)
  ret i64 %t409
  endif155:
  %t410 = load i64, i64* %t0
  ; enum variant: TokenKind::Pipe
  %t411 = call i8* @malloc(i64 24)
  %t412 = bitcast i8* %t411 to %TokenKind*
  %t413 = getelementptr %TokenKind, %TokenKind* %t412, i32 0, i32 0
  store i64 29, i64* %t413
  %t414 = getelementptr %TokenKind, %TokenKind* %t412, i32 0, i32 1
  store i8* null, i8** %t414
  %t415 = getelementptr %TokenKind, %TokenKind* %t412, i32 0, i32 2
  %t416 = getelementptr [5 x i8], [5 x i8]* @.str.228, i64 0, i64 0
  store i8* %t416, i8** %t415
  %t417 = ptrtoint %TokenKind* %t412 to i64
  %t418 = getelementptr [2 x i8], [2 x i8]* @.str.229, i64 0, i64 0
  %t419 = ptrtoint i8* %t418 to i64
  %t420 = call i64 @Lexer_make_token(i64 %t410, i64 %t417, i64 %t419)
  ret i64 %t420
  match_next151:
  %t421 = getelementptr [2 x i8], [2 x i8]* @.str.230, i64 0, i64 0
  %t422 = ptrtoint i8* %t421 to i64
  %t423 = call i64 @kore_str_eq(i64 %t103, i64 %t422)
  %t424 = icmp ne i64 %t423, 0
  br i1 %t424, label %match_body157, label %match_next156
  match_body157:
  %t425 = load i64, i64* %t0
  %t426 = call i64 @Lexer_peek(i64 %t425)
  %t427 = getelementptr [2 x i8], [2 x i8]* @.str.231, i64 0, i64 0
  %t428 = ptrtoint i8* %t427 to i64
  %t429 = call i64 @kore_str_eq(i64 %t426, i64 %t428)
  %t430 = icmp ne i64 %t429, 0
  br i1 %t430, label %then158, label %endif160
  then158:
  %t431 = load i64, i64* %t0
  %t432 = call i64 @Lexer_advance(i64 %t431)
  %t433 = load i64, i64* %t0
  ; enum variant: TokenKind::DotDot
  %t434 = call i8* @malloc(i64 24)
  %t435 = bitcast i8* %t434 to %TokenKind*
  %t436 = getelementptr %TokenKind, %TokenKind* %t435, i32 0, i32 0
  store i64 24, i64* %t436
  %t437 = getelementptr %TokenKind, %TokenKind* %t435, i32 0, i32 1
  store i8* null, i8** %t437
  %t438 = getelementptr %TokenKind, %TokenKind* %t435, i32 0, i32 2
  %t439 = getelementptr [7 x i8], [7 x i8]* @.str.232, i64 0, i64 0
  store i8* %t439, i8** %t438
  %t440 = ptrtoint %TokenKind* %t435 to i64
  %t441 = getelementptr [3 x i8], [3 x i8]* @.str.233, i64 0, i64 0
  %t442 = ptrtoint i8* %t441 to i64
  %t443 = call i64 @Lexer_make_token(i64 %t433, i64 %t440, i64 %t442)
  ret i64 %t443
  endif160:
  %t444 = load i64, i64* %t0
  ; enum variant: TokenKind::Dot
  %t445 = call i8* @malloc(i64 24)
  %t446 = bitcast i8* %t445 to %TokenKind*
  %t447 = getelementptr %TokenKind, %TokenKind* %t446, i32 0, i32 0
  store i64 23, i64* %t447
  %t448 = getelementptr %TokenKind, %TokenKind* %t446, i32 0, i32 1
  store i8* null, i8** %t448
  %t449 = getelementptr %TokenKind, %TokenKind* %t446, i32 0, i32 2
  %t450 = getelementptr [4 x i8], [4 x i8]* @.str.234, i64 0, i64 0
  store i8* %t450, i8** %t449
  %t451 = ptrtoint %TokenKind* %t446 to i64
  %t452 = getelementptr [2 x i8], [2 x i8]* @.str.235, i64 0, i64 0
  %t453 = ptrtoint i8* %t452 to i64
  %t454 = call i64 @Lexer_make_token(i64 %t444, i64 %t451, i64 %t453)
  ret i64 %t454
  match_next156:
  %t455 = getelementptr [2 x i8], [2 x i8]* @.str.236, i64 0, i64 0
  %t456 = ptrtoint i8* %t455 to i64
  %t457 = call i64 @kore_str_eq(i64 %t103, i64 %t456)
  %t458 = icmp ne i64 %t457, 0
  br i1 %t458, label %match_body162, label %match_next161
  match_body162:
  %t459 = load i64, i64* %t0
  %t460 = call i64 @Lexer_peek(i64 %t459)
  %t461 = getelementptr [2 x i8], [2 x i8]* @.str.237, i64 0, i64 0
  %t462 = ptrtoint i8* %t461 to i64
  %t463 = call i64 @kore_str_eq(i64 %t460, i64 %t462)
  %t464 = icmp ne i64 %t463, 0
  br i1 %t464, label %then163, label %endif165
  then163:
  %t465 = load i64, i64* %t0
  %t466 = call i64 @Lexer_advance(i64 %t465)
  %t467 = load i64, i64* %t0
  ; enum variant: TokenKind::ColonColon
  %t468 = call i8* @malloc(i64 24)
  %t469 = bitcast i8* %t468 to %TokenKind*
  %t470 = getelementptr %TokenKind, %TokenKind* %t469, i32 0, i32 0
  store i64 26, i64* %t470
  %t471 = getelementptr %TokenKind, %TokenKind* %t469, i32 0, i32 1
  store i8* null, i8** %t471
  %t472 = getelementptr %TokenKind, %TokenKind* %t469, i32 0, i32 2
  %t473 = getelementptr [11 x i8], [11 x i8]* @.str.238, i64 0, i64 0
  store i8* %t473, i8** %t472
  %t474 = ptrtoint %TokenKind* %t469 to i64
  %t475 = getelementptr [3 x i8], [3 x i8]* @.str.239, i64 0, i64 0
  %t476 = ptrtoint i8* %t475 to i64
  %t477 = call i64 @Lexer_make_token(i64 %t467, i64 %t474, i64 %t476)
  ret i64 %t477
  endif165:
  %t478 = load i64, i64* %t0
  ; enum variant: TokenKind::Colon
  %t479 = call i8* @malloc(i64 24)
  %t480 = bitcast i8* %t479 to %TokenKind*
  %t481 = getelementptr %TokenKind, %TokenKind* %t480, i32 0, i32 0
  store i64 25, i64* %t481
  %t482 = getelementptr %TokenKind, %TokenKind* %t480, i32 0, i32 1
  store i8* null, i8** %t482
  %t483 = getelementptr %TokenKind, %TokenKind* %t480, i32 0, i32 2
  %t484 = getelementptr [6 x i8], [6 x i8]* @.str.240, i64 0, i64 0
  store i8* %t484, i8** %t483
  %t485 = ptrtoint %TokenKind* %t480 to i64
  %t486 = getelementptr [2 x i8], [2 x i8]* @.str.241, i64 0, i64 0
  %t487 = ptrtoint i8* %t486 to i64
  %t488 = call i64 @Lexer_make_token(i64 %t478, i64 %t485, i64 %t487)
  ret i64 %t488
  match_next161:
  %t489 = getelementptr [2 x i8], [2 x i8]* @.str.242, i64 0, i64 0
  %t490 = ptrtoint i8* %t489 to i64
  %t491 = call i64 @kore_str_eq(i64 %t103, i64 %t490)
  %t492 = icmp ne i64 %t491, 0
  br i1 %t492, label %match_body167, label %match_next166
  match_body167:
  %t493 = load i64, i64* %t0
  ; enum variant: TokenKind::Comma
  %t494 = call i8* @malloc(i64 24)
  %t495 = bitcast i8* %t494 to %TokenKind*
  %t496 = getelementptr %TokenKind, %TokenKind* %t495, i32 0, i32 0
  store i64 27, i64* %t496
  %t497 = getelementptr %TokenKind, %TokenKind* %t495, i32 0, i32 1
  store i8* null, i8** %t497
  %t498 = getelementptr %TokenKind, %TokenKind* %t495, i32 0, i32 2
  %t499 = getelementptr [6 x i8], [6 x i8]* @.str.243, i64 0, i64 0
  store i8* %t499, i8** %t498
  %t500 = ptrtoint %TokenKind* %t495 to i64
  %t501 = getelementptr [2 x i8], [2 x i8]* @.str.244, i64 0, i64 0
  %t502 = ptrtoint i8* %t501 to i64
  %t503 = call i64 @Lexer_make_token(i64 %t493, i64 %t500, i64 %t502)
  ret i64 %t503
  match_next166:
  %t504 = getelementptr [2 x i8], [2 x i8]* @.str.245, i64 0, i64 0
  %t505 = ptrtoint i8* %t504 to i64
  %t506 = call i64 @kore_str_eq(i64 %t103, i64 %t505)
  %t507 = icmp ne i64 %t506, 0
  br i1 %t507, label %match_body169, label %match_next168
  match_body169:
  %t508 = load i64, i64* %t0
  ; enum variant: TokenKind::Semicolon
  %t509 = call i8* @malloc(i64 24)
  %t510 = bitcast i8* %t509 to %TokenKind*
  %t511 = getelementptr %TokenKind, %TokenKind* %t510, i32 0, i32 0
  store i64 28, i64* %t511
  %t512 = getelementptr %TokenKind, %TokenKind* %t510, i32 0, i32 1
  store i8* null, i8** %t512
  %t513 = getelementptr %TokenKind, %TokenKind* %t510, i32 0, i32 2
  %t514 = getelementptr [10 x i8], [10 x i8]* @.str.246, i64 0, i64 0
  store i8* %t514, i8** %t513
  %t515 = ptrtoint %TokenKind* %t510 to i64
  %t516 = getelementptr [2 x i8], [2 x i8]* @.str.247, i64 0, i64 0
  %t517 = ptrtoint i8* %t516 to i64
  %t518 = call i64 @Lexer_make_token(i64 %t508, i64 %t515, i64 %t517)
  ret i64 %t518
  match_next168:
  %t519 = getelementptr [2 x i8], [2 x i8]* @.str.248, i64 0, i64 0
  %t520 = ptrtoint i8* %t519 to i64
  %t521 = call i64 @kore_str_eq(i64 %t103, i64 %t520)
  %t522 = icmp ne i64 %t521, 0
  br i1 %t522, label %match_body171, label %match_next170
  match_body171:
  %t523 = load i64, i64* %t0
  ; enum variant: TokenKind::LParen
  %t524 = call i8* @malloc(i64 24)
  %t525 = bitcast i8* %t524 to %TokenKind*
  %t526 = getelementptr %TokenKind, %TokenKind* %t525, i32 0, i32 0
  store i64 31, i64* %t526
  %t527 = getelementptr %TokenKind, %TokenKind* %t525, i32 0, i32 1
  store i8* null, i8** %t527
  %t528 = getelementptr %TokenKind, %TokenKind* %t525, i32 0, i32 2
  %t529 = getelementptr [7 x i8], [7 x i8]* @.str.249, i64 0, i64 0
  store i8* %t529, i8** %t528
  %t530 = ptrtoint %TokenKind* %t525 to i64
  %t531 = getelementptr [2 x i8], [2 x i8]* @.str.250, i64 0, i64 0
  %t532 = ptrtoint i8* %t531 to i64
  %t533 = call i64 @Lexer_make_token(i64 %t523, i64 %t530, i64 %t532)
  ret i64 %t533
  match_next170:
  %t534 = getelementptr [2 x i8], [2 x i8]* @.str.251, i64 0, i64 0
  %t535 = ptrtoint i8* %t534 to i64
  %t536 = call i64 @kore_str_eq(i64 %t103, i64 %t535)
  %t537 = icmp ne i64 %t536, 0
  br i1 %t537, label %match_body173, label %match_next172
  match_body173:
  %t538 = load i64, i64* %t0
  ; enum variant: TokenKind::RParen
  %t539 = call i8* @malloc(i64 24)
  %t540 = bitcast i8* %t539 to %TokenKind*
  %t541 = getelementptr %TokenKind, %TokenKind* %t540, i32 0, i32 0
  store i64 32, i64* %t541
  %t542 = getelementptr %TokenKind, %TokenKind* %t540, i32 0, i32 1
  store i8* null, i8** %t542
  %t543 = getelementptr %TokenKind, %TokenKind* %t540, i32 0, i32 2
  %t544 = getelementptr [7 x i8], [7 x i8]* @.str.252, i64 0, i64 0
  store i8* %t544, i8** %t543
  %t545 = ptrtoint %TokenKind* %t540 to i64
  %t546 = getelementptr [2 x i8], [2 x i8]* @.str.253, i64 0, i64 0
  %t547 = ptrtoint i8* %t546 to i64
  %t548 = call i64 @Lexer_make_token(i64 %t538, i64 %t545, i64 %t547)
  ret i64 %t548
  match_next172:
  %t549 = getelementptr [2 x i8], [2 x i8]* @.str.254, i64 0, i64 0
  %t550 = ptrtoint i8* %t549 to i64
  %t551 = call i64 @kore_str_eq(i64 %t103, i64 %t550)
  %t552 = icmp ne i64 %t551, 0
  br i1 %t552, label %match_body175, label %match_next174
  match_body175:
  %t553 = load i64, i64* %t0
  ; enum variant: TokenKind::LBracket
  %t554 = call i8* @malloc(i64 24)
  %t555 = bitcast i8* %t554 to %TokenKind*
  %t556 = getelementptr %TokenKind, %TokenKind* %t555, i32 0, i32 0
  store i64 33, i64* %t556
  %t557 = getelementptr %TokenKind, %TokenKind* %t555, i32 0, i32 1
  store i8* null, i8** %t557
  %t558 = getelementptr %TokenKind, %TokenKind* %t555, i32 0, i32 2
  %t559 = getelementptr [9 x i8], [9 x i8]* @.str.255, i64 0, i64 0
  store i8* %t559, i8** %t558
  %t560 = ptrtoint %TokenKind* %t555 to i64
  %t561 = getelementptr [2 x i8], [2 x i8]* @.str.256, i64 0, i64 0
  %t562 = ptrtoint i8* %t561 to i64
  %t563 = call i64 @Lexer_make_token(i64 %t553, i64 %t560, i64 %t562)
  ret i64 %t563
  match_next174:
  %t564 = getelementptr [2 x i8], [2 x i8]* @.str.257, i64 0, i64 0
  %t565 = ptrtoint i8* %t564 to i64
  %t566 = call i64 @kore_str_eq(i64 %t103, i64 %t565)
  %t567 = icmp ne i64 %t566, 0
  br i1 %t567, label %match_body177, label %match_next176
  match_body177:
  %t568 = load i64, i64* %t0
  ; enum variant: TokenKind::RBracket
  %t569 = call i8* @malloc(i64 24)
  %t570 = bitcast i8* %t569 to %TokenKind*
  %t571 = getelementptr %TokenKind, %TokenKind* %t570, i32 0, i32 0
  store i64 34, i64* %t571
  %t572 = getelementptr %TokenKind, %TokenKind* %t570, i32 0, i32 1
  store i8* null, i8** %t572
  %t573 = getelementptr %TokenKind, %TokenKind* %t570, i32 0, i32 2
  %t574 = getelementptr [9 x i8], [9 x i8]* @.str.258, i64 0, i64 0
  store i8* %t574, i8** %t573
  %t575 = ptrtoint %TokenKind* %t570 to i64
  %t576 = getelementptr [2 x i8], [2 x i8]* @.str.259, i64 0, i64 0
  %t577 = ptrtoint i8* %t576 to i64
  %t578 = call i64 @Lexer_make_token(i64 %t568, i64 %t575, i64 %t577)
  ret i64 %t578
  match_next176:
  %t579 = getelementptr [2 x i8], [2 x i8]* @.str.260, i64 0, i64 0
  %t580 = ptrtoint i8* %t579 to i64
  %t581 = call i64 @kore_str_eq(i64 %t103, i64 %t580)
  %t582 = icmp ne i64 %t581, 0
  br i1 %t582, label %match_body179, label %match_next178
  match_body179:
  %t583 = load i64, i64* %t0
  ; enum variant: TokenKind::LBrace
  %t584 = call i8* @malloc(i64 24)
  %t585 = bitcast i8* %t584 to %TokenKind*
  %t586 = getelementptr %TokenKind, %TokenKind* %t585, i32 0, i32 0
  store i64 35, i64* %t586
  %t587 = getelementptr %TokenKind, %TokenKind* %t585, i32 0, i32 1
  store i8* null, i8** %t587
  %t588 = getelementptr %TokenKind, %TokenKind* %t585, i32 0, i32 2
  %t589 = getelementptr [7 x i8], [7 x i8]* @.str.261, i64 0, i64 0
  store i8* %t589, i8** %t588
  %t590 = ptrtoint %TokenKind* %t585 to i64
  %t591 = getelementptr [2 x i8], [2 x i8]* @.str.262, i64 0, i64 0
  %t592 = ptrtoint i8* %t591 to i64
  %t593 = call i64 @Lexer_make_token(i64 %t583, i64 %t590, i64 %t592)
  ret i64 %t593
  match_next178:
  %t594 = getelementptr [2 x i8], [2 x i8]* @.str.263, i64 0, i64 0
  %t595 = ptrtoint i8* %t594 to i64
  %t596 = call i64 @kore_str_eq(i64 %t103, i64 %t595)
  %t597 = icmp ne i64 %t596, 0
  br i1 %t597, label %match_body181, label %match_next180
  match_body181:
  %t598 = load i64, i64* %t0
  ; enum variant: TokenKind::RBrace
  %t599 = call i8* @malloc(i64 24)
  %t600 = bitcast i8* %t599 to %TokenKind*
  %t601 = getelementptr %TokenKind, %TokenKind* %t600, i32 0, i32 0
  store i64 36, i64* %t601
  %t602 = getelementptr %TokenKind, %TokenKind* %t600, i32 0, i32 1
  store i8* null, i8** %t602
  %t603 = getelementptr %TokenKind, %TokenKind* %t600, i32 0, i32 2
  %t604 = getelementptr [7 x i8], [7 x i8]* @.str.264, i64 0, i64 0
  store i8* %t604, i8** %t603
  %t605 = ptrtoint %TokenKind* %t600 to i64
  %t606 = getelementptr [2 x i8], [2 x i8]* @.str.265, i64 0, i64 0
  %t607 = ptrtoint i8* %t606 to i64
  %t608 = call i64 @Lexer_make_token(i64 %t598, i64 %t605, i64 %t607)
  ret i64 %t608
  match_next180:
  br label %match_body183
  match_body183:
  %t609 = load i64, i64* %t0
  ; enum variant: TokenKind::Error
  %t610 = call i8* @malloc(i64 24)
  %t611 = bitcast i8* %t610 to %TokenKind*
  %t612 = getelementptr %TokenKind, %TokenKind* %t611, i32 0, i32 0
  store i64 43, i64* %t612
  %t613 = call i8* @malloc(i64 8)
  %t614 = bitcast i8* %t613 to i64*
  %t615 = getelementptr [20 x i8], [20 x i8]* @.str.266, i64 0, i64 0
  %t616 = ptrtoint i8* %t615 to i64
  %t617 = load i64, i64* %t19
  %t618 = call i64 @kore_str_concat(i64 %t616, i64 %t617)
  %t619 = getelementptr i64, i64* %t614, i32 0
  store i64 %t618, i64* %t619
  %t620 = getelementptr %TokenKind, %TokenKind* %t611, i32 0, i32 1
  store i8* %t613, i8** %t620
  %t621 = getelementptr %TokenKind, %TokenKind* %t611, i32 0, i32 2
  %t622 = getelementptr [6 x i8], [6 x i8]* @.str.267, i64 0, i64 0
  store i8* %t622, i8** %t621
  %t623 = ptrtoint %TokenKind* %t611 to i64
  %t624 = load i64, i64* %t19
  %t625 = call i64 @Lexer_make_token(i64 %t609, i64 %t623, i64 %t624)
  ret i64 %t625
  match_next182:
  br label %match_end109
  match_end109:
  ret i64 0
}
define i64 @Lexer_tokenize(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = call i64 @kore_array_new()
  %t2 = alloca i64
  store i64 %t1, i64* %t2
  %t3 = alloca i64
  store i64 1, i64* %t3
  br label %loop184
  loop184:
  %t4 = load i64, i64* %t0
  %t5 = call i64 @Lexer_is_eof(i64 %t4)
  %t6 = icmp ne i64 %t5, 0
  br i1 %t6, label %then186, label %endif188
  then186:
  br label %while_cond189
  while_cond189:
  %t7 = load i64, i64* %t0
  %t8 = inttoptr i64 %t7 to %Lexer*
  %t9 = getelementptr %Lexer, %Lexer* %t8, i32 0, i32 5
  %t10 = load i64, i64* %t9
  %t11 = call i64 @kore_array_len(i64 %t10)
  %t13 = icmp sgt i64 %t11, 1
  %t12 = zext i1 %t13 to i64
  %t14 = icmp ne i64 %t12, 0
  br i1 %t14, label %while_body190, label %while_end191
  while_body190:
  %t15 = load i64, i64* %t0
  %t16 = inttoptr i64 %t15 to %Lexer*
  %t17 = getelementptr %Lexer, %Lexer* %t16, i32 0, i32 5
  %t18 = load i64, i64* %t17
  %t19 = call i64 @kore_array_pop(i64 %t18)
  %t20 = load i64, i64* %t2
  ; enum variant: TokenKind::Dedent
  %t21 = call i8* @malloc(i64 24)
  %t22 = bitcast i8* %t21 to %TokenKind*
  %t23 = getelementptr %TokenKind, %TokenKind* %t22, i32 0, i32 0
  store i64 41, i64* %t23
  %t24 = getelementptr %TokenKind, %TokenKind* %t22, i32 0, i32 1
  store i8* null, i8** %t24
  %t25 = getelementptr %TokenKind, %TokenKind* %t22, i32 0, i32 2
  %t26 = getelementptr [7 x i8], [7 x i8]* @.str.268, i64 0, i64 0
  store i8* %t26, i8** %t25
  %t27 = ptrtoint %TokenKind* %t22 to i64
  %t28 = load i64, i64* %t0
  %t29 = inttoptr i64 %t28 to %Lexer*
  %t30 = getelementptr %Lexer, %Lexer* %t29, i32 0, i32 3
  %t31 = load i64, i64* %t30
  %t32 = load i64, i64* %t0
  %t33 = inttoptr i64 %t32 to %Lexer*
  %t34 = getelementptr %Lexer, %Lexer* %t33, i32 0, i32 4
  %t35 = load i64, i64* %t34
  %t36 = getelementptr [7 x i8], [7 x i8]* @.str.269, i64 0, i64 0
  %t37 = ptrtoint i8* %t36 to i64
  %t38 = call i64 @Token_new(i64 %t27, i64 %t31, i64 %t35, i64 %t37)
  %t39 = call i64 @kore_array_push(i64 %t20, i64 %t38)
  br label %while_cond189
  while_end191:
  %t40 = load i64, i64* %t2
  ; enum variant: TokenKind::Eof
  %t41 = call i8* @malloc(i64 24)
  %t42 = bitcast i8* %t41 to %TokenKind*
  %t43 = getelementptr %TokenKind, %TokenKind* %t42, i32 0, i32 0
  store i64 42, i64* %t43
  %t44 = getelementptr %TokenKind, %TokenKind* %t42, i32 0, i32 1
  store i8* null, i8** %t44
  %t45 = getelementptr %TokenKind, %TokenKind* %t42, i32 0, i32 2
  %t46 = getelementptr [4 x i8], [4 x i8]* @.str.270, i64 0, i64 0
  store i8* %t46, i8** %t45
  %t47 = ptrtoint %TokenKind* %t42 to i64
  %t48 = load i64, i64* %t0
  %t49 = inttoptr i64 %t48 to %Lexer*
  %t50 = getelementptr %Lexer, %Lexer* %t49, i32 0, i32 3
  %t51 = load i64, i64* %t50
  %t52 = load i64, i64* %t0
  %t53 = inttoptr i64 %t52 to %Lexer*
  %t54 = getelementptr %Lexer, %Lexer* %t53, i32 0, i32 4
  %t55 = load i64, i64* %t54
  %t56 = getelementptr [1 x i8], [1 x i8]* @.str.271, i64 0, i64 0
  %t57 = ptrtoint i8* %t56 to i64
  %t58 = call i64 @Token_new(i64 %t47, i64 %t51, i64 %t55, i64 %t57)
  %t59 = call i64 @kore_array_push(i64 %t40, i64 %t58)
  br label %loop_end185
  endif188:
  %t60 = alloca i64
  store i64 0, i64* %t60
  %t61 = load i64, i64* %t3
  %t62 = icmp ne i64 %t61, 0
  br i1 %t62, label %then192, label %else193
  then192:
  br label %while_cond195
  while_cond195:
  %t63 = load i64, i64* %t0
  %t64 = call i64 @Lexer_is_eof(i64 %t63)
  %t66 = icmp eq i64 %t64, 0
  %t65 = zext i1 %t66 to i64
  %t67 = icmp ne i64 %t65, 0
  br i1 %t67, label %while_body196, label %while_end197
  while_body196:
  %t68 = load i64, i64* %t0
  %t69 = call i64 @Lexer_peek(i64 %t68)
  %t70 = alloca i64
  store i64 %t69, i64* %t70
  %t71 = load i64, i64* %t70
  %t72 = getelementptr [2 x i8], [2 x i8]* @.str.272, i64 0, i64 0
  %t73 = ptrtoint i8* %t72 to i64
  %t74 = call i64 @kore_str_eq(i64 %t71, i64 %t73)
  %t75 = icmp ne i64 %t74, 0
  br i1 %t75, label %then198, label %else199
  then198:
  %t76 = load i64, i64* %t60
  %t77 = add i64 %t76, 1
  store i64 %t77, i64* %t60
  %t78 = load i64, i64* %t0
  %t79 = call i64 @Lexer_advance(i64 %t78)
  br label %endif200
  else199:
  %t80 = load i64, i64* %t70
  %t81 = getelementptr [2 x i8], [2 x i8]* @.str.273, i64 0, i64 0
  %t82 = ptrtoint i8* %t81 to i64
  %t83 = call i64 @kore_str_eq(i64 %t80, i64 %t82)
  %t84 = icmp ne i64 %t83, 0
  br i1 %t84, label %then201, label %else202
  then201:
  %t85 = load i64, i64* %t60
  %t86 = add i64 %t85, 4
  store i64 %t86, i64* %t60
  %t87 = load i64, i64* %t0
  %t88 = call i64 @Lexer_advance(i64 %t87)
  br label %endif203
  else202:
  %t89 = load i64, i64* %t70
  %t90 = getelementptr [2 x i8], [2 x i8]* @.str.274, i64 0, i64 0
  %t91 = ptrtoint i8* %t90 to i64
  %t92 = call i64 @kore_str_eq(i64 %t89, i64 %t91)
  %t93 = icmp ne i64 %t92, 0
  br i1 %t93, label %then204, label %else205
  then204:
  %t94 = load i64, i64* %t0
  %t95 = call i64 @Lexer_advance(i64 %t94)
  br label %endif206
  else205:
  br label %while_end197
  endif206:
  br label %endif203
  endif203:
  br label %endif200
  endif200:
  br label %while_cond195
  while_end197:
  br label %endif194
  else193:
  br label %while_cond207
  while_cond207:
  %t96 = load i64, i64* %t0
  %t97 = call i64 @Lexer_is_eof(i64 %t96)
  %t99 = icmp eq i64 %t97, 0
  %t98 = zext i1 %t99 to i64
  %t100 = icmp ne i64 %t98, 0
  br i1 %t100, label %while_body208, label %while_end209
  while_body208:
  %t101 = load i64, i64* %t0
  %t102 = call i64 @Lexer_peek(i64 %t101)
  %t103 = alloca i64
  store i64 %t102, i64* %t103
  %t104 = load i64, i64* %t103
  %t105 = getelementptr [2 x i8], [2 x i8]* @.str.275, i64 0, i64 0
  %t106 = ptrtoint i8* %t105 to i64
  %t107 = call i64 @kore_str_eq(i64 %t104, i64 %t106)
  %t108 = load i64, i64* %t103
  %t109 = getelementptr [2 x i8], [2 x i8]* @.str.276, i64 0, i64 0
  %t110 = ptrtoint i8* %t109 to i64
  %t111 = call i64 @kore_str_eq(i64 %t108, i64 %t110)
  %t112 = or i64 %t107, %t111
  %t113 = icmp ne i64 %t112, 0
  br i1 %t113, label %then210, label %else211
  then210:
  %t114 = load i64, i64* %t0
  %t115 = call i64 @Lexer_advance(i64 %t114)
  br label %endif212
  else211:
  br label %while_end209
  endif212:
  br label %while_cond207
  while_end209:
  br label %endif194
  endif194:
  %t116 = load i64, i64* %t0
  %t117 = call i64 @Lexer_is_eof(i64 %t116)
  %t118 = icmp ne i64 %t117, 0
  br i1 %t118, label %then213, label %endif215
  then213:
  br label %loop184
  endif215:
  %t119 = load i64, i64* %t0
  %t120 = call i64 @Lexer_peek(i64 %t119)
  %t121 = getelementptr [2 x i8], [2 x i8]* @.str.277, i64 0, i64 0
  %t122 = ptrtoint i8* %t121 to i64
  %t123 = call i64 @kore_str_eq(i64 %t120, i64 %t122)
  %t124 = icmp ne i64 %t123, 0
  br i1 %t124, label %then216, label %endif218
  then216:
  %t125 = load i64, i64* %t0
  %t126 = call i64 @Lexer_advance(i64 %t125)
  %t127 = load i64, i64* %t2
  ; enum variant: TokenKind::Newline
  %t128 = call i8* @malloc(i64 24)
  %t129 = bitcast i8* %t128 to %TokenKind*
  %t130 = getelementptr %TokenKind, %TokenKind* %t129, i32 0, i32 0
  store i64 39, i64* %t130
  %t131 = getelementptr %TokenKind, %TokenKind* %t129, i32 0, i32 1
  store i8* null, i8** %t131
  %t132 = getelementptr %TokenKind, %TokenKind* %t129, i32 0, i32 2
  %t133 = getelementptr [8 x i8], [8 x i8]* @.str.278, i64 0, i64 0
  store i8* %t133, i8** %t132
  %t134 = ptrtoint %TokenKind* %t129 to i64
  %t135 = load i64, i64* %t0
  %t136 = inttoptr i64 %t135 to %Lexer*
  %t137 = getelementptr %Lexer, %Lexer* %t136, i32 0, i32 3
  %t138 = load i64, i64* %t137
  %t139 = load i64, i64* %t0
  %t140 = inttoptr i64 %t139 to %Lexer*
  %t141 = getelementptr %Lexer, %Lexer* %t140, i32 0, i32 4
  %t142 = load i64, i64* %t141
  %t143 = getelementptr [2 x i8], [2 x i8]* @.str.279, i64 0, i64 0
  %t144 = ptrtoint i8* %t143 to i64
  %t145 = call i64 @Token_new(i64 %t134, i64 %t138, i64 %t142, i64 %t144)
  %t146 = call i64 @kore_array_push(i64 %t127, i64 %t145)
  store i64 1, i64* %t3
  br label %loop184
  endif218:
  %t147 = load i64, i64* %t0
  %t148 = call i64 @Lexer_peek(i64 %t147)
  %t149 = getelementptr [2 x i8], [2 x i8]* @.str.280, i64 0, i64 0
  %t150 = ptrtoint i8* %t149 to i64
  %t151 = call i64 @kore_str_eq(i64 %t148, i64 %t150)
  %t152 = icmp ne i64 %t151, 0
  br i1 %t152, label %then219, label %endif221
  then219:
  br label %while_cond222
  while_cond222:
  %t153 = load i64, i64* %t0
  %t154 = call i64 @Lexer_is_eof(i64 %t153)
  %t156 = icmp eq i64 %t154, 0
  %t155 = zext i1 %t156 to i64
  %t157 = load i64, i64* %t0
  %t158 = call i64 @Lexer_peek(i64 %t157)
  %t159 = getelementptr [2 x i8], [2 x i8]* @.str.281, i64 0, i64 0
  %t160 = ptrtoint i8* %t159 to i64
  %t162 = call i64 @kore_str_eq(i64 %t158, i64 %t160)
  %t163 = icmp eq i64 %t162, 0
  %t161 = zext i1 %t163 to i64
  %t164 = and i64 %t155, %t161
  %t165 = icmp ne i64 %t164, 0
  br i1 %t165, label %while_body223, label %while_end224
  while_body223:
  %t166 = load i64, i64* %t0
  %t167 = call i64 @Lexer_advance(i64 %t166)
  br label %while_cond222
  while_end224:
  br label %loop184
  endif221:
  %t168 = load i64, i64* %t0
  %t169 = call i64 @Lexer_peek(i64 %t168)
  %t170 = getelementptr [2 x i8], [2 x i8]* @.str.282, i64 0, i64 0
  %t171 = ptrtoint i8* %t170 to i64
  %t172 = call i64 @kore_str_eq(i64 %t169, i64 %t171)
  %t173 = load i64, i64* %t0
  %t174 = call i64 @Lexer_peek_n(i64 %t173, i64 1)
  %t175 = getelementptr [2 x i8], [2 x i8]* @.str.283, i64 0, i64 0
  %t176 = ptrtoint i8* %t175 to i64
  %t177 = call i64 @kore_str_eq(i64 %t174, i64 %t176)
  %t178 = and i64 %t172, %t177
  %t179 = icmp ne i64 %t178, 0
  br i1 %t179, label %then225, label %endif227
  then225:
  br label %while_cond228
  while_cond228:
  %t180 = load i64, i64* %t0
  %t181 = call i64 @Lexer_is_eof(i64 %t180)
  %t183 = icmp eq i64 %t181, 0
  %t182 = zext i1 %t183 to i64
  %t184 = load i64, i64* %t0
  %t185 = call i64 @Lexer_peek(i64 %t184)
  %t186 = getelementptr [2 x i8], [2 x i8]* @.str.284, i64 0, i64 0
  %t187 = ptrtoint i8* %t186 to i64
  %t189 = call i64 @kore_str_eq(i64 %t185, i64 %t187)
  %t190 = icmp eq i64 %t189, 0
  %t188 = zext i1 %t190 to i64
  %t191 = and i64 %t182, %t188
  %t192 = icmp ne i64 %t191, 0
  br i1 %t192, label %while_body229, label %while_end230
  while_body229:
  %t193 = load i64, i64* %t0
  %t194 = call i64 @Lexer_advance(i64 %t193)
  br label %while_cond228
  while_end230:
  br label %loop184
  endif227:
  %t195 = load i64, i64* %t3
  %t196 = icmp ne i64 %t195, 0
  br i1 %t196, label %then231, label %endif233
  then231:
  %t197 = alloca i64
  store i64 0, i64* %t197
  %t198 = load i64, i64* %t0
  %t199 = inttoptr i64 %t198 to %Lexer*
  %t200 = getelementptr %Lexer, %Lexer* %t199, i32 0, i32 5
  %t201 = load i64, i64* %t200
  %t202 = call i64 @kore_array_len(i64 %t201)
  %t204 = icmp sgt i64 %t202, 0
  %t203 = zext i1 %t204 to i64
  %t205 = icmp ne i64 %t203, 0
  br i1 %t205, label %then234, label %endif236
  then234:
  %t206 = load i64, i64* %t0
  %t207 = inttoptr i64 %t206 to %Lexer*
  %t208 = getelementptr %Lexer, %Lexer* %t207, i32 0, i32 5
  %t209 = load i64, i64* %t208
  %t210 = load i64, i64* %t0
  %t211 = inttoptr i64 %t210 to %Lexer*
  %t212 = getelementptr %Lexer, %Lexer* %t211, i32 0, i32 5
  %t213 = load i64, i64* %t212
  %t214 = call i64 @kore_array_len(i64 %t213)
  %t215 = sub i64 %t214, 1
  %t216 = call i64 @kore_array_get(i64 %t209, i64 %t215)
  store i64 %t216, i64* %t197
  br label %endif236
  endif236:
  %t217 = load i64, i64* %t60
  %t218 = load i64, i64* %t197
  %t220 = icmp sgt i64 %t217, %t218
  %t219 = zext i1 %t220 to i64
  %t221 = icmp ne i64 %t219, 0
  br i1 %t221, label %then237, label %else238
  then237:
  %t222 = load i64, i64* %t0
  %t223 = inttoptr i64 %t222 to %Lexer*
  %t224 = getelementptr %Lexer, %Lexer* %t223, i32 0, i32 5
  %t225 = load i64, i64* %t224
  %t226 = load i64, i64* %t60
  %t227 = call i64 @kore_array_push(i64 %t225, i64 %t226)
  %t228 = load i64, i64* %t2
  ; enum variant: TokenKind::Indent
  %t229 = call i8* @malloc(i64 24)
  %t230 = bitcast i8* %t229 to %TokenKind*
  %t231 = getelementptr %TokenKind, %TokenKind* %t230, i32 0, i32 0
  store i64 40, i64* %t231
  %t232 = getelementptr %TokenKind, %TokenKind* %t230, i32 0, i32 1
  store i8* null, i8** %t232
  %t233 = getelementptr %TokenKind, %TokenKind* %t230, i32 0, i32 2
  %t234 = getelementptr [7 x i8], [7 x i8]* @.str.285, i64 0, i64 0
  store i8* %t234, i8** %t233
  %t235 = ptrtoint %TokenKind* %t230 to i64
  %t236 = load i64, i64* %t0
  %t237 = inttoptr i64 %t236 to %Lexer*
  %t238 = getelementptr %Lexer, %Lexer* %t237, i32 0, i32 3
  %t239 = load i64, i64* %t238
  %t240 = load i64, i64* %t0
  %t241 = inttoptr i64 %t240 to %Lexer*
  %t242 = getelementptr %Lexer, %Lexer* %t241, i32 0, i32 4
  %t243 = load i64, i64* %t242
  %t244 = getelementptr [5 x i8], [5 x i8]* @.str.286, i64 0, i64 0
  %t245 = ptrtoint i8* %t244 to i64
  %t246 = call i64 @Token_new(i64 %t235, i64 %t239, i64 %t243, i64 %t245)
  %t247 = call i64 @kore_array_push(i64 %t228, i64 %t246)
  br label %endif239
  else238:
  %t248 = load i64, i64* %t60
  %t249 = load i64, i64* %t197
  %t251 = icmp slt i64 %t248, %t249
  %t250 = zext i1 %t251 to i64
  %t252 = icmp ne i64 %t250, 0
  br i1 %t252, label %then240, label %endif242
  then240:
  br label %while_cond243
  while_cond243:
  %t253 = load i64, i64* %t0
  %t254 = inttoptr i64 %t253 to %Lexer*
  %t255 = getelementptr %Lexer, %Lexer* %t254, i32 0, i32 5
  %t256 = load i64, i64* %t255
  %t257 = call i64 @kore_array_len(i64 %t256)
  %t259 = icmp sgt i64 %t257, 0
  %t258 = zext i1 %t259 to i64
  %t260 = icmp ne i64 %t258, 0
  br i1 %t260, label %while_body244, label %while_end245
  while_body244:
  %t261 = load i64, i64* %t0
  %t262 = inttoptr i64 %t261 to %Lexer*
  %t263 = getelementptr %Lexer, %Lexer* %t262, i32 0, i32 5
  %t264 = load i64, i64* %t263
  %t265 = load i64, i64* %t0
  %t266 = inttoptr i64 %t265 to %Lexer*
  %t267 = getelementptr %Lexer, %Lexer* %t266, i32 0, i32 5
  %t268 = load i64, i64* %t267
  %t269 = call i64 @kore_array_len(i64 %t268)
  %t270 = sub i64 %t269, 1
  %t271 = call i64 @kore_array_get(i64 %t264, i64 %t270)
  %t272 = alloca i64
  store i64 %t271, i64* %t272
  %t273 = load i64, i64* %t272
  %t274 = load i64, i64* %t60
  %t276 = icmp sle i64 %t273, %t274
  %t275 = zext i1 %t276 to i64
  %t277 = icmp ne i64 %t275, 0
  br i1 %t277, label %then246, label %endif248
  then246:
  br label %while_end245
  endif248:
  %t278 = load i64, i64* %t0
  %t279 = inttoptr i64 %t278 to %Lexer*
  %t280 = getelementptr %Lexer, %Lexer* %t279, i32 0, i32 5
  %t281 = load i64, i64* %t280
  %t282 = call i64 @kore_array_pop(i64 %t281)
  %t283 = load i64, i64* %t2
  ; enum variant: TokenKind::Dedent
  %t284 = call i8* @malloc(i64 24)
  %t285 = bitcast i8* %t284 to %TokenKind*
  %t286 = getelementptr %TokenKind, %TokenKind* %t285, i32 0, i32 0
  store i64 41, i64* %t286
  %t287 = getelementptr %TokenKind, %TokenKind* %t285, i32 0, i32 1
  store i8* null, i8** %t287
  %t288 = getelementptr %TokenKind, %TokenKind* %t285, i32 0, i32 2
  %t289 = getelementptr [7 x i8], [7 x i8]* @.str.287, i64 0, i64 0
  store i8* %t289, i8** %t288
  %t290 = ptrtoint %TokenKind* %t285 to i64
  %t291 = load i64, i64* %t0
  %t292 = inttoptr i64 %t291 to %Lexer*
  %t293 = getelementptr %Lexer, %Lexer* %t292, i32 0, i32 3
  %t294 = load i64, i64* %t293
  %t295 = load i64, i64* %t0
  %t296 = inttoptr i64 %t295 to %Lexer*
  %t297 = getelementptr %Lexer, %Lexer* %t296, i32 0, i32 4
  %t298 = load i64, i64* %t297
  %t299 = getelementptr [7 x i8], [7 x i8]* @.str.288, i64 0, i64 0
  %t300 = ptrtoint i8* %t299 to i64
  %t301 = call i64 @Token_new(i64 %t290, i64 %t294, i64 %t298, i64 %t300)
  %t302 = call i64 @kore_array_push(i64 %t283, i64 %t301)
  br label %while_cond243
  while_end245:
  br label %endif242
  endif242:
  br label %endif239
  endif239:
  store i64 0, i64* %t3
  br label %endif233
  endif233:
  %t303 = load i64, i64* %t0
  %t304 = call i64 @Lexer_next_token(i64 %t303)
  %t305 = alloca i64
  store i64 %t304, i64* %t305
  %t306 = load i64, i64* %t2
  %t307 = load i64, i64* %t305
  %t308 = call i64 @kore_array_push(i64 %t306, i64 %t307)
  br label %loop184
  loop_end185:
  %t309 = load i64, i64* %t2
  ret i64 %t309
}

; impl Parser
define i64 @Parser_new(i64 %tokens) {
  entry:
  %t0 = alloca i64
  store i64 %tokens, i64* %t0
  ; struct literal: Parser
  %t1 = call i8* @malloc(i64 16)
  %t2 = bitcast i8* %t1 to %Parser*
  %t3 = load i64, i64* %t0
  %t4 = getelementptr %Parser, %Parser* %t2, i32 0, i32 0
  store i64 %t3, i64* %t4
  %t5 = getelementptr %Parser, %Parser* %t2, i32 0, i32 1
  store i64 0, i64* %t5
  %t6 = ptrtoint %Parser* %t2 to i64
  ret i64 %t6
}
define i64 @Parser_is_eof(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %Parser*
  %t3 = getelementptr %Parser, %Parser* %t2, i32 0, i32 1
  %t4 = load i64, i64* %t3
  %t5 = load i64, i64* %t0
  %t6 = inttoptr i64 %t5 to %Parser*
  %t7 = getelementptr %Parser, %Parser* %t6, i32 0, i32 0
  %t8 = load i64, i64* %t7
  %t9 = call i64 @kore_array_len(i64 %t8)
  %t11 = icmp sge i64 %t4, %t9
  %t10 = zext i1 %t11 to i64
  %t12 = icmp ne i64 %t10, 0
  br i1 %t12, label %then249, label %endif251
  then249:
  ret i64 1
  endif251:
  %t13 = load i64, i64* %t0
  %t14 = inttoptr i64 %t13 to %Parser*
  %t15 = getelementptr %Parser, %Parser* %t14, i32 0, i32 0
  %t16 = load i64, i64* %t15
  %t17 = load i64, i64* %t0
  %t18 = inttoptr i64 %t17 to %Parser*
  %t19 = getelementptr %Parser, %Parser* %t18, i32 0, i32 1
  %t20 = load i64, i64* %t19
  %t21 = call i64 @kore_array_get(i64 %t16, i64 %t20)
  %t22 = alloca i64
  store i64 %t21, i64* %t22
  %t23 = load i64, i64* %t22
  %t24 = inttoptr i64 %t23 to %Token*
  %t25 = getelementptr %Token, %Token* %t24, i32 0, i32 3
  %t26 = load i64, i64* %t25
  %t27 = getelementptr [1 x i8], [1 x i8]* @.str.289, i64 0, i64 0
  %t28 = ptrtoint i8* %t27 to i64
  %t29 = call i64 @kore_str_eq(i64 %t26, i64 %t28)
  %t30 = load i64, i64* %t22
  %t31 = call i64 @Token_is_dedent(i64 %t30)
  %t33 = icmp eq i64 %t31, 0
  %t32 = zext i1 %t33 to i64
  %t34 = and i64 %t29, %t32
  %t35 = load i64, i64* %t22
  %t36 = call i64 @Token_is_indent(i64 %t35)
  %t38 = icmp eq i64 %t36, 0
  %t37 = zext i1 %t38 to i64
  %t39 = and i64 %t34, %t37
  ret i64 %t39
}
define i64 @Parser_peek(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_is_eof(i64 %t1)
  %t3 = icmp ne i64 %t2, 0
  br i1 %t3, label %then252, label %endif254
  then252:
  ; enum variant: TokenKind::Eof
  %t4 = call i8* @malloc(i64 24)
  %t5 = bitcast i8* %t4 to %TokenKind*
  %t6 = getelementptr %TokenKind, %TokenKind* %t5, i32 0, i32 0
  store i64 42, i64* %t6
  %t7 = getelementptr %TokenKind, %TokenKind* %t5, i32 0, i32 1
  store i8* null, i8** %t7
  %t8 = getelementptr %TokenKind, %TokenKind* %t5, i32 0, i32 2
  %t9 = getelementptr [4 x i8], [4 x i8]* @.str.290, i64 0, i64 0
  store i8* %t9, i8** %t8
  %t10 = ptrtoint %TokenKind* %t5 to i64
  %t11 = getelementptr [1 x i8], [1 x i8]* @.str.291, i64 0, i64 0
  %t12 = ptrtoint i8* %t11 to i64
  %t13 = call i64 @Token_new(i64 %t10, i64 0, i64 0, i64 %t12)
  ret i64 %t13
  endif254:
  %t14 = load i64, i64* %t0
  %t15 = inttoptr i64 %t14 to %Parser*
  %t16 = getelementptr %Parser, %Parser* %t15, i32 0, i32 0
  %t17 = load i64, i64* %t16
  %t18 = load i64, i64* %t0
  %t19 = inttoptr i64 %t18 to %Parser*
  %t20 = getelementptr %Parser, %Parser* %t19, i32 0, i32 1
  %t21 = load i64, i64* %t20
  %t22 = call i64 @kore_array_get(i64 %t17, i64 %t21)
  %t23 = alloca i64
  store i64 %t22, i64* %t23
  %t24 = load i64, i64* %t23
  ret i64 %t24
}
define i64 @Parser_advance(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_peek(i64 %t1)
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  %t4 = load i64, i64* %t0
  %t5 = inttoptr i64 %t4 to %Parser*
  %t6 = getelementptr %Parser, %Parser* %t5, i32 0, i32 1
  %t7 = load i64, i64* %t6
  %t8 = add i64 %t7, 1
  %t9 = load i64, i64* %t0
  %t10 = inttoptr i64 %t9 to %Parser*
  %t11 = getelementptr %Parser, %Parser* %t10, i32 0, i32 1
  store i64 %t8, i64* %t11
  %t12 = load i64, i64* %t3
  ret i64 %t12
}
define i64 @Parser_expect_keyword(i64 %self, i64 %kw) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %kw, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = call i64 @Parser_advance(i64 %t2)
  %t4 = alloca i64
  store i64 %t3, i64* %t4
  %t5 = load i64, i64* %t4
  %t6 = load i64, i64* %t1
  %t7 = call i64 @Token_is_keyword(i64 %t5, i64 %t6)
  %t9 = icmp eq i64 %t7, 0
  %t8 = zext i1 %t9 to i64
  %t10 = icmp ne i64 %t8, 0
  br i1 %t10, label %then255, label %endif257
  then255:
  %t11 = getelementptr [18 x i8], [18 x i8]* @.str.292, i64 0, i64 0
  %t12 = ptrtoint i8* %t11 to i64
  %t13 = load i64, i64* %t1
  %t14 = call i64 @kore_str_concat(i64 %t12, i64 %t13)
  %t15 = getelementptr [8 x i8], [8 x i8]* @.str.293, i64 0, i64 0
  %t16 = ptrtoint i8* %t15 to i64
  %t17 = call i64 @kore_str_concat(i64 %t14, i64 %t16)
  %t18 = load i64, i64* %t4
  %t19 = inttoptr i64 %t18 to %Token*
  %t20 = getelementptr %Token, %Token* %t19, i32 0, i32 3
  %t21 = load i64, i64* %t20
  %t22 = call i64 @kore_str_concat(i64 %t17, i64 %t21)
  %t23 = call i64 @kore_panic(i64 %t22)
  br label %endif257
  endif257:
  %t24 = load i64, i64* %t4
  ret i64 %t24
}
define i64 @Parser_expect(i64 %self, i64 %kind_name) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %kind_name, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = call i64 @Parser_advance(i64 %t2)
  %t4 = alloca i64
  store i64 %t3, i64* %t4
  %t5 = load i64, i64* %t4
  ret i64 %t5
}
define i64 @Parser_skip_newlines(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  br label %while_cond258
  while_cond258:
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_is_eof(i64 %t1)
  %t4 = icmp eq i64 %t2, 0
  %t3 = zext i1 %t4 to i64
  %t5 = icmp ne i64 %t3, 0
  br i1 %t5, label %while_body259, label %while_end260
  while_body259:
  %t6 = load i64, i64* %t0
  %t7 = inttoptr i64 %t6 to %Parser*
  %t8 = getelementptr %Parser, %Parser* %t7, i32 0, i32 0
  %t9 = load i64, i64* %t8
  %t10 = load i64, i64* %t0
  %t11 = inttoptr i64 %t10 to %Parser*
  %t12 = getelementptr %Parser, %Parser* %t11, i32 0, i32 1
  %t13 = load i64, i64* %t12
  %t14 = call i64 @kore_array_get(i64 %t9, i64 %t13)
  %t15 = alloca i64
  store i64 %t14, i64* %t15
  %t16 = load i64, i64* %t15
  %t17 = call i64 @Token_is_newline(i64 %t16)
  %t18 = load i64, i64* %t15
  %t19 = call i64 @Token_is_dedent(i64 %t18)
  %t20 = or i64 %t17, %t19
  %t21 = icmp ne i64 %t20, 0
  br i1 %t21, label %then261, label %else262
  then261:
  %t22 = load i64, i64* %t0
  %t23 = call i64 @Parser_advance(i64 %t22)
  br label %endif263
  else262:
  br label %while_end260
  endif263:
  br label %while_cond258
  while_end260:
  ret i64 0
}
define i64 @Parser_parse_program(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = call i64 @kore_array_new()
  %t2 = alloca i64
  store i64 %t1, i64* %t2
  %t3 = load i64, i64* %t0
  %t4 = call i64 @Parser_skip_newlines(i64 %t3)
  br label %while_cond264
  while_cond264:
  %t5 = load i64, i64* %t0
  %t6 = call i64 @Parser_is_eof(i64 %t5)
  %t8 = icmp eq i64 %t6, 0
  %t7 = zext i1 %t8 to i64
  %t9 = icmp ne i64 %t7, 0
  br i1 %t9, label %while_body265, label %while_end266
  while_body265:
  br label %while_cond267
  while_cond267:
  %t10 = icmp ne i64 1, 0
  br i1 %t10, label %while_body268, label %while_end269
  while_body268:
  %t11 = load i64, i64* %t0
  %t12 = call i64 @Parser_is_eof(i64 %t11)
  %t13 = icmp ne i64 %t12, 0
  br i1 %t13, label %then270, label %endif272
  then270:
  br label %while_end269
  endif272:
  %t14 = load i64, i64* %t0
  %t15 = inttoptr i64 %t14 to %Parser*
  %t16 = getelementptr %Parser, %Parser* %t15, i32 0, i32 0
  %t17 = load i64, i64* %t16
  %t18 = load i64, i64* %t0
  %t19 = inttoptr i64 %t18 to %Parser*
  %t20 = getelementptr %Parser, %Parser* %t19, i32 0, i32 1
  %t21 = load i64, i64* %t20
  %t22 = call i64 @kore_array_get(i64 %t17, i64 %t21)
  %t23 = alloca i64
  store i64 %t22, i64* %t23
  %t24 = load i64, i64* %t23
  %t25 = call i64 @Token_is_indent(i64 %t24)
  %t26 = load i64, i64* %t23
  %t27 = call i64 @Token_is_dedent(i64 %t26)
  %t28 = or i64 %t25, %t27
  %t29 = icmp ne i64 %t28, 0
  br i1 %t29, label %then273, label %else274
  then273:
  %t30 = load i64, i64* %t0
  %t31 = call i64 @Parser_advance(i64 %t30)
  %t32 = load i64, i64* %t0
  %t33 = call i64 @Parser_skip_newlines(i64 %t32)
  br label %endif275
  else274:
  br label %while_end269
  endif275:
  br label %while_cond267
  while_end269:
  %t34 = load i64, i64* %t0
  %t35 = call i64 @Parser_is_eof(i64 %t34)
  %t36 = icmp ne i64 %t35, 0
  br i1 %t36, label %then276, label %endif278
  then276:
  br label %while_end266
  endif278:
  %t37 = load i64, i64* %t0
  %t38 = call i64 @Parser_parse_item(i64 %t37)
  %t39 = alloca i64
  store i64 %t38, i64* %t39
  %t40 = load i64, i64* %t2
  %t41 = load i64, i64* %t39
  %t42 = call i64 @kore_array_push(i64 %t40, i64 %t41)
  %t43 = load i64, i64* %t0
  %t44 = call i64 @Parser_skip_newlines(i64 %t43)
  br label %while_cond264
  while_end266:
  ; struct literal: Program
  %t45 = call i8* @malloc(i64 8)
  %t46 = bitcast i8* %t45 to %Program*
  %t47 = load i64, i64* %t2
  %t48 = getelementptr %Program, %Program* %t46, i32 0, i32 0
  store i64 %t47, i64* %t48
  %t49 = ptrtoint %Program* %t46 to i64
  ret i64 %t49
}
define i64 @Parser_parse_item(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_peek(i64 %t1)
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  %t4 = load i64, i64* %t3
  %t5 = getelementptr [3 x i8], [3 x i8]* @.str.294, i64 0, i64 0
  %t6 = ptrtoint i8* %t5 to i64
  %t7 = call i64 @Token_is_keyword(i64 %t4, i64 %t6)
  %t8 = icmp ne i64 %t7, 0
  br i1 %t8, label %then279, label %else280
  then279:
  ; enum variant: Item::Function
  %t9 = call i8* @malloc(i64 24)
  %t10 = bitcast i8* %t9 to %Item*
  %t11 = getelementptr %Item, %Item* %t10, i32 0, i32 0
  store i64 0, i64* %t11
  %t12 = call i8* @malloc(i64 8)
  %t13 = bitcast i8* %t12 to i64*
  %t14 = load i64, i64* %t0
  %t15 = call i64 @Parser_parse_fn_def(i64 %t14, i64 0, i64 0)
  %t16 = getelementptr i64, i64* %t13, i32 0
  store i64 %t15, i64* %t16
  %t17 = getelementptr %Item, %Item* %t10, i32 0, i32 1
  store i8* %t12, i8** %t17
  %t18 = getelementptr %Item, %Item* %t10, i32 0, i32 2
  %t19 = getelementptr [9 x i8], [9 x i8]* @.str.295, i64 0, i64 0
  store i8* %t19, i8** %t18
  %t20 = ptrtoint %Item* %t10 to i64
  ret i64 %t20
  else280:
  %t21 = load i64, i64* %t3
  %t22 = getelementptr [4 x i8], [4 x i8]* @.str.296, i64 0, i64 0
  %t23 = ptrtoint i8* %t22 to i64
  %t24 = call i64 @Token_is_keyword(i64 %t21, i64 %t23)
  %t25 = icmp ne i64 %t24, 0
  br i1 %t25, label %then282, label %else283
  then282:
  %t26 = load i64, i64* %t0
  %t27 = call i64 @Parser_advance(i64 %t26)
  %t28 = load i64, i64* %t0
  %t29 = call i64 @Parser_peek(i64 %t28)
  %t30 = alloca i64
  store i64 %t29, i64* %t30
  %t31 = load i64, i64* %t30
  %t32 = getelementptr [3 x i8], [3 x i8]* @.str.297, i64 0, i64 0
  %t33 = ptrtoint i8* %t32 to i64
  %t34 = call i64 @Token_is_keyword(i64 %t31, i64 %t33)
  %t35 = icmp ne i64 %t34, 0
  br i1 %t35, label %then285, label %else286
  then285:
  ; enum variant: Item::Function
  %t36 = call i8* @malloc(i64 24)
  %t37 = bitcast i8* %t36 to %Item*
  %t38 = getelementptr %Item, %Item* %t37, i32 0, i32 0
  store i64 0, i64* %t38
  %t39 = call i8* @malloc(i64 8)
  %t40 = bitcast i8* %t39 to i64*
  %t41 = load i64, i64* %t0
  %t42 = call i64 @Parser_parse_fn_def(i64 %t41, i64 1, i64 0)
  %t43 = getelementptr i64, i64* %t40, i32 0
  store i64 %t42, i64* %t43
  %t44 = getelementptr %Item, %Item* %t37, i32 0, i32 1
  store i8* %t39, i8** %t44
  %t45 = getelementptr %Item, %Item* %t37, i32 0, i32 2
  %t46 = getelementptr [9 x i8], [9 x i8]* @.str.298, i64 0, i64 0
  store i8* %t46, i8** %t45
  %t47 = ptrtoint %Item* %t37 to i64
  ret i64 %t47
  else286:
  %t48 = load i64, i64* %t30
  %t49 = getelementptr [7 x i8], [7 x i8]* @.str.299, i64 0, i64 0
  %t50 = ptrtoint i8* %t49 to i64
  %t51 = call i64 @Token_is_keyword(i64 %t48, i64 %t50)
  %t52 = icmp ne i64 %t51, 0
  br i1 %t52, label %then288, label %else289
  then288:
  ; enum variant: Item::Struct
  %t53 = call i8* @malloc(i64 24)
  %t54 = bitcast i8* %t53 to %Item*
  %t55 = getelementptr %Item, %Item* %t54, i32 0, i32 0
  store i64 1, i64* %t55
  %t56 = call i8* @malloc(i64 8)
  %t57 = bitcast i8* %t56 to i64*
  %t58 = load i64, i64* %t0
  %t59 = call i64 @Parser_parse_struct_def(i64 %t58, i64 1)
  %t60 = getelementptr i64, i64* %t57, i32 0
  store i64 %t59, i64* %t60
  %t61 = getelementptr %Item, %Item* %t54, i32 0, i32 1
  store i8* %t56, i8** %t61
  %t62 = getelementptr %Item, %Item* %t54, i32 0, i32 2
  %t63 = getelementptr [7 x i8], [7 x i8]* @.str.300, i64 0, i64 0
  store i8* %t63, i8** %t62
  %t64 = ptrtoint %Item* %t54 to i64
  ret i64 %t64
  else289:
  %t65 = getelementptr [32 x i8], [32 x i8]* @.str.301, i64 0, i64 0
  %t66 = ptrtoint i8* %t65 to i64
  %t67 = call i64 @kore_panic(i64 %t66)
  br label %endif290
  endif290:
  br label %endif287
  endif287:
  br label %endif284
  else283:
  %t68 = load i64, i64* %t3
  %t69 = getelementptr [6 x i8], [6 x i8]* @.str.302, i64 0, i64 0
  %t70 = ptrtoint i8* %t69 to i64
  %t71 = call i64 @Token_is_keyword(i64 %t68, i64 %t70)
  %t72 = icmp ne i64 %t71, 0
  br i1 %t72, label %then291, label %else292
  then291:
  %t73 = load i64, i64* %t0
  %t74 = call i64 @Parser_advance(i64 %t73)
  %t75 = load i64, i64* %t0
  %t76 = getelementptr [3 x i8], [3 x i8]* @.str.303, i64 0, i64 0
  %t77 = ptrtoint i8* %t76 to i64
  %t78 = call i64 @Parser_expect_keyword(i64 %t75, i64 %t77)
  ; enum variant: Item::Function
  %t79 = call i8* @malloc(i64 24)
  %t80 = bitcast i8* %t79 to %Item*
  %t81 = getelementptr %Item, %Item* %t80, i32 0, i32 0
  store i64 0, i64* %t81
  %t82 = call i8* @malloc(i64 8)
  %t83 = bitcast i8* %t82 to i64*
  %t84 = load i64, i64* %t0
  %t85 = call i64 @Parser_parse_fn_def(i64 %t84, i64 0, i64 1)
  %t86 = getelementptr i64, i64* %t83, i32 0
  store i64 %t85, i64* %t86
  %t87 = getelementptr %Item, %Item* %t80, i32 0, i32 1
  store i8* %t82, i8** %t87
  %t88 = getelementptr %Item, %Item* %t80, i32 0, i32 2
  %t89 = getelementptr [9 x i8], [9 x i8]* @.str.304, i64 0, i64 0
  store i8* %t89, i8** %t88
  %t90 = ptrtoint %Item* %t80 to i64
  ret i64 %t90
  else292:
  %t91 = load i64, i64* %t3
  %t92 = getelementptr [7 x i8], [7 x i8]* @.str.305, i64 0, i64 0
  %t93 = ptrtoint i8* %t92 to i64
  %t94 = call i64 @Token_is_keyword(i64 %t91, i64 %t93)
  %t95 = icmp ne i64 %t94, 0
  br i1 %t95, label %then294, label %else295
  then294:
  ; enum variant: Item::Struct
  %t96 = call i8* @malloc(i64 24)
  %t97 = bitcast i8* %t96 to %Item*
  %t98 = getelementptr %Item, %Item* %t97, i32 0, i32 0
  store i64 1, i64* %t98
  %t99 = call i8* @malloc(i64 8)
  %t100 = bitcast i8* %t99 to i64*
  %t101 = load i64, i64* %t0
  %t102 = call i64 @Parser_parse_struct_def(i64 %t101, i64 0)
  %t103 = getelementptr i64, i64* %t100, i32 0
  store i64 %t102, i64* %t103
  %t104 = getelementptr %Item, %Item* %t97, i32 0, i32 1
  store i8* %t99, i8** %t104
  %t105 = getelementptr %Item, %Item* %t97, i32 0, i32 2
  %t106 = getelementptr [7 x i8], [7 x i8]* @.str.306, i64 0, i64 0
  store i8* %t106, i8** %t105
  %t107 = ptrtoint %Item* %t97 to i64
  ret i64 %t107
  else295:
  %t108 = load i64, i64* %t3
  %t109 = getelementptr [5 x i8], [5 x i8]* @.str.307, i64 0, i64 0
  %t110 = ptrtoint i8* %t109 to i64
  %t111 = call i64 @Token_is_keyword(i64 %t108, i64 %t110)
  %t112 = icmp ne i64 %t111, 0
  br i1 %t112, label %then297, label %else298
  then297:
  ; enum variant: Item::Enum
  %t113 = call i8* @malloc(i64 24)
  %t114 = bitcast i8* %t113 to %Item*
  %t115 = getelementptr %Item, %Item* %t114, i32 0, i32 0
  store i64 2, i64* %t115
  %t116 = call i8* @malloc(i64 8)
  %t117 = bitcast i8* %t116 to i64*
  %t118 = load i64, i64* %t0
  %t119 = call i64 @Parser_parse_enum_def(i64 %t118)
  %t120 = getelementptr i64, i64* %t117, i32 0
  store i64 %t119, i64* %t120
  %t121 = getelementptr %Item, %Item* %t114, i32 0, i32 1
  store i8* %t116, i8** %t121
  %t122 = getelementptr %Item, %Item* %t114, i32 0, i32 2
  %t123 = getelementptr [5 x i8], [5 x i8]* @.str.308, i64 0, i64 0
  store i8* %t123, i8** %t122
  %t124 = ptrtoint %Item* %t114 to i64
  ret i64 %t124
  else298:
  %t125 = load i64, i64* %t3
  %t126 = getelementptr [5 x i8], [5 x i8]* @.str.309, i64 0, i64 0
  %t127 = ptrtoint i8* %t126 to i64
  %t128 = call i64 @Token_is_keyword(i64 %t125, i64 %t127)
  %t129 = icmp ne i64 %t128, 0
  br i1 %t129, label %then300, label %else301
  then300:
  ; enum variant: Item::Impl
  %t130 = call i8* @malloc(i64 24)
  %t131 = bitcast i8* %t130 to %Item*
  %t132 = getelementptr %Item, %Item* %t131, i32 0, i32 0
  store i64 3, i64* %t132
  %t133 = call i8* @malloc(i64 8)
  %t134 = bitcast i8* %t133 to i64*
  %t135 = load i64, i64* %t0
  %t136 = call i64 @Parser_parse_impl_def(i64 %t135)
  %t137 = getelementptr i64, i64* %t134, i32 0
  store i64 %t136, i64* %t137
  %t138 = getelementptr %Item, %Item* %t131, i32 0, i32 1
  store i8* %t133, i8** %t138
  %t139 = getelementptr %Item, %Item* %t131, i32 0, i32 2
  %t140 = getelementptr [5 x i8], [5 x i8]* @.str.310, i64 0, i64 0
  store i8* %t140, i8** %t139
  %t141 = ptrtoint %Item* %t131 to i64
  ret i64 %t141
  else301:
  %t142 = load i64, i64* %t3
  %t143 = getelementptr [4 x i8], [4 x i8]* @.str.311, i64 0, i64 0
  %t144 = ptrtoint i8* %t143 to i64
  %t145 = call i64 @Token_is_keyword(i64 %t142, i64 %t144)
  %t146 = icmp ne i64 %t145, 0
  br i1 %t146, label %then303, label %else304
  then303:
  ; enum variant: Item::Use
  %t147 = call i8* @malloc(i64 24)
  %t148 = bitcast i8* %t147 to %Item*
  %t149 = getelementptr %Item, %Item* %t148, i32 0, i32 0
  store i64 4, i64* %t149
  %t150 = call i8* @malloc(i64 8)
  %t151 = bitcast i8* %t150 to i64*
  %t152 = load i64, i64* %t0
  %t153 = call i64 @Parser_parse_use(i64 %t152)
  %t154 = getelementptr i64, i64* %t151, i32 0
  store i64 %t153, i64* %t154
  %t155 = getelementptr %Item, %Item* %t148, i32 0, i32 1
  store i8* %t150, i8** %t155
  %t156 = getelementptr %Item, %Item* %t148, i32 0, i32 2
  %t157 = getelementptr [4 x i8], [4 x i8]* @.str.312, i64 0, i64 0
  store i8* %t157, i8** %t156
  %t158 = ptrtoint %Item* %t148 to i64
  ret i64 %t158
  else304:
  %t159 = getelementptr [8 x i8], [8 x i8]* @.str.313, i64 0, i64 0
  %t160 = ptrtoint i8* %t159 to i64
  %t161 = alloca i64
  store i64 %t160, i64* %t161
  ; match
  %t162 = load i64, i64* %t3
  %t163 = inttoptr i64 %t162 to %Token*
  %t164 = getelementptr %Token, %Token* %t163, i32 0, i32 0
  %t165 = load i64, i64* %t164
  %t166 = inttoptr i64 %t165 to { i64, i8* }*
  %t167 = getelementptr { i64, i8* }, { i64, i8* }* %t166, i32 0, i32 0
  %t168 = load i64, i64* %t167
  %t169 = icmp eq i64 %t168, 0
  br i1 %t169, label %match_body308, label %match_next307
  match_body308:
  %t170 = getelementptr { i64, i8* }, { i64, i8* }* %t166, i32 0, i32 1
  %t171 = load i8*, i8** %t170
  %t172 = ptrtoint i8* %t171 to i64
  %t173 = inttoptr i64 %t172 to i64*
  %t174 = getelementptr [4 x i8], [4 x i8]* @.str.314, i64 0, i64 0
  %t175 = ptrtoint i8* %t174 to i64
  store i64 %t175, i64* %t161
  br label %match_end306
  match_next307:
  %t176 = inttoptr i64 %t165 to { i64, i8* }*
  %t177 = getelementptr { i64, i8* }, { i64, i8* }* %t176, i32 0, i32 0
  %t178 = load i64, i64* %t177
  %t179 = icmp eq i64 %t178, 2
  br i1 %t179, label %match_body310, label %match_next309
  match_body310:
  %t180 = getelementptr { i64, i8* }, { i64, i8* }* %t176, i32 0, i32 1
  %t181 = load i8*, i8** %t180
  %t182 = ptrtoint i8* %t181 to i64
  %t183 = inttoptr i64 %t182 to i64*
  %t184 = getelementptr [7 x i8], [7 x i8]* @.str.315, i64 0, i64 0
  %t185 = ptrtoint i8* %t184 to i64
  store i64 %t185, i64* %t161
  br label %match_end306
  match_next309:
  %t186 = inttoptr i64 %t165 to { i64, i8* }*
  %t187 = getelementptr { i64, i8* }, { i64, i8* }* %t186, i32 0, i32 0
  %t188 = load i64, i64* %t187
  %t189 = icmp eq i64 %t188, 4
  br i1 %t189, label %match_body312, label %match_next311
  match_body312:
  %t190 = getelementptr { i64, i8* }, { i64, i8* }* %t186, i32 0, i32 1
  %t191 = load i8*, i8** %t190
  %t192 = ptrtoint i8* %t191 to i64
  %t193 = inttoptr i64 %t192 to i64*
  %t194 = getelementptr [6 x i8], [6 x i8]* @.str.316, i64 0, i64 0
  %t195 = ptrtoint i8* %t194 to i64
  store i64 %t195, i64* %t161
  br label %match_end306
  match_next311:
  %t196 = inttoptr i64 %t165 to { i64, i8* }*
  %t197 = getelementptr { i64, i8* }, { i64, i8* }* %t196, i32 0, i32 0
  %t198 = load i64, i64* %t197
  %t199 = icmp eq i64 %t198, 5
  br i1 %t199, label %match_body314, label %match_next313
  match_body314:
  %t200 = getelementptr { i64, i8* }, { i64, i8* }* %t196, i32 0, i32 1
  %t201 = load i8*, i8** %t200
  %t202 = ptrtoint i8* %t201 to i64
  %t203 = inttoptr i64 %t202 to i64*
  %t204 = getelementptr [8 x i8], [8 x i8]* @.str.317, i64 0, i64 0
  %t205 = ptrtoint i8* %t204 to i64
  store i64 %t205, i64* %t161
  br label %match_end306
  match_next313:
  %t206 = inttoptr i64 %t165 to { i64, i8* }*
  %t207 = getelementptr { i64, i8* }, { i64, i8* }* %t206, i32 0, i32 0
  %t208 = load i64, i64* %t207
  %t209 = icmp eq i64 %t208, 43
  br i1 %t209, label %match_body316, label %match_next315
  match_body316:
  %t210 = getelementptr { i64, i8* }, { i64, i8* }* %t206, i32 0, i32 1
  %t211 = load i8*, i8** %t210
  %t212 = ptrtoint i8* %t211 to i64
  %t213 = inttoptr i64 %t212 to i64*
  %t214 = getelementptr i64, i64* %t213, i32 0
  %t215 = load i64, i64* %t214
  %t216 = alloca i64
  store i64 %t215, i64* %t216
  %t217 = getelementptr [7 x i8], [7 x i8]* @.str.318, i64 0, i64 0
  %t218 = ptrtoint i8* %t217 to i64
  %t219 = load i64, i64* %t216
  %t220 = call i64 @kore_str_concat(i64 %t218, i64 %t219)
  %t221 = getelementptr [2 x i8], [2 x i8]* @.str.319, i64 0, i64 0
  %t222 = ptrtoint i8* %t221 to i64
  %t223 = call i64 @kore_str_concat(i64 %t220, i64 %t222)
  store i64 %t223, i64* %t161
  br label %match_end306
  match_next315:
  br label %match_body318
  match_body318:
  %t224 = getelementptr [6 x i8], [6 x i8]* @.str.320, i64 0, i64 0
  %t225 = ptrtoint i8* %t224 to i64
  store i64 %t225, i64* %t161
  br label %match_end306
  match_next317:
  br label %match_end306
  match_end306:
  %t226 = getelementptr [33 x i8], [33 x i8]* @.str.321, i64 0, i64 0
  %t227 = ptrtoint i8* %t226 to i64
  %t228 = load i64, i64* %t3
  %t229 = inttoptr i64 %t228 to %Token*
  %t230 = getelementptr %Token, %Token* %t229, i32 0, i32 3
  %t231 = load i64, i64* %t230
  %t232 = call i64 @kore_str_concat(i64 %t227, i64 %t231)
  %t233 = getelementptr [9 x i8], [9 x i8]* @.str.322, i64 0, i64 0
  %t234 = ptrtoint i8* %t233 to i64
  %t235 = call i64 @kore_str_concat(i64 %t232, i64 %t234)
  %t236 = load i64, i64* %t161
  %t237 = call i64 @kore_str_concat(i64 %t235, i64 %t236)
  %t238 = call i64 @kore_panic(i64 %t237)
  br label %endif305
  endif305:
  br label %endif302
  endif302:
  br label %endif299
  endif299:
  br label %endif296
  endif296:
  br label %endif293
  endif293:
  br label %endif284
  endif284:
  br label %endif281
  endif281:
  ret i64 0
}
define i64 @Parser_parse_fn_def(i64 %self, i64 %is_pub, i64 %is_async) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %is_pub, i64* %t1
  %t2 = alloca i64
  store i64 %is_async, i64* %t2
  %t3 = load i64, i64* %t0
  %t4 = getelementptr [3 x i8], [3 x i8]* @.str.323, i64 0, i64 0
  %t5 = ptrtoint i8* %t4 to i64
  %t6 = call i64 @Parser_expect_keyword(i64 %t3, i64 %t5)
  %t7 = load i64, i64* %t0
  %t8 = call i64 @Parser_advance(i64 %t7)
  %t9 = alloca i64
  store i64 %t8, i64* %t9
  %t10 = load i64, i64* %t9
  %t11 = inttoptr i64 %t10 to %Token*
  %t12 = getelementptr %Token, %Token* %t11, i32 0, i32 3
  %t13 = load i64, i64* %t12
  %t14 = alloca i64
  store i64 %t13, i64* %t14
  %t15 = load i64, i64* %t0
  %t16 = getelementptr [2 x i8], [2 x i8]* @.str.324, i64 0, i64 0
  %t17 = ptrtoint i8* %t16 to i64
  %t18 = call i64 @Parser_expect(i64 %t15, i64 %t17)
  %t19 = load i64, i64* %t0
  %t20 = call i64 @Parser_parse_params(i64 %t19)
  %t21 = alloca i64
  store i64 %t20, i64* %t21
  %t22 = load i64, i64* %t0
  %t23 = getelementptr [2 x i8], [2 x i8]* @.str.325, i64 0, i64 0
  %t24 = ptrtoint i8* %t23 to i64
  %t25 = call i64 @Parser_expect(i64 %t22, i64 %t24)
  %t26 = alloca i64
  store i64 0, i64* %t26
  %t27 = load i64, i64* %t0
  %t28 = call i64 @Parser_peek(i64 %t27)
  %t29 = inttoptr i64 %t28 to %Token*
  %t30 = getelementptr %Token, %Token* %t29, i32 0, i32 3
  %t31 = load i64, i64* %t30
  %t32 = getelementptr [3 x i8], [3 x i8]* @.str.326, i64 0, i64 0
  %t33 = ptrtoint i8* %t32 to i64
  %t34 = call i64 @kore_str_eq(i64 %t31, i64 %t33)
  %t35 = icmp ne i64 %t34, 0
  br i1 %t35, label %then319, label %endif321
  then319:
  %t36 = load i64, i64* %t0
  %t37 = call i64 @Parser_advance(i64 %t36)
  %t38 = load i64, i64* %t0
  %t39 = call i64 @Parser_parse_type(i64 %t38)
  %t40 = call i64 @kore_some(i64 %t39)
  store i64 %t40, i64* %t26
  br label %endif321
  endif321:
  %t41 = load i64, i64* %t0
  %t42 = call i64 @Parser_peek(i64 %t41)
  %t43 = getelementptr [5 x i8], [5 x i8]* @.str.327, i64 0, i64 0
  %t44 = ptrtoint i8* %t43 to i64
  %t45 = call i64 @Token_is_keyword(i64 %t42, i64 %t44)
  %t46 = icmp ne i64 %t45, 0
  br i1 %t46, label %then322, label %endif324
  then322:
  %t47 = load i64, i64* %t0
  %t48 = call i64 @Parser_advance(i64 %t47)
  %t49 = load i64, i64* %t0
  %t50 = call i64 @Parser_advance(i64 %t49)
  br label %endif324
  endif324:
  %t51 = load i64, i64* %t0
  %t52 = getelementptr [2 x i8], [2 x i8]* @.str.328, i64 0, i64 0
  %t53 = ptrtoint i8* %t52 to i64
  %t54 = call i64 @Parser_expect(i64 %t51, i64 %t53)
  %t55 = load i64, i64* %t0
  %t56 = call i64 @Parser_skip_newlines(i64 %t55)
  %t57 = load i64, i64* %t0
  %t58 = call i64 @Parser_parse_block(i64 %t57)
  %t59 = alloca i64
  store i64 %t58, i64* %t59
  ; struct literal: FnDef
  %t60 = call i8* @malloc(i64 48)
  %t61 = bitcast i8* %t60 to %FnDef*
  %t62 = load i64, i64* %t14
  %t63 = getelementptr %FnDef, %FnDef* %t61, i32 0, i32 0
  store i64 %t62, i64* %t63
  %t64 = load i64, i64* %t21
  %t65 = getelementptr %FnDef, %FnDef* %t61, i32 0, i32 1
  store i64 %t64, i64* %t65
  %t66 = load i64, i64* %t26
  %t67 = getelementptr %FnDef, %FnDef* %t61, i32 0, i32 2
  store i64 %t66, i64* %t67
  %t68 = load i64, i64* %t59
  %t69 = getelementptr %FnDef, %FnDef* %t61, i32 0, i32 3
  store i64 %t68, i64* %t69
  %t70 = load i64, i64* %t1
  %t71 = getelementptr %FnDef, %FnDef* %t61, i32 0, i32 4
  store i64 %t70, i64* %t71
  %t72 = load i64, i64* %t2
  %t73 = getelementptr %FnDef, %FnDef* %t61, i32 0, i32 5
  store i64 %t72, i64* %t73
  %t74 = ptrtoint %FnDef* %t61 to i64
  ret i64 %t74
}
define i64 @Parser_parse_params(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = call i64 @kore_array_new()
  %t2 = alloca i64
  store i64 %t1, i64* %t2
  br label %while_cond325
  while_cond325:
  %t3 = load i64, i64* %t0
  %t4 = call i64 @Parser_is_eof(i64 %t3)
  %t6 = icmp eq i64 %t4, 0
  %t5 = zext i1 %t6 to i64
  %t7 = icmp ne i64 %t5, 0
  br i1 %t7, label %while_body326, label %while_end327
  while_body326:
  %t8 = load i64, i64* %t0
  %t9 = call i64 @Parser_peek(i64 %t8)
  %t10 = alloca i64
  store i64 %t9, i64* %t10
  %t11 = load i64, i64* %t10
  %t12 = inttoptr i64 %t11 to %Token*
  %t13 = getelementptr %Token, %Token* %t12, i32 0, i32 3
  %t14 = load i64, i64* %t13
  %t15 = getelementptr [2 x i8], [2 x i8]* @.str.329, i64 0, i64 0
  %t16 = ptrtoint i8* %t15 to i64
  %t17 = call i64 @kore_str_eq(i64 %t14, i64 %t16)
  %t18 = icmp ne i64 %t17, 0
  br i1 %t18, label %then328, label %endif330
  then328:
  br label %while_end327
  endif330:
  %t19 = load i64, i64* %t10
  %t20 = getelementptr [5 x i8], [5 x i8]* @.str.330, i64 0, i64 0
  %t21 = ptrtoint i8* %t20 to i64
  %t22 = call i64 @Token_is_keyword(i64 %t19, i64 %t21)
  %t23 = icmp ne i64 %t22, 0
  br i1 %t23, label %then331, label %endif333
  then331:
  %t24 = load i64, i64* %t0
  %t25 = call i64 @Parser_advance(i64 %t24)
  %t26 = load i64, i64* %t2
  ; struct literal: Param
  %t27 = call i8* @malloc(i64 16)
  %t28 = bitcast i8* %t27 to %Param*
  %t29 = getelementptr [5 x i8], [5 x i8]* @.str.331, i64 0, i64 0
  %t30 = ptrtoint i8* %t29 to i64
  %t31 = getelementptr %Param, %Param* %t28, i32 0, i32 0
  store i64 %t30, i64* %t31
  %t32 = getelementptr [5 x i8], [5 x i8]* @.str.332, i64 0, i64 0
  %t33 = ptrtoint i8* %t32 to i64
  %t34 = call i64 @kore_some(i64 %t33)
  %t35 = getelementptr %Param, %Param* %t28, i32 0, i32 1
  store i64 %t34, i64* %t35
  %t36 = ptrtoint %Param* %t28 to i64
  %t37 = call i64 @kore_array_push(i64 %t26, i64 %t36)
  %t38 = load i64, i64* %t0
  %t39 = call i64 @Parser_peek(i64 %t38)
  %t40 = inttoptr i64 %t39 to %Token*
  %t41 = getelementptr %Token, %Token* %t40, i32 0, i32 3
  %t42 = load i64, i64* %t41
  %t43 = getelementptr [2 x i8], [2 x i8]* @.str.333, i64 0, i64 0
  %t44 = ptrtoint i8* %t43 to i64
  %t45 = call i64 @kore_str_eq(i64 %t42, i64 %t44)
  %t46 = icmp ne i64 %t45, 0
  br i1 %t46, label %then334, label %endif336
  then334:
  %t47 = load i64, i64* %t0
  %t48 = call i64 @Parser_advance(i64 %t47)
  br label %endif336
  endif336:
  br label %while_cond325
  endif333:
  %t49 = load i64, i64* %t10
  %t50 = call i64 @Token_is_ident(i64 %t49)
  %t51 = icmp ne i64 %t50, 0
  br i1 %t51, label %then337, label %else338
  then337:
  %t52 = load i64, i64* %t0
  %t53 = call i64 @Parser_advance(i64 %t52)
  %t54 = load i64, i64* %t10
  %t55 = inttoptr i64 %t54 to %Token*
  %t56 = getelementptr %Token, %Token* %t55, i32 0, i32 3
  %t57 = load i64, i64* %t56
  %t58 = alloca i64
  store i64 %t57, i64* %t58
  %t59 = alloca i64
  store i64 0, i64* %t59
  %t60 = load i64, i64* %t0
  %t61 = call i64 @Parser_peek(i64 %t60)
  %t62 = inttoptr i64 %t61 to %Token*
  %t63 = getelementptr %Token, %Token* %t62, i32 0, i32 3
  %t64 = load i64, i64* %t63
  %t65 = getelementptr [2 x i8], [2 x i8]* @.str.334, i64 0, i64 0
  %t66 = ptrtoint i8* %t65 to i64
  %t67 = call i64 @kore_str_eq(i64 %t64, i64 %t66)
  %t68 = icmp ne i64 %t67, 0
  br i1 %t68, label %then340, label %endif342
  then340:
  %t69 = load i64, i64* %t0
  %t70 = call i64 @Parser_advance(i64 %t69)
  %t71 = load i64, i64* %t0
  %t72 = call i64 @Parser_parse_type(i64 %t71)
  %t73 = call i64 @kore_some(i64 %t72)
  store i64 %t73, i64* %t59
  br label %endif342
  endif342:
  %t74 = load i64, i64* %t2
  ; struct literal: Param
  %t75 = call i8* @malloc(i64 16)
  %t76 = bitcast i8* %t75 to %Param*
  %t77 = load i64, i64* %t58
  %t78 = getelementptr %Param, %Param* %t76, i32 0, i32 0
  store i64 %t77, i64* %t78
  %t79 = load i64, i64* %t59
  %t80 = getelementptr %Param, %Param* %t76, i32 0, i32 1
  store i64 %t79, i64* %t80
  %t81 = ptrtoint %Param* %t76 to i64
  %t82 = call i64 @kore_array_push(i64 %t74, i64 %t81)
  %t83 = load i64, i64* %t0
  %t84 = call i64 @Parser_peek(i64 %t83)
  %t85 = inttoptr i64 %t84 to %Token*
  %t86 = getelementptr %Token, %Token* %t85, i32 0, i32 3
  %t87 = load i64, i64* %t86
  %t88 = getelementptr [2 x i8], [2 x i8]* @.str.335, i64 0, i64 0
  %t89 = ptrtoint i8* %t88 to i64
  %t90 = call i64 @kore_str_eq(i64 %t87, i64 %t89)
  %t91 = icmp ne i64 %t90, 0
  br i1 %t91, label %then343, label %endif345
  then343:
  %t92 = load i64, i64* %t0
  %t93 = call i64 @Parser_advance(i64 %t92)
  br label %endif345
  endif345:
  br label %endif339
  else338:
  br label %while_end327
  endif339:
  br label %while_cond325
  while_end327:
  %t94 = load i64, i64* %t2
  ret i64 %t94
}
define i64 @Parser_parse_type(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_advance(i64 %t1)
  %t3 = inttoptr i64 %t2 to %Token*
  %t4 = getelementptr %Token, %Token* %t3, i32 0, i32 3
  %t5 = load i64, i64* %t4
  %t6 = alloca i64
  store i64 %t5, i64* %t6
  %t7 = load i64, i64* %t0
  %t8 = call i64 @Parser_peek(i64 %t7)
  %t9 = inttoptr i64 %t8 to %Token*
  %t10 = getelementptr %Token, %Token* %t9, i32 0, i32 3
  %t11 = load i64, i64* %t10
  %t12 = getelementptr [2 x i8], [2 x i8]* @.str.336, i64 0, i64 0
  %t13 = ptrtoint i8* %t12 to i64
  %t14 = call i64 @kore_str_eq(i64 %t11, i64 %t13)
  %t15 = icmp ne i64 %t14, 0
  br i1 %t15, label %then346, label %endif348
  then346:
  %t16 = load i64, i64* %t0
  %t17 = call i64 @Parser_advance(i64 %t16)
  %t18 = load i64, i64* %t0
  %t19 = call i64 @Parser_parse_type(i64 %t18)
  %t20 = alloca i64
  store i64 %t19, i64* %t20
  br label %while_cond349
  while_cond349:
  %t21 = load i64, i64* %t0
  %t22 = call i64 @Parser_peek(i64 %t21)
  %t23 = inttoptr i64 %t22 to %Token*
  %t24 = getelementptr %Token, %Token* %t23, i32 0, i32 3
  %t25 = load i64, i64* %t24
  %t26 = getelementptr [2 x i8], [2 x i8]* @.str.337, i64 0, i64 0
  %t27 = ptrtoint i8* %t26 to i64
  %t28 = call i64 @kore_str_eq(i64 %t25, i64 %t27)
  %t29 = icmp ne i64 %t28, 0
  br i1 %t29, label %while_body350, label %while_end351
  while_body350:
  %t30 = load i64, i64* %t0
  %t31 = call i64 @Parser_advance(i64 %t30)
  %t32 = load i64, i64* %t20
  %t33 = getelementptr [3 x i8], [3 x i8]* @.str.338, i64 0, i64 0
  %t34 = ptrtoint i8* %t33 to i64
  %t35 = call i64 @kore_str_concat(i64 %t32, i64 %t34)
  %t36 = load i64, i64* %t0
  %t37 = call i64 @Parser_parse_type(i64 %t36)
  %t38 = call i64 @kore_str_concat(i64 %t35, i64 %t37)
  store i64 %t38, i64* %t20
  br label %while_cond349
  while_end351:
  %t39 = load i64, i64* %t0
  %t40 = call i64 @Parser_advance(i64 %t39)
  %t41 = load i64, i64* %t6
  %t42 = getelementptr [2 x i8], [2 x i8]* @.str.339, i64 0, i64 0
  %t43 = ptrtoint i8* %t42 to i64
  %t44 = call i64 @kore_str_concat(i64 %t41, i64 %t43)
  %t45 = load i64, i64* %t20
  %t46 = call i64 @kore_str_concat(i64 %t44, i64 %t45)
  %t47 = getelementptr [2 x i8], [2 x i8]* @.str.340, i64 0, i64 0
  %t48 = ptrtoint i8* %t47 to i64
  %t49 = call i64 @kore_str_concat(i64 %t46, i64 %t48)
  ret i64 %t49
  endif348:
  %t50 = load i64, i64* %t6
  ret i64 %t50
}
define i64 @Parser_parse_block(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = call i64 @kore_array_new()
  %t2 = alloca i64
  store i64 %t1, i64* %t2
  %t3 = alloca i64
  store i64 10000, i64* %t3
  %t4 = load i64, i64* %t0
  %t5 = call i64 @Parser_skip_newlines(i64 %t4)
  %t6 = alloca i64
  store i64 0, i64* %t6
  %t7 = load i64, i64* %t0
  %t8 = call i64 @Parser_peek(i64 %t7)
  %t9 = alloca i64
  store i64 %t8, i64* %t9
  %t10 = load i64, i64* %t9
  %t11 = call i64 @Token_is_indent(i64 %t10)
  %t12 = icmp ne i64 %t11, 0
  br i1 %t12, label %then352, label %endif354
  then352:
  %t13 = load i64, i64* %t0
  %t14 = call i64 @Parser_advance(i64 %t13)
  store i64 1, i64* %t6
  br label %endif354
  endif354:
  br label %while_cond355
  while_cond355:
  %t15 = load i64, i64* %t0
  %t16 = call i64 @Parser_is_eof(i64 %t15)
  %t18 = icmp eq i64 %t16, 0
  %t17 = zext i1 %t18 to i64
  %t19 = load i64, i64* %t2
  %t20 = call i64 @kore_array_len(i64 %t19)
  %t21 = load i64, i64* %t3
  %t23 = icmp slt i64 %t20, %t21
  %t22 = zext i1 %t23 to i64
  %t24 = and i64 %t17, %t22
  %t25 = icmp ne i64 %t24, 0
  br i1 %t25, label %while_body356, label %while_end357
  while_body356:
  %t26 = load i64, i64* %t0
  %t27 = call i64 @Parser_peek(i64 %t26)
  %t28 = alloca i64
  store i64 %t27, i64* %t28
  %t29 = load i64, i64* %t6
  %t30 = load i64, i64* %t28
  %t31 = call i64 @Token_is_dedent(i64 %t30)
  %t32 = and i64 %t29, %t31
  %t33 = icmp ne i64 %t32, 0
  br i1 %t33, label %then358, label %endif360
  then358:
  %t34 = load i64, i64* %t0
  %t35 = call i64 @Parser_advance(i64 %t34)
  br label %while_end357
  endif360:
  %t36 = load i64, i64* %t28
  %t37 = call i64 @Token_is_newline(i64 %t36)
  %t38 = icmp ne i64 %t37, 0
  br i1 %t38, label %then361, label %endif363
  then361:
  %t39 = load i64, i64* %t0
  %t40 = call i64 @Parser_advance(i64 %t39)
  br label %while_cond355
  endif363:
  %t41 = load i64, i64* %t6
  %t43 = icmp eq i64 %t41, 0
  %t42 = zext i1 %t43 to i64
  %t44 = icmp ne i64 %t42, 0
  br i1 %t44, label %then364, label %endif366
  then364:
  %t45 = load i64, i64* %t28
  %t46 = getelementptr [3 x i8], [3 x i8]* @.str.341, i64 0, i64 0
  %t47 = ptrtoint i8* %t46 to i64
  %t48 = call i64 @Token_is_keyword(i64 %t45, i64 %t47)
  %t49 = load i64, i64* %t28
  %t50 = getelementptr [4 x i8], [4 x i8]* @.str.342, i64 0, i64 0
  %t51 = ptrtoint i8* %t50 to i64
  %t52 = call i64 @Token_is_keyword(i64 %t49, i64 %t51)
  %t53 = or i64 %t48, %t52
  %t54 = load i64, i64* %t28
  %t55 = getelementptr [7 x i8], [7 x i8]* @.str.343, i64 0, i64 0
  %t56 = ptrtoint i8* %t55 to i64
  %t57 = call i64 @Token_is_keyword(i64 %t54, i64 %t56)
  %t58 = or i64 %t53, %t57
  %t59 = load i64, i64* %t28
  %t60 = getelementptr [5 x i8], [5 x i8]* @.str.344, i64 0, i64 0
  %t61 = ptrtoint i8* %t60 to i64
  %t62 = call i64 @Token_is_keyword(i64 %t59, i64 %t61)
  %t63 = or i64 %t58, %t62
  %t64 = load i64, i64* %t28
  %t65 = getelementptr [5 x i8], [5 x i8]* @.str.345, i64 0, i64 0
  %t66 = ptrtoint i8* %t65 to i64
  %t67 = call i64 @Token_is_keyword(i64 %t64, i64 %t66)
  %t68 = or i64 %t63, %t67
  %t69 = load i64, i64* %t28
  %t70 = getelementptr [4 x i8], [4 x i8]* @.str.346, i64 0, i64 0
  %t71 = ptrtoint i8* %t70 to i64
  %t72 = call i64 @Token_is_keyword(i64 %t69, i64 %t71)
  %t73 = or i64 %t68, %t72
  %t74 = icmp ne i64 %t73, 0
  br i1 %t74, label %then367, label %endif369
  then367:
  br label %while_end357
  endif369:
  br label %endif366
  endif366:
  %t75 = load i64, i64* %t0
  %t76 = inttoptr i64 %t75 to %Parser*
  %t77 = getelementptr %Parser, %Parser* %t76, i32 0, i32 1
  %t78 = load i64, i64* %t77
  %t79 = alloca i64
  store i64 %t78, i64* %t79
  %t80 = load i64, i64* %t0
  %t81 = call i64 @Parser_parse_stmt(i64 %t80)
  %t82 = alloca i64
  store i64 %t81, i64* %t82
  %t83 = load i64, i64* %t2
  %t84 = load i64, i64* %t82
  %t85 = call i64 @kore_array_push(i64 %t83, i64 %t84)
  %t86 = load i64, i64* %t0
  %t87 = inttoptr i64 %t86 to %Parser*
  %t88 = getelementptr %Parser, %Parser* %t87, i32 0, i32 1
  %t89 = load i64, i64* %t88
  %t90 = load i64, i64* %t79
  %t91 = call i64 @kore_str_eq(i64 %t89, i64 %t90)
  %t92 = icmp ne i64 %t91, 0
  br i1 %t92, label %then370, label %endif372
  then370:
  br label %while_end357
  endif372:
  %t93 = load i64, i64* %t6
  %t95 = icmp eq i64 %t93, 0
  %t94 = zext i1 %t95 to i64
  %t96 = icmp ne i64 %t94, 0
  br i1 %t96, label %then373, label %endif375
  then373:
  br label %while_end357
  endif375:
  br label %while_cond355
  while_end357:
  %t97 = load i64, i64* %t2
  ret i64 %t97
}
define i64 @Parser_parse_stmt(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_peek(i64 %t1)
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  %t4 = load i64, i64* %t3
  %t5 = call i64 @Token_is_error(i64 %t4)
  %t6 = icmp ne i64 %t5, 0
  br i1 %t6, label %then376, label %endif378
  then376:
  %t7 = load i64, i64* %t0
  %t8 = call i64 @Parser_advance(i64 %t7)
  ; enum variant: Stmt::Expr
  %t9 = call i8* @malloc(i64 24)
  %t10 = bitcast i8* %t9 to %Stmt*
  %t11 = getelementptr %Stmt, %Stmt* %t10, i32 0, i32 0
  store i64 9, i64* %t11
  %t12 = call i8* @malloc(i64 8)
  %t13 = bitcast i8* %t12 to i64*
  ; enum variant: Expr::None
  %t14 = call i8* @malloc(i64 24)
  %t15 = bitcast i8* %t14 to %Expr*
  %t16 = getelementptr %Expr, %Expr* %t15, i32 0, i32 0
  store i64 0, i64* %t16
  %t17 = getelementptr %Expr, %Expr* %t15, i32 0, i32 1
  store i8* null, i8** %t17
  %t18 = getelementptr %Expr, %Expr* %t15, i32 0, i32 2
  %t19 = getelementptr [5 x i8], [5 x i8]* @.str.347, i64 0, i64 0
  store i8* %t19, i8** %t18
  %t20 = ptrtoint %Expr* %t15 to i64
  %t21 = getelementptr i64, i64* %t13, i32 0
  store i64 %t20, i64* %t21
  %t22 = getelementptr %Stmt, %Stmt* %t10, i32 0, i32 1
  store i8* %t12, i8** %t22
  %t23 = getelementptr %Stmt, %Stmt* %t10, i32 0, i32 2
  %t24 = getelementptr [5 x i8], [5 x i8]* @.str.348, i64 0, i64 0
  store i8* %t24, i8** %t23
  %t25 = ptrtoint %Stmt* %t10 to i64
  ret i64 %t25
  endif378:
  %t26 = load i64, i64* %t3
  %t27 = getelementptr [4 x i8], [4 x i8]* @.str.349, i64 0, i64 0
  %t28 = ptrtoint i8* %t27 to i64
  %t29 = call i64 @Token_is_keyword(i64 %t26, i64 %t28)
  %t30 = icmp ne i64 %t29, 0
  br i1 %t30, label %then379, label %endif381
  then379:
  %t31 = load i64, i64* %t0
  %t32 = call i64 @Parser_parse_let(i64 %t31)
  ret i64 %t32
  endif381:
  %t33 = load i64, i64* %t3
  %t34 = getelementptr [4 x i8], [4 x i8]* @.str.350, i64 0, i64 0
  %t35 = ptrtoint i8* %t34 to i64
  %t36 = call i64 @Token_is_keyword(i64 %t33, i64 %t35)
  %t37 = icmp ne i64 %t36, 0
  br i1 %t37, label %then382, label %endif384
  then382:
  %t38 = load i64, i64* %t0
  %t39 = call i64 @Parser_parse_var(i64 %t38)
  ret i64 %t39
  endif384:
  %t40 = load i64, i64* %t3
  %t41 = getelementptr [7 x i8], [7 x i8]* @.str.351, i64 0, i64 0
  %t42 = ptrtoint i8* %t41 to i64
  %t43 = call i64 @Token_is_keyword(i64 %t40, i64 %t42)
  %t44 = icmp ne i64 %t43, 0
  br i1 %t44, label %then385, label %endif387
  then385:
  %t45 = load i64, i64* %t0
  %t46 = call i64 @Parser_parse_return(i64 %t45)
  ret i64 %t46
  endif387:
  %t47 = load i64, i64* %t3
  %t48 = getelementptr [3 x i8], [3 x i8]* @.str.352, i64 0, i64 0
  %t49 = ptrtoint i8* %t48 to i64
  %t50 = call i64 @Token_is_keyword(i64 %t47, i64 %t49)
  %t51 = icmp ne i64 %t50, 0
  br i1 %t51, label %then388, label %endif390
  then388:
  %t52 = load i64, i64* %t0
  %t53 = call i64 @Parser_parse_if(i64 %t52)
  ret i64 %t53
  endif390:
  %t54 = load i64, i64* %t3
  %t55 = getelementptr [6 x i8], [6 x i8]* @.str.353, i64 0, i64 0
  %t56 = ptrtoint i8* %t55 to i64
  %t57 = call i64 @Token_is_keyword(i64 %t54, i64 %t56)
  %t58 = icmp ne i64 %t57, 0
  br i1 %t58, label %then391, label %endif393
  then391:
  %t59 = load i64, i64* %t0
  %t60 = call i64 @Parser_parse_while(i64 %t59)
  ret i64 %t60
  endif393:
  %t61 = load i64, i64* %t3
  %t62 = getelementptr [4 x i8], [4 x i8]* @.str.354, i64 0, i64 0
  %t63 = ptrtoint i8* %t62 to i64
  %t64 = call i64 @Token_is_keyword(i64 %t61, i64 %t63)
  %t65 = icmp ne i64 %t64, 0
  br i1 %t65, label %then394, label %endif396
  then394:
  %t66 = load i64, i64* %t0
  %t67 = call i64 @Parser_parse_for(i64 %t66)
  ret i64 %t67
  endif396:
  %t68 = load i64, i64* %t3
  %t69 = getelementptr [6 x i8], [6 x i8]* @.str.355, i64 0, i64 0
  %t70 = ptrtoint i8* %t69 to i64
  %t71 = call i64 @Token_is_keyword(i64 %t68, i64 %t70)
  %t72 = icmp ne i64 %t71, 0
  br i1 %t72, label %then397, label %endif399
  then397:
  %t73 = load i64, i64* %t0
  %t74 = call i64 @Parser_parse_match(i64 %t73)
  ret i64 %t74
  endif399:
  %t75 = load i64, i64* %t3
  %t76 = getelementptr [6 x i8], [6 x i8]* @.str.356, i64 0, i64 0
  %t77 = ptrtoint i8* %t76 to i64
  %t78 = call i64 @Token_is_keyword(i64 %t75, i64 %t77)
  %t79 = icmp ne i64 %t78, 0
  br i1 %t79, label %then400, label %endif402
  then400:
  %t80 = load i64, i64* %t0
  %t81 = call i64 @Parser_advance(i64 %t80)
  ; enum variant: Stmt::Break
  %t82 = call i8* @malloc(i64 24)
  %t83 = bitcast i8* %t82 to %Stmt*
  %t84 = getelementptr %Stmt, %Stmt* %t83, i32 0, i32 0
  store i64 10, i64* %t84
  %t85 = getelementptr %Stmt, %Stmt* %t83, i32 0, i32 1
  store i8* null, i8** %t85
  %t86 = getelementptr %Stmt, %Stmt* %t83, i32 0, i32 2
  %t87 = getelementptr [6 x i8], [6 x i8]* @.str.357, i64 0, i64 0
  store i8* %t87, i8** %t86
  %t88 = ptrtoint %Stmt* %t83 to i64
  ret i64 %t88
  endif402:
  %t89 = load i64, i64* %t3
  %t90 = getelementptr [9 x i8], [9 x i8]* @.str.358, i64 0, i64 0
  %t91 = ptrtoint i8* %t90 to i64
  %t92 = call i64 @Token_is_keyword(i64 %t89, i64 %t91)
  %t93 = icmp ne i64 %t92, 0
  br i1 %t93, label %then403, label %endif405
  then403:
  %t94 = load i64, i64* %t0
  %t95 = call i64 @Parser_advance(i64 %t94)
  ; enum variant: Stmt::Continue
  %t96 = call i8* @malloc(i64 24)
  %t97 = bitcast i8* %t96 to %Stmt*
  %t98 = getelementptr %Stmt, %Stmt* %t97, i32 0, i32 0
  store i64 11, i64* %t98
  %t99 = getelementptr %Stmt, %Stmt* %t97, i32 0, i32 1
  store i8* null, i8** %t99
  %t100 = getelementptr %Stmt, %Stmt* %t97, i32 0, i32 2
  %t101 = getelementptr [9 x i8], [9 x i8]* @.str.359, i64 0, i64 0
  store i8* %t101, i8** %t100
  %t102 = ptrtoint %Stmt* %t97 to i64
  ret i64 %t102
  endif405:
  %t103 = load i64, i64* %t3
  %t104 = getelementptr [5 x i8], [5 x i8]* @.str.360, i64 0, i64 0
  %t105 = ptrtoint i8* %t104 to i64
  %t106 = call i64 @Token_is_keyword(i64 %t103, i64 %t105)
  %t107 = icmp ne i64 %t106, 0
  br i1 %t107, label %then406, label %endif408
  then406:
  %t108 = load i64, i64* %t0
  %t109 = call i64 @Parser_parse_loop(i64 %t108)
  ret i64 %t109
  endif408:
  %t110 = load i64, i64* %t0
  %t111 = call i64 @Parser_parse_expr(i64 %t110)
  %t112 = alloca i64
  store i64 %t111, i64* %t112
  %t113 = load i64, i64* %t0
  %t114 = call i64 @Parser_peek(i64 %t113)
  %t115 = inttoptr i64 %t114 to %Token*
  %t116 = getelementptr %Token, %Token* %t115, i32 0, i32 3
  %t117 = load i64, i64* %t116
  %t118 = getelementptr [2 x i8], [2 x i8]* @.str.361, i64 0, i64 0
  %t119 = ptrtoint i8* %t118 to i64
  %t120 = call i64 @kore_str_eq(i64 %t117, i64 %t119)
  %t121 = icmp ne i64 %t120, 0
  br i1 %t121, label %then409, label %endif411
  then409:
  %t122 = load i64, i64* %t0
  %t123 = call i64 @Parser_advance(i64 %t122)
  %t124 = load i64, i64* %t0
  %t125 = call i64 @Parser_parse_expr(i64 %t124)
  %t126 = alloca i64
  store i64 %t125, i64* %t126
  ; enum variant: Stmt::Assign
  %t127 = call i8* @malloc(i64 24)
  %t128 = bitcast i8* %t127 to %Stmt*
  %t129 = getelementptr %Stmt, %Stmt* %t128, i32 0, i32 0
  store i64 2, i64* %t129
  %t130 = call i8* @malloc(i64 16)
  %t131 = bitcast i8* %t130 to i64*
  %t132 = load i64, i64* %t112
  %t133 = getelementptr i64, i64* %t131, i32 0
  store i64 %t132, i64* %t133
  %t134 = load i64, i64* %t126
  %t135 = getelementptr i64, i64* %t131, i32 1
  store i64 %t134, i64* %t135
  %t136 = getelementptr %Stmt, %Stmt* %t128, i32 0, i32 1
  store i8* %t130, i8** %t136
  %t137 = getelementptr %Stmt, %Stmt* %t128, i32 0, i32 2
  %t138 = getelementptr [7 x i8], [7 x i8]* @.str.362, i64 0, i64 0
  store i8* %t138, i8** %t137
  %t139 = ptrtoint %Stmt* %t128 to i64
  ret i64 %t139
  endif411:
  ; enum variant: Stmt::Expr
  %t140 = call i8* @malloc(i64 24)
  %t141 = bitcast i8* %t140 to %Stmt*
  %t142 = getelementptr %Stmt, %Stmt* %t141, i32 0, i32 0
  store i64 9, i64* %t142
  %t143 = call i8* @malloc(i64 8)
  %t144 = bitcast i8* %t143 to i64*
  %t145 = load i64, i64* %t112
  %t146 = getelementptr i64, i64* %t144, i32 0
  store i64 %t145, i64* %t146
  %t147 = getelementptr %Stmt, %Stmt* %t141, i32 0, i32 1
  store i8* %t143, i8** %t147
  %t148 = getelementptr %Stmt, %Stmt* %t141, i32 0, i32 2
  %t149 = getelementptr [5 x i8], [5 x i8]* @.str.363, i64 0, i64 0
  store i8* %t149, i8** %t148
  %t150 = ptrtoint %Stmt* %t141 to i64
  ret i64 %t150
}
define i64 @Parser_parse_let(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = getelementptr [4 x i8], [4 x i8]* @.str.364, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = call i64 @Parser_expect_keyword(i64 %t1, i64 %t3)
  %t5 = load i64, i64* %t0
  %t6 = call i64 @Parser_advance(i64 %t5)
  %t7 = alloca i64
  store i64 %t6, i64* %t7
  %t8 = load i64, i64* %t7
  %t9 = inttoptr i64 %t8 to %Token*
  %t10 = getelementptr %Token, %Token* %t9, i32 0, i32 3
  %t11 = load i64, i64* %t10
  %t12 = alloca i64
  store i64 %t11, i64* %t12
  %t13 = load i64, i64* %t0
  %t14 = getelementptr [2 x i8], [2 x i8]* @.str.365, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  %t16 = call i64 @Parser_expect(i64 %t13, i64 %t15)
  %t17 = load i64, i64* %t0
  %t18 = call i64 @Parser_parse_expr(i64 %t17)
  %t19 = alloca i64
  store i64 %t18, i64* %t19
  ; enum variant: Stmt::Let
  %t20 = call i8* @malloc(i64 24)
  %t21 = bitcast i8* %t20 to %Stmt*
  %t22 = getelementptr %Stmt, %Stmt* %t21, i32 0, i32 0
  store i64 0, i64* %t22
  %t23 = call i8* @malloc(i64 24)
  %t24 = bitcast i8* %t23 to i64*
  %t25 = load i64, i64* %t12
  %t26 = getelementptr i64, i64* %t24, i32 0
  store i64 %t25, i64* %t26
  %t27 = getelementptr i64, i64* %t24, i32 1
  store i64 0, i64* %t27
  %t28 = load i64, i64* %t19
  %t29 = getelementptr i64, i64* %t24, i32 2
  store i64 %t28, i64* %t29
  %t30 = getelementptr %Stmt, %Stmt* %t21, i32 0, i32 1
  store i8* %t23, i8** %t30
  %t31 = getelementptr %Stmt, %Stmt* %t21, i32 0, i32 2
  %t32 = getelementptr [4 x i8], [4 x i8]* @.str.366, i64 0, i64 0
  store i8* %t32, i8** %t31
  %t33 = ptrtoint %Stmt* %t21 to i64
  ret i64 %t33
}
define i64 @Parser_parse_var(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = getelementptr [4 x i8], [4 x i8]* @.str.367, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = call i64 @Parser_expect_keyword(i64 %t1, i64 %t3)
  %t5 = load i64, i64* %t0
  %t6 = call i64 @Parser_advance(i64 %t5)
  %t7 = alloca i64
  store i64 %t6, i64* %t7
  %t8 = load i64, i64* %t7
  %t9 = inttoptr i64 %t8 to %Token*
  %t10 = getelementptr %Token, %Token* %t9, i32 0, i32 3
  %t11 = load i64, i64* %t10
  %t12 = alloca i64
  store i64 %t11, i64* %t12
  %t13 = load i64, i64* %t0
  %t14 = getelementptr [2 x i8], [2 x i8]* @.str.368, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  %t16 = call i64 @Parser_expect(i64 %t13, i64 %t15)
  %t17 = load i64, i64* %t0
  %t18 = call i64 @Parser_parse_expr(i64 %t17)
  %t19 = alloca i64
  store i64 %t18, i64* %t19
  ; enum variant: Stmt::Var
  %t20 = call i8* @malloc(i64 24)
  %t21 = bitcast i8* %t20 to %Stmt*
  %t22 = getelementptr %Stmt, %Stmt* %t21, i32 0, i32 0
  store i64 1, i64* %t22
  %t23 = call i8* @malloc(i64 24)
  %t24 = bitcast i8* %t23 to i64*
  %t25 = load i64, i64* %t12
  %t26 = getelementptr i64, i64* %t24, i32 0
  store i64 %t25, i64* %t26
  %t27 = getelementptr i64, i64* %t24, i32 1
  store i64 0, i64* %t27
  %t28 = load i64, i64* %t19
  %t29 = getelementptr i64, i64* %t24, i32 2
  store i64 %t28, i64* %t29
  %t30 = getelementptr %Stmt, %Stmt* %t21, i32 0, i32 1
  store i8* %t23, i8** %t30
  %t31 = getelementptr %Stmt, %Stmt* %t21, i32 0, i32 2
  %t32 = getelementptr [4 x i8], [4 x i8]* @.str.369, i64 0, i64 0
  store i8* %t32, i8** %t31
  %t33 = ptrtoint %Stmt* %t21 to i64
  ret i64 %t33
}
define i64 @Parser_parse_return(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = getelementptr [7 x i8], [7 x i8]* @.str.370, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = call i64 @Parser_expect_keyword(i64 %t1, i64 %t3)
  %t5 = load i64, i64* %t0
  %t6 = call i64 @Parser_peek(i64 %t5)
  %t7 = inttoptr i64 %t6 to %Token*
  %t8 = getelementptr %Token, %Token* %t7, i32 0, i32 3
  %t9 = load i64, i64* %t8
  %t10 = getelementptr [2 x i8], [2 x i8]* @.str.371, i64 0, i64 0
  %t11 = ptrtoint i8* %t10 to i64
  %t12 = call i64 @kore_str_eq(i64 %t9, i64 %t11)
  %t13 = icmp ne i64 %t12, 0
  br i1 %t13, label %then412, label %endif414
  then412:
  ; enum variant: Stmt::Return
  %t14 = call i8* @malloc(i64 24)
  %t15 = bitcast i8* %t14 to %Stmt*
  %t16 = getelementptr %Stmt, %Stmt* %t15, i32 0, i32 0
  store i64 3, i64* %t16
  %t17 = call i8* @malloc(i64 8)
  %t18 = bitcast i8* %t17 to i64*
  %t19 = getelementptr i64, i64* %t18, i32 0
  store i64 0, i64* %t19
  %t20 = getelementptr %Stmt, %Stmt* %t15, i32 0, i32 1
  store i8* %t17, i8** %t20
  %t21 = getelementptr %Stmt, %Stmt* %t15, i32 0, i32 2
  %t22 = getelementptr [7 x i8], [7 x i8]* @.str.372, i64 0, i64 0
  store i8* %t22, i8** %t21
  %t23 = ptrtoint %Stmt* %t15 to i64
  ret i64 %t23
  endif414:
  %t24 = load i64, i64* %t0
  %t25 = call i64 @Parser_parse_expr(i64 %t24)
  %t26 = alloca i64
  store i64 %t25, i64* %t26
  ; enum variant: Stmt::Return
  %t27 = call i8* @malloc(i64 24)
  %t28 = bitcast i8* %t27 to %Stmt*
  %t29 = getelementptr %Stmt, %Stmt* %t28, i32 0, i32 0
  store i64 3, i64* %t29
  %t30 = call i8* @malloc(i64 8)
  %t31 = bitcast i8* %t30 to i64*
  %t32 = load i64, i64* %t26
  %t33 = call i64 @kore_some(i64 %t32)
  %t34 = getelementptr i64, i64* %t31, i32 0
  store i64 %t33, i64* %t34
  %t35 = getelementptr %Stmt, %Stmt* %t28, i32 0, i32 1
  store i8* %t30, i8** %t35
  %t36 = getelementptr %Stmt, %Stmt* %t28, i32 0, i32 2
  %t37 = getelementptr [7 x i8], [7 x i8]* @.str.373, i64 0, i64 0
  store i8* %t37, i8** %t36
  %t38 = ptrtoint %Stmt* %t28 to i64
  ret i64 %t38
}
define i64 @Parser_parse_if(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = getelementptr [3 x i8], [3 x i8]* @.str.374, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = call i64 @Parser_expect_keyword(i64 %t1, i64 %t3)
  %t5 = load i64, i64* %t0
  %t6 = call i64 @Parser_parse_expr(i64 %t5)
  %t7 = alloca i64
  store i64 %t6, i64* %t7
  %t8 = load i64, i64* %t0
  %t9 = getelementptr [2 x i8], [2 x i8]* @.str.375, i64 0, i64 0
  %t10 = ptrtoint i8* %t9 to i64
  %t11 = call i64 @Parser_expect(i64 %t8, i64 %t10)
  %t12 = load i64, i64* %t0
  %t13 = call i64 @Parser_skip_newlines(i64 %t12)
  %t14 = load i64, i64* %t0
  %t15 = call i64 @Parser_parse_block(i64 %t14)
  %t16 = alloca i64
  store i64 %t15, i64* %t16
  %t17 = alloca i64
  store i64 0, i64* %t17
  %t18 = load i64, i64* %t0
  %t19 = call i64 @Parser_peek(i64 %t18)
  %t20 = getelementptr [5 x i8], [5 x i8]* @.str.376, i64 0, i64 0
  %t21 = ptrtoint i8* %t20 to i64
  %t22 = call i64 @Token_is_keyword(i64 %t19, i64 %t21)
  %t23 = icmp ne i64 %t22, 0
  br i1 %t23, label %then415, label %endif417
  then415:
  %t24 = load i64, i64* %t0
  %t25 = call i64 @Parser_advance(i64 %t24)
  %t26 = load i64, i64* %t0
  %t27 = getelementptr [2 x i8], [2 x i8]* @.str.377, i64 0, i64 0
  %t28 = ptrtoint i8* %t27 to i64
  %t29 = call i64 @Parser_expect(i64 %t26, i64 %t28)
  %t30 = load i64, i64* %t0
  %t31 = call i64 @Parser_skip_newlines(i64 %t30)
  %t32 = load i64, i64* %t0
  %t33 = call i64 @Parser_parse_block(i64 %t32)
  %t34 = call i64 @kore_some(i64 %t33)
  store i64 %t34, i64* %t17
  br label %endif417
  endif417:
  ; enum variant: Stmt::If
  %t35 = call i8* @malloc(i64 24)
  %t36 = bitcast i8* %t35 to %Stmt*
  %t37 = getelementptr %Stmt, %Stmt* %t36, i32 0, i32 0
  store i64 4, i64* %t37
  %t38 = call i8* @malloc(i64 24)
  %t39 = bitcast i8* %t38 to i64*
  %t40 = load i64, i64* %t7
  %t41 = getelementptr i64, i64* %t39, i32 0
  store i64 %t40, i64* %t41
  %t42 = load i64, i64* %t16
  %t43 = getelementptr i64, i64* %t39, i32 1
  store i64 %t42, i64* %t43
  %t44 = load i64, i64* %t17
  %t45 = getelementptr i64, i64* %t39, i32 2
  store i64 %t44, i64* %t45
  %t46 = getelementptr %Stmt, %Stmt* %t36, i32 0, i32 1
  store i8* %t38, i8** %t46
  %t47 = getelementptr %Stmt, %Stmt* %t36, i32 0, i32 2
  %t48 = getelementptr [3 x i8], [3 x i8]* @.str.378, i64 0, i64 0
  store i8* %t48, i8** %t47
  %t49 = ptrtoint %Stmt* %t36 to i64
  ret i64 %t49
}
define i64 @Parser_parse_while(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = getelementptr [6 x i8], [6 x i8]* @.str.379, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = call i64 @Parser_expect_keyword(i64 %t1, i64 %t3)
  %t5 = load i64, i64* %t0
  %t6 = call i64 @Parser_parse_expr(i64 %t5)
  %t7 = alloca i64
  store i64 %t6, i64* %t7
  %t8 = load i64, i64* %t0
  %t9 = getelementptr [2 x i8], [2 x i8]* @.str.380, i64 0, i64 0
  %t10 = ptrtoint i8* %t9 to i64
  %t11 = call i64 @Parser_expect(i64 %t8, i64 %t10)
  %t12 = load i64, i64* %t0
  %t13 = call i64 @Parser_skip_newlines(i64 %t12)
  %t14 = load i64, i64* %t0
  %t15 = call i64 @Parser_parse_block(i64 %t14)
  %t16 = alloca i64
  store i64 %t15, i64* %t16
  ; enum variant: Stmt::While
  %t17 = call i8* @malloc(i64 24)
  %t18 = bitcast i8* %t17 to %Stmt*
  %t19 = getelementptr %Stmt, %Stmt* %t18, i32 0, i32 0
  store i64 5, i64* %t19
  %t20 = call i8* @malloc(i64 16)
  %t21 = bitcast i8* %t20 to i64*
  %t22 = load i64, i64* %t7
  %t23 = getelementptr i64, i64* %t21, i32 0
  store i64 %t22, i64* %t23
  %t24 = load i64, i64* %t16
  %t25 = getelementptr i64, i64* %t21, i32 1
  store i64 %t24, i64* %t25
  %t26 = getelementptr %Stmt, %Stmt* %t18, i32 0, i32 1
  store i8* %t20, i8** %t26
  %t27 = getelementptr %Stmt, %Stmt* %t18, i32 0, i32 2
  %t28 = getelementptr [6 x i8], [6 x i8]* @.str.381, i64 0, i64 0
  store i8* %t28, i8** %t27
  %t29 = ptrtoint %Stmt* %t18 to i64
  ret i64 %t29
}
define i64 @Parser_parse_for(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = getelementptr [4 x i8], [4 x i8]* @.str.382, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = call i64 @Parser_expect_keyword(i64 %t1, i64 %t3)
  %t5 = load i64, i64* %t0
  %t6 = call i64 @Parser_advance(i64 %t5)
  %t7 = alloca i64
  store i64 %t6, i64* %t7
  %t8 = load i64, i64* %t7
  %t9 = inttoptr i64 %t8 to %Token*
  %t10 = getelementptr %Token, %Token* %t9, i32 0, i32 3
  %t11 = load i64, i64* %t10
  %t12 = alloca i64
  store i64 %t11, i64* %t12
  %t13 = load i64, i64* %t0
  %t14 = getelementptr [3 x i8], [3 x i8]* @.str.383, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  %t16 = call i64 @Parser_expect_keyword(i64 %t13, i64 %t15)
  %t17 = load i64, i64* %t0
  %t18 = call i64 @Parser_parse_expr(i64 %t17)
  %t19 = alloca i64
  store i64 %t18, i64* %t19
  %t20 = load i64, i64* %t0
  %t21 = getelementptr [2 x i8], [2 x i8]* @.str.384, i64 0, i64 0
  %t22 = ptrtoint i8* %t21 to i64
  %t23 = call i64 @Parser_expect(i64 %t20, i64 %t22)
  %t24 = load i64, i64* %t0
  %t25 = call i64 @Parser_skip_newlines(i64 %t24)
  %t26 = load i64, i64* %t0
  %t27 = call i64 @Parser_parse_block(i64 %t26)
  %t28 = alloca i64
  store i64 %t27, i64* %t28
  ; enum variant: Stmt::For
  %t29 = call i8* @malloc(i64 24)
  %t30 = bitcast i8* %t29 to %Stmt*
  %t31 = getelementptr %Stmt, %Stmt* %t30, i32 0, i32 0
  store i64 7, i64* %t31
  %t32 = call i8* @malloc(i64 24)
  %t33 = bitcast i8* %t32 to i64*
  %t34 = load i64, i64* %t12
  %t35 = getelementptr i64, i64* %t33, i32 0
  store i64 %t34, i64* %t35
  %t36 = load i64, i64* %t19
  %t37 = getelementptr i64, i64* %t33, i32 1
  store i64 %t36, i64* %t37
  %t38 = load i64, i64* %t28
  %t39 = getelementptr i64, i64* %t33, i32 2
  store i64 %t38, i64* %t39
  %t40 = getelementptr %Stmt, %Stmt* %t30, i32 0, i32 1
  store i8* %t32, i8** %t40
  %t41 = getelementptr %Stmt, %Stmt* %t30, i32 0, i32 2
  %t42 = getelementptr [4 x i8], [4 x i8]* @.str.385, i64 0, i64 0
  store i8* %t42, i8** %t41
  %t43 = ptrtoint %Stmt* %t30 to i64
  ret i64 %t43
}
define i64 @Parser_parse_loop(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = getelementptr [5 x i8], [5 x i8]* @.str.386, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = call i64 @Parser_expect_keyword(i64 %t1, i64 %t3)
  %t5 = load i64, i64* %t0
  %t6 = getelementptr [2 x i8], [2 x i8]* @.str.387, i64 0, i64 0
  %t7 = ptrtoint i8* %t6 to i64
  %t8 = call i64 @Parser_expect(i64 %t5, i64 %t7)
  %t9 = load i64, i64* %t0
  %t10 = call i64 @Parser_skip_newlines(i64 %t9)
  %t11 = load i64, i64* %t0
  %t12 = call i64 @Parser_parse_block(i64 %t11)
  %t13 = alloca i64
  store i64 %t12, i64* %t13
  ; enum variant: Stmt::Loop
  %t14 = call i8* @malloc(i64 24)
  %t15 = bitcast i8* %t14 to %Stmt*
  %t16 = getelementptr %Stmt, %Stmt* %t15, i32 0, i32 0
  store i64 6, i64* %t16
  %t17 = call i8* @malloc(i64 8)
  %t18 = bitcast i8* %t17 to i64*
  %t19 = load i64, i64* %t13
  %t20 = getelementptr i64, i64* %t18, i32 0
  store i64 %t19, i64* %t20
  %t21 = getelementptr %Stmt, %Stmt* %t15, i32 0, i32 1
  store i8* %t17, i8** %t21
  %t22 = getelementptr %Stmt, %Stmt* %t15, i32 0, i32 2
  %t23 = getelementptr [5 x i8], [5 x i8]* @.str.388, i64 0, i64 0
  store i8* %t23, i8** %t22
  %t24 = ptrtoint %Stmt* %t15 to i64
  ret i64 %t24
}
define i64 @Parser_parse_match(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = getelementptr [6 x i8], [6 x i8]* @.str.389, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = call i64 @Parser_expect_keyword(i64 %t1, i64 %t3)
  %t5 = load i64, i64* %t0
  %t6 = call i64 @Parser_parse_expr(i64 %t5)
  %t7 = alloca i64
  store i64 %t6, i64* %t7
  %t8 = load i64, i64* %t0
  %t9 = getelementptr [2 x i8], [2 x i8]* @.str.390, i64 0, i64 0
  %t10 = ptrtoint i8* %t9 to i64
  %t11 = call i64 @Parser_expect(i64 %t8, i64 %t10)
  %t12 = load i64, i64* %t0
  %t13 = call i64 @Parser_skip_newlines(i64 %t12)
  %t14 = call i64 @kore_array_new()
  %t15 = alloca i64
  store i64 %t14, i64* %t15
  br label %while_cond418
  while_cond418:
  %t16 = load i64, i64* %t0
  %t17 = call i64 @Parser_is_eof(i64 %t16)
  %t19 = icmp eq i64 %t17, 0
  %t18 = zext i1 %t19 to i64
  %t20 = icmp ne i64 %t18, 0
  br i1 %t20, label %while_body419, label %while_end420
  while_body419:
  %t21 = load i64, i64* %t0
  %t22 = call i64 @Parser_peek(i64 %t21)
  %t23 = alloca i64
  store i64 %t22, i64* %t23
  %t24 = load i64, i64* %t23
  %t25 = getelementptr [3 x i8], [3 x i8]* @.str.391, i64 0, i64 0
  %t26 = ptrtoint i8* %t25 to i64
  %t27 = call i64 @Token_is_keyword(i64 %t24, i64 %t26)
  %t28 = load i64, i64* %t23
  %t29 = getelementptr [4 x i8], [4 x i8]* @.str.392, i64 0, i64 0
  %t30 = ptrtoint i8* %t29 to i64
  %t31 = call i64 @Token_is_keyword(i64 %t28, i64 %t30)
  %t32 = or i64 %t27, %t31
  %t33 = load i64, i64* %t23
  %t34 = getelementptr [4 x i8], [4 x i8]* @.str.393, i64 0, i64 0
  %t35 = ptrtoint i8* %t34 to i64
  %t36 = call i64 @Token_is_keyword(i64 %t33, i64 %t35)
  %t37 = or i64 %t32, %t36
  %t38 = load i64, i64* %t23
  %t39 = getelementptr [7 x i8], [7 x i8]* @.str.394, i64 0, i64 0
  %t40 = ptrtoint i8* %t39 to i64
  %t41 = call i64 @Token_is_keyword(i64 %t38, i64 %t40)
  %t42 = or i64 %t37, %t41
  %t43 = load i64, i64* %t23
  %t44 = getelementptr [3 x i8], [3 x i8]* @.str.395, i64 0, i64 0
  %t45 = ptrtoint i8* %t44 to i64
  %t46 = call i64 @Token_is_keyword(i64 %t43, i64 %t45)
  %t47 = or i64 %t42, %t46
  %t48 = load i64, i64* %t23
  %t49 = getelementptr [6 x i8], [6 x i8]* @.str.396, i64 0, i64 0
  %t50 = ptrtoint i8* %t49 to i64
  %t51 = call i64 @Token_is_keyword(i64 %t48, i64 %t50)
  %t52 = or i64 %t47, %t51
  %t53 = load i64, i64* %t23
  %t54 = getelementptr [4 x i8], [4 x i8]* @.str.397, i64 0, i64 0
  %t55 = ptrtoint i8* %t54 to i64
  %t56 = call i64 @Token_is_keyword(i64 %t53, i64 %t55)
  %t57 = or i64 %t52, %t56
  %t58 = icmp ne i64 %t57, 0
  br i1 %t58, label %then421, label %endif423
  then421:
  br label %while_end420
  endif423:
  %t59 = load i64, i64* %t23
  %t60 = getelementptr [7 x i8], [7 x i8]* @.str.398, i64 0, i64 0
  %t61 = ptrtoint i8* %t60 to i64
  %t62 = call i64 @Token_is_keyword(i64 %t59, i64 %t61)
  %t63 = load i64, i64* %t23
  %t64 = getelementptr [5 x i8], [5 x i8]* @.str.399, i64 0, i64 0
  %t65 = ptrtoint i8* %t64 to i64
  %t66 = call i64 @Token_is_keyword(i64 %t63, i64 %t65)
  %t67 = or i64 %t62, %t66
  %t68 = load i64, i64* %t23
  %t69 = getelementptr [5 x i8], [5 x i8]* @.str.400, i64 0, i64 0
  %t70 = ptrtoint i8* %t69 to i64
  %t71 = call i64 @Token_is_keyword(i64 %t68, i64 %t70)
  %t72 = or i64 %t67, %t71
  %t73 = load i64, i64* %t23
  %t74 = getelementptr [4 x i8], [4 x i8]* @.str.401, i64 0, i64 0
  %t75 = ptrtoint i8* %t74 to i64
  %t76 = call i64 @Token_is_keyword(i64 %t73, i64 %t75)
  %t77 = or i64 %t72, %t76
  %t78 = load i64, i64* %t23
  %t79 = getelementptr [4 x i8], [4 x i8]* @.str.402, i64 0, i64 0
  %t80 = ptrtoint i8* %t79 to i64
  %t81 = call i64 @Token_is_keyword(i64 %t78, i64 %t80)
  %t82 = or i64 %t77, %t81
  %t83 = icmp ne i64 %t82, 0
  br i1 %t83, label %then424, label %endif426
  then424:
  br label %while_end420
  endif426:
  %t84 = load i64, i64* %t23
  %t85 = inttoptr i64 %t84 to %Token*
  %t86 = getelementptr %Token, %Token* %t85, i32 0, i32 3
  %t87 = load i64, i64* %t86
  %t88 = getelementptr [2 x i8], [2 x i8]* @.str.403, i64 0, i64 0
  %t89 = ptrtoint i8* %t88 to i64
  %t90 = call i64 @kore_str_eq(i64 %t87, i64 %t89)
  %t91 = icmp ne i64 %t90, 0
  br i1 %t91, label %then427, label %endif429
  then427:
  %t92 = load i64, i64* %t0
  %t93 = call i64 @Parser_advance(i64 %t92)
  br label %while_cond418
  endif429:
  %t94 = load i64, i64* %t0
  %t95 = call i64 @Parser_parse_pattern(i64 %t94)
  %t96 = alloca i64
  store i64 %t95, i64* %t96
  %t97 = load i64, i64* %t0
  %t98 = getelementptr [2 x i8], [2 x i8]* @.str.404, i64 0, i64 0
  %t99 = ptrtoint i8* %t98 to i64
  %t100 = call i64 @Parser_expect(i64 %t97, i64 %t99)
  %t101 = load i64, i64* %t0
  %t102 = getelementptr [2 x i8], [2 x i8]* @.str.405, i64 0, i64 0
  %t103 = ptrtoint i8* %t102 to i64
  %t104 = call i64 @Parser_expect(i64 %t101, i64 %t103)
  %t105 = call i64 @kore_array_new()
  %t106 = alloca i64
  store i64 %t105, i64* %t106
  %t107 = load i64, i64* %t0
  %t108 = call i64 @Parser_peek(i64 %t107)
  %t109 = inttoptr i64 %t108 to %Token*
  %t110 = getelementptr %Token, %Token* %t109, i32 0, i32 3
  %t111 = load i64, i64* %t110
  %t112 = getelementptr [2 x i8], [2 x i8]* @.str.406, i64 0, i64 0
  %t113 = ptrtoint i8* %t112 to i64
  %t114 = call i64 @kore_str_eq(i64 %t111, i64 %t113)
  %t115 = icmp ne i64 %t114, 0
  br i1 %t115, label %then430, label %else431
  then430:
  %t116 = load i64, i64* %t0
  %t117 = call i64 @Parser_skip_newlines(i64 %t116)
  %t118 = load i64, i64* %t0
  %t119 = call i64 @Parser_parse_block(i64 %t118)
  store i64 %t119, i64* %t106
  br label %endif432
  else431:
  %t120 = load i64, i64* %t0
  %t121 = call i64 @Parser_parse_expr(i64 %t120)
  %t122 = alloca i64
  store i64 %t121, i64* %t122
  %t123 = load i64, i64* %t106
  ; enum variant: Stmt::Expr
  %t124 = call i8* @malloc(i64 24)
  %t125 = bitcast i8* %t124 to %Stmt*
  %t126 = getelementptr %Stmt, %Stmt* %t125, i32 0, i32 0
  store i64 9, i64* %t126
  %t127 = call i8* @malloc(i64 8)
  %t128 = bitcast i8* %t127 to i64*
  %t129 = load i64, i64* %t122
  %t130 = getelementptr i64, i64* %t128, i32 0
  store i64 %t129, i64* %t130
  %t131 = getelementptr %Stmt, %Stmt* %t125, i32 0, i32 1
  store i8* %t127, i8** %t131
  %t132 = getelementptr %Stmt, %Stmt* %t125, i32 0, i32 2
  %t133 = getelementptr [5 x i8], [5 x i8]* @.str.407, i64 0, i64 0
  store i8* %t133, i8** %t132
  %t134 = ptrtoint %Stmt* %t125 to i64
  %t135 = call i64 @kore_array_push(i64 %t123, i64 %t134)
  br label %endif432
  endif432:
  %t136 = load i64, i64* %t15
  ; struct literal: MatchArm
  %t137 = call i8* @malloc(i64 16)
  %t138 = bitcast i8* %t137 to %MatchArm*
  %t139 = load i64, i64* %t96
  %t140 = getelementptr %MatchArm, %MatchArm* %t138, i32 0, i32 0
  store i64 %t139, i64* %t140
  %t141 = load i64, i64* %t106
  %t142 = getelementptr %MatchArm, %MatchArm* %t138, i32 0, i32 1
  store i64 %t141, i64* %t142
  %t143 = ptrtoint %MatchArm* %t138 to i64
  %t144 = call i64 @kore_array_push(i64 %t136, i64 %t143)
  br label %while_cond418
  while_end420:
  ; enum variant: Stmt::Match
  %t145 = call i8* @malloc(i64 24)
  %t146 = bitcast i8* %t145 to %Stmt*
  %t147 = getelementptr %Stmt, %Stmt* %t146, i32 0, i32 0
  store i64 8, i64* %t147
  %t148 = call i8* @malloc(i64 16)
  %t149 = bitcast i8* %t148 to i64*
  %t150 = load i64, i64* %t7
  %t151 = getelementptr i64, i64* %t149, i32 0
  store i64 %t150, i64* %t151
  %t152 = load i64, i64* %t15
  %t153 = getelementptr i64, i64* %t149, i32 1
  store i64 %t152, i64* %t153
  %t154 = getelementptr %Stmt, %Stmt* %t146, i32 0, i32 1
  store i8* %t148, i8** %t154
  %t155 = getelementptr %Stmt, %Stmt* %t146, i32 0, i32 2
  %t156 = getelementptr [6 x i8], [6 x i8]* @.str.408, i64 0, i64 0
  store i8* %t156, i8** %t155
  %t157 = ptrtoint %Stmt* %t146 to i64
  ret i64 %t157
}
define i64 @Parser_parse_pattern(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_peek(i64 %t1)
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  %t4 = load i64, i64* %t3
  %t5 = inttoptr i64 %t4 to %Token*
  %t6 = getelementptr %Token, %Token* %t5, i32 0, i32 3
  %t7 = load i64, i64* %t6
  %t8 = getelementptr [2 x i8], [2 x i8]* @.str.409, i64 0, i64 0
  %t9 = ptrtoint i8* %t8 to i64
  %t10 = call i64 @kore_str_eq(i64 %t7, i64 %t9)
  %t11 = icmp ne i64 %t10, 0
  br i1 %t11, label %then433, label %endif435
  then433:
  %t12 = load i64, i64* %t0
  %t13 = call i64 @Parser_advance(i64 %t12)
  ; enum variant: Pattern::Wildcard
  %t14 = call i8* @malloc(i64 24)
  %t15 = bitcast i8* %t14 to %Pattern*
  %t16 = getelementptr %Pattern, %Pattern* %t15, i32 0, i32 0
  store i64 0, i64* %t16
  %t17 = getelementptr %Pattern, %Pattern* %t15, i32 0, i32 1
  store i8* null, i8** %t17
  %t18 = getelementptr %Pattern, %Pattern* %t15, i32 0, i32 2
  %t19 = getelementptr [9 x i8], [9 x i8]* @.str.410, i64 0, i64 0
  store i8* %t19, i8** %t18
  %t20 = ptrtoint %Pattern* %t15 to i64
  ret i64 %t20
  endif435:
  %t21 = load i64, i64* %t3
  %t22 = call i64 @Token_is_ident(i64 %t21)
  %t23 = icmp ne i64 %t22, 0
  br i1 %t23, label %then436, label %endif438
  then436:
  %t24 = load i64, i64* %t0
  %t25 = call i64 @Parser_advance(i64 %t24)
  %t26 = load i64, i64* %t3
  %t27 = inttoptr i64 %t26 to %Token*
  %t28 = getelementptr %Token, %Token* %t27, i32 0, i32 3
  %t29 = load i64, i64* %t28
  %t30 = alloca i64
  store i64 %t29, i64* %t30
  %t31 = load i64, i64* %t0
  %t32 = call i64 @Parser_peek(i64 %t31)
  %t33 = inttoptr i64 %t32 to %Token*
  %t34 = getelementptr %Token, %Token* %t33, i32 0, i32 3
  %t35 = load i64, i64* %t34
  %t36 = getelementptr [2 x i8], [2 x i8]* @.str.411, i64 0, i64 0
  %t37 = ptrtoint i8* %t36 to i64
  %t38 = call i64 @kore_str_eq(i64 %t35, i64 %t37)
  %t39 = icmp ne i64 %t38, 0
  br i1 %t39, label %then439, label %endif441
  then439:
  %t40 = load i64, i64* %t0
  %t41 = call i64 @Parser_advance(i64 %t40)
  %t42 = call i64 @kore_array_new()
  %t43 = alloca i64
  store i64 %t42, i64* %t43
  br label %while_cond442
  while_cond442:
  %t44 = load i64, i64* %t0
  %t45 = call i64 @Parser_peek(i64 %t44)
  %t46 = inttoptr i64 %t45 to %Token*
  %t47 = getelementptr %Token, %Token* %t46, i32 0, i32 3
  %t48 = load i64, i64* %t47
  %t49 = getelementptr [2 x i8], [2 x i8]* @.str.412, i64 0, i64 0
  %t50 = ptrtoint i8* %t49 to i64
  %t52 = call i64 @kore_str_eq(i64 %t48, i64 %t50)
  %t53 = icmp eq i64 %t52, 0
  %t51 = zext i1 %t53 to i64
  %t54 = icmp ne i64 %t51, 0
  br i1 %t54, label %while_body443, label %while_end444
  while_body443:
  %t55 = load i64, i64* %t43
  %t56 = load i64, i64* %t0
  %t57 = call i64 @Parser_parse_pattern(i64 %t56)
  %t58 = call i64 @kore_array_push(i64 %t55, i64 %t57)
  %t59 = load i64, i64* %t0
  %t60 = call i64 @Parser_peek(i64 %t59)
  %t61 = inttoptr i64 %t60 to %Token*
  %t62 = getelementptr %Token, %Token* %t61, i32 0, i32 3
  %t63 = load i64, i64* %t62
  %t64 = getelementptr [2 x i8], [2 x i8]* @.str.413, i64 0, i64 0
  %t65 = ptrtoint i8* %t64 to i64
  %t66 = call i64 @kore_str_eq(i64 %t63, i64 %t65)
  %t67 = icmp ne i64 %t66, 0
  br i1 %t67, label %then445, label %endif447
  then445:
  %t68 = load i64, i64* %t0
  %t69 = call i64 @Parser_advance(i64 %t68)
  br label %endif447
  endif447:
  br label %while_cond442
  while_end444:
  %t70 = load i64, i64* %t0
  %t71 = call i64 @Parser_advance(i64 %t70)
  ; enum variant: Pattern::Variant
  %t72 = call i8* @malloc(i64 24)
  %t73 = bitcast i8* %t72 to %Pattern*
  %t74 = getelementptr %Pattern, %Pattern* %t73, i32 0, i32 0
  store i64 3, i64* %t74
  %t75 = call i8* @malloc(i64 16)
  %t76 = bitcast i8* %t75 to i64*
  %t77 = load i64, i64* %t30
  %t78 = getelementptr i64, i64* %t76, i32 0
  store i64 %t77, i64* %t78
  %t79 = load i64, i64* %t43
  %t80 = getelementptr i64, i64* %t76, i32 1
  store i64 %t79, i64* %t80
  %t81 = getelementptr %Pattern, %Pattern* %t73, i32 0, i32 1
  store i8* %t75, i8** %t81
  %t82 = getelementptr %Pattern, %Pattern* %t73, i32 0, i32 2
  %t83 = getelementptr [8 x i8], [8 x i8]* @.str.414, i64 0, i64 0
  store i8* %t83, i8** %t82
  %t84 = ptrtoint %Pattern* %t73 to i64
  ret i64 %t84
  endif441:
  ; enum variant: Pattern::Ident
  %t85 = call i8* @malloc(i64 24)
  %t86 = bitcast i8* %t85 to %Pattern*
  %t87 = getelementptr %Pattern, %Pattern* %t86, i32 0, i32 0
  store i64 4, i64* %t87
  %t88 = call i8* @malloc(i64 8)
  %t89 = bitcast i8* %t88 to i64*
  %t90 = load i64, i64* %t30
  %t91 = getelementptr i64, i64* %t89, i32 0
  store i64 %t90, i64* %t91
  %t92 = getelementptr %Pattern, %Pattern* %t86, i32 0, i32 1
  store i8* %t88, i8** %t92
  %t93 = getelementptr %Pattern, %Pattern* %t86, i32 0, i32 2
  %t94 = getelementptr [6 x i8], [6 x i8]* @.str.415, i64 0, i64 0
  store i8* %t94, i8** %t93
  %t95 = ptrtoint %Pattern* %t86 to i64
  ret i64 %t95
  endif438:
  %t96 = load i64, i64* %t0
  %t97 = call i64 @Parser_parse_primary(i64 %t96)
  %t98 = alloca i64
  store i64 %t97, i64* %t98
  ; enum variant: Pattern::Literal
  %t99 = call i8* @malloc(i64 24)
  %t100 = bitcast i8* %t99 to %Pattern*
  %t101 = getelementptr %Pattern, %Pattern* %t100, i32 0, i32 0
  store i64 2, i64* %t101
  %t102 = call i8* @malloc(i64 8)
  %t103 = bitcast i8* %t102 to i64*
  %t104 = load i64, i64* %t98
  %t105 = getelementptr i64, i64* %t103, i32 0
  store i64 %t104, i64* %t105
  %t106 = getelementptr %Pattern, %Pattern* %t100, i32 0, i32 1
  store i8* %t102, i8** %t106
  %t107 = getelementptr %Pattern, %Pattern* %t100, i32 0, i32 2
  %t108 = getelementptr [8 x i8], [8 x i8]* @.str.416, i64 0, i64 0
  store i8* %t108, i8** %t107
  %t109 = ptrtoint %Pattern* %t100 to i64
  ret i64 %t109
}
define i64 @Parser_parse_expr(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_parse_or(i64 %t1)
  ret i64 %t2
}
define i64 @Parser_parse_or(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_parse_and(i64 %t1)
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  br label %while_cond448
  while_cond448:
  %t4 = load i64, i64* %t0
  %t5 = call i64 @Parser_peek(i64 %t4)
  %t6 = inttoptr i64 %t5 to %Token*
  %t7 = getelementptr %Token, %Token* %t6, i32 0, i32 3
  %t8 = load i64, i64* %t7
  %t9 = getelementptr [3 x i8], [3 x i8]* @.str.417, i64 0, i64 0
  %t10 = ptrtoint i8* %t9 to i64
  %t11 = call i64 @kore_str_eq(i64 %t8, i64 %t10)
  %t12 = icmp ne i64 %t11, 0
  br i1 %t12, label %while_body449, label %while_end450
  while_body449:
  %t13 = load i64, i64* %t0
  %t14 = call i64 @Parser_advance(i64 %t13)
  %t15 = load i64, i64* %t0
  %t16 = call i64 @Parser_parse_and(i64 %t15)
  %t17 = alloca i64
  store i64 %t16, i64* %t17
  ; enum variant: Expr::Binary
  %t18 = call i8* @malloc(i64 24)
  %t19 = bitcast i8* %t18 to %Expr*
  %t20 = getelementptr %Expr, %Expr* %t19, i32 0, i32 0
  store i64 6, i64* %t20
  %t21 = call i8* @malloc(i64 24)
  %t22 = bitcast i8* %t21 to i64*
  %t23 = load i64, i64* %t3
  %t24 = getelementptr i64, i64* %t22, i32 0
  store i64 %t23, i64* %t24
  %t25 = getelementptr [3 x i8], [3 x i8]* @.str.418, i64 0, i64 0
  %t26 = ptrtoint i8* %t25 to i64
  %t27 = getelementptr i64, i64* %t22, i32 1
  store i64 %t26, i64* %t27
  %t28 = load i64, i64* %t17
  %t29 = getelementptr i64, i64* %t22, i32 2
  store i64 %t28, i64* %t29
  %t30 = getelementptr %Expr, %Expr* %t19, i32 0, i32 1
  store i8* %t21, i8** %t30
  %t31 = getelementptr %Expr, %Expr* %t19, i32 0, i32 2
  %t32 = getelementptr [7 x i8], [7 x i8]* @.str.419, i64 0, i64 0
  store i8* %t32, i8** %t31
  %t33 = ptrtoint %Expr* %t19 to i64
  store i64 %t33, i64* %t3
  br label %while_cond448
  while_end450:
  %t34 = load i64, i64* %t3
  ret i64 %t34
}
define i64 @Parser_parse_and(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_parse_equality(i64 %t1)
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  br label %while_cond451
  while_cond451:
  %t4 = load i64, i64* %t0
  %t5 = call i64 @Parser_peek(i64 %t4)
  %t6 = inttoptr i64 %t5 to %Token*
  %t7 = getelementptr %Token, %Token* %t6, i32 0, i32 3
  %t8 = load i64, i64* %t7
  %t9 = getelementptr [3 x i8], [3 x i8]* @.str.420, i64 0, i64 0
  %t10 = ptrtoint i8* %t9 to i64
  %t11 = call i64 @kore_str_eq(i64 %t8, i64 %t10)
  %t12 = icmp ne i64 %t11, 0
  br i1 %t12, label %while_body452, label %while_end453
  while_body452:
  %t13 = load i64, i64* %t0
  %t14 = call i64 @Parser_advance(i64 %t13)
  %t15 = load i64, i64* %t0
  %t16 = call i64 @Parser_parse_equality(i64 %t15)
  %t17 = alloca i64
  store i64 %t16, i64* %t17
  ; enum variant: Expr::Binary
  %t18 = call i8* @malloc(i64 24)
  %t19 = bitcast i8* %t18 to %Expr*
  %t20 = getelementptr %Expr, %Expr* %t19, i32 0, i32 0
  store i64 6, i64* %t20
  %t21 = call i8* @malloc(i64 24)
  %t22 = bitcast i8* %t21 to i64*
  %t23 = load i64, i64* %t3
  %t24 = getelementptr i64, i64* %t22, i32 0
  store i64 %t23, i64* %t24
  %t25 = getelementptr [3 x i8], [3 x i8]* @.str.421, i64 0, i64 0
  %t26 = ptrtoint i8* %t25 to i64
  %t27 = getelementptr i64, i64* %t22, i32 1
  store i64 %t26, i64* %t27
  %t28 = load i64, i64* %t17
  %t29 = getelementptr i64, i64* %t22, i32 2
  store i64 %t28, i64* %t29
  %t30 = getelementptr %Expr, %Expr* %t19, i32 0, i32 1
  store i8* %t21, i8** %t30
  %t31 = getelementptr %Expr, %Expr* %t19, i32 0, i32 2
  %t32 = getelementptr [7 x i8], [7 x i8]* @.str.422, i64 0, i64 0
  store i8* %t32, i8** %t31
  %t33 = ptrtoint %Expr* %t19 to i64
  store i64 %t33, i64* %t3
  br label %while_cond451
  while_end453:
  %t34 = load i64, i64* %t3
  ret i64 %t34
}
define i64 @Parser_parse_equality(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_parse_comparison(i64 %t1)
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  br label %while_cond454
  while_cond454:
  %t4 = load i64, i64* %t0
  %t5 = call i64 @Parser_peek(i64 %t4)
  %t6 = inttoptr i64 %t5 to %Token*
  %t7 = getelementptr %Token, %Token* %t6, i32 0, i32 3
  %t8 = load i64, i64* %t7
  %t9 = getelementptr [3 x i8], [3 x i8]* @.str.423, i64 0, i64 0
  %t10 = ptrtoint i8* %t9 to i64
  %t11 = call i64 @kore_str_eq(i64 %t8, i64 %t10)
  %t12 = load i64, i64* %t0
  %t13 = call i64 @Parser_peek(i64 %t12)
  %t14 = inttoptr i64 %t13 to %Token*
  %t15 = getelementptr %Token, %Token* %t14, i32 0, i32 3
  %t16 = load i64, i64* %t15
  %t17 = getelementptr [3 x i8], [3 x i8]* @.str.424, i64 0, i64 0
  %t18 = ptrtoint i8* %t17 to i64
  %t19 = call i64 @kore_str_eq(i64 %t16, i64 %t18)
  %t20 = or i64 %t11, %t19
  %t21 = icmp ne i64 %t20, 0
  br i1 %t21, label %while_body455, label %while_end456
  while_body455:
  %t22 = load i64, i64* %t0
  %t23 = call i64 @Parser_advance(i64 %t22)
  %t24 = inttoptr i64 %t23 to %Token*
  %t25 = getelementptr %Token, %Token* %t24, i32 0, i32 3
  %t26 = load i64, i64* %t25
  %t27 = alloca i64
  store i64 %t26, i64* %t27
  %t28 = load i64, i64* %t0
  %t29 = call i64 @Parser_parse_comparison(i64 %t28)
  %t30 = alloca i64
  store i64 %t29, i64* %t30
  ; enum variant: Expr::Binary
  %t31 = call i8* @malloc(i64 24)
  %t32 = bitcast i8* %t31 to %Expr*
  %t33 = getelementptr %Expr, %Expr* %t32, i32 0, i32 0
  store i64 6, i64* %t33
  %t34 = call i8* @malloc(i64 24)
  %t35 = bitcast i8* %t34 to i64*
  %t36 = load i64, i64* %t3
  %t37 = getelementptr i64, i64* %t35, i32 0
  store i64 %t36, i64* %t37
  %t38 = load i64, i64* %t27
  %t39 = getelementptr i64, i64* %t35, i32 1
  store i64 %t38, i64* %t39
  %t40 = load i64, i64* %t30
  %t41 = getelementptr i64, i64* %t35, i32 2
  store i64 %t40, i64* %t41
  %t42 = getelementptr %Expr, %Expr* %t32, i32 0, i32 1
  store i8* %t34, i8** %t42
  %t43 = getelementptr %Expr, %Expr* %t32, i32 0, i32 2
  %t44 = getelementptr [7 x i8], [7 x i8]* @.str.425, i64 0, i64 0
  store i8* %t44, i8** %t43
  %t45 = ptrtoint %Expr* %t32 to i64
  store i64 %t45, i64* %t3
  br label %while_cond454
  while_end456:
  %t46 = load i64, i64* %t3
  ret i64 %t46
}
define i64 @Parser_parse_comparison(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_parse_term(i64 %t1)
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  br label %while_cond457
  while_cond457:
  %t4 = load i64, i64* %t0
  %t5 = call i64 @Parser_peek(i64 %t4)
  %t6 = inttoptr i64 %t5 to %Token*
  %t7 = getelementptr %Token, %Token* %t6, i32 0, i32 3
  %t8 = load i64, i64* %t7
  %t9 = getelementptr [2 x i8], [2 x i8]* @.str.426, i64 0, i64 0
  %t10 = ptrtoint i8* %t9 to i64
  %t11 = call i64 @kore_str_eq(i64 %t8, i64 %t10)
  %t12 = load i64, i64* %t0
  %t13 = call i64 @Parser_peek(i64 %t12)
  %t14 = inttoptr i64 %t13 to %Token*
  %t15 = getelementptr %Token, %Token* %t14, i32 0, i32 3
  %t16 = load i64, i64* %t15
  %t17 = getelementptr [2 x i8], [2 x i8]* @.str.427, i64 0, i64 0
  %t18 = ptrtoint i8* %t17 to i64
  %t19 = call i64 @kore_str_eq(i64 %t16, i64 %t18)
  %t20 = or i64 %t11, %t19
  %t21 = load i64, i64* %t0
  %t22 = call i64 @Parser_peek(i64 %t21)
  %t23 = inttoptr i64 %t22 to %Token*
  %t24 = getelementptr %Token, %Token* %t23, i32 0, i32 3
  %t25 = load i64, i64* %t24
  %t26 = getelementptr [3 x i8], [3 x i8]* @.str.428, i64 0, i64 0
  %t27 = ptrtoint i8* %t26 to i64
  %t28 = call i64 @kore_str_eq(i64 %t25, i64 %t27)
  %t29 = or i64 %t20, %t28
  %t30 = load i64, i64* %t0
  %t31 = call i64 @Parser_peek(i64 %t30)
  %t32 = inttoptr i64 %t31 to %Token*
  %t33 = getelementptr %Token, %Token* %t32, i32 0, i32 3
  %t34 = load i64, i64* %t33
  %t35 = getelementptr [3 x i8], [3 x i8]* @.str.429, i64 0, i64 0
  %t36 = ptrtoint i8* %t35 to i64
  %t37 = call i64 @kore_str_eq(i64 %t34, i64 %t36)
  %t38 = or i64 %t29, %t37
  %t39 = icmp ne i64 %t38, 0
  br i1 %t39, label %while_body458, label %while_end459
  while_body458:
  %t40 = load i64, i64* %t0
  %t41 = call i64 @Parser_advance(i64 %t40)
  %t42 = inttoptr i64 %t41 to %Token*
  %t43 = getelementptr %Token, %Token* %t42, i32 0, i32 3
  %t44 = load i64, i64* %t43
  %t45 = alloca i64
  store i64 %t44, i64* %t45
  %t46 = load i64, i64* %t0
  %t47 = call i64 @Parser_parse_term(i64 %t46)
  %t48 = alloca i64
  store i64 %t47, i64* %t48
  ; enum variant: Expr::Binary
  %t49 = call i8* @malloc(i64 24)
  %t50 = bitcast i8* %t49 to %Expr*
  %t51 = getelementptr %Expr, %Expr* %t50, i32 0, i32 0
  store i64 6, i64* %t51
  %t52 = call i8* @malloc(i64 24)
  %t53 = bitcast i8* %t52 to i64*
  %t54 = load i64, i64* %t3
  %t55 = getelementptr i64, i64* %t53, i32 0
  store i64 %t54, i64* %t55
  %t56 = load i64, i64* %t45
  %t57 = getelementptr i64, i64* %t53, i32 1
  store i64 %t56, i64* %t57
  %t58 = load i64, i64* %t48
  %t59 = getelementptr i64, i64* %t53, i32 2
  store i64 %t58, i64* %t59
  %t60 = getelementptr %Expr, %Expr* %t50, i32 0, i32 1
  store i8* %t52, i8** %t60
  %t61 = getelementptr %Expr, %Expr* %t50, i32 0, i32 2
  %t62 = getelementptr [7 x i8], [7 x i8]* @.str.430, i64 0, i64 0
  store i8* %t62, i8** %t61
  %t63 = ptrtoint %Expr* %t50 to i64
  store i64 %t63, i64* %t3
  br label %while_cond457
  while_end459:
  %t64 = load i64, i64* %t3
  ret i64 %t64
}
define i64 @Parser_parse_term(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_parse_factor(i64 %t1)
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  br label %while_cond460
  while_cond460:
  %t4 = load i64, i64* %t0
  %t5 = call i64 @Parser_peek(i64 %t4)
  %t6 = inttoptr i64 %t5 to %Token*
  %t7 = getelementptr %Token, %Token* %t6, i32 0, i32 3
  %t8 = load i64, i64* %t7
  %t9 = getelementptr [2 x i8], [2 x i8]* @.str.431, i64 0, i64 0
  %t10 = ptrtoint i8* %t9 to i64
  %t11 = call i64 @kore_str_eq(i64 %t8, i64 %t10)
  %t12 = load i64, i64* %t0
  %t13 = call i64 @Parser_peek(i64 %t12)
  %t14 = inttoptr i64 %t13 to %Token*
  %t15 = getelementptr %Token, %Token* %t14, i32 0, i32 3
  %t16 = load i64, i64* %t15
  %t17 = getelementptr [2 x i8], [2 x i8]* @.str.432, i64 0, i64 0
  %t18 = ptrtoint i8* %t17 to i64
  %t19 = call i64 @kore_str_eq(i64 %t16, i64 %t18)
  %t20 = or i64 %t11, %t19
  %t21 = icmp ne i64 %t20, 0
  br i1 %t21, label %while_body461, label %while_end462
  while_body461:
  %t22 = load i64, i64* %t0
  %t23 = call i64 @Parser_advance(i64 %t22)
  %t24 = inttoptr i64 %t23 to %Token*
  %t25 = getelementptr %Token, %Token* %t24, i32 0, i32 3
  %t26 = load i64, i64* %t25
  %t27 = alloca i64
  store i64 %t26, i64* %t27
  %t28 = load i64, i64* %t0
  %t29 = call i64 @Parser_parse_factor(i64 %t28)
  %t30 = alloca i64
  store i64 %t29, i64* %t30
  ; enum variant: Expr::Binary
  %t31 = call i8* @malloc(i64 24)
  %t32 = bitcast i8* %t31 to %Expr*
  %t33 = getelementptr %Expr, %Expr* %t32, i32 0, i32 0
  store i64 6, i64* %t33
  %t34 = call i8* @malloc(i64 24)
  %t35 = bitcast i8* %t34 to i64*
  %t36 = load i64, i64* %t3
  %t37 = getelementptr i64, i64* %t35, i32 0
  store i64 %t36, i64* %t37
  %t38 = load i64, i64* %t27
  %t39 = getelementptr i64, i64* %t35, i32 1
  store i64 %t38, i64* %t39
  %t40 = load i64, i64* %t30
  %t41 = getelementptr i64, i64* %t35, i32 2
  store i64 %t40, i64* %t41
  %t42 = getelementptr %Expr, %Expr* %t32, i32 0, i32 1
  store i8* %t34, i8** %t42
  %t43 = getelementptr %Expr, %Expr* %t32, i32 0, i32 2
  %t44 = getelementptr [7 x i8], [7 x i8]* @.str.433, i64 0, i64 0
  store i8* %t44, i8** %t43
  %t45 = ptrtoint %Expr* %t32 to i64
  store i64 %t45, i64* %t3
  br label %while_cond460
  while_end462:
  %t46 = load i64, i64* %t3
  ret i64 %t46
}
define i64 @Parser_parse_factor(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_parse_unary(i64 %t1)
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  br label %while_cond463
  while_cond463:
  %t4 = load i64, i64* %t0
  %t5 = call i64 @Parser_peek(i64 %t4)
  %t6 = inttoptr i64 %t5 to %Token*
  %t7 = getelementptr %Token, %Token* %t6, i32 0, i32 3
  %t8 = load i64, i64* %t7
  %t9 = getelementptr [2 x i8], [2 x i8]* @.str.434, i64 0, i64 0
  %t10 = ptrtoint i8* %t9 to i64
  %t11 = call i64 @kore_str_eq(i64 %t8, i64 %t10)
  %t12 = load i64, i64* %t0
  %t13 = call i64 @Parser_peek(i64 %t12)
  %t14 = inttoptr i64 %t13 to %Token*
  %t15 = getelementptr %Token, %Token* %t14, i32 0, i32 3
  %t16 = load i64, i64* %t15
  %t17 = getelementptr [2 x i8], [2 x i8]* @.str.435, i64 0, i64 0
  %t18 = ptrtoint i8* %t17 to i64
  %t19 = call i64 @kore_str_eq(i64 %t16, i64 %t18)
  %t20 = or i64 %t11, %t19
  %t21 = load i64, i64* %t0
  %t22 = call i64 @Parser_peek(i64 %t21)
  %t23 = inttoptr i64 %t22 to %Token*
  %t24 = getelementptr %Token, %Token* %t23, i32 0, i32 3
  %t25 = load i64, i64* %t24
  %t26 = getelementptr [2 x i8], [2 x i8]* @.str.436, i64 0, i64 0
  %t27 = ptrtoint i8* %t26 to i64
  %t28 = call i64 @kore_str_eq(i64 %t25, i64 %t27)
  %t29 = or i64 %t20, %t28
  %t30 = icmp ne i64 %t29, 0
  br i1 %t30, label %while_body464, label %while_end465
  while_body464:
  %t31 = load i64, i64* %t0
  %t32 = call i64 @Parser_advance(i64 %t31)
  %t33 = inttoptr i64 %t32 to %Token*
  %t34 = getelementptr %Token, %Token* %t33, i32 0, i32 3
  %t35 = load i64, i64* %t34
  %t36 = alloca i64
  store i64 %t35, i64* %t36
  %t37 = load i64, i64* %t0
  %t38 = call i64 @Parser_parse_unary(i64 %t37)
  %t39 = alloca i64
  store i64 %t38, i64* %t39
  ; enum variant: Expr::Binary
  %t40 = call i8* @malloc(i64 24)
  %t41 = bitcast i8* %t40 to %Expr*
  %t42 = getelementptr %Expr, %Expr* %t41, i32 0, i32 0
  store i64 6, i64* %t42
  %t43 = call i8* @malloc(i64 24)
  %t44 = bitcast i8* %t43 to i64*
  %t45 = load i64, i64* %t3
  %t46 = getelementptr i64, i64* %t44, i32 0
  store i64 %t45, i64* %t46
  %t47 = load i64, i64* %t36
  %t48 = getelementptr i64, i64* %t44, i32 1
  store i64 %t47, i64* %t48
  %t49 = load i64, i64* %t39
  %t50 = getelementptr i64, i64* %t44, i32 2
  store i64 %t49, i64* %t50
  %t51 = getelementptr %Expr, %Expr* %t41, i32 0, i32 1
  store i8* %t43, i8** %t51
  %t52 = getelementptr %Expr, %Expr* %t41, i32 0, i32 2
  %t53 = getelementptr [7 x i8], [7 x i8]* @.str.437, i64 0, i64 0
  store i8* %t53, i8** %t52
  %t54 = ptrtoint %Expr* %t41 to i64
  store i64 %t54, i64* %t3
  br label %while_cond463
  while_end465:
  %t55 = load i64, i64* %t3
  ret i64 %t55
}
define i64 @Parser_parse_unary(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_peek(i64 %t1)
  %t3 = inttoptr i64 %t2 to %Token*
  %t4 = getelementptr %Token, %Token* %t3, i32 0, i32 3
  %t5 = load i64, i64* %t4
  %t6 = getelementptr [2 x i8], [2 x i8]* @.str.438, i64 0, i64 0
  %t7 = ptrtoint i8* %t6 to i64
  %t8 = call i64 @kore_str_eq(i64 %t5, i64 %t7)
  %t9 = load i64, i64* %t0
  %t10 = call i64 @Parser_peek(i64 %t9)
  %t11 = inttoptr i64 %t10 to %Token*
  %t12 = getelementptr %Token, %Token* %t11, i32 0, i32 3
  %t13 = load i64, i64* %t12
  %t14 = getelementptr [2 x i8], [2 x i8]* @.str.439, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  %t16 = call i64 @kore_str_eq(i64 %t13, i64 %t15)
  %t17 = or i64 %t8, %t16
  %t18 = icmp ne i64 %t17, 0
  br i1 %t18, label %then466, label %endif468
  then466:
  %t19 = load i64, i64* %t0
  %t20 = call i64 @Parser_advance(i64 %t19)
  %t21 = inttoptr i64 %t20 to %Token*
  %t22 = getelementptr %Token, %Token* %t21, i32 0, i32 3
  %t23 = load i64, i64* %t22
  %t24 = alloca i64
  store i64 %t23, i64* %t24
  %t25 = load i64, i64* %t0
  %t26 = call i64 @Parser_parse_unary(i64 %t25)
  %t27 = alloca i64
  store i64 %t26, i64* %t27
  ; enum variant: Expr::Unary
  %t28 = call i8* @malloc(i64 24)
  %t29 = bitcast i8* %t28 to %Expr*
  %t30 = getelementptr %Expr, %Expr* %t29, i32 0, i32 0
  store i64 7, i64* %t30
  %t31 = call i8* @malloc(i64 16)
  %t32 = bitcast i8* %t31 to i64*
  %t33 = load i64, i64* %t24
  %t34 = getelementptr i64, i64* %t32, i32 0
  store i64 %t33, i64* %t34
  %t35 = load i64, i64* %t27
  %t36 = getelementptr i64, i64* %t32, i32 1
  store i64 %t35, i64* %t36
  %t37 = getelementptr %Expr, %Expr* %t29, i32 0, i32 1
  store i8* %t31, i8** %t37
  %t38 = getelementptr %Expr, %Expr* %t29, i32 0, i32 2
  %t39 = getelementptr [6 x i8], [6 x i8]* @.str.440, i64 0, i64 0
  store i8* %t39, i8** %t38
  %t40 = ptrtoint %Expr* %t29 to i64
  ret i64 %t40
  endif468:
  %t41 = load i64, i64* %t0
  %t42 = call i64 @Parser_parse_postfix(i64 %t41)
  ret i64 %t42
}
define i64 @Parser_parse_postfix(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_parse_primary(i64 %t1)
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  br label %loop469
  loop469:
  %t4 = load i64, i64* %t0
  %t5 = call i64 @Parser_peek(i64 %t4)
  %t6 = inttoptr i64 %t5 to %Token*
  %t7 = getelementptr %Token, %Token* %t6, i32 0, i32 3
  %t8 = load i64, i64* %t7
  %t9 = alloca i64
  store i64 %t8, i64* %t9
  %t10 = load i64, i64* %t9
  %t11 = getelementptr [2 x i8], [2 x i8]* @.str.441, i64 0, i64 0
  %t12 = ptrtoint i8* %t11 to i64
  %t13 = call i64 @kore_str_eq(i64 %t10, i64 %t12)
  %t14 = icmp ne i64 %t13, 0
  br i1 %t14, label %then471, label %endif473
  then471:
  %t15 = load i64, i64* %t0
  %t16 = call i64 @Parser_advance(i64 %t15)
  %t17 = load i64, i64* %t0
  %t18 = call i64 @Parser_advance(i64 %t17)
  %t19 = inttoptr i64 %t18 to %Token*
  %t20 = getelementptr %Token, %Token* %t19, i32 0, i32 3
  %t21 = load i64, i64* %t20
  %t22 = alloca i64
  store i64 %t21, i64* %t22
  %t23 = load i64, i64* %t0
  %t24 = call i64 @Parser_peek(i64 %t23)
  %t25 = inttoptr i64 %t24 to %Token*
  %t26 = getelementptr %Token, %Token* %t25, i32 0, i32 3
  %t27 = load i64, i64* %t26
  %t28 = getelementptr [2 x i8], [2 x i8]* @.str.442, i64 0, i64 0
  %t29 = ptrtoint i8* %t28 to i64
  %t30 = call i64 @kore_str_eq(i64 %t27, i64 %t29)
  %t31 = icmp ne i64 %t30, 0
  br i1 %t31, label %then474, label %else475
  then474:
  %t32 = load i64, i64* %t0
  %t33 = call i64 @Parser_advance(i64 %t32)
  %t34 = load i64, i64* %t0
  %t35 = call i64 @Parser_parse_args(i64 %t34)
  %t36 = alloca i64
  store i64 %t35, i64* %t36
  %t37 = load i64, i64* %t0
  %t38 = call i64 @Parser_advance(i64 %t37)
  ; enum variant: Expr::MethodCall
  %t39 = call i8* @malloc(i64 24)
  %t40 = bitcast i8* %t39 to %Expr*
  %t41 = getelementptr %Expr, %Expr* %t40, i32 0, i32 0
  store i64 9, i64* %t41
  %t42 = call i8* @malloc(i64 24)
  %t43 = bitcast i8* %t42 to i64*
  %t44 = load i64, i64* %t3
  %t45 = getelementptr i64, i64* %t43, i32 0
  store i64 %t44, i64* %t45
  %t46 = load i64, i64* %t22
  %t47 = getelementptr i64, i64* %t43, i32 1
  store i64 %t46, i64* %t47
  %t48 = load i64, i64* %t36
  %t49 = getelementptr i64, i64* %t43, i32 2
  store i64 %t48, i64* %t49
  %t50 = getelementptr %Expr, %Expr* %t40, i32 0, i32 1
  store i8* %t42, i8** %t50
  %t51 = getelementptr %Expr, %Expr* %t40, i32 0, i32 2
  %t52 = getelementptr [11 x i8], [11 x i8]* @.str.443, i64 0, i64 0
  store i8* %t52, i8** %t51
  %t53 = ptrtoint %Expr* %t40 to i64
  store i64 %t53, i64* %t3
  br label %endif476
  else475:
  ; enum variant: Expr::Field
  %t54 = call i8* @malloc(i64 24)
  %t55 = bitcast i8* %t54 to %Expr*
  %t56 = getelementptr %Expr, %Expr* %t55, i32 0, i32 0
  store i64 11, i64* %t56
  %t57 = call i8* @malloc(i64 16)
  %t58 = bitcast i8* %t57 to i64*
  %t59 = load i64, i64* %t3
  %t60 = getelementptr i64, i64* %t58, i32 0
  store i64 %t59, i64* %t60
  %t61 = load i64, i64* %t22
  %t62 = getelementptr i64, i64* %t58, i32 1
  store i64 %t61, i64* %t62
  %t63 = getelementptr %Expr, %Expr* %t55, i32 0, i32 1
  store i8* %t57, i8** %t63
  %t64 = getelementptr %Expr, %Expr* %t55, i32 0, i32 2
  %t65 = getelementptr [6 x i8], [6 x i8]* @.str.444, i64 0, i64 0
  store i8* %t65, i8** %t64
  %t66 = ptrtoint %Expr* %t55 to i64
  store i64 %t66, i64* %t3
  br label %endif476
  endif476:
  br label %loop469
  endif473:
  %t67 = load i64, i64* %t9
  %t68 = getelementptr [2 x i8], [2 x i8]* @.str.445, i64 0, i64 0
  %t69 = ptrtoint i8* %t68 to i64
  %t70 = call i64 @kore_str_eq(i64 %t67, i64 %t69)
  %t71 = icmp ne i64 %t70, 0
  br i1 %t71, label %then477, label %endif479
  then477:
  %t72 = load i64, i64* %t0
  %t73 = call i64 @Parser_advance(i64 %t72)
  %t74 = load i64, i64* %t0
  %t75 = call i64 @Parser_parse_expr(i64 %t74)
  %t76 = alloca i64
  store i64 %t75, i64* %t76
  %t77 = load i64, i64* %t0
  %t78 = call i64 @Parser_advance(i64 %t77)
  ; enum variant: Expr::Index
  %t79 = call i8* @malloc(i64 24)
  %t80 = bitcast i8* %t79 to %Expr*
  %t81 = getelementptr %Expr, %Expr* %t80, i32 0, i32 0
  store i64 10, i64* %t81
  %t82 = call i8* @malloc(i64 16)
  %t83 = bitcast i8* %t82 to i64*
  %t84 = load i64, i64* %t3
  %t85 = getelementptr i64, i64* %t83, i32 0
  store i64 %t84, i64* %t85
  %t86 = load i64, i64* %t76
  %t87 = getelementptr i64, i64* %t83, i32 1
  store i64 %t86, i64* %t87
  %t88 = getelementptr %Expr, %Expr* %t80, i32 0, i32 1
  store i8* %t82, i8** %t88
  %t89 = getelementptr %Expr, %Expr* %t80, i32 0, i32 2
  %t90 = getelementptr [6 x i8], [6 x i8]* @.str.446, i64 0, i64 0
  store i8* %t90, i8** %t89
  %t91 = ptrtoint %Expr* %t80 to i64
  store i64 %t91, i64* %t3
  br label %loop469
  endif479:
  %t92 = load i64, i64* %t9
  %t93 = getelementptr [2 x i8], [2 x i8]* @.str.447, i64 0, i64 0
  %t94 = ptrtoint i8* %t93 to i64
  %t95 = call i64 @kore_str_eq(i64 %t92, i64 %t94)
  %t96 = icmp ne i64 %t95, 0
  br i1 %t96, label %then480, label %endif482
  then480:
  %t97 = load i64, i64* %t0
  %t98 = call i64 @Parser_advance(i64 %t97)
  %t99 = load i64, i64* %t0
  %t100 = call i64 @Parser_parse_args(i64 %t99)
  %t101 = alloca i64
  store i64 %t100, i64* %t101
  %t102 = load i64, i64* %t0
  %t103 = call i64 @Parser_advance(i64 %t102)
  ; enum variant: Expr::Call
  %t104 = call i8* @malloc(i64 24)
  %t105 = bitcast i8* %t104 to %Expr*
  %t106 = getelementptr %Expr, %Expr* %t105, i32 0, i32 0
  store i64 8, i64* %t106
  %t107 = call i8* @malloc(i64 16)
  %t108 = bitcast i8* %t107 to i64*
  %t109 = load i64, i64* %t3
  %t110 = getelementptr i64, i64* %t108, i32 0
  store i64 %t109, i64* %t110
  %t111 = load i64, i64* %t101
  %t112 = getelementptr i64, i64* %t108, i32 1
  store i64 %t111, i64* %t112
  %t113 = getelementptr %Expr, %Expr* %t105, i32 0, i32 1
  store i8* %t107, i8** %t113
  %t114 = getelementptr %Expr, %Expr* %t105, i32 0, i32 2
  %t115 = getelementptr [5 x i8], [5 x i8]* @.str.448, i64 0, i64 0
  store i8* %t115, i8** %t114
  %t116 = ptrtoint %Expr* %t105 to i64
  store i64 %t116, i64* %t3
  br label %loop469
  endif482:
  br label %loop_end470
  loop_end470:
  %t117 = load i64, i64* %t3
  ret i64 %t117
}
define i64 @Parser_parse_args(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = call i64 @kore_array_new()
  %t2 = alloca i64
  store i64 %t1, i64* %t2
  br label %while_cond483
  while_cond483:
  %t3 = load i64, i64* %t0
  %t4 = call i64 @Parser_peek(i64 %t3)
  %t5 = inttoptr i64 %t4 to %Token*
  %t6 = getelementptr %Token, %Token* %t5, i32 0, i32 3
  %t7 = load i64, i64* %t6
  %t8 = getelementptr [2 x i8], [2 x i8]* @.str.449, i64 0, i64 0
  %t9 = ptrtoint i8* %t8 to i64
  %t11 = call i64 @kore_str_eq(i64 %t7, i64 %t9)
  %t12 = icmp eq i64 %t11, 0
  %t10 = zext i1 %t12 to i64
  %t13 = icmp ne i64 %t10, 0
  br i1 %t13, label %while_body484, label %while_end485
  while_body484:
  %t14 = load i64, i64* %t2
  %t15 = load i64, i64* %t0
  %t16 = call i64 @Parser_parse_expr(i64 %t15)
  %t17 = call i64 @kore_array_push(i64 %t14, i64 %t16)
  %t18 = load i64, i64* %t0
  %t19 = call i64 @Parser_peek(i64 %t18)
  %t20 = inttoptr i64 %t19 to %Token*
  %t21 = getelementptr %Token, %Token* %t20, i32 0, i32 3
  %t22 = load i64, i64* %t21
  %t23 = getelementptr [2 x i8], [2 x i8]* @.str.450, i64 0, i64 0
  %t24 = ptrtoint i8* %t23 to i64
  %t25 = call i64 @kore_str_eq(i64 %t22, i64 %t24)
  %t26 = icmp ne i64 %t25, 0
  br i1 %t26, label %then486, label %endif488
  then486:
  %t27 = load i64, i64* %t0
  %t28 = call i64 @Parser_advance(i64 %t27)
  br label %endif488
  endif488:
  br label %while_cond483
  while_end485:
  %t29 = load i64, i64* %t2
  ret i64 %t29
}
define i64 @Parser_parse_primary(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = call i64 @Parser_peek(i64 %t1)
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  %t4 = load i64, i64* %t3
  %t5 = inttoptr i64 %t4 to %Token*
  %t6 = getelementptr %Token, %Token* %t5, i32 0, i32 3
  %t7 = load i64, i64* %t6
  %t8 = getelementptr [2 x i8], [2 x i8]* @.str.451, i64 0, i64 0
  %t9 = ptrtoint i8* %t8 to i64
  %t10 = call i64 @kore_str_eq(i64 %t7, i64 %t9)
  %t11 = icmp ne i64 %t10, 0
  br i1 %t11, label %then489, label %endif491
  then489:
  %t12 = load i64, i64* %t0
  %t13 = call i64 @Parser_advance(i64 %t12)
  %t14 = load i64, i64* %t0
  %t15 = call i64 @Parser_parse_expr(i64 %t14)
  %t16 = alloca i64
  store i64 %t15, i64* %t16
  %t17 = load i64, i64* %t0
  %t18 = call i64 @Parser_advance(i64 %t17)
  %t19 = load i64, i64* %t16
  ret i64 %t19
  endif491:
  %t20 = load i64, i64* %t3
  %t21 = inttoptr i64 %t20 to %Token*
  %t22 = getelementptr %Token, %Token* %t21, i32 0, i32 3
  %t23 = load i64, i64* %t22
  %t24 = getelementptr [2 x i8], [2 x i8]* @.str.452, i64 0, i64 0
  %t25 = ptrtoint i8* %t24 to i64
  %t26 = call i64 @kore_str_eq(i64 %t23, i64 %t25)
  %t27 = icmp ne i64 %t26, 0
  br i1 %t27, label %then492, label %endif494
  then492:
  %t28 = load i64, i64* %t0
  %t29 = call i64 @Parser_advance(i64 %t28)
  %t30 = call i64 @kore_array_new()
  %t31 = alloca i64
  store i64 %t30, i64* %t31
  %t32 = load i64, i64* %t0
  %t33 = call i64 @Parser_skip_newlines(i64 %t32)
  br label %while_cond495
  while_cond495:
  %t34 = load i64, i64* %t0
  %t35 = call i64 @Parser_peek(i64 %t34)
  %t36 = inttoptr i64 %t35 to %Token*
  %t37 = getelementptr %Token, %Token* %t36, i32 0, i32 3
  %t38 = load i64, i64* %t37
  %t39 = getelementptr [2 x i8], [2 x i8]* @.str.453, i64 0, i64 0
  %t40 = ptrtoint i8* %t39 to i64
  %t42 = call i64 @kore_str_eq(i64 %t38, i64 %t40)
  %t43 = icmp eq i64 %t42, 0
  %t41 = zext i1 %t43 to i64
  %t44 = icmp ne i64 %t41, 0
  br i1 %t44, label %while_body496, label %while_end497
  while_body496:
  %t45 = load i64, i64* %t0
  %t46 = call i64 @Parser_peek(i64 %t45)
  %t47 = alloca i64
  store i64 %t46, i64* %t47
  %t48 = load i64, i64* %t47
  %t49 = call i64 @Token_is_indent(i64 %t48)
  %t50 = load i64, i64* %t47
  %t51 = call i64 @Token_is_dedent(i64 %t50)
  %t52 = or i64 %t49, %t51
  %t53 = load i64, i64* %t47
  %t54 = call i64 @Token_is_newline(i64 %t53)
  %t55 = or i64 %t52, %t54
  %t56 = icmp ne i64 %t55, 0
  br i1 %t56, label %then498, label %endif500
  then498:
  %t57 = load i64, i64* %t0
  %t58 = call i64 @Parser_advance(i64 %t57)
  br label %while_cond495
  endif500:
  %t59 = load i64, i64* %t31
  %t60 = load i64, i64* %t0
  %t61 = call i64 @Parser_parse_expr(i64 %t60)
  %t62 = call i64 @kore_array_push(i64 %t59, i64 %t61)
  %t63 = load i64, i64* %t0
  %t64 = call i64 @Parser_peek(i64 %t63)
  %t65 = inttoptr i64 %t64 to %Token*
  %t66 = getelementptr %Token, %Token* %t65, i32 0, i32 3
  %t67 = load i64, i64* %t66
  %t68 = getelementptr [2 x i8], [2 x i8]* @.str.454, i64 0, i64 0
  %t69 = ptrtoint i8* %t68 to i64
  %t70 = call i64 @kore_str_eq(i64 %t67, i64 %t69)
  %t71 = icmp ne i64 %t70, 0
  br i1 %t71, label %then501, label %endif503
  then501:
  %t72 = load i64, i64* %t0
  %t73 = call i64 @Parser_advance(i64 %t72)
  br label %endif503
  endif503:
  %t74 = load i64, i64* %t0
  %t75 = call i64 @Parser_skip_newlines(i64 %t74)
  br label %while_cond495
  while_end497:
  %t76 = load i64, i64* %t0
  %t77 = call i64 @Parser_advance(i64 %t76)
  ; enum variant: Expr::Array
  %t78 = call i8* @malloc(i64 24)
  %t79 = bitcast i8* %t78 to %Expr*
  %t80 = getelementptr %Expr, %Expr* %t79, i32 0, i32 0
  store i64 12, i64* %t80
  %t81 = call i8* @malloc(i64 8)
  %t82 = bitcast i8* %t81 to i64*
  %t83 = load i64, i64* %t31
  %t84 = getelementptr i64, i64* %t82, i32 0
  store i64 %t83, i64* %t84
  %t85 = getelementptr %Expr, %Expr* %t79, i32 0, i32 1
  store i8* %t81, i8** %t85
  %t86 = getelementptr %Expr, %Expr* %t79, i32 0, i32 2
  %t87 = getelementptr [6 x i8], [6 x i8]* @.str.455, i64 0, i64 0
  store i8* %t87, i8** %t86
  %t88 = ptrtoint %Expr* %t79 to i64
  ret i64 %t88
  endif494:
  %t89 = load i64, i64* %t0
  %t90 = call i64 @Parser_advance(i64 %t89)
  %t91 = load i64, i64* %t3
  %t92 = inttoptr i64 %t91 to %Token*
  %t93 = getelementptr %Token, %Token* %t92, i32 0, i32 3
  %t94 = load i64, i64* %t93
  %t95 = call i64 @kore_str_len(i64 %t94)
  %t97 = icmp sgt i64 %t95, 0
  %t96 = zext i1 %t97 to i64
  %t98 = icmp ne i64 %t96, 0
  br i1 %t98, label %then504, label %endif506
  then504:
  %t99 = load i64, i64* %t3
  %t100 = inttoptr i64 %t99 to %Token*
  %t101 = getelementptr %Token, %Token* %t100, i32 0, i32 3
  %t102 = load i64, i64* %t101
  %t103 = call i64 @kore_ord(i64 %t102)
  %t104 = alloca i64
  store i64 %t103, i64* %t104
  %t105 = load i64, i64* %t104
  %t107 = icmp sge i64 %t105, 48
  %t106 = zext i1 %t107 to i64
  %t108 = load i64, i64* %t104
  %t110 = icmp sle i64 %t108, 57
  %t109 = zext i1 %t110 to i64
  %t111 = and i64 %t106, %t109
  %t112 = alloca i64
  store i64 %t111, i64* %t112
  %t113 = load i64, i64* %t112
  %t114 = icmp ne i64 %t113, 0
  br i1 %t114, label %then507, label %endif509
  then507:
  ; enum variant: Expr::Int
  %t115 = call i8* @malloc(i64 24)
  %t116 = bitcast i8* %t115 to %Expr*
  %t117 = getelementptr %Expr, %Expr* %t116, i32 0, i32 0
  store i64 0, i64* %t117
  %t118 = call i8* @malloc(i64 8)
  %t119 = bitcast i8* %t118 to i64*
  %t120 = load i64, i64* %t3
  %t121 = inttoptr i64 %t120 to %Token*
  %t122 = getelementptr %Token, %Token* %t121, i32 0, i32 3
  %t123 = load i64, i64* %t122
  %t124 = call i64 @kore_to_int(i64 %t123)
  %t125 = getelementptr i64, i64* %t119, i32 0
  store i64 %t124, i64* %t125
  %t126 = getelementptr %Expr, %Expr* %t116, i32 0, i32 1
  store i8* %t118, i8** %t126
  %t127 = getelementptr %Expr, %Expr* %t116, i32 0, i32 2
  %t128 = getelementptr [4 x i8], [4 x i8]* @.str.456, i64 0, i64 0
  store i8* %t128, i8** %t127
  %t129 = ptrtoint %Expr* %t116 to i64
  ret i64 %t129
  endif509:
  br label %endif506
  endif506:
  %t130 = load i64, i64* %t3
  %t131 = inttoptr i64 %t130 to %Token*
  %t132 = getelementptr %Token, %Token* %t131, i32 0, i32 3
  %t133 = load i64, i64* %t132
  %t134 = getelementptr [1 x i8], [1 x i8]* @.str.457, i64 0, i64 0
  %t135 = ptrtoint i8* %t134 to i64
  %t136 = call i64 @kore_split(i64 %t133, i64 %t135)
  %t137 = getelementptr [2 x i8], [2 x i8]* @.str.458, i64 0, i64 0
  %t138 = ptrtoint i8* %t137 to i64
  %t139 = call i64 @kore_contains(i64 %t136, i64 %t138)
  %t140 = icmp ne i64 %t139, 0
  br i1 %t140, label %then510, label %endif512
  then510:
  %t141 = load i64, i64* %t3
  %t142 = inttoptr i64 %t141 to %Token*
  %t143 = getelementptr %Token, %Token* %t142, i32 0, i32 3
  %t144 = load i64, i64* %t143
  %t145 = call i64 @kore_ord(i64 %t144)
  %t146 = alloca i64
  store i64 %t145, i64* %t146
  %t147 = load i64, i64* %t146
  %t149 = icmp sge i64 %t147, 48
  %t148 = zext i1 %t149 to i64
  %t150 = load i64, i64* %t146
  %t152 = icmp sle i64 %t150, 57
  %t151 = zext i1 %t152 to i64
  %t153 = and i64 %t148, %t151
  %t154 = alloca i64
  store i64 %t153, i64* %t154
  %t155 = load i64, i64* %t154
  %t156 = icmp ne i64 %t155, 0
  br i1 %t156, label %then513, label %endif515
  then513:
  ; enum variant: Expr::Float
  %t157 = call i8* @malloc(i64 24)
  %t158 = bitcast i8* %t157 to %Expr*
  %t159 = getelementptr %Expr, %Expr* %t158, i32 0, i32 0
  store i64 1, i64* %t159
  %t160 = call i8* @malloc(i64 8)
  %t161 = bitcast i8* %t160 to i64*
  %t162 = load i64, i64* %t3
  %t163 = inttoptr i64 %t162 to %Token*
  %t164 = getelementptr %Token, %Token* %t163, i32 0, i32 3
  %t165 = load i64, i64* %t164
  %t166 = call i64 @kore_to_float(i64 %t165)
  %t167 = getelementptr i64, i64* %t161, i32 0
  store i64 %t166, i64* %t167
  %t168 = getelementptr %Expr, %Expr* %t158, i32 0, i32 1
  store i8* %t160, i8** %t168
  %t169 = getelementptr %Expr, %Expr* %t158, i32 0, i32 2
  %t170 = getelementptr [6 x i8], [6 x i8]* @.str.459, i64 0, i64 0
  store i8* %t170, i8** %t169
  %t171 = ptrtoint %Expr* %t158 to i64
  ret i64 %t171
  endif515:
  br label %endif512
  endif512:
  %t172 = load i64, i64* %t3
  %t173 = inttoptr i64 %t172 to %Token*
  %t174 = getelementptr %Token, %Token* %t173, i32 0, i32 3
  %t175 = load i64, i64* %t174
  %t176 = call i64 @kore_str_len(i64 %t175)
  %t178 = icmp sgt i64 %t176, 0
  %t177 = zext i1 %t178 to i64
  %t179 = icmp ne i64 %t177, 0
  br i1 %t179, label %then516, label %endif518
  then516:
  %t180 = load i64, i64* %t3
  %t181 = inttoptr i64 %t180 to %Token*
  %t182 = getelementptr %Token, %Token* %t181, i32 0, i32 3
  %t183 = load i64, i64* %t182
  %t184 = call i64 @kore_ord(i64 %t183)
  %t185 = alloca i64
  store i64 %t184, i64* %t185
  %t186 = load i64, i64* %t185
  %t187 = call i64 @kore_str_eq(i64 %t186, i64 34)
  %t188 = load i64, i64* %t185
  %t189 = call i64 @kore_str_eq(i64 %t188, i64 39)
  %t190 = or i64 %t187, %t189
  %t191 = icmp ne i64 %t190, 0
  br i1 %t191, label %then519, label %endif521
  then519:
  ; enum variant: Expr::String
  %t192 = call i8* @malloc(i64 24)
  %t193 = bitcast i8* %t192 to %Expr*
  %t194 = getelementptr %Expr, %Expr* %t193, i32 0, i32 0
  store i64 2, i64* %t194
  %t195 = call i8* @malloc(i64 8)
  %t196 = bitcast i8* %t195 to i64*
  %t197 = load i64, i64* %t3
  %t198 = inttoptr i64 %t197 to %Token*
  %t199 = getelementptr %Token, %Token* %t198, i32 0, i32 3
  %t200 = load i64, i64* %t199
  %t201 = getelementptr i64, i64* %t196, i32 0
  store i64 %t200, i64* %t201
  %t202 = getelementptr %Expr, %Expr* %t193, i32 0, i32 1
  store i8* %t195, i8** %t202
  %t203 = getelementptr %Expr, %Expr* %t193, i32 0, i32 2
  %t204 = getelementptr [7 x i8], [7 x i8]* @.str.460, i64 0, i64 0
  store i8* %t204, i8** %t203
  %t205 = ptrtoint %Expr* %t193 to i64
  ret i64 %t205
  endif521:
  br label %endif518
  endif518:
  %t206 = load i64, i64* %t3
  %t207 = inttoptr i64 %t206 to %Token*
  %t208 = getelementptr %Token, %Token* %t207, i32 0, i32 3
  %t209 = load i64, i64* %t208
  %t210 = getelementptr [5 x i8], [5 x i8]* @.str.461, i64 0, i64 0
  %t211 = ptrtoint i8* %t210 to i64
  %t212 = call i64 @kore_str_eq(i64 %t209, i64 %t211)
  %t213 = icmp ne i64 %t212, 0
  br i1 %t213, label %then522, label %endif524
  then522:
  ; enum variant: Expr::Bool
  %t214 = call i8* @malloc(i64 24)
  %t215 = bitcast i8* %t214 to %Expr*
  %t216 = getelementptr %Expr, %Expr* %t215, i32 0, i32 0
  store i64 3, i64* %t216
  %t217 = call i8* @malloc(i64 8)
  %t218 = bitcast i8* %t217 to i64*
  %t219 = getelementptr i64, i64* %t218, i32 0
  store i64 1, i64* %t219
  %t220 = getelementptr %Expr, %Expr* %t215, i32 0, i32 1
  store i8* %t217, i8** %t220
  %t221 = getelementptr %Expr, %Expr* %t215, i32 0, i32 2
  %t222 = getelementptr [5 x i8], [5 x i8]* @.str.462, i64 0, i64 0
  store i8* %t222, i8** %t221
  %t223 = ptrtoint %Expr* %t215 to i64
  ret i64 %t223
  endif524:
  %t224 = load i64, i64* %t3
  %t225 = inttoptr i64 %t224 to %Token*
  %t226 = getelementptr %Token, %Token* %t225, i32 0, i32 3
  %t227 = load i64, i64* %t226
  %t228 = getelementptr [6 x i8], [6 x i8]* @.str.463, i64 0, i64 0
  %t229 = ptrtoint i8* %t228 to i64
  %t230 = call i64 @kore_str_eq(i64 %t227, i64 %t229)
  %t231 = icmp ne i64 %t230, 0
  br i1 %t231, label %then525, label %endif527
  then525:
  ; enum variant: Expr::Bool
  %t232 = call i8* @malloc(i64 24)
  %t233 = bitcast i8* %t232 to %Expr*
  %t234 = getelementptr %Expr, %Expr* %t233, i32 0, i32 0
  store i64 3, i64* %t234
  %t235 = call i8* @malloc(i64 8)
  %t236 = bitcast i8* %t235 to i64*
  %t237 = getelementptr i64, i64* %t236, i32 0
  store i64 0, i64* %t237
  %t238 = getelementptr %Expr, %Expr* %t233, i32 0, i32 1
  store i8* %t235, i8** %t238
  %t239 = getelementptr %Expr, %Expr* %t233, i32 0, i32 2
  %t240 = getelementptr [5 x i8], [5 x i8]* @.str.464, i64 0, i64 0
  store i8* %t240, i8** %t239
  %t241 = ptrtoint %Expr* %t233 to i64
  ret i64 %t241
  endif527:
  %t242 = load i64, i64* %t3
  %t243 = inttoptr i64 %t242 to %Token*
  %t244 = getelementptr %Token, %Token* %t243, i32 0, i32 3
  %t245 = load i64, i64* %t244
  %t246 = getelementptr [5 x i8], [5 x i8]* @.str.465, i64 0, i64 0
  %t247 = ptrtoint i8* %t246 to i64
  %t248 = call i64 @kore_str_eq(i64 %t245, i64 %t247)
  %t249 = load i64, i64* %t3
  %t250 = inttoptr i64 %t249 to %Token*
  %t251 = getelementptr %Token, %Token* %t250, i32 0, i32 3
  %t252 = load i64, i64* %t251
  %t253 = getelementptr [5 x i8], [5 x i8]* @.str.466, i64 0, i64 0
  %t254 = ptrtoint i8* %t253 to i64
  %t255 = call i64 @kore_str_eq(i64 %t252, i64 %t254)
  %t256 = or i64 %t248, %t255
  %t257 = icmp ne i64 %t256, 0
  br i1 %t257, label %then528, label %endif530
  then528:
  ; enum variant: Expr::None
  %t258 = call i8* @malloc(i64 24)
  %t259 = bitcast i8* %t258 to %Expr*
  %t260 = getelementptr %Expr, %Expr* %t259, i32 0, i32 0
  store i64 0, i64* %t260
  %t261 = getelementptr %Expr, %Expr* %t259, i32 0, i32 1
  store i8* null, i8** %t261
  %t262 = getelementptr %Expr, %Expr* %t259, i32 0, i32 2
  %t263 = getelementptr [5 x i8], [5 x i8]* @.str.467, i64 0, i64 0
  store i8* %t263, i8** %t262
  %t264 = ptrtoint %Expr* %t259 to i64
  ret i64 %t264
  endif530:
  %t265 = load i64, i64* %t3
  %t266 = call i64 @Token_is_ident(i64 %t265)
  %t267 = icmp ne i64 %t266, 0
  br i1 %t267, label %then531, label %endif533
  then531:
  %t268 = load i64, i64* %t3
  %t269 = inttoptr i64 %t268 to %Token*
  %t270 = getelementptr %Token, %Token* %t269, i32 0, i32 3
  %t271 = load i64, i64* %t270
  %t272 = alloca i64
  store i64 %t271, i64* %t272
  %t273 = load i64, i64* %t0
  %t274 = call i64 @Parser_peek(i64 %t273)
  %t275 = inttoptr i64 %t274 to %Token*
  %t276 = getelementptr %Token, %Token* %t275, i32 0, i32 3
  %t277 = load i64, i64* %t276
  %t278 = getelementptr [2 x i8], [2 x i8]* @.str.468, i64 0, i64 0
  %t279 = ptrtoint i8* %t278 to i64
  %t280 = call i64 @kore_str_eq(i64 %t277, i64 %t279)
  %t281 = icmp ne i64 %t280, 0
  br i1 %t281, label %then534, label %endif536
  then534:
  %t282 = load i64, i64* %t0
  %t283 = call i64 @Parser_peek_n(i64 %t282, i64 1)
  %t284 = inttoptr i64 %t283 to %Token*
  %t285 = getelementptr %Token, %Token* %t284, i32 0, i32 3
  %t286 = load i64, i64* %t285
  %t287 = getelementptr [2 x i8], [2 x i8]* @.str.469, i64 0, i64 0
  %t288 = ptrtoint i8* %t287 to i64
  %t289 = call i64 @kore_str_eq(i64 %t286, i64 %t288)
  %t290 = icmp ne i64 %t289, 0
  br i1 %t290, label %then537, label %endif539
  then537:
  %t291 = load i64, i64* %t0
  %t292 = call i64 @Parser_advance(i64 %t291)
  %t293 = load i64, i64* %t0
  %t294 = call i64 @Parser_advance(i64 %t293)
  %t295 = load i64, i64* %t0
  %t296 = call i64 @Parser_advance(i64 %t295)
  %t297 = inttoptr i64 %t296 to %Token*
  %t298 = getelementptr %Token, %Token* %t297, i32 0, i32 3
  %t299 = load i64, i64* %t298
  %t300 = alloca i64
  store i64 %t299, i64* %t300
  %t301 = load i64, i64* %t0
  %t302 = call i64 @Parser_peek(i64 %t301)
  %t303 = inttoptr i64 %t302 to %Token*
  %t304 = getelementptr %Token, %Token* %t303, i32 0, i32 3
  %t305 = load i64, i64* %t304
  %t306 = getelementptr [2 x i8], [2 x i8]* @.str.470, i64 0, i64 0
  %t307 = ptrtoint i8* %t306 to i64
  %t308 = call i64 @kore_str_eq(i64 %t305, i64 %t307)
  %t309 = icmp ne i64 %t308, 0
  br i1 %t309, label %then540, label %endif542
  then540:
  %t310 = load i64, i64* %t0
  %t311 = call i64 @Parser_advance(i64 %t310)
  %t312 = load i64, i64* %t0
  %t313 = call i64 @Parser_parse_args(i64 %t312)
  %t314 = alloca i64
  store i64 %t313, i64* %t314
  %t315 = load i64, i64* %t0
  %t316 = call i64 @Parser_advance(i64 %t315)
  ; enum variant: Expr::EnumVariant
  %t317 = call i8* @malloc(i64 24)
  %t318 = bitcast i8* %t317 to %Expr*
  %t319 = getelementptr %Expr, %Expr* %t318, i32 0, i32 0
  store i64 14, i64* %t319
  %t320 = call i8* @malloc(i64 24)
  %t321 = bitcast i8* %t320 to i64*
  %t322 = load i64, i64* %t272
  %t323 = getelementptr i64, i64* %t321, i32 0
  store i64 %t322, i64* %t323
  %t324 = load i64, i64* %t300
  %t325 = getelementptr i64, i64* %t321, i32 1
  store i64 %t324, i64* %t325
  %t326 = load i64, i64* %t314
  %t327 = getelementptr i64, i64* %t321, i32 2
  store i64 %t326, i64* %t327
  %t328 = getelementptr %Expr, %Expr* %t318, i32 0, i32 1
  store i8* %t320, i8** %t328
  %t329 = getelementptr %Expr, %Expr* %t318, i32 0, i32 2
  %t330 = getelementptr [12 x i8], [12 x i8]* @.str.471, i64 0, i64 0
  store i8* %t330, i8** %t329
  %t331 = ptrtoint %Expr* %t318 to i64
  ret i64 %t331
  endif542:
  ; enum variant: Expr::EnumVariant
  %t332 = call i8* @malloc(i64 24)
  %t333 = bitcast i8* %t332 to %Expr*
  %t334 = getelementptr %Expr, %Expr* %t333, i32 0, i32 0
  store i64 14, i64* %t334
  %t335 = call i8* @malloc(i64 24)
  %t336 = bitcast i8* %t335 to i64*
  %t337 = load i64, i64* %t272
  %t338 = getelementptr i64, i64* %t336, i32 0
  store i64 %t337, i64* %t338
  %t339 = load i64, i64* %t300
  %t340 = getelementptr i64, i64* %t336, i32 1
  store i64 %t339, i64* %t340
  %t341 = call i64 @kore_array_new()
  %t342 = getelementptr i64, i64* %t336, i32 2
  store i64 %t341, i64* %t342
  %t343 = getelementptr %Expr, %Expr* %t333, i32 0, i32 1
  store i8* %t335, i8** %t343
  %t344 = getelementptr %Expr, %Expr* %t333, i32 0, i32 2
  %t345 = getelementptr [12 x i8], [12 x i8]* @.str.472, i64 0, i64 0
  store i8* %t345, i8** %t344
  %t346 = ptrtoint %Expr* %t333 to i64
  ret i64 %t346
  endif539:
  br label %endif536
  endif536:
  %t347 = load i64, i64* %t0
  %t348 = call i64 @Parser_peek(i64 %t347)
  %t349 = inttoptr i64 %t348 to %Token*
  %t350 = getelementptr %Token, %Token* %t349, i32 0, i32 3
  %t351 = load i64, i64* %t350
  %t352 = getelementptr [2 x i8], [2 x i8]* @.str.473, i64 0, i64 0
  %t353 = ptrtoint i8* %t352 to i64
  %t354 = call i64 @kore_str_eq(i64 %t351, i64 %t353)
  %t355 = icmp ne i64 %t354, 0
  br i1 %t355, label %then543, label %endif545
  then543:
  %t356 = load i64, i64* %t0
  %t357 = call i64 @Parser_advance(i64 %t356)
  %t358 = call i64 @kore_array_new()
  %t359 = alloca i64
  store i64 %t358, i64* %t359
  br label %while_cond546
  while_cond546:
  %t360 = load i64, i64* %t0
  %t361 = call i64 @Parser_peek(i64 %t360)
  %t362 = inttoptr i64 %t361 to %Token*
  %t363 = getelementptr %Token, %Token* %t362, i32 0, i32 3
  %t364 = load i64, i64* %t363
  %t365 = getelementptr [2 x i8], [2 x i8]* @.str.474, i64 0, i64 0
  %t366 = ptrtoint i8* %t365 to i64
  %t368 = call i64 @kore_str_eq(i64 %t364, i64 %t366)
  %t369 = icmp eq i64 %t368, 0
  %t367 = zext i1 %t369 to i64
  %t370 = icmp ne i64 %t367, 0
  br i1 %t370, label %while_body547, label %while_end548
  while_body547:
  %t371 = load i64, i64* %t0
  %t372 = call i64 @Parser_advance(i64 %t371)
  %t373 = inttoptr i64 %t372 to %Token*
  %t374 = getelementptr %Token, %Token* %t373, i32 0, i32 3
  %t375 = load i64, i64* %t374
  %t376 = alloca i64
  store i64 %t375, i64* %t376
  %t377 = load i64, i64* %t0
  %t378 = getelementptr [2 x i8], [2 x i8]* @.str.475, i64 0, i64 0
  %t379 = ptrtoint i8* %t378 to i64
  %t380 = call i64 @Parser_expect(i64 %t377, i64 %t379)
  %t381 = load i64, i64* %t0
  %t382 = call i64 @Parser_parse_expr(i64 %t381)
  %t383 = alloca i64
  store i64 %t382, i64* %t383
  %t384 = load i64, i64* %t359
  ; struct literal: FieldInit
  %t385 = call i8* @malloc(i64 16)
  %t386 = bitcast i8* %t385 to %FieldInit*
  %t387 = load i64, i64* %t376
  %t388 = getelementptr %FieldInit, %FieldInit* %t386, i32 0, i32 0
  store i64 %t387, i64* %t388
  %t389 = load i64, i64* %t383
  %t390 = getelementptr %FieldInit, %FieldInit* %t386, i32 0, i32 1
  store i64 %t389, i64* %t390
  %t391 = ptrtoint %FieldInit* %t386 to i64
  %t392 = call i64 @kore_array_push(i64 %t384, i64 %t391)
  %t393 = load i64, i64* %t0
  %t394 = call i64 @Parser_peek(i64 %t393)
  %t395 = inttoptr i64 %t394 to %Token*
  %t396 = getelementptr %Token, %Token* %t395, i32 0, i32 3
  %t397 = load i64, i64* %t396
  %t398 = getelementptr [2 x i8], [2 x i8]* @.str.476, i64 0, i64 0
  %t399 = ptrtoint i8* %t398 to i64
  %t400 = call i64 @kore_str_eq(i64 %t397, i64 %t399)
  %t401 = icmp ne i64 %t400, 0
  br i1 %t401, label %then549, label %endif551
  then549:
  %t402 = load i64, i64* %t0
  %t403 = call i64 @Parser_advance(i64 %t402)
  br label %endif551
  endif551:
  br label %while_cond546
  while_end548:
  %t404 = load i64, i64* %t0
  %t405 = call i64 @Parser_advance(i64 %t404)
  ; enum variant: Expr::Struct
  %t406 = call i8* @malloc(i64 24)
  %t407 = bitcast i8* %t406 to %Expr*
  %t408 = getelementptr %Expr, %Expr* %t407, i32 0, i32 0
  store i64 1, i64* %t408
  %t409 = call i8* @malloc(i64 16)
  %t410 = bitcast i8* %t409 to i64*
  %t411 = load i64, i64* %t272
  %t412 = getelementptr i64, i64* %t410, i32 0
  store i64 %t411, i64* %t412
  %t413 = load i64, i64* %t359
  %t414 = getelementptr i64, i64* %t410, i32 1
  store i64 %t413, i64* %t414
  %t415 = getelementptr %Expr, %Expr* %t407, i32 0, i32 1
  store i8* %t409, i8** %t415
  %t416 = getelementptr %Expr, %Expr* %t407, i32 0, i32 2
  %t417 = getelementptr [7 x i8], [7 x i8]* @.str.477, i64 0, i64 0
  store i8* %t417, i8** %t416
  %t418 = ptrtoint %Expr* %t407 to i64
  ret i64 %t418
  endif545:
  ; enum variant: Expr::Ident
  %t419 = call i8* @malloc(i64 24)
  %t420 = bitcast i8* %t419 to %Expr*
  %t421 = getelementptr %Expr, %Expr* %t420, i32 0, i32 0
  store i64 4, i64* %t421
  %t422 = call i8* @malloc(i64 8)
  %t423 = bitcast i8* %t422 to i64*
  %t424 = load i64, i64* %t272
  %t425 = getelementptr i64, i64* %t423, i32 0
  store i64 %t424, i64* %t425
  %t426 = getelementptr %Expr, %Expr* %t420, i32 0, i32 1
  store i8* %t422, i8** %t426
  %t427 = getelementptr %Expr, %Expr* %t420, i32 0, i32 2
  %t428 = getelementptr [6 x i8], [6 x i8]* @.str.478, i64 0, i64 0
  store i8* %t428, i8** %t427
  %t429 = ptrtoint %Expr* %t420 to i64
  ret i64 %t429
  endif533:
  ; enum variant: Expr::Ident
  %t430 = call i8* @malloc(i64 24)
  %t431 = bitcast i8* %t430 to %Expr*
  %t432 = getelementptr %Expr, %Expr* %t431, i32 0, i32 0
  store i64 4, i64* %t432
  %t433 = call i8* @malloc(i64 8)
  %t434 = bitcast i8* %t433 to i64*
  %t435 = load i64, i64* %t3
  %t436 = inttoptr i64 %t435 to %Token*
  %t437 = getelementptr %Token, %Token* %t436, i32 0, i32 3
  %t438 = load i64, i64* %t437
  %t439 = getelementptr i64, i64* %t434, i32 0
  store i64 %t438, i64* %t439
  %t440 = getelementptr %Expr, %Expr* %t431, i32 0, i32 1
  store i8* %t433, i8** %t440
  %t441 = getelementptr %Expr, %Expr* %t431, i32 0, i32 2
  %t442 = getelementptr [6 x i8], [6 x i8]* @.str.479, i64 0, i64 0
  store i8* %t442, i8** %t441
  %t443 = ptrtoint %Expr* %t431 to i64
  ret i64 %t443
}
define i64 @Parser_peek_n(i64 %self, i64 %n) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %n, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = inttoptr i64 %t2 to %Parser*
  %t4 = getelementptr %Parser, %Parser* %t3, i32 0, i32 1
  %t5 = load i64, i64* %t4
  %t6 = load i64, i64* %t1
  %t7 = add i64 %t5, %t6
  %t8 = alloca i64
  store i64 %t7, i64* %t8
  %t9 = load i64, i64* %t8
  %t10 = load i64, i64* %t0
  %t11 = inttoptr i64 %t10 to %Parser*
  %t12 = getelementptr %Parser, %Parser* %t11, i32 0, i32 0
  %t13 = load i64, i64* %t12
  %t14 = call i64 @kore_array_len(i64 %t13)
  %t16 = icmp sge i64 %t9, %t14
  %t15 = zext i1 %t16 to i64
  %t17 = icmp ne i64 %t15, 0
  br i1 %t17, label %then552, label %endif554
  then552:
  ; enum variant: TokenKind::Eof
  %t18 = call i8* @malloc(i64 24)
  %t19 = bitcast i8* %t18 to %TokenKind*
  %t20 = getelementptr %TokenKind, %TokenKind* %t19, i32 0, i32 0
  store i64 42, i64* %t20
  %t21 = getelementptr %TokenKind, %TokenKind* %t19, i32 0, i32 1
  store i8* null, i8** %t21
  %t22 = getelementptr %TokenKind, %TokenKind* %t19, i32 0, i32 2
  %t23 = getelementptr [4 x i8], [4 x i8]* @.str.480, i64 0, i64 0
  store i8* %t23, i8** %t22
  %t24 = ptrtoint %TokenKind* %t19 to i64
  %t25 = getelementptr [1 x i8], [1 x i8]* @.str.481, i64 0, i64 0
  %t26 = ptrtoint i8* %t25 to i64
  %t27 = call i64 @Token_new(i64 %t24, i64 0, i64 0, i64 %t26)
  ret i64 %t27
  endif554:
  %t28 = load i64, i64* %t0
  %t29 = inttoptr i64 %t28 to %Parser*
  %t30 = getelementptr %Parser, %Parser* %t29, i32 0, i32 0
  %t31 = load i64, i64* %t30
  %t32 = load i64, i64* %t8
  %t33 = call i64 @kore_array_get(i64 %t31, i64 %t32)
  ret i64 %t33
}
define i64 @Parser_parse_struct_def(i64 %self, i64 %is_pub) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %is_pub, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = getelementptr [7 x i8], [7 x i8]* @.str.482, i64 0, i64 0
  %t4 = ptrtoint i8* %t3 to i64
  %t5 = call i64 @Parser_expect_keyword(i64 %t2, i64 %t4)
  %t6 = load i64, i64* %t0
  %t7 = call i64 @Parser_advance(i64 %t6)
  %t8 = inttoptr i64 %t7 to %Token*
  %t9 = getelementptr %Token, %Token* %t8, i32 0, i32 3
  %t10 = load i64, i64* %t9
  %t11 = alloca i64
  store i64 %t10, i64* %t11
  %t12 = load i64, i64* %t0
  %t13 = getelementptr [2 x i8], [2 x i8]* @.str.483, i64 0, i64 0
  %t14 = ptrtoint i8* %t13 to i64
  %t15 = call i64 @Parser_expect(i64 %t12, i64 %t14)
  %t16 = load i64, i64* %t0
  %t17 = call i64 @Parser_skip_newlines(i64 %t16)
  %t18 = alloca i64
  store i64 0, i64* %t18
  %t19 = load i64, i64* %t0
  %t20 = call i64 @Parser_peek(i64 %t19)
  %t21 = call i64 @Token_is_indent(i64 %t20)
  %t22 = icmp ne i64 %t21, 0
  br i1 %t22, label %then555, label %endif557
  then555:
  %t23 = load i64, i64* %t0
  %t24 = call i64 @Parser_advance(i64 %t23)
  store i64 1, i64* %t18
  br label %endif557
  endif557:
  %t25 = call i64 @kore_array_new()
  %t26 = alloca i64
  store i64 %t25, i64* %t26
  br label %while_cond558
  while_cond558:
  %t27 = load i64, i64* %t0
  %t28 = call i64 @Parser_is_eof(i64 %t27)
  %t30 = icmp eq i64 %t28, 0
  %t29 = zext i1 %t30 to i64
  %t31 = icmp ne i64 %t29, 0
  br i1 %t31, label %while_body559, label %while_end560
  while_body559:
  %t32 = load i64, i64* %t0
  %t33 = call i64 @Parser_peek(i64 %t32)
  %t34 = alloca i64
  store i64 %t33, i64* %t34
  %t35 = load i64, i64* %t18
  %t36 = load i64, i64* %t34
  %t37 = call i64 @Token_is_dedent(i64 %t36)
  %t38 = and i64 %t35, %t37
  %t39 = icmp ne i64 %t38, 0
  br i1 %t39, label %then561, label %endif563
  then561:
  %t40 = load i64, i64* %t0
  %t41 = call i64 @Parser_advance(i64 %t40)
  br label %while_end560
  endif563:
  %t42 = load i64, i64* %t18
  %t44 = icmp eq i64 %t42, 0
  %t43 = zext i1 %t44 to i64
  %t45 = icmp ne i64 %t43, 0
  br i1 %t45, label %then564, label %endif566
  then564:
  %t46 = load i64, i64* %t34
  %t47 = getelementptr [3 x i8], [3 x i8]* @.str.484, i64 0, i64 0
  %t48 = ptrtoint i8* %t47 to i64
  %t49 = call i64 @Token_is_keyword(i64 %t46, i64 %t48)
  %t50 = load i64, i64* %t34
  %t51 = getelementptr [4 x i8], [4 x i8]* @.str.485, i64 0, i64 0
  %t52 = ptrtoint i8* %t51 to i64
  %t53 = call i64 @Token_is_keyword(i64 %t50, i64 %t52)
  %t54 = or i64 %t49, %t53
  %t55 = load i64, i64* %t34
  %t56 = getelementptr [7 x i8], [7 x i8]* @.str.486, i64 0, i64 0
  %t57 = ptrtoint i8* %t56 to i64
  %t58 = call i64 @Token_is_keyword(i64 %t55, i64 %t57)
  %t59 = or i64 %t54, %t58
  %t60 = load i64, i64* %t34
  %t61 = getelementptr [5 x i8], [5 x i8]* @.str.487, i64 0, i64 0
  %t62 = ptrtoint i8* %t61 to i64
  %t63 = call i64 @Token_is_keyword(i64 %t60, i64 %t62)
  %t64 = or i64 %t59, %t63
  %t65 = load i64, i64* %t34
  %t66 = getelementptr [5 x i8], [5 x i8]* @.str.488, i64 0, i64 0
  %t67 = ptrtoint i8* %t66 to i64
  %t68 = call i64 @Token_is_keyword(i64 %t65, i64 %t67)
  %t69 = or i64 %t64, %t68
  %t70 = load i64, i64* %t34
  %t71 = getelementptr [4 x i8], [4 x i8]* @.str.489, i64 0, i64 0
  %t72 = ptrtoint i8* %t71 to i64
  %t73 = call i64 @Token_is_keyword(i64 %t70, i64 %t72)
  %t74 = or i64 %t69, %t73
  %t75 = icmp ne i64 %t74, 0
  br i1 %t75, label %then567, label %endif569
  then567:
  br label %while_end560
  endif569:
  br label %endif566
  endif566:
  %t76 = load i64, i64* %t34
  %t77 = inttoptr i64 %t76 to %Token*
  %t78 = getelementptr %Token, %Token* %t77, i32 0, i32 3
  %t79 = load i64, i64* %t78
  %t80 = getelementptr [2 x i8], [2 x i8]* @.str.490, i64 0, i64 0
  %t81 = ptrtoint i8* %t80 to i64
  %t82 = call i64 @kore_str_eq(i64 %t79, i64 %t81)
  %t83 = icmp ne i64 %t82, 0
  br i1 %t83, label %then570, label %endif572
  then570:
  %t84 = load i64, i64* %t0
  %t85 = call i64 @Parser_advance(i64 %t84)
  br label %while_cond558
  endif572:
  %t86 = load i64, i64* %t34
  %t87 = call i64 @Token_is_ident(i64 %t86)
  %t88 = icmp ne i64 %t87, 0
  br i1 %t88, label %then573, label %else574
  then573:
  %t89 = load i64, i64* %t0
  %t90 = call i64 @Parser_advance(i64 %t89)
  %t91 = inttoptr i64 %t90 to %Token*
  %t92 = getelementptr %Token, %Token* %t91, i32 0, i32 3
  %t93 = load i64, i64* %t92
  %t94 = alloca i64
  store i64 %t93, i64* %t94
  %t95 = load i64, i64* %t0
  %t96 = getelementptr [2 x i8], [2 x i8]* @.str.491, i64 0, i64 0
  %t97 = ptrtoint i8* %t96 to i64
  %t98 = call i64 @Parser_expect(i64 %t95, i64 %t97)
  %t99 = load i64, i64* %t0
  %t100 = call i64 @Parser_parse_type(i64 %t99)
  %t101 = alloca i64
  store i64 %t100, i64* %t101
  %t102 = load i64, i64* %t26
  ; struct literal: Field
  %t103 = call i8* @malloc(i64 16)
  %t104 = bitcast i8* %t103 to %Field*
  %t105 = load i64, i64* %t94
  %t106 = getelementptr %Field, %Field* %t104, i32 0, i32 0
  store i64 %t105, i64* %t106
  %t107 = load i64, i64* %t101
  %t108 = getelementptr %Field, %Field* %t104, i32 0, i32 1
  store i64 %t107, i64* %t108
  %t109 = ptrtoint %Field* %t104 to i64
  %t110 = call i64 @kore_array_push(i64 %t102, i64 %t109)
  br label %endif575
  else574:
  br label %while_end560
  endif575:
  br label %while_cond558
  while_end560:
  ; struct literal: StructDef
  %t111 = call i8* @malloc(i64 24)
  %t112 = bitcast i8* %t111 to %StructDef*
  %t113 = load i64, i64* %t11
  %t114 = getelementptr %StructDef, %StructDef* %t112, i32 0, i32 0
  store i64 %t113, i64* %t114
  %t115 = load i64, i64* %t26
  %t116 = getelementptr %StructDef, %StructDef* %t112, i32 0, i32 1
  store i64 %t115, i64* %t116
  %t117 = load i64, i64* %t1
  %t118 = getelementptr %StructDef, %StructDef* %t112, i32 0, i32 2
  store i64 %t117, i64* %t118
  %t119 = ptrtoint %StructDef* %t112 to i64
  ret i64 %t119
}
define i64 @Parser_parse_enum_def(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = getelementptr [5 x i8], [5 x i8]* @.str.492, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = call i64 @Parser_expect_keyword(i64 %t1, i64 %t3)
  %t5 = load i64, i64* %t0
  %t6 = call i64 @Parser_advance(i64 %t5)
  %t7 = inttoptr i64 %t6 to %Token*
  %t8 = getelementptr %Token, %Token* %t7, i32 0, i32 3
  %t9 = load i64, i64* %t8
  %t10 = alloca i64
  store i64 %t9, i64* %t10
  %t11 = load i64, i64* %t0
  %t12 = getelementptr [2 x i8], [2 x i8]* @.str.493, i64 0, i64 0
  %t13 = ptrtoint i8* %t12 to i64
  %t14 = call i64 @Parser_expect(i64 %t11, i64 %t13)
  %t15 = load i64, i64* %t0
  %t16 = call i64 @Parser_skip_newlines(i64 %t15)
  %t17 = alloca i64
  store i64 0, i64* %t17
  %t18 = load i64, i64* %t0
  %t19 = call i64 @Parser_peek(i64 %t18)
  %t20 = call i64 @Token_is_indent(i64 %t19)
  %t21 = icmp ne i64 %t20, 0
  br i1 %t21, label %then576, label %endif578
  then576:
  %t22 = load i64, i64* %t0
  %t23 = call i64 @Parser_advance(i64 %t22)
  store i64 1, i64* %t17
  br label %endif578
  endif578:
  %t24 = call i64 @kore_array_new()
  %t25 = alloca i64
  store i64 %t24, i64* %t25
  br label %while_cond579
  while_cond579:
  %t26 = load i64, i64* %t0
  %t27 = call i64 @Parser_is_eof(i64 %t26)
  %t29 = icmp eq i64 %t27, 0
  %t28 = zext i1 %t29 to i64
  %t30 = icmp ne i64 %t28, 0
  br i1 %t30, label %while_body580, label %while_end581
  while_body580:
  %t31 = load i64, i64* %t0
  %t32 = call i64 @Parser_peek(i64 %t31)
  %t33 = alloca i64
  store i64 %t32, i64* %t33
  %t34 = load i64, i64* %t17
  %t35 = load i64, i64* %t33
  %t36 = call i64 @Token_is_dedent(i64 %t35)
  %t37 = and i64 %t34, %t36
  %t38 = icmp ne i64 %t37, 0
  br i1 %t38, label %then582, label %endif584
  then582:
  %t39 = load i64, i64* %t0
  %t40 = call i64 @Parser_advance(i64 %t39)
  br label %while_end581
  endif584:
  %t41 = load i64, i64* %t17
  %t43 = icmp eq i64 %t41, 0
  %t42 = zext i1 %t43 to i64
  %t44 = icmp ne i64 %t42, 0
  br i1 %t44, label %then585, label %endif587
  then585:
  %t45 = load i64, i64* %t33
  %t46 = getelementptr [3 x i8], [3 x i8]* @.str.494, i64 0, i64 0
  %t47 = ptrtoint i8* %t46 to i64
  %t48 = call i64 @Token_is_keyword(i64 %t45, i64 %t47)
  %t49 = load i64, i64* %t33
  %t50 = getelementptr [4 x i8], [4 x i8]* @.str.495, i64 0, i64 0
  %t51 = ptrtoint i8* %t50 to i64
  %t52 = call i64 @Token_is_keyword(i64 %t49, i64 %t51)
  %t53 = or i64 %t48, %t52
  %t54 = load i64, i64* %t33
  %t55 = getelementptr [7 x i8], [7 x i8]* @.str.496, i64 0, i64 0
  %t56 = ptrtoint i8* %t55 to i64
  %t57 = call i64 @Token_is_keyword(i64 %t54, i64 %t56)
  %t58 = or i64 %t53, %t57
  %t59 = load i64, i64* %t33
  %t60 = getelementptr [5 x i8], [5 x i8]* @.str.497, i64 0, i64 0
  %t61 = ptrtoint i8* %t60 to i64
  %t62 = call i64 @Token_is_keyword(i64 %t59, i64 %t61)
  %t63 = or i64 %t58, %t62
  %t64 = load i64, i64* %t33
  %t65 = getelementptr [5 x i8], [5 x i8]* @.str.498, i64 0, i64 0
  %t66 = ptrtoint i8* %t65 to i64
  %t67 = call i64 @Token_is_keyword(i64 %t64, i64 %t66)
  %t68 = or i64 %t63, %t67
  %t69 = load i64, i64* %t33
  %t70 = getelementptr [4 x i8], [4 x i8]* @.str.499, i64 0, i64 0
  %t71 = ptrtoint i8* %t70 to i64
  %t72 = call i64 @Token_is_keyword(i64 %t69, i64 %t71)
  %t73 = or i64 %t68, %t72
  %t74 = icmp ne i64 %t73, 0
  br i1 %t74, label %then588, label %endif590
  then588:
  br label %while_end581
  endif590:
  br label %endif587
  endif587:
  %t75 = load i64, i64* %t33
  %t76 = inttoptr i64 %t75 to %Token*
  %t77 = getelementptr %Token, %Token* %t76, i32 0, i32 3
  %t78 = load i64, i64* %t77
  %t79 = getelementptr [2 x i8], [2 x i8]* @.str.500, i64 0, i64 0
  %t80 = ptrtoint i8* %t79 to i64
  %t81 = call i64 @kore_str_eq(i64 %t78, i64 %t80)
  %t82 = icmp ne i64 %t81, 0
  br i1 %t82, label %then591, label %endif593
  then591:
  %t83 = load i64, i64* %t0
  %t84 = call i64 @Parser_advance(i64 %t83)
  br label %while_cond579
  endif593:
  %t85 = load i64, i64* %t33
  %t86 = call i64 @Token_is_ident(i64 %t85)
  %t87 = icmp ne i64 %t86, 0
  br i1 %t87, label %then594, label %else595
  then594:
  %t88 = load i64, i64* %t0
  %t89 = call i64 @Parser_advance(i64 %t88)
  %t90 = inttoptr i64 %t89 to %Token*
  %t91 = getelementptr %Token, %Token* %t90, i32 0, i32 3
  %t92 = load i64, i64* %t91
  %t93 = alloca i64
  store i64 %t92, i64* %t93
  %t94 = call i64 @kore_array_new()
  %t95 = alloca i64
  store i64 %t94, i64* %t95
  %t96 = load i64, i64* %t0
  %t97 = call i64 @Parser_peek(i64 %t96)
  %t98 = inttoptr i64 %t97 to %Token*
  %t99 = getelementptr %Token, %Token* %t98, i32 0, i32 3
  %t100 = load i64, i64* %t99
  %t101 = getelementptr [2 x i8], [2 x i8]* @.str.501, i64 0, i64 0
  %t102 = ptrtoint i8* %t101 to i64
  %t103 = call i64 @kore_str_eq(i64 %t100, i64 %t102)
  %t104 = icmp ne i64 %t103, 0
  br i1 %t104, label %then597, label %endif599
  then597:
  %t105 = load i64, i64* %t0
  %t106 = call i64 @Parser_advance(i64 %t105)
  br label %while_cond600
  while_cond600:
  %t107 = load i64, i64* %t0
  %t108 = call i64 @Parser_peek(i64 %t107)
  %t109 = inttoptr i64 %t108 to %Token*
  %t110 = getelementptr %Token, %Token* %t109, i32 0, i32 3
  %t111 = load i64, i64* %t110
  %t112 = getelementptr [2 x i8], [2 x i8]* @.str.502, i64 0, i64 0
  %t113 = ptrtoint i8* %t112 to i64
  %t115 = call i64 @kore_str_eq(i64 %t111, i64 %t113)
  %t116 = icmp eq i64 %t115, 0
  %t114 = zext i1 %t116 to i64
  %t117 = icmp ne i64 %t114, 0
  br i1 %t117, label %while_body601, label %while_end602
  while_body601:
  %t118 = load i64, i64* %t95
  %t119 = load i64, i64* %t0
  %t120 = call i64 @Parser_parse_type(i64 %t119)
  %t121 = call i64 @kore_array_push(i64 %t118, i64 %t120)
  %t122 = load i64, i64* %t0
  %t123 = call i64 @Parser_peek(i64 %t122)
  %t124 = inttoptr i64 %t123 to %Token*
  %t125 = getelementptr %Token, %Token* %t124, i32 0, i32 3
  %t126 = load i64, i64* %t125
  %t127 = getelementptr [2 x i8], [2 x i8]* @.str.503, i64 0, i64 0
  %t128 = ptrtoint i8* %t127 to i64
  %t129 = call i64 @kore_str_eq(i64 %t126, i64 %t128)
  %t130 = icmp ne i64 %t129, 0
  br i1 %t130, label %then603, label %endif605
  then603:
  %t131 = load i64, i64* %t0
  %t132 = call i64 @Parser_advance(i64 %t131)
  br label %endif605
  endif605:
  br label %while_cond600
  while_end602:
  %t133 = load i64, i64* %t0
  %t134 = call i64 @Parser_advance(i64 %t133)
  br label %endif599
  endif599:
  %t135 = load i64, i64* %t25
  ; struct literal: Variant
  %t136 = call i8* @malloc(i64 16)
  %t137 = bitcast i8* %t136 to %Variant*
  %t138 = load i64, i64* %t93
  %t139 = getelementptr %Variant, %Variant* %t137, i32 0, i32 0
  store i64 %t138, i64* %t139
  %t140 = load i64, i64* %t95
  %t141 = getelementptr %Variant, %Variant* %t137, i32 0, i32 1
  store i64 %t140, i64* %t141
  %t142 = ptrtoint %Variant* %t137 to i64
  %t143 = call i64 @kore_array_push(i64 %t135, i64 %t142)
  br label %endif596
  else595:
  br label %while_end581
  endif596:
  br label %while_cond579
  while_end581:
  ; struct literal: EnumDef
  %t144 = call i8* @malloc(i64 16)
  %t145 = bitcast i8* %t144 to %EnumDef*
  %t146 = load i64, i64* %t10
  %t147 = getelementptr %EnumDef, %EnumDef* %t145, i32 0, i32 0
  store i64 %t146, i64* %t147
  %t148 = load i64, i64* %t25
  %t149 = getelementptr %EnumDef, %EnumDef* %t145, i32 0, i32 1
  store i64 %t148, i64* %t149
  %t150 = ptrtoint %EnumDef* %t145 to i64
  ret i64 %t150
}
define i64 @Parser_parse_impl_def(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = getelementptr [5 x i8], [5 x i8]* @.str.504, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = call i64 @Parser_expect_keyword(i64 %t1, i64 %t3)
  %t5 = load i64, i64* %t0
  %t6 = call i64 @Parser_advance(i64 %t5)
  %t7 = inttoptr i64 %t6 to %Token*
  %t8 = getelementptr %Token, %Token* %t7, i32 0, i32 3
  %t9 = load i64, i64* %t8
  %t10 = alloca i64
  store i64 %t9, i64* %t10
  %t11 = load i64, i64* %t0
  %t12 = getelementptr [2 x i8], [2 x i8]* @.str.505, i64 0, i64 0
  %t13 = ptrtoint i8* %t12 to i64
  %t14 = call i64 @Parser_expect(i64 %t11, i64 %t13)
  %t15 = load i64, i64* %t0
  %t16 = call i64 @Parser_skip_newlines(i64 %t15)
  %t17 = alloca i64
  store i64 0, i64* %t17
  %t18 = load i64, i64* %t0
  %t19 = call i64 @Parser_peek(i64 %t18)
  %t20 = call i64 @Token_is_indent(i64 %t19)
  %t21 = icmp ne i64 %t20, 0
  br i1 %t21, label %then606, label %endif608
  then606:
  %t22 = load i64, i64* %t0
  %t23 = call i64 @Parser_advance(i64 %t22)
  store i64 1, i64* %t17
  br label %endif608
  endif608:
  %t24 = call i64 @kore_array_new()
  %t25 = alloca i64
  store i64 %t24, i64* %t25
  br label %while_cond609
  while_cond609:
  %t26 = load i64, i64* %t0
  %t27 = call i64 @Parser_is_eof(i64 %t26)
  %t29 = icmp eq i64 %t27, 0
  %t28 = zext i1 %t29 to i64
  %t30 = icmp ne i64 %t28, 0
  br i1 %t30, label %while_body610, label %while_end611
  while_body610:
  %t31 = load i64, i64* %t0
  %t32 = call i64 @Parser_peek(i64 %t31)
  %t33 = alloca i64
  store i64 %t32, i64* %t33
  %t34 = load i64, i64* %t17
  %t35 = load i64, i64* %t33
  %t36 = call i64 @Token_is_dedent(i64 %t35)
  %t37 = and i64 %t34, %t36
  %t38 = icmp ne i64 %t37, 0
  br i1 %t38, label %then612, label %endif614
  then612:
  %t39 = load i64, i64* %t0
  %t40 = call i64 @Parser_advance(i64 %t39)
  br label %while_end611
  endif614:
  %t41 = load i64, i64* %t17
  %t43 = icmp eq i64 %t41, 0
  %t42 = zext i1 %t43 to i64
  %t44 = icmp ne i64 %t42, 0
  br i1 %t44, label %then615, label %endif617
  then615:
  %t45 = load i64, i64* %t33
  %t46 = getelementptr [7 x i8], [7 x i8]* @.str.506, i64 0, i64 0
  %t47 = ptrtoint i8* %t46 to i64
  %t48 = call i64 @Token_is_keyword(i64 %t45, i64 %t47)
  %t49 = load i64, i64* %t33
  %t50 = getelementptr [5 x i8], [5 x i8]* @.str.507, i64 0, i64 0
  %t51 = ptrtoint i8* %t50 to i64
  %t52 = call i64 @Token_is_keyword(i64 %t49, i64 %t51)
  %t53 = or i64 %t48, %t52
  %t54 = load i64, i64* %t33
  %t55 = getelementptr [5 x i8], [5 x i8]* @.str.508, i64 0, i64 0
  %t56 = ptrtoint i8* %t55 to i64
  %t57 = call i64 @Token_is_keyword(i64 %t54, i64 %t56)
  %t58 = or i64 %t53, %t57
  %t59 = load i64, i64* %t33
  %t60 = getelementptr [4 x i8], [4 x i8]* @.str.509, i64 0, i64 0
  %t61 = ptrtoint i8* %t60 to i64
  %t62 = call i64 @Token_is_keyword(i64 %t59, i64 %t61)
  %t63 = or i64 %t58, %t62
  %t64 = icmp ne i64 %t63, 0
  br i1 %t64, label %then618, label %endif620
  then618:
  br label %while_end611
  endif620:
  br label %endif617
  endif617:
  %t65 = load i64, i64* %t33
  %t66 = inttoptr i64 %t65 to %Token*
  %t67 = getelementptr %Token, %Token* %t66, i32 0, i32 3
  %t68 = load i64, i64* %t67
  %t69 = getelementptr [2 x i8], [2 x i8]* @.str.510, i64 0, i64 0
  %t70 = ptrtoint i8* %t69 to i64
  %t71 = call i64 @kore_str_eq(i64 %t68, i64 %t70)
  %t72 = icmp ne i64 %t71, 0
  br i1 %t72, label %then621, label %endif623
  then621:
  %t73 = load i64, i64* %t0
  %t74 = call i64 @Parser_advance(i64 %t73)
  br label %while_cond609
  endif623:
  %t75 = load i64, i64* %t33
  %t76 = getelementptr [4 x i8], [4 x i8]* @.str.511, i64 0, i64 0
  %t77 = ptrtoint i8* %t76 to i64
  %t78 = call i64 @Token_is_keyword(i64 %t75, i64 %t77)
  %t79 = icmp ne i64 %t78, 0
  br i1 %t79, label %then624, label %else625
  then624:
  %t80 = load i64, i64* %t0
  %t81 = call i64 @Parser_advance(i64 %t80)
  %t82 = load i64, i64* %t0
  %t83 = call i64 @Parser_peek(i64 %t82)
  %t84 = getelementptr [3 x i8], [3 x i8]* @.str.512, i64 0, i64 0
  %t85 = ptrtoint i8* %t84 to i64
  %t86 = call i64 @Token_is_keyword(i64 %t83, i64 %t85)
  %t87 = icmp ne i64 %t86, 0
  br i1 %t87, label %then627, label %else628
  then627:
  %t88 = load i64, i64* %t0
  %t89 = call i64 @Parser_parse_fn_def(i64 %t88, i64 1, i64 0)
  %t90 = alloca i64
  store i64 %t89, i64* %t90
  %t91 = load i64, i64* %t25
  %t92 = load i64, i64* %t90
  %t93 = call i64 @kore_array_push(i64 %t91, i64 %t92)
  br label %endif629
  else628:
  br label %while_end611
  endif629:
  br label %endif626
  else625:
  %t94 = load i64, i64* %t33
  %t95 = getelementptr [3 x i8], [3 x i8]* @.str.513, i64 0, i64 0
  %t96 = ptrtoint i8* %t95 to i64
  %t97 = call i64 @Token_is_keyword(i64 %t94, i64 %t96)
  %t98 = icmp ne i64 %t97, 0
  br i1 %t98, label %then630, label %else631
  then630:
  %t99 = load i64, i64* %t0
  %t100 = call i64 @Parser_parse_fn_def(i64 %t99, i64 0, i64 0)
  %t101 = alloca i64
  store i64 %t100, i64* %t101
  %t102 = load i64, i64* %t25
  %t103 = load i64, i64* %t101
  %t104 = call i64 @kore_array_push(i64 %t102, i64 %t103)
  br label %endif632
  else631:
  br label %while_end611
  endif632:
  br label %endif626
  endif626:
  br label %while_cond609
  while_end611:
  ; struct literal: ImplDef
  %t105 = call i8* @malloc(i64 16)
  %t106 = bitcast i8* %t105 to %ImplDef*
  %t107 = load i64, i64* %t10
  %t108 = getelementptr %ImplDef, %ImplDef* %t106, i32 0, i32 0
  store i64 %t107, i64* %t108
  %t109 = load i64, i64* %t25
  %t110 = getelementptr %ImplDef, %ImplDef* %t106, i32 0, i32 1
  store i64 %t109, i64* %t110
  %t111 = ptrtoint %ImplDef* %t106 to i64
  ret i64 %t111
}
define i64 @Parser_parse_use(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = getelementptr [4 x i8], [4 x i8]* @.str.514, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = call i64 @Parser_expect_keyword(i64 %t1, i64 %t3)
  %t5 = load i64, i64* %t0
  %t6 = call i64 @Parser_advance(i64 %t5)
  %t7 = inttoptr i64 %t6 to %Token*
  %t8 = getelementptr %Token, %Token* %t7, i32 0, i32 3
  %t9 = load i64, i64* %t8
  %t10 = alloca i64
  store i64 %t9, i64* %t10
  %t11 = load i64, i64* %t10
  ret i64 %t11
}

; impl CodeGen
define i64 @CodeGen_new() {
  entry:
  ; struct literal: CodeGen
  %t0 = call i8* @malloc(i64 88)
  %t1 = bitcast i8* %t0 to %CodeGen*
  %t2 = call i64 @StringBuilder_new()
  %t3 = getelementptr %CodeGen, %CodeGen* %t1, i32 0, i32 0
  store i64 %t2, i64* %t3
  %t4 = getelementptr %CodeGen, %CodeGen* %t1, i32 0, i32 1
  store i64 0, i64* %t4
  %t5 = getelementptr %CodeGen, %CodeGen* %t1, i32 0, i32 2
  store i64 0, i64* %t5
  %t6 = getelementptr %CodeGen, %CodeGen* %t1, i32 0, i32 3
  store i64 0, i64* %t6
  %t7 = getelementptr %CodeGen, %CodeGen* %t1, i32 0, i32 4
  store i64 0, i64* %t7
  %t8 = call i64 @kore_array_new()
  %t9 = getelementptr %CodeGen, %CodeGen* %t1, i32 0, i32 5
  store i64 %t8, i64* %t9
  %t10 = call i64 @Map_new()
  %t11 = getelementptr %CodeGen, %CodeGen* %t1, i32 0, i32 6
  store i64 %t10, i64* %t11
  %t12 = call i64 @kore_array_new()
  %t13 = getelementptr %CodeGen, %CodeGen* %t1, i32 0, i32 7
  store i64 %t12, i64* %t13
  %t14 = call i64 @Map_new()
  %t15 = getelementptr %CodeGen, %CodeGen* %t1, i32 0, i32 8
  store i64 %t14, i64* %t15
  %t16 = call i64 @Map_new()
  %t17 = getelementptr %CodeGen, %CodeGen* %t1, i32 0, i32 9
  store i64 %t16, i64* %t17
  %t18 = call i64 @Map_new()
  %t19 = getelementptr %CodeGen, %CodeGen* %t1, i32 0, i32 10
  store i64 %t18, i64* %t19
  %t20 = ptrtoint %CodeGen* %t1 to i64
  ret i64 %t20
}
define i64 @CodeGen_fresh_local(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %CodeGen*
  %t3 = getelementptr %CodeGen, %CodeGen* %t2, i32 0, i32 2
  %t4 = load i64, i64* %t3
  %t5 = alloca i64
  store i64 %t4, i64* %t5
  %t6 = load i64, i64* %t0
  %t7 = inttoptr i64 %t6 to %CodeGen*
  %t8 = getelementptr %CodeGen, %CodeGen* %t7, i32 0, i32 2
  %t9 = load i64, i64* %t8
  %t10 = add i64 %t9, 1
  %t11 = load i64, i64* %t0
  %t12 = inttoptr i64 %t11 to %CodeGen*
  %t13 = getelementptr %CodeGen, %CodeGen* %t12, i32 0, i32 2
  store i64 %t10, i64* %t13
  %t14 = getelementptr [3 x i8], [3 x i8]* @.str.515, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  %t16 = load i64, i64* %t5
  %t17 = call i64 @kore_to_string(i64 %t16)
  %t18 = call i64 @kore_str_concat(i64 %t15, i64 %t17)
  ret i64 %t18
  %t19 = getelementptr [7 x i8], [7 x i8]* @.str.516, i64 0, i64 0
  %t20 = ptrtoint i8* %t19 to i64
  ret i64 %t20
}
define i64 @CodeGen_fresh_label(i64 %self, i64 %prefix) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %prefix, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = inttoptr i64 %t2 to %CodeGen*
  %t4 = getelementptr %CodeGen, %CodeGen* %t3, i32 0, i32 4
  %t5 = load i64, i64* %t4
  %t6 = alloca i64
  store i64 %t5, i64* %t6
  %t7 = load i64, i64* %t0
  %t8 = inttoptr i64 %t7 to %CodeGen*
  %t9 = getelementptr %CodeGen, %CodeGen* %t8, i32 0, i32 4
  %t10 = load i64, i64* %t9
  %t11 = add i64 %t10, 1
  %t12 = load i64, i64* %t0
  %t13 = inttoptr i64 %t12 to %CodeGen*
  %t14 = getelementptr %CodeGen, %CodeGen* %t13, i32 0, i32 4
  store i64 %t11, i64* %t14
  %t15 = load i64, i64* %t1
  %t16 = load i64, i64* %t6
  %t17 = call i64 @kore_to_string(i64 %t16)
  %t18 = call i64 @kore_str_concat(i64 %t15, i64 %t17)
  ret i64 %t18
}
define i64 @CodeGen_fresh_string(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %CodeGen*
  %t3 = getelementptr %CodeGen, %CodeGen* %t2, i32 0, i32 3
  %t4 = load i64, i64* %t3
  %t5 = alloca i64
  store i64 %t4, i64* %t5
  %t6 = load i64, i64* %t0
  %t7 = inttoptr i64 %t6 to %CodeGen*
  %t8 = getelementptr %CodeGen, %CodeGen* %t7, i32 0, i32 3
  %t9 = load i64, i64* %t8
  %t10 = add i64 %t9, 1
  %t11 = load i64, i64* %t0
  %t12 = inttoptr i64 %t11 to %CodeGen*
  %t13 = getelementptr %CodeGen, %CodeGen* %t12, i32 0, i32 3
  store i64 %t10, i64* %t13
  %t14 = getelementptr [7 x i8], [7 x i8]* @.str.517, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  %t16 = load i64, i64* %t5
  %t17 = call i64 @kore_to_string(i64 %t16)
  %t18 = call i64 @kore_str_concat(i64 %t15, i64 %t17)
  ret i64 %t18
}
define i64 @CodeGen_write_line(i64 %self, i64 %line) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %line, i64* %t1
  %t2 = getelementptr [1 x i8], [1 x i8]* @.str.518, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = alloca i64
  store i64 %t3, i64* %t4
  ; for i in ...
  %t5 = load i64, i64* %t0
  %t6 = inttoptr i64 %t5 to %CodeGen*
  %t7 = getelementptr %CodeGen, %CodeGen* %t6, i32 0, i32 1
  %t8 = load i64, i64* %t7
  %t9 = call i64 @kore_range(i64 0, i64 %t8)
  %t10 = call i64 @kore_array_len(i64 %t9)
  %t11 = alloca i64
  store i64 0, i64* %t11
  br label %for_cond633
  for_cond633:
  %t12 = load i64, i64* %t11
  %t13 = icmp slt i64 %t12, %t10
  br i1 %t13, label %for_body634, label %for_end636
  for_body634:
  %t14 = call i64 @kore_array_get(i64 %t9, i64 %t12)
  %t15 = alloca i64
  store i64 %t14, i64* %t15
  %t16 = load i64, i64* %t4
  %t17 = getelementptr [3 x i8], [3 x i8]* @.str.519, i64 0, i64 0
  %t18 = ptrtoint i8* %t17 to i64
  %t19 = call i64 @kore_str_concat(i64 %t16, i64 %t18)
  store i64 %t19, i64* %t4
  br label %for_update635
  for_update635:
  %t20 = load i64, i64* %t11
  %t21 = add i64 %t20, 1
  store i64 %t21, i64* %t11
  br label %for_cond633
  for_end636:
  %t22 = load i64, i64* %t0
  %t23 = inttoptr i64 %t22 to %CodeGen*
  %t24 = getelementptr %CodeGen, %CodeGen* %t23, i32 0, i32 0
  %t25 = load i64, i64* %t24
  %t26 = load i64, i64* %t4
  %t27 = load i64, i64* %t1
  %t28 = call i64 @kore_str_concat(i64 %t26, i64 %t27)
  %t29 = call i64 @StringBuilder_push_line(i64 %t25, i64 %t28)
  ret i64 0
}
define i64 @CodeGen_emit_raw(i64 %self, i64 %text) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %text, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = inttoptr i64 %t2 to %CodeGen*
  %t4 = getelementptr %CodeGen, %CodeGen* %t3, i32 0, i32 0
  %t5 = load i64, i64* %t4
  %t6 = load i64, i64* %t1
  %t7 = call i64 @StringBuilder_push(i64 %t5, i64 %t6)
  ret i64 0
}
define i64 @CodeGen_gen_program(i64 %self, i64 %program) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %program, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = getelementptr [33 x i8], [33 x i8]* @.str.520, i64 0, i64 0
  %t4 = ptrtoint i8* %t3 to i64
  %t5 = call i64 @CodeGen_write_line(i64 %t2, i64 %t4)
  %t6 = load i64, i64* %t0
  %t7 = getelementptr [33 x i8], [33 x i8]* @.str.521, i64 0, i64 0
  %t8 = ptrtoint i8* %t7 to i64
  %t9 = call i64 @CodeGen_write_line(i64 %t6, i64 %t8)
  %t10 = load i64, i64* %t0
  %t11 = getelementptr [42 x i8], [42 x i8]* @.str.522, i64 0, i64 0
  %t12 = ptrtoint i8* %t11 to i64
  %t13 = call i64 @CodeGen_write_line(i64 %t10, i64 %t12)
  %t14 = load i64, i64* %t0
  %t15 = getelementptr [1 x i8], [1 x i8]* @.str.523, i64 0, i64 0
  %t16 = ptrtoint i8* %t15 to i64
  %t17 = call i64 @CodeGen_write_line(i64 %t14, i64 %t16)
  %t18 = load i64, i64* %t0
  %t19 = getelementptr [1 x i8], [1 x i8]* @.str.524, i64 0, i64 0
  %t20 = ptrtoint i8* %t19 to i64
  %t21 = call i64 @CodeGen_write_line(i64 %t18, i64 %t20)
  %t22 = load i64, i64* %t0
  %t23 = call i64 @CodeGen_emit_externals(i64 %t22)
  %t24 = load i64, i64* %t0
  %t25 = getelementptr [1 x i8], [1 x i8]* @.str.525, i64 0, i64 0
  %t26 = ptrtoint i8* %t25 to i64
  %t27 = call i64 @CodeGen_write_line(i64 %t24, i64 %t26)
  ; for item in ...
  %t28 = load i64, i64* %t1
  %t29 = inttoptr i64 %t28 to %Program*
  %t30 = getelementptr %Program, %Program* %t29, i32 0, i32 0
  %t31 = load i64, i64* %t30
  %t32 = call i64 @kore_array_len(i64 %t31)
  %t33 = alloca i64
  store i64 0, i64* %t33
  br label %for_cond637
  for_cond637:
  %t34 = load i64, i64* %t33
  %t35 = icmp slt i64 %t34, %t32
  br i1 %t35, label %for_body638, label %for_end640
  for_body638:
  %t36 = call i64 @kore_array_get(i64 %t31, i64 %t34)
  %t37 = alloca i64
  store i64 %t36, i64* %t37
  ; match
  %t38 = load i64, i64* %t37
  %t39 = inttoptr i64 %t38 to { i64, i8* }*
  %t40 = getelementptr { i64, i8* }, { i64, i8* }* %t39, i32 0, i32 0
  %t41 = load i64, i64* %t40
  %t42 = icmp eq i64 %t41, 1
  br i1 %t42, label %match_body643, label %match_next642
  match_body643:
  %t43 = getelementptr { i64, i8* }, { i64, i8* }* %t39, i32 0, i32 1
  %t44 = load i8*, i8** %t43
  %t45 = ptrtoint i8* %t44 to i64
  %t46 = inttoptr i64 %t45 to i64*
  %t47 = getelementptr i64, i64* %t46, i32 0
  %t48 = load i64, i64* %t47
  %t49 = alloca i64
  store i64 %t48, i64* %t49
  %t50 = call i64 @kore_array_new()
  %t51 = alloca i64
  store i64 %t50, i64* %t51
  ; for f in ...
  %t52 = load i64, i64* %t49
  %t53 = inttoptr i64 %t52 to %StructDef*
  %t54 = getelementptr %StructDef, %StructDef* %t53, i32 0, i32 1
  %t55 = load i64, i64* %t54
  %t56 = call i64 @kore_array_len(i64 %t55)
  %t57 = alloca i64
  store i64 0, i64* %t57
  br label %for_cond644
  for_cond644:
  %t58 = load i64, i64* %t57
  %t59 = icmp slt i64 %t58, %t56
  br i1 %t59, label %for_body645, label %for_end647
  for_body645:
  %t60 = call i64 @kore_array_get(i64 %t55, i64 %t58)
  %t61 = alloca i64
  store i64 %t60, i64* %t61
  %t62 = load i64, i64* %t51
  %t63 = load i64, i64* %t61
  %t64 = inttoptr i64 %t63 to %FieldInit*
  %t65 = getelementptr %FieldInit, %FieldInit* %t64, i32 0, i32 0
  %t66 = load i64, i64* %t65
  %t67 = call i64 @kore_array_push(i64 %t62, i64 %t66)
  %t68 = load i64, i64* %t0
  %t69 = inttoptr i64 %t68 to %CodeGen*
  %t70 = getelementptr %CodeGen, %CodeGen* %t69, i32 0, i32 9
  %t71 = load i64, i64* %t70
  %t72 = load i64, i64* %t61
  %t73 = inttoptr i64 %t72 to %FieldInit*
  %t74 = getelementptr %FieldInit, %FieldInit* %t73, i32 0, i32 0
  %t75 = load i64, i64* %t74
  %t76 = load i64, i64* %t49
  %t77 = inttoptr i64 %t76 to %StructDef*
  %t78 = getelementptr %StructDef, %StructDef* %t77, i32 0, i32 0
  %t79 = load i64, i64* %t78
  %t80 = call i64 @kore_map_set(i64 %t71, i64 %t75, i64 %t79)
  br label %for_update646
  for_update646:
  %t81 = load i64, i64* %t57
  %t82 = add i64 %t81, 1
  store i64 %t82, i64* %t57
  br label %for_cond644
  for_end647:
  %t83 = load i64, i64* %t0
  %t84 = inttoptr i64 %t83 to %CodeGen*
  %t85 = getelementptr %CodeGen, %CodeGen* %t84, i32 0, i32 8
  %t86 = load i64, i64* %t85
  %t87 = load i64, i64* %t49
  %t88 = inttoptr i64 %t87 to %StructDef*
  %t89 = getelementptr %StructDef, %StructDef* %t88, i32 0, i32 0
  %t90 = load i64, i64* %t89
  %t91 = load i64, i64* %t51
  %t92 = call i64 @kore_map_set(i64 %t86, i64 %t90, i64 %t91)
  br label %match_end641
  match_next642:
  %t93 = inttoptr i64 %t38 to { i64, i8* }*
  %t94 = getelementptr { i64, i8* }, { i64, i8* }* %t93, i32 0, i32 0
  %t95 = load i64, i64* %t94
  %t96 = icmp eq i64 %t95, 3
  br i1 %t96, label %match_body649, label %match_next648
  match_body649:
  %t97 = getelementptr { i64, i8* }, { i64, i8* }* %t93, i32 0, i32 1
  %t98 = load i8*, i8** %t97
  %t99 = ptrtoint i8* %t98 to i64
  %t100 = inttoptr i64 %t99 to i64*
  %t101 = getelementptr i64, i64* %t100, i32 0
  %t102 = load i64, i64* %t101
  %t103 = alloca i64
  store i64 %t102, i64* %t103
  ; for m in ...
  %t104 = load i64, i64* %t103
  %t105 = inttoptr i64 %t104 to %ImplDef*
  %t106 = getelementptr %ImplDef, %ImplDef* %t105, i32 0, i32 1
  %t107 = load i64, i64* %t106
  %t108 = call i64 @kore_array_len(i64 %t107)
  %t109 = alloca i64
  store i64 0, i64* %t109
  br label %for_cond650
  for_cond650:
  %t110 = load i64, i64* %t109
  %t111 = icmp slt i64 %t110, %t108
  br i1 %t111, label %for_body651, label %for_end653
  for_body651:
  %t112 = call i64 @kore_array_get(i64 %t107, i64 %t110)
  %t113 = alloca i64
  store i64 %t112, i64* %t113
  %t114 = load i64, i64* %t0
  %t115 = inttoptr i64 %t114 to %CodeGen*
  %t116 = getelementptr %CodeGen, %CodeGen* %t115, i32 0, i32 10
  %t117 = load i64, i64* %t116
  %t118 = load i64, i64* %t113
  %t119 = inttoptr i64 %t118 to %FieldInit*
  %t120 = getelementptr %FieldInit, %FieldInit* %t119, i32 0, i32 0
  %t121 = load i64, i64* %t120
  %t122 = load i64, i64* %t103
  %t123 = inttoptr i64 %t122 to %ImplDef*
  %t124 = getelementptr %ImplDef, %ImplDef* %t123, i32 0, i32 0
  %t125 = load i64, i64* %t124
  %t126 = call i64 @kore_map_set(i64 %t117, i64 %t121, i64 %t125)
  br label %for_update652
  for_update652:
  %t127 = load i64, i64* %t109
  %t128 = add i64 %t127, 1
  store i64 %t128, i64* %t109
  br label %for_cond650
  for_end653:
  br label %match_end641
  match_next648:
  br label %match_body655
  match_body655:
  br label %match_end641
  match_next654:
  br label %match_end641
  match_end641:
  br label %for_update639
  for_update639:
  %t129 = load i64, i64* %t33
  %t130 = add i64 %t129, 1
  store i64 %t130, i64* %t33
  br label %for_cond637
  for_end640:
  %t131 = load i64, i64* %t1
  %t132 = inttoptr i64 %t131 to %Program*
  %t133 = getelementptr %Program, %Program* %t132, i32 0, i32 0
  %t134 = load i64, i64* %t133
  %t135 = alloca i64
  store i64 %t134, i64* %t135
  %t136 = load i64, i64* %t135
  call void @kore_print_i64(i64 %t136)
  %t137 = load i64, i64* %t135
  %t138 = call i64 @kore_array_len(i64 %t137)
  %t139 = alloca i64
  store i64 %t138, i64* %t139
  %t140 = load i64, i64* %t139
  call void @kore_print_i64(i64 %t140)
  ; for item in ...
  %t141 = load i64, i64* %t1
  %t142 = inttoptr i64 %t141 to %Program*
  %t143 = getelementptr %Program, %Program* %t142, i32 0, i32 0
  %t144 = load i64, i64* %t143
  %t145 = call i64 @kore_array_len(i64 %t144)
  %t146 = alloca i64
  store i64 0, i64* %t146
  br label %for_cond656
  for_cond656:
  %t147 = load i64, i64* %t146
  %t148 = icmp slt i64 %t147, %t145
  br i1 %t148, label %for_body657, label %for_end659
  for_body657:
  %t149 = call i64 @kore_array_get(i64 %t144, i64 %t147)
  %t150 = alloca i64
  store i64 %t149, i64* %t150
  %t151 = load i64, i64* %t0
  %t152 = load i64, i64* %t150
  %t153 = call i64 @CodeGen_gen_item(i64 %t151, i64 %t152)
  %t154 = load i64, i64* %t0
  %t155 = getelementptr [1 x i8], [1 x i8]* @.str.526, i64 0, i64 0
  %t156 = ptrtoint i8* %t155 to i64
  %t157 = call i64 @CodeGen_write_line(i64 %t154, i64 %t156)
  br label %for_update658
  for_update658:
  %t158 = load i64, i64* %t146
  %t159 = add i64 %t158, 1
  store i64 %t159, i64* %t146
  br label %for_cond656
  for_end659:
  %t160 = load i64, i64* %t0
  %t161 = inttoptr i64 %t160 to %CodeGen*
  %t162 = getelementptr %CodeGen, %CodeGen* %t161, i32 0, i32 5
  %t163 = load i64, i64* %t162
  %t164 = call i64 @kore_array_len(i64 %t163)
  %t166 = icmp sgt i64 %t164, 0
  %t165 = zext i1 %t166 to i64
  %t167 = icmp ne i64 %t165, 0
  br i1 %t167, label %then660, label %endif662
  then660:
  %t168 = load i64, i64* %t0
  %t169 = getelementptr [19 x i8], [19 x i8]* @.str.527, i64 0, i64 0
  %t170 = ptrtoint i8* %t169 to i64
  %t171 = call i64 @CodeGen_write_line(i64 %t168, i64 %t170)
  ; for i in ...
  %t172 = load i64, i64* %t0
  %t173 = inttoptr i64 %t172 to %CodeGen*
  %t174 = getelementptr %CodeGen, %CodeGen* %t173, i32 0, i32 5
  %t175 = load i64, i64* %t174
  %t176 = call i64 @kore_array_len(i64 %t175)
  %t177 = call i64 @kore_range(i64 0, i64 %t176)
  %t178 = call i64 @kore_array_len(i64 %t177)
  %t179 = alloca i64
  store i64 0, i64* %t179
  br label %for_cond663
  for_cond663:
  %t180 = load i64, i64* %t179
  %t181 = icmp slt i64 %t180, %t178
  br i1 %t181, label %for_body664, label %for_end666
  for_body664:
  %t182 = call i64 @kore_array_get(i64 %t177, i64 %t180)
  %t183 = alloca i64
  store i64 %t182, i64* %t183
  %t184 = load i64, i64* %t0
  %t185 = inttoptr i64 %t184 to %CodeGen*
  %t186 = getelementptr %CodeGen, %CodeGen* %t185, i32 0, i32 5
  %t187 = load i64, i64* %t186
  %t188 = load i64, i64* %t183
  %t189 = call i64 @kore_array_get(i64 %t187, i64 %t188)
  %t190 = alloca i64
  store i64 %t189, i64* %t190
  %t191 = getelementptr [7 x i8], [7 x i8]* @.str.528, i64 0, i64 0
  %t192 = ptrtoint i8* %t191 to i64
  %t193 = load i64, i64* %t183
  %t194 = call i64 @kore_to_string(i64 %t193)
  %t195 = call i64 @kore_str_concat(i64 %t192, i64 %t194)
  %t196 = alloca i64
  store i64 %t195, i64* %t196
  %t197 = load i64, i64* %t0
  %t198 = load i64, i64* %t190
  %t199 = call i64 @CodeGen_escape_string(i64 %t197, i64 %t198)
  %t200 = alloca i64
  store i64 %t199, i64* %t200
  %t201 = load i64, i64* %t0
  %t202 = load i64, i64* %t196
  %t203 = getelementptr [35 x i8], [35 x i8]* @.str.529, i64 0, i64 0
  %t204 = ptrtoint i8* %t203 to i64
  %t205 = call i64 @kore_str_concat(i64 %t202, i64 %t204)
  %t206 = load i64, i64* %t190
  %t207 = call i64 @kore_str_len(i64 %t206)
  %t208 = call i64 @kore_add_op(i64 %t207, i64 1)
  %t209 = call i64 @kore_to_string(i64 %t208)
  %t210 = call i64 @kore_str_concat(i64 %t205, i64 %t209)
  %t211 = getelementptr [9 x i8], [9 x i8]* @.str.530, i64 0, i64 0
  %t212 = ptrtoint i8* %t211 to i64
  %t213 = call i64 @kore_str_concat(i64 %t210, i64 %t212)
  %t214 = load i64, i64* %t200
  %t215 = call i64 @kore_str_concat(i64 %t213, i64 %t214)
  %t216 = getelementptr [4 x i8], [4 x i8]* @.str.531, i64 0, i64 0
  %t217 = ptrtoint i8* %t216 to i64
  %t218 = call i64 @kore_str_concat(i64 %t215, i64 %t217)
  %t219 = call i64 @CodeGen_write_line(i64 %t201, i64 %t218)
  br label %for_update665
  for_update665:
  %t220 = load i64, i64* %t179
  %t221 = add i64 %t220, 1
  store i64 %t221, i64* %t179
  br label %for_cond663
  for_end666:
  br label %endif662
  endif662:
  %t222 = load i64, i64* %t0
  %t223 = inttoptr i64 %t222 to %CodeGen*
  %t224 = getelementptr %CodeGen, %CodeGen* %t223, i32 0, i32 0
  %t225 = load i64, i64* %t224
  %t226 = call i64 @StringBuilder_build(i64 %t225)
  ret i64 %t226
}
define i64 @CodeGen_emit_externals(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = getelementptr [29 x i8], [29 x i8]* @.str.532, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = call i64 @CodeGen_write_line(i64 %t1, i64 %t3)
  %t5 = load i64, i64* %t0
  %t6 = getelementptr [25 x i8], [25 x i8]* @.str.533, i64 0, i64 0
  %t7 = ptrtoint i8* %t6 to i64
  %t8 = call i64 @CodeGen_write_line(i64 %t5, i64 %t7)
  %t9 = load i64, i64* %t0
  %t10 = getelementptr [24 x i8], [24 x i8]* @.str.534, i64 0, i64 0
  %t11 = ptrtoint i8* %t10 to i64
  %t12 = call i64 @CodeGen_write_line(i64 %t9, i64 %t11)
  %t13 = load i64, i64* %t0
  %t14 = getelementptr [30 x i8], [30 x i8]* @.str.535, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  %t16 = call i64 @CodeGen_write_line(i64 %t13, i64 %t15)
  %t17 = load i64, i64* %t0
  %t18 = getelementptr [23 x i8], [23 x i8]* @.str.536, i64 0, i64 0
  %t19 = ptrtoint i8* %t18 to i64
  %t20 = call i64 @CodeGen_write_line(i64 %t17, i64 %t19)
  %t21 = load i64, i64* %t0
  %t22 = getelementptr [1 x i8], [1 x i8]* @.str.537, i64 0, i64 0
  %t23 = ptrtoint i8* %t22 to i64
  %t24 = call i64 @CodeGen_write_line(i64 %t21, i64 %t23)
  %t25 = load i64, i64* %t0
  %t26 = getelementptr [15 x i8], [15 x i8]* @.str.538, i64 0, i64 0
  %t27 = ptrtoint i8* %t26 to i64
  %t28 = call i64 @CodeGen_write_line(i64 %t25, i64 %t27)
  %t29 = load i64, i64* %t0
  %t30 = getelementptr [34 x i8], [34 x i8]* @.str.539, i64 0, i64 0
  %t31 = ptrtoint i8* %t30 to i64
  %t32 = call i64 @CodeGen_write_line(i64 %t29, i64 %t31)
  %t33 = load i64, i64* %t0
  %t34 = getelementptr [34 x i8], [34 x i8]* @.str.540, i64 0, i64 0
  %t35 = ptrtoint i8* %t34 to i64
  %t36 = call i64 @CodeGen_write_line(i64 %t33, i64 %t35)
  %t37 = load i64, i64* %t0
  %t38 = getelementptr [36 x i8], [36 x i8]* @.str.541, i64 0, i64 0
  %t39 = ptrtoint i8* %t38 to i64
  %t40 = call i64 @CodeGen_write_line(i64 %t37, i64 %t39)
  %t41 = load i64, i64* %t0
  %t42 = getelementptr [39 x i8], [39 x i8]* @.str.542, i64 0, i64 0
  %t43 = ptrtoint i8* %t42 to i64
  %t44 = call i64 @CodeGen_write_line(i64 %t41, i64 %t43)
  %t45 = load i64, i64* %t0
  %t46 = getelementptr [30 x i8], [30 x i8]* @.str.543, i64 0, i64 0
  %t47 = ptrtoint i8* %t46 to i64
  %t48 = call i64 @CodeGen_write_line(i64 %t45, i64 %t47)
  %t49 = load i64, i64* %t0
  %t50 = getelementptr [40 x i8], [40 x i8]* @.str.544, i64 0, i64 0
  %t51 = ptrtoint i8* %t50 to i64
  %t52 = call i64 @CodeGen_write_line(i64 %t49, i64 %t51)
  %t53 = load i64, i64* %t0
  %t54 = getelementptr [38 x i8], [38 x i8]* @.str.545, i64 0, i64 0
  %t55 = ptrtoint i8* %t54 to i64
  %t56 = call i64 @CodeGen_write_line(i64 %t53, i64 %t55)
  %t57 = load i64, i64* %t0
  %t58 = getelementptr [33 x i8], [33 x i8]* @.str.546, i64 0, i64 0
  %t59 = ptrtoint i8* %t58 to i64
  %t60 = call i64 @CodeGen_write_line(i64 %t57, i64 %t59)
  ret i64 0
}
define i64 @CodeGen_escape_string(i64 %self, i64 %s) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %s, i64* %t1
  %t2 = getelementptr [1 x i8], [1 x i8]* @.str.547, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = alloca i64
  store i64 %t3, i64* %t4
  %t5 = load i64, i64* %t1
  %t6 = getelementptr [1 x i8], [1 x i8]* @.str.548, i64 0, i64 0
  %t7 = ptrtoint i8* %t6 to i64
  %t8 = call i64 @kore_split(i64 %t5, i64 %t7)
  %t9 = alloca i64
  store i64 %t8, i64* %t9
  ; for c in ...
  %t10 = load i64, i64* %t9
  %t11 = call i64 @kore_array_len(i64 %t10)
  %t12 = alloca i64
  store i64 0, i64* %t12
  br label %for_cond667
  for_cond667:
  %t13 = load i64, i64* %t12
  %t14 = icmp slt i64 %t13, %t11
  br i1 %t14, label %for_body668, label %for_end670
  for_body668:
  %t15 = call i64 @kore_array_get(i64 %t10, i64 %t13)
  %t16 = alloca i64
  store i64 %t15, i64* %t16
  %t17 = load i64, i64* %t16
  %t18 = getelementptr [2 x i8], [2 x i8]* @.str.549, i64 0, i64 0
  %t19 = ptrtoint i8* %t18 to i64
  %t20 = call i64 @kore_str_eq(i64 %t17, i64 %t19)
  %t21 = icmp ne i64 %t20, 0
  br i1 %t21, label %then671, label %else672
  then671:
  %t22 = load i64, i64* %t4
  %t23 = getelementptr [4 x i8], [4 x i8]* @.str.550, i64 0, i64 0
  %t24 = ptrtoint i8* %t23 to i64
  %t25 = call i64 @kore_str_concat(i64 %t22, i64 %t24)
  store i64 %t25, i64* %t4
  br label %endif673
  else672:
  %t26 = load i64, i64* %t16
  %t27 = getelementptr [2 x i8], [2 x i8]* @.str.551, i64 0, i64 0
  %t28 = ptrtoint i8* %t27 to i64
  %t29 = call i64 @kore_str_eq(i64 %t26, i64 %t28)
  %t30 = icmp ne i64 %t29, 0
  br i1 %t30, label %then674, label %else675
  then674:
  %t31 = load i64, i64* %t4
  %t32 = getelementptr [4 x i8], [4 x i8]* @.str.552, i64 0, i64 0
  %t33 = ptrtoint i8* %t32 to i64
  %t34 = call i64 @kore_str_concat(i64 %t31, i64 %t33)
  store i64 %t34, i64* %t4
  br label %endif676
  else675:
  %t35 = load i64, i64* %t16
  %t36 = getelementptr [2 x i8], [2 x i8]* @.str.553, i64 0, i64 0
  %t37 = ptrtoint i8* %t36 to i64
  %t38 = call i64 @kore_str_eq(i64 %t35, i64 %t37)
  %t39 = icmp ne i64 %t38, 0
  br i1 %t39, label %then677, label %else678
  then677:
  %t40 = load i64, i64* %t4
  %t41 = getelementptr [3 x i8], [3 x i8]* @.str.554, i64 0, i64 0
  %t42 = ptrtoint i8* %t41 to i64
  %t43 = call i64 @kore_str_concat(i64 %t40, i64 %t42)
  store i64 %t43, i64* %t4
  br label %endif679
  else678:
  %t44 = load i64, i64* %t16
  %t45 = getelementptr [1 x i8], [1 x i8]* @.str.555, i64 0, i64 0
  %t46 = ptrtoint i8* %t45 to i64
  %t47 = call i64 @kore_str_eq(i64 %t44, i64 %t46)
  %t48 = icmp ne i64 %t47, 0
  br i1 %t48, label %then680, label %else681
  then680:
  %t49 = load i64, i64* %t4
  %t50 = getelementptr [4 x i8], [4 x i8]* @.str.556, i64 0, i64 0
  %t51 = ptrtoint i8* %t50 to i64
  %t52 = call i64 @kore_str_concat(i64 %t49, i64 %t51)
  store i64 %t52, i64* %t4
  br label %endif682
  else681:
  %t53 = load i64, i64* %t4
  %t54 = load i64, i64* %t16
  %t55 = call i64 @kore_str_concat(i64 %t53, i64 %t54)
  store i64 %t55, i64* %t4
  br label %endif682
  endif682:
  br label %endif679
  endif679:
  br label %endif676
  endif676:
  br label %endif673
  endif673:
  br label %for_update669
  for_update669:
  %t56 = load i64, i64* %t12
  %t57 = add i64 %t56, 1
  store i64 %t57, i64* %t12
  br label %for_cond667
  for_end670:
  %t58 = load i64, i64* %t4
  ret i64 %t58
}
define i64 @CodeGen_gen_item(i64 %self, i64 %item) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %item, i64* %t1
  %t2 = load i64, i64* %t1
  %t3 = call i64 @kore_variant_of(i64 %t2)
  %t4 = alloca i64
  store i64 %t3, i64* %t4
  ; match
  %t5 = load i64, i64* %t1
  %t6 = inttoptr i64 %t5 to { i64, i8* }*
  %t7 = getelementptr { i64, i8* }, { i64, i8* }* %t6, i32 0, i32 0
  %t8 = load i64, i64* %t7
  %t9 = icmp eq i64 %t8, 0
  br i1 %t9, label %match_body685, label %match_next684
  match_body685:
  %t10 = getelementptr { i64, i8* }, { i64, i8* }* %t6, i32 0, i32 1
  %t11 = load i8*, i8** %t10
  %t12 = ptrtoint i8* %t11 to i64
  %t13 = inttoptr i64 %t12 to i64*
  %t14 = getelementptr i64, i64* %t13, i32 0
  %t15 = load i64, i64* %t14
  %t16 = alloca i64
  store i64 %t15, i64* %t16
  %t17 = load i64, i64* %t0
  %t18 = load i64, i64* %t16
  %t19 = call i64 @CodeGen_gen_function(i64 %t17, i64 %t18)
  br label %match_end683
  match_next684:
  %t20 = inttoptr i64 %t5 to { i64, i8* }*
  %t21 = getelementptr { i64, i8* }, { i64, i8* }* %t20, i32 0, i32 0
  %t22 = load i64, i64* %t21
  %t23 = icmp eq i64 %t22, 1
  br i1 %t23, label %match_body687, label %match_next686
  match_body687:
  %t24 = getelementptr { i64, i8* }, { i64, i8* }* %t20, i32 0, i32 1
  %t25 = load i8*, i8** %t24
  %t26 = ptrtoint i8* %t25 to i64
  %t27 = inttoptr i64 %t26 to i64*
  %t28 = getelementptr i64, i64* %t27, i32 0
  %t29 = load i64, i64* %t28
  %t30 = alloca i64
  store i64 %t29, i64* %t30
  %t31 = load i64, i64* %t0
  %t32 = load i64, i64* %t30
  %t33 = call i64 @CodeGen_gen_struct(i64 %t31, i64 %t32)
  br label %match_end683
  match_next686:
  %t34 = inttoptr i64 %t5 to { i64, i8* }*
  %t35 = getelementptr { i64, i8* }, { i64, i8* }* %t34, i32 0, i32 0
  %t36 = load i64, i64* %t35
  %t37 = icmp eq i64 %t36, 2
  br i1 %t37, label %match_body689, label %match_next688
  match_body689:
  %t38 = getelementptr { i64, i8* }, { i64, i8* }* %t34, i32 0, i32 1
  %t39 = load i8*, i8** %t38
  %t40 = ptrtoint i8* %t39 to i64
  %t41 = inttoptr i64 %t40 to i64*
  %t42 = getelementptr i64, i64* %t41, i32 0
  %t43 = load i64, i64* %t42
  %t44 = alloca i64
  store i64 %t43, i64* %t44
  %t45 = load i64, i64* %t0
  %t46 = load i64, i64* %t44
  %t47 = call i64 @CodeGen_gen_enum(i64 %t45, i64 %t46)
  br label %match_end683
  match_next688:
  %t48 = inttoptr i64 %t5 to { i64, i8* }*
  %t49 = getelementptr { i64, i8* }, { i64, i8* }* %t48, i32 0, i32 0
  %t50 = load i64, i64* %t49
  %t51 = icmp eq i64 %t50, 3
  br i1 %t51, label %match_body691, label %match_next690
  match_body691:
  %t52 = getelementptr { i64, i8* }, { i64, i8* }* %t48, i32 0, i32 1
  %t53 = load i8*, i8** %t52
  %t54 = ptrtoint i8* %t53 to i64
  %t55 = inttoptr i64 %t54 to i64*
  %t56 = getelementptr i64, i64* %t55, i32 0
  %t57 = load i64, i64* %t56
  %t58 = alloca i64
  store i64 %t57, i64* %t58
  %t59 = load i64, i64* %t0
  %t60 = load i64, i64* %t58
  %t61 = call i64 @CodeGen_gen_impl(i64 %t59, i64 %t60)
  br label %match_end683
  match_next690:
  %t62 = inttoptr i64 %t5 to { i64, i8* }*
  %t63 = getelementptr { i64, i8* }, { i64, i8* }* %t62, i32 0, i32 0
  %t64 = load i64, i64* %t63
  %t65 = icmp eq i64 %t64, 4
  br i1 %t65, label %match_body693, label %match_next692
  match_body693:
  %t66 = getelementptr { i64, i8* }, { i64, i8* }* %t62, i32 0, i32 1
  %t67 = load i8*, i8** %t66
  %t68 = ptrtoint i8* %t67 to i64
  %t69 = inttoptr i64 %t68 to i64*
  %t70 = getelementptr i64, i64* %t69, i32 0
  %t71 = load i64, i64* %t70
  %t72 = alloca i64
  store i64 %t71, i64* %t72
  %t73 = load i64, i64* %t0
  %t74 = getelementptr [7 x i8], [7 x i8]* @.str.557, i64 0, i64 0
  %t75 = ptrtoint i8* %t74 to i64
  %t76 = load i64, i64* %t72
  %t77 = call i64 @kore_str_concat(i64 %t75, i64 %t76)
  %t78 = call i64 @CodeGen_write_line(i64 %t73, i64 %t77)
  br label %match_end683
  match_next692:
  br label %match_end683
  match_end683:
  ret i64 0
}
define i64 @CodeGen_gen_function(i64 %self, i64 %fn_def) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %fn_def, i64* %t1
  %t2 = load i64, i64* %t1
  %t3 = inttoptr i64 %t2 to %FnDef*
  %t4 = getelementptr %FnDef, %FnDef* %t3, i32 0, i32 0
  %t5 = load i64, i64* %t4
  %t6 = alloca i64
  store i64 %t5, i64* %t6
  %t7 = load i64, i64* %t6
  %t8 = getelementptr [5 x i8], [5 x i8]* @.str.558, i64 0, i64 0
  %t9 = ptrtoint i8* %t8 to i64
  %t10 = call i64 @kore_str_eq(i64 %t7, i64 %t9)
  %t11 = icmp ne i64 %t10, 0
  br i1 %t11, label %then694, label %endif696
  then694:
  %t12 = getelementptr [10 x i8], [10 x i8]* @.str.559, i64 0, i64 0
  %t13 = ptrtoint i8* %t12 to i64
  store i64 %t13, i64* %t6
  br label %endif696
  endif696:
  %t14 = load i64, i64* %t0
  %t15 = inttoptr i64 %t14 to %CodeGen*
  %t16 = getelementptr %CodeGen, %CodeGen* %t15, i32 0, i32 2
  store i64 0, i64* %t16
  %t17 = call i64 @Map_new()
  %t18 = load i64, i64* %t0
  %t19 = inttoptr i64 %t18 to %CodeGen*
  %t20 = getelementptr %CodeGen, %CodeGen* %t19, i32 0, i32 6
  store i64 %t17, i64* %t20
  %t21 = getelementptr [1 x i8], [1 x i8]* @.str.560, i64 0, i64 0
  %t22 = ptrtoint i8* %t21 to i64
  %t23 = alloca i64
  store i64 %t22, i64* %t23
  %t24 = alloca i64
  store i64 1, i64* %t24
  %t25 = load i64, i64* %t1
  %t26 = inttoptr i64 %t25 to %FnDef*
  %t27 = getelementptr %FnDef, %FnDef* %t26, i32 0, i32 1
  %t28 = load i64, i64* %t27
  %t29 = alloca i64
  store i64 %t28, i64* %t29
  ; for param in ...
  %t30 = load i64, i64* %t1
  %t31 = inttoptr i64 %t30 to %FnDef*
  %t32 = getelementptr %FnDef, %FnDef* %t31, i32 0, i32 1
  %t33 = load i64, i64* %t32
  %t34 = call i64 @kore_array_len(i64 %t33)
  %t35 = alloca i64
  store i64 0, i64* %t35
  br label %for_cond697
  for_cond697:
  %t36 = load i64, i64* %t35
  %t37 = icmp slt i64 %t36, %t34
  br i1 %t37, label %for_body698, label %for_end700
  for_body698:
  %t38 = call i64 @kore_array_get(i64 %t33, i64 %t36)
  %t39 = alloca i64
  store i64 %t38, i64* %t39
  %t40 = load i64, i64* %t24
  %t42 = icmp eq i64 %t40, 0
  %t41 = zext i1 %t42 to i64
  %t43 = icmp ne i64 %t41, 0
  br i1 %t43, label %then701, label %endif703
  then701:
  %t44 = load i64, i64* %t23
  %t45 = getelementptr [3 x i8], [3 x i8]* @.str.561, i64 0, i64 0
  %t46 = ptrtoint i8* %t45 to i64
  %t47 = call i64 @kore_str_concat(i64 %t44, i64 %t46)
  store i64 %t47, i64* %t23
  br label %endif703
  endif703:
  store i64 0, i64* %t24
  %t48 = load i64, i64* %t23
  %t49 = getelementptr [6 x i8], [6 x i8]* @.str.562, i64 0, i64 0
  %t50 = ptrtoint i8* %t49 to i64
  %t51 = call i64 @kore_str_concat(i64 %t48, i64 %t50)
  %t52 = load i64, i64* %t39
  %t53 = inttoptr i64 %t52 to %FieldInit*
  %t54 = getelementptr %FieldInit, %FieldInit* %t53, i32 0, i32 0
  %t55 = load i64, i64* %t54
  %t56 = call i64 @kore_str_concat(i64 %t51, i64 %t55)
  store i64 %t56, i64* %t23
  br label %for_update699
  for_update699:
  %t57 = load i64, i64* %t35
  %t58 = add i64 %t57, 1
  store i64 %t58, i64* %t35
  br label %for_cond697
  for_end700:
  %t59 = load i64, i64* %t0
  %t60 = getelementptr [13 x i8], [13 x i8]* @.str.563, i64 0, i64 0
  %t61 = ptrtoint i8* %t60 to i64
  %t62 = load i64, i64* %t6
  %t63 = call i64 @kore_str_concat(i64 %t61, i64 %t62)
  %t64 = getelementptr [2 x i8], [2 x i8]* @.str.564, i64 0, i64 0
  %t65 = ptrtoint i8* %t64 to i64
  %t66 = call i64 @kore_str_concat(i64 %t63, i64 %t65)
  %t67 = load i64, i64* %t23
  %t68 = call i64 @kore_str_concat(i64 %t66, i64 %t67)
  %t69 = getelementptr [4 x i8], [4 x i8]* @.str.565, i64 0, i64 0
  %t70 = ptrtoint i8* %t69 to i64
  %t71 = call i64 @kore_str_concat(i64 %t68, i64 %t70)
  %t72 = call i64 @CodeGen_write_line(i64 %t59, i64 %t71)
  %t73 = load i64, i64* %t0
  %t74 = inttoptr i64 %t73 to %CodeGen*
  %t75 = getelementptr %CodeGen, %CodeGen* %t74, i32 0, i32 1
  %t76 = load i64, i64* %t75
  %t77 = add i64 %t76, 1
  %t78 = load i64, i64* %t0
  %t79 = inttoptr i64 %t78 to %CodeGen*
  %t80 = getelementptr %CodeGen, %CodeGen* %t79, i32 0, i32 1
  store i64 %t77, i64* %t80
  %t81 = load i64, i64* %t0
  %t82 = getelementptr [7 x i8], [7 x i8]* @.str.566, i64 0, i64 0
  %t83 = ptrtoint i8* %t82 to i64
  %t84 = call i64 @CodeGen_write_line(i64 %t81, i64 %t83)
  ; for stmt in ...
  %t85 = load i64, i64* %t1
  %t86 = inttoptr i64 %t85 to %FnDef*
  %t87 = getelementptr %FnDef, %FnDef* %t86, i32 0, i32 3
  %t88 = load i64, i64* %t87
  %t89 = call i64 @kore_array_len(i64 %t88)
  %t90 = alloca i64
  store i64 0, i64* %t90
  br label %for_cond704
  for_cond704:
  %t91 = load i64, i64* %t90
  %t92 = icmp slt i64 %t91, %t89
  br i1 %t92, label %for_body705, label %for_end707
  for_body705:
  %t93 = call i64 @kore_array_get(i64 %t88, i64 %t91)
  %t94 = alloca i64
  store i64 %t93, i64* %t94
  %t95 = load i64, i64* %t0
  %t96 = load i64, i64* %t94
  %t97 = call i64 @CodeGen_gen_stmt(i64 %t95, i64 %t96)
  br label %for_update706
  for_update706:
  %t98 = load i64, i64* %t90
  %t99 = add i64 %t98, 1
  store i64 %t99, i64* %t90
  br label %for_cond704
  for_end707:
  %t100 = load i64, i64* %t0
  %t101 = getelementptr [10 x i8], [10 x i8]* @.str.567, i64 0, i64 0
  %t102 = ptrtoint i8* %t101 to i64
  %t103 = call i64 @CodeGen_write_line(i64 %t100, i64 %t102)
  %t104 = load i64, i64* %t0
  %t105 = inttoptr i64 %t104 to %CodeGen*
  %t106 = getelementptr %CodeGen, %CodeGen* %t105, i32 0, i32 1
  %t107 = load i64, i64* %t106
  %t108 = sub i64 %t107, 1
  %t109 = load i64, i64* %t0
  %t110 = inttoptr i64 %t109 to %CodeGen*
  %t111 = getelementptr %CodeGen, %CodeGen* %t110, i32 0, i32 1
  store i64 %t108, i64* %t111
  %t112 = load i64, i64* %t0
  %t113 = getelementptr [2 x i8], [2 x i8]* @.str.568, i64 0, i64 0
  %t114 = ptrtoint i8* %t113 to i64
  %t115 = call i64 @CodeGen_write_line(i64 %t112, i64 %t114)
  ret i64 0
}
define i64 @CodeGen_gen_struct(i64 %self, i64 %struct_def) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %struct_def, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = getelementptr [10 x i8], [10 x i8]* @.str.569, i64 0, i64 0
  %t4 = ptrtoint i8* %t3 to i64
  %t5 = load i64, i64* %t1
  %t6 = inttoptr i64 %t5 to %StructDef*
  %t7 = getelementptr %StructDef, %StructDef* %t6, i32 0, i32 0
  %t8 = load i64, i64* %t7
  %t9 = call i64 @kore_str_concat(i64 %t4, i64 %t8)
  %t10 = call i64 @CodeGen_write_line(i64 %t2, i64 %t9)
  %t11 = getelementptr [1 x i8], [1 x i8]* @.str.570, i64 0, i64 0
  %t12 = ptrtoint i8* %t11 to i64
  %t13 = alloca i64
  store i64 %t12, i64* %t13
  %t14 = alloca i64
  store i64 1, i64* %t14
  ; for field in ...
  %t15 = load i64, i64* %t1
  %t16 = inttoptr i64 %t15 to %StructDef*
  %t17 = getelementptr %StructDef, %StructDef* %t16, i32 0, i32 1
  %t18 = load i64, i64* %t17
  %t19 = call i64 @kore_array_len(i64 %t18)
  %t20 = alloca i64
  store i64 0, i64* %t20
  br label %for_cond708
  for_cond708:
  %t21 = load i64, i64* %t20
  %t22 = icmp slt i64 %t21, %t19
  br i1 %t22, label %for_body709, label %for_end711
  for_body709:
  %t23 = call i64 @kore_array_get(i64 %t18, i64 %t21)
  %t24 = alloca i64
  store i64 %t23, i64* %t24
  %t25 = load i64, i64* %t14
  %t27 = icmp eq i64 %t25, 0
  %t26 = zext i1 %t27 to i64
  %t28 = icmp ne i64 %t26, 0
  br i1 %t28, label %then712, label %endif714
  then712:
  %t29 = load i64, i64* %t13
  %t30 = getelementptr [3 x i8], [3 x i8]* @.str.571, i64 0, i64 0
  %t31 = ptrtoint i8* %t30 to i64
  %t32 = call i64 @kore_str_concat(i64 %t29, i64 %t31)
  store i64 %t32, i64* %t13
  br label %endif714
  endif714:
  store i64 0, i64* %t14
  %t33 = load i64, i64* %t13
  %t34 = getelementptr [4 x i8], [4 x i8]* @.str.572, i64 0, i64 0
  %t35 = ptrtoint i8* %t34 to i64
  %t36 = call i64 @kore_str_concat(i64 %t33, i64 %t35)
  store i64 %t36, i64* %t13
  br label %for_update710
  for_update710:
  %t37 = load i64, i64* %t20
  %t38 = add i64 %t37, 1
  store i64 %t38, i64* %t20
  br label %for_cond708
  for_end711:
  %t39 = load i64, i64* %t13
  %t40 = getelementptr [1 x i8], [1 x i8]* @.str.573, i64 0, i64 0
  %t41 = ptrtoint i8* %t40 to i64
  %t42 = call i64 @kore_str_eq(i64 %t39, i64 %t41)
  %t43 = icmp ne i64 %t42, 0
  br i1 %t43, label %then715, label %endif717
  then715:
  %t44 = getelementptr [4 x i8], [4 x i8]* @.str.574, i64 0, i64 0
  %t45 = ptrtoint i8* %t44 to i64
  store i64 %t45, i64* %t13
  br label %endif717
  endif717:
  %t46 = load i64, i64* %t0
  %t47 = getelementptr [2 x i8], [2 x i8]* @.str.575, i64 0, i64 0
  %t48 = ptrtoint i8* %t47 to i64
  %t49 = load i64, i64* %t1
  %t50 = inttoptr i64 %t49 to %StructDef*
  %t51 = getelementptr %StructDef, %StructDef* %t50, i32 0, i32 0
  %t52 = load i64, i64* %t51
  %t53 = call i64 @kore_str_concat(i64 %t48, i64 %t52)
  %t54 = getelementptr [11 x i8], [11 x i8]* @.str.576, i64 0, i64 0
  %t55 = ptrtoint i8* %t54 to i64
  %t56 = call i64 @kore_str_concat(i64 %t53, i64 %t55)
  %t57 = load i64, i64* %t13
  %t58 = call i64 @kore_str_concat(i64 %t56, i64 %t57)
  %t59 = getelementptr [3 x i8], [3 x i8]* @.str.577, i64 0, i64 0
  %t60 = ptrtoint i8* %t59 to i64
  %t61 = call i64 @kore_str_concat(i64 %t58, i64 %t60)
  %t62 = call i64 @CodeGen_write_line(i64 %t46, i64 %t61)
  ret i64 0
}
define i64 @CodeGen_gen_enum(i64 %self, i64 %enum_def) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %enum_def, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = getelementptr [8 x i8], [8 x i8]* @.str.578, i64 0, i64 0
  %t4 = ptrtoint i8* %t3 to i64
  %t5 = load i64, i64* %t1
  %t6 = inttoptr i64 %t5 to %EnumDef*
  %t7 = getelementptr %EnumDef, %EnumDef* %t6, i32 0, i32 0
  %t8 = load i64, i64* %t7
  %t9 = call i64 @kore_str_concat(i64 %t4, i64 %t8)
  %t10 = call i64 @CodeGen_write_line(i64 %t2, i64 %t9)
  %t11 = load i64, i64* %t0
  %t12 = getelementptr [2 x i8], [2 x i8]* @.str.579, i64 0, i64 0
  %t13 = ptrtoint i8* %t12 to i64
  %t14 = load i64, i64* %t1
  %t15 = inttoptr i64 %t14 to %EnumDef*
  %t16 = getelementptr %EnumDef, %EnumDef* %t15, i32 0, i32 0
  %t17 = load i64, i64* %t16
  %t18 = call i64 @kore_str_concat(i64 %t13, i64 %t17)
  %t19 = getelementptr [21 x i8], [21 x i8]* @.str.580, i64 0, i64 0
  %t20 = ptrtoint i8* %t19 to i64
  %t21 = call i64 @kore_str_concat(i64 %t18, i64 %t20)
  %t22 = call i64 @CodeGen_write_line(i64 %t11, i64 %t21)
  ret i64 0
}
define i64 @CodeGen_gen_impl(i64 %self, i64 %impl_def) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %impl_def, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = getelementptr [8 x i8], [8 x i8]* @.str.581, i64 0, i64 0
  %t4 = ptrtoint i8* %t3 to i64
  %t5 = load i64, i64* %t1
  %t6 = inttoptr i64 %t5 to %ImplDef*
  %t7 = getelementptr %ImplDef, %ImplDef* %t6, i32 0, i32 0
  %t8 = load i64, i64* %t7
  %t9 = call i64 @kore_str_concat(i64 %t4, i64 %t8)
  %t10 = call i64 @CodeGen_write_line(i64 %t2, i64 %t9)
  ; for method in ...
  %t11 = load i64, i64* %t1
  %t12 = inttoptr i64 %t11 to %ImplDef*
  %t13 = getelementptr %ImplDef, %ImplDef* %t12, i32 0, i32 1
  %t14 = load i64, i64* %t13
  %t15 = call i64 @kore_array_len(i64 %t14)
  %t16 = alloca i64
  store i64 0, i64* %t16
  br label %for_cond718
  for_cond718:
  %t17 = load i64, i64* %t16
  %t18 = icmp slt i64 %t17, %t15
  br i1 %t18, label %for_body719, label %for_end721
  for_body719:
  %t19 = call i64 @kore_array_get(i64 %t14, i64 %t17)
  %t20 = alloca i64
  store i64 %t19, i64* %t20
  %t21 = load i64, i64* %t20
  %t22 = inttoptr i64 %t21 to %FieldInit*
  %t23 = getelementptr %FieldInit, %FieldInit* %t22, i32 0, i32 0
  %t24 = load i64, i64* %t23
  %t25 = alloca i64
  store i64 %t24, i64* %t25
  %t26 = load i64, i64* %t1
  %t27 = inttoptr i64 %t26 to %ImplDef*
  %t28 = getelementptr %ImplDef, %ImplDef* %t27, i32 0, i32 0
  %t29 = load i64, i64* %t28
  %t30 = getelementptr [2 x i8], [2 x i8]* @.str.582, i64 0, i64 0
  %t31 = ptrtoint i8* %t30 to i64
  %t32 = call i64 @kore_str_concat(i64 %t29, i64 %t31)
  %t33 = load i64, i64* %t20
  %t34 = inttoptr i64 %t33 to %FieldInit*
  %t35 = getelementptr %FieldInit, %FieldInit* %t34, i32 0, i32 0
  %t36 = load i64, i64* %t35
  %t37 = call i64 @kore_str_concat(i64 %t32, i64 %t36)
  %t38 = load i64, i64* %t20
  %t39 = inttoptr i64 %t38 to %FieldInit*
  %t40 = getelementptr %FieldInit, %FieldInit* %t39, i32 0, i32 0
  store i64 %t37, i64* %t40
  %t41 = load i64, i64* %t0
  %t42 = load i64, i64* %t20
  %t43 = call i64 @CodeGen_gen_function(i64 %t41, i64 %t42)
  %t44 = load i64, i64* %t25
  %t45 = load i64, i64* %t20
  %t46 = inttoptr i64 %t45 to %FieldInit*
  %t47 = getelementptr %FieldInit, %FieldInit* %t46, i32 0, i32 0
  store i64 %t44, i64* %t47
  br label %for_update720
  for_update720:
  %t48 = load i64, i64* %t16
  %t49 = add i64 %t48, 1
  store i64 %t49, i64* %t16
  br label %for_cond718
  for_end721:
  ret i64 0
}
define i64 @CodeGen_gen_stmt(i64 %self, i64 %stmt) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %stmt, i64* %t1
  %t2 = load i64, i64* %t1
  %t3 = call i64 @kore_variant_of(i64 %t2)
  %t4 = alloca i64
  store i64 %t3, i64* %t4
  %t5 = load i64, i64* %t4
  %t6 = getelementptr [4 x i8], [4 x i8]* @.str.583, i64 0, i64 0
  %t7 = ptrtoint i8* %t6 to i64
  %t8 = call i64 @kore_str_eq(i64 %t5, i64 %t7)
  %t9 = icmp ne i64 %t8, 0
  br i1 %t9, label %then722, label %endif724
  then722:
  %t10 = load i64, i64* %t1
  %t11 = call i64 @kore_variant_field(i64 %t10, i64 0)
  %t12 = alloca i64
  store i64 %t11, i64* %t12
  %t13 = load i64, i64* %t1
  %t14 = call i64 @kore_variant_field(i64 %t13, i64 1)
  %t15 = alloca i64
  store i64 %t14, i64* %t15
  %t16 = load i64, i64* %t1
  %t17 = call i64 @kore_variant_field(i64 %t16, i64 2)
  %t18 = alloca i64
  store i64 %t17, i64* %t18
  %t19 = load i64, i64* %t0
  %t20 = load i64, i64* %t18
  %t21 = call i64 @CodeGen_gen_expr(i64 %t19, i64 %t20)
  %t22 = alloca i64
  store i64 %t21, i64* %t22
  %t23 = load i64, i64* %t0
  %t24 = call i64 @CodeGen_fresh_local(i64 %t23)
  %t25 = alloca i64
  store i64 %t24, i64* %t25
  %t26 = load i64, i64* %t0
  %t27 = load i64, i64* %t25
  %t28 = getelementptr [14 x i8], [14 x i8]* @.str.584, i64 0, i64 0
  %t29 = ptrtoint i8* %t28 to i64
  %t30 = call i64 @kore_str_concat(i64 %t27, i64 %t29)
  %t31 = call i64 @CodeGen_write_line(i64 %t26, i64 %t30)
  %t32 = load i64, i64* %t0
  %t33 = getelementptr [11 x i8], [11 x i8]* @.str.585, i64 0, i64 0
  %t34 = ptrtoint i8* %t33 to i64
  %t35 = load i64, i64* %t22
  %t36 = call i64 @kore_str_concat(i64 %t34, i64 %t35)
  %t37 = getelementptr [8 x i8], [8 x i8]* @.str.586, i64 0, i64 0
  %t38 = ptrtoint i8* %t37 to i64
  %t39 = call i64 @kore_str_concat(i64 %t36, i64 %t38)
  %t40 = load i64, i64* %t25
  %t41 = call i64 @kore_str_concat(i64 %t39, i64 %t40)
  %t42 = call i64 @CodeGen_write_line(i64 %t32, i64 %t41)
  %t43 = load i64, i64* %t0
  %t44 = inttoptr i64 %t43 to %CodeGen*
  %t45 = getelementptr %CodeGen, %CodeGen* %t44, i32 0, i32 6
  %t46 = load i64, i64* %t45
  %t47 = load i64, i64* %t12
  %t48 = load i64, i64* %t25
  %t49 = call i64 @kore_map_set(i64 %t46, i64 %t47, i64 %t48)
  ret i64 0
  endif724:
  %t50 = load i64, i64* %t4
  %t51 = getelementptr [4 x i8], [4 x i8]* @.str.587, i64 0, i64 0
  %t52 = ptrtoint i8* %t51 to i64
  %t53 = call i64 @kore_str_eq(i64 %t50, i64 %t52)
  %t54 = icmp ne i64 %t53, 0
  br i1 %t54, label %then725, label %endif727
  then725:
  %t55 = load i64, i64* %t1
  %t56 = call i64 @kore_variant_field(i64 %t55, i64 0)
  %t57 = alloca i64
  store i64 %t56, i64* %t57
  %t58 = load i64, i64* %t1
  %t59 = call i64 @kore_variant_field(i64 %t58, i64 1)
  %t60 = alloca i64
  store i64 %t59, i64* %t60
  %t61 = load i64, i64* %t1
  %t62 = call i64 @kore_variant_field(i64 %t61, i64 2)
  %t63 = alloca i64
  store i64 %t62, i64* %t63
  %t64 = load i64, i64* %t0
  %t65 = load i64, i64* %t63
  %t66 = call i64 @CodeGen_gen_expr(i64 %t64, i64 %t65)
  %t67 = alloca i64
  store i64 %t66, i64* %t67
  %t68 = load i64, i64* %t0
  %t69 = call i64 @CodeGen_fresh_local(i64 %t68)
  %t70 = alloca i64
  store i64 %t69, i64* %t70
  %t71 = load i64, i64* %t0
  %t72 = load i64, i64* %t70
  %t73 = getelementptr [14 x i8], [14 x i8]* @.str.588, i64 0, i64 0
  %t74 = ptrtoint i8* %t73 to i64
  %t75 = call i64 @kore_str_concat(i64 %t72, i64 %t74)
  %t76 = call i64 @CodeGen_write_line(i64 %t71, i64 %t75)
  %t77 = load i64, i64* %t0
  %t78 = getelementptr [11 x i8], [11 x i8]* @.str.589, i64 0, i64 0
  %t79 = ptrtoint i8* %t78 to i64
  %t80 = load i64, i64* %t67
  %t81 = call i64 @kore_str_concat(i64 %t79, i64 %t80)
  %t82 = getelementptr [8 x i8], [8 x i8]* @.str.590, i64 0, i64 0
  %t83 = ptrtoint i8* %t82 to i64
  %t84 = call i64 @kore_str_concat(i64 %t81, i64 %t83)
  %t85 = load i64, i64* %t70
  %t86 = call i64 @kore_str_concat(i64 %t84, i64 %t85)
  %t87 = call i64 @CodeGen_write_line(i64 %t77, i64 %t86)
  %t88 = load i64, i64* %t0
  %t89 = inttoptr i64 %t88 to %CodeGen*
  %t90 = getelementptr %CodeGen, %CodeGen* %t89, i32 0, i32 6
  %t91 = load i64, i64* %t90
  %t92 = load i64, i64* %t57
  %t93 = load i64, i64* %t70
  %t94 = call i64 @kore_map_set(i64 %t91, i64 %t92, i64 %t93)
  ret i64 0
  endif727:
  %t95 = load i64, i64* %t4
  %t96 = getelementptr [7 x i8], [7 x i8]* @.str.591, i64 0, i64 0
  %t97 = ptrtoint i8* %t96 to i64
  %t98 = call i64 @kore_str_eq(i64 %t95, i64 %t97)
  %t99 = icmp ne i64 %t98, 0
  br i1 %t99, label %then728, label %endif730
  then728:
  %t100 = load i64, i64* %t1
  %t101 = call i64 @kore_variant_field(i64 %t100, i64 0)
  %t102 = alloca i64
  store i64 %t101, i64* %t102
  %t103 = load i64, i64* %t102
  %t105 = call i64 @kore_str_eq(i64 %t103, i64 0)
  %t106 = icmp eq i64 %t105, 0
  %t104 = zext i1 %t106 to i64
  %t107 = icmp ne i64 %t104, 0
  br i1 %t107, label %then731, label %else732
  then731:
  %t108 = load i64, i64* %t0
  %t109 = load i64, i64* %t102
  %t110 = call i64 @CodeGen_gen_expr(i64 %t108, i64 %t109)
  %t111 = alloca i64
  store i64 %t110, i64* %t111
  %t112 = load i64, i64* %t0
  %t113 = getelementptr [9 x i8], [9 x i8]* @.str.592, i64 0, i64 0
  %t114 = ptrtoint i8* %t113 to i64
  %t115 = load i64, i64* %t111
  %t116 = call i64 @kore_str_concat(i64 %t114, i64 %t115)
  %t117 = call i64 @CodeGen_write_line(i64 %t112, i64 %t116)
  br label %endif733
  else732:
  %t118 = load i64, i64* %t0
  %t119 = getelementptr [10 x i8], [10 x i8]* @.str.593, i64 0, i64 0
  %t120 = ptrtoint i8* %t119 to i64
  %t121 = call i64 @CodeGen_write_line(i64 %t118, i64 %t120)
  br label %endif733
  endif733:
  ret i64 0
  endif730:
  %t122 = load i64, i64* %t4
  %t123 = getelementptr [5 x i8], [5 x i8]* @.str.594, i64 0, i64 0
  %t124 = ptrtoint i8* %t123 to i64
  %t125 = call i64 @kore_str_eq(i64 %t122, i64 %t124)
  %t126 = icmp ne i64 %t125, 0
  br i1 %t126, label %then734, label %endif736
  then734:
  %t127 = load i64, i64* %t1
  %t128 = call i64 @kore_variant_field(i64 %t127, i64 0)
  %t129 = alloca i64
  store i64 %t128, i64* %t129
  %t130 = load i64, i64* %t0
  %t131 = load i64, i64* %t129
  %t132 = call i64 @CodeGen_gen_expr(i64 %t130, i64 %t131)
  ret i64 0
  endif736:
  %t133 = load i64, i64* %t4
  %t134 = getelementptr [3 x i8], [3 x i8]* @.str.595, i64 0, i64 0
  %t135 = ptrtoint i8* %t134 to i64
  %t136 = call i64 @kore_str_eq(i64 %t133, i64 %t135)
  %t137 = icmp ne i64 %t136, 0
  br i1 %t137, label %then737, label %endif739
  then737:
  %t138 = load i64, i64* %t1
  %t139 = call i64 @kore_variant_field(i64 %t138, i64 0)
  %t140 = alloca i64
  store i64 %t139, i64* %t140
  %t141 = load i64, i64* %t1
  %t142 = call i64 @kore_variant_field(i64 %t141, i64 1)
  %t143 = alloca i64
  store i64 %t142, i64* %t143
  %t144 = load i64, i64* %t1
  %t145 = call i64 @kore_variant_field(i64 %t144, i64 2)
  %t146 = alloca i64
  store i64 %t145, i64* %t146
  %t147 = load i64, i64* %t0
  %t148 = load i64, i64* %t140
  %t149 = call i64 @CodeGen_gen_expr(i64 %t147, i64 %t148)
  %t150 = alloca i64
  store i64 %t149, i64* %t150
  %t151 = load i64, i64* %t0
  %t152 = call i64 @CodeGen_fresh_local(i64 %t151)
  %t153 = alloca i64
  store i64 %t152, i64* %t153
  %t154 = load i64, i64* %t0
  %t155 = load i64, i64* %t153
  %t156 = getelementptr [16 x i8], [16 x i8]* @.str.596, i64 0, i64 0
  %t157 = ptrtoint i8* %t156 to i64
  %t158 = call i64 @kore_str_concat(i64 %t155, i64 %t157)
  %t159 = load i64, i64* %t150
  %t160 = call i64 @kore_str_concat(i64 %t158, i64 %t159)
  %t161 = getelementptr [4 x i8], [4 x i8]* @.str.597, i64 0, i64 0
  %t162 = ptrtoint i8* %t161 to i64
  %t163 = call i64 @kore_str_concat(i64 %t160, i64 %t162)
  %t164 = call i64 @CodeGen_write_line(i64 %t154, i64 %t163)
  %t165 = load i64, i64* %t0
  %t166 = getelementptr [5 x i8], [5 x i8]* @.str.598, i64 0, i64 0
  %t167 = ptrtoint i8* %t166 to i64
  %t168 = call i64 @CodeGen_fresh_label(i64 %t165, i64 %t167)
  %t169 = alloca i64
  store i64 %t168, i64* %t169
  %t170 = load i64, i64* %t0
  %t171 = getelementptr [5 x i8], [5 x i8]* @.str.599, i64 0, i64 0
  %t172 = ptrtoint i8* %t171 to i64
  %t173 = call i64 @CodeGen_fresh_label(i64 %t170, i64 %t172)
  %t174 = alloca i64
  store i64 %t173, i64* %t174
  %t175 = load i64, i64* %t0
  %t176 = getelementptr [6 x i8], [6 x i8]* @.str.600, i64 0, i64 0
  %t177 = ptrtoint i8* %t176 to i64
  %t178 = call i64 @CodeGen_fresh_label(i64 %t175, i64 %t177)
  %t179 = alloca i64
  store i64 %t178, i64* %t179
  %t180 = load i64, i64* %t146
  %t182 = call i64 @kore_str_eq(i64 %t180, i64 0)
  %t183 = icmp eq i64 %t182, 0
  %t181 = zext i1 %t183 to i64
  %t184 = icmp ne i64 %t181, 0
  br i1 %t184, label %then740, label %else741
  then740:
  %t185 = load i64, i64* %t0
  %t186 = getelementptr [7 x i8], [7 x i8]* @.str.601, i64 0, i64 0
  %t187 = ptrtoint i8* %t186 to i64
  %t188 = load i64, i64* %t153
  %t189 = call i64 @kore_str_concat(i64 %t187, i64 %t188)
  %t190 = getelementptr [10 x i8], [10 x i8]* @.str.602, i64 0, i64 0
  %t191 = ptrtoint i8* %t190 to i64
  %t192 = call i64 @kore_str_concat(i64 %t189, i64 %t191)
  %t193 = load i64, i64* %t169
  %t194 = call i64 @kore_str_concat(i64 %t192, i64 %t193)
  %t195 = getelementptr [10 x i8], [10 x i8]* @.str.603, i64 0, i64 0
  %t196 = ptrtoint i8* %t195 to i64
  %t197 = call i64 @kore_str_concat(i64 %t194, i64 %t196)
  %t198 = load i64, i64* %t174
  %t199 = call i64 @kore_str_concat(i64 %t197, i64 %t198)
  %t200 = call i64 @CodeGen_write_line(i64 %t185, i64 %t199)
  br label %endif742
  else741:
  %t201 = load i64, i64* %t0
  %t202 = getelementptr [7 x i8], [7 x i8]* @.str.604, i64 0, i64 0
  %t203 = ptrtoint i8* %t202 to i64
  %t204 = load i64, i64* %t153
  %t205 = call i64 @kore_str_concat(i64 %t203, i64 %t204)
  %t206 = getelementptr [10 x i8], [10 x i8]* @.str.605, i64 0, i64 0
  %t207 = ptrtoint i8* %t206 to i64
  %t208 = call i64 @kore_str_concat(i64 %t205, i64 %t207)
  %t209 = load i64, i64* %t169
  %t210 = call i64 @kore_str_concat(i64 %t208, i64 %t209)
  %t211 = getelementptr [10 x i8], [10 x i8]* @.str.606, i64 0, i64 0
  %t212 = ptrtoint i8* %t211 to i64
  %t213 = call i64 @kore_str_concat(i64 %t210, i64 %t212)
  %t214 = load i64, i64* %t179
  %t215 = call i64 @kore_str_concat(i64 %t213, i64 %t214)
  %t216 = call i64 @CodeGen_write_line(i64 %t201, i64 %t215)
  br label %endif742
  endif742:
  %t217 = load i64, i64* %t0
  %t218 = load i64, i64* %t169
  %t219 = getelementptr [2 x i8], [2 x i8]* @.str.607, i64 0, i64 0
  %t220 = ptrtoint i8* %t219 to i64
  %t221 = call i64 @kore_str_concat(i64 %t218, i64 %t220)
  %t222 = call i64 @CodeGen_write_line(i64 %t217, i64 %t221)
  ; for s in ...
  %t223 = load i64, i64* %t143
  %t224 = call i64 @kore_array_len(i64 %t223)
  %t225 = alloca i64
  store i64 0, i64* %t225
  br label %for_cond743
  for_cond743:
  %t226 = load i64, i64* %t225
  %t227 = icmp slt i64 %t226, %t224
  br i1 %t227, label %for_body744, label %for_end746
  for_body744:
  %t228 = call i64 @kore_array_get(i64 %t223, i64 %t226)
  %t229 = alloca i64
  store i64 %t228, i64* %t229
  %t230 = load i64, i64* %t0
  %t231 = load i64, i64* %t229
  %t232 = call i64 @CodeGen_gen_stmt(i64 %t230, i64 %t231)
  br label %for_update745
  for_update745:
  %t233 = load i64, i64* %t225
  %t234 = add i64 %t233, 1
  store i64 %t234, i64* %t225
  br label %for_cond743
  for_end746:
  %t235 = load i64, i64* %t0
  %t236 = getelementptr [11 x i8], [11 x i8]* @.str.608, i64 0, i64 0
  %t237 = ptrtoint i8* %t236 to i64
  %t238 = load i64, i64* %t179
  %t239 = call i64 @kore_str_concat(i64 %t237, i64 %t238)
  %t240 = call i64 @CodeGen_write_line(i64 %t235, i64 %t239)
  %t241 = load i64, i64* %t146
  %t243 = call i64 @kore_str_eq(i64 %t241, i64 0)
  %t244 = icmp eq i64 %t243, 0
  %t242 = zext i1 %t244 to i64
  %t245 = icmp ne i64 %t242, 0
  br i1 %t245, label %then747, label %endif749
  then747:
  %t246 = load i64, i64* %t0
  %t247 = load i64, i64* %t174
  %t248 = getelementptr [2 x i8], [2 x i8]* @.str.609, i64 0, i64 0
  %t249 = ptrtoint i8* %t248 to i64
  %t250 = call i64 @kore_str_concat(i64 %t247, i64 %t249)
  %t251 = call i64 @CodeGen_write_line(i64 %t246, i64 %t250)
  ; for s in ...
  %t252 = load i64, i64* %t146
  %t253 = call i64 @kore_array_len(i64 %t252)
  %t254 = alloca i64
  store i64 0, i64* %t254
  br label %for_cond750
  for_cond750:
  %t255 = load i64, i64* %t254
  %t256 = icmp slt i64 %t255, %t253
  br i1 %t256, label %for_body751, label %for_end753
  for_body751:
  %t257 = call i64 @kore_array_get(i64 %t252, i64 %t255)
  %t258 = alloca i64
  store i64 %t257, i64* %t258
  %t259 = load i64, i64* %t0
  %t260 = load i64, i64* %t258
  %t261 = call i64 @CodeGen_gen_stmt(i64 %t259, i64 %t260)
  br label %for_update752
  for_update752:
  %t262 = load i64, i64* %t254
  %t263 = add i64 %t262, 1
  store i64 %t263, i64* %t254
  br label %for_cond750
  for_end753:
  %t264 = load i64, i64* %t0
  %t265 = getelementptr [11 x i8], [11 x i8]* @.str.610, i64 0, i64 0
  %t266 = ptrtoint i8* %t265 to i64
  %t267 = load i64, i64* %t179
  %t268 = call i64 @kore_str_concat(i64 %t266, i64 %t267)
  %t269 = call i64 @CodeGen_write_line(i64 %t264, i64 %t268)
  br label %endif749
  endif749:
  %t270 = load i64, i64* %t0
  %t271 = load i64, i64* %t179
  %t272 = getelementptr [2 x i8], [2 x i8]* @.str.611, i64 0, i64 0
  %t273 = ptrtoint i8* %t272 to i64
  %t274 = call i64 @kore_str_concat(i64 %t271, i64 %t273)
  %t275 = call i64 @CodeGen_write_line(i64 %t270, i64 %t274)
  ret i64 0
  endif739:
  %t276 = load i64, i64* %t4
  %t277 = getelementptr [6 x i8], [6 x i8]* @.str.612, i64 0, i64 0
  %t278 = ptrtoint i8* %t277 to i64
  %t279 = call i64 @kore_str_eq(i64 %t276, i64 %t278)
  %t280 = icmp ne i64 %t279, 0
  br i1 %t280, label %then754, label %endif756
  then754:
  %t281 = load i64, i64* %t1
  %t282 = call i64 @kore_variant_field(i64 %t281, i64 0)
  %t283 = alloca i64
  store i64 %t282, i64* %t283
  %t284 = load i64, i64* %t1
  %t285 = call i64 @kore_variant_field(i64 %t284, i64 1)
  %t286 = alloca i64
  store i64 %t285, i64* %t286
  %t287 = load i64, i64* %t0
  %t288 = getelementptr [11 x i8], [11 x i8]* @.str.613, i64 0, i64 0
  %t289 = ptrtoint i8* %t288 to i64
  %t290 = call i64 @CodeGen_fresh_label(i64 %t287, i64 %t289)
  %t291 = alloca i64
  store i64 %t290, i64* %t291
  %t292 = load i64, i64* %t0
  %t293 = getelementptr [11 x i8], [11 x i8]* @.str.614, i64 0, i64 0
  %t294 = ptrtoint i8* %t293 to i64
  %t295 = call i64 @CodeGen_fresh_label(i64 %t292, i64 %t294)
  %t296 = alloca i64
  store i64 %t295, i64* %t296
  %t297 = load i64, i64* %t0
  %t298 = getelementptr [10 x i8], [10 x i8]* @.str.615, i64 0, i64 0
  %t299 = ptrtoint i8* %t298 to i64
  %t300 = call i64 @CodeGen_fresh_label(i64 %t297, i64 %t299)
  %t301 = alloca i64
  store i64 %t300, i64* %t301
  %t302 = load i64, i64* %t0
  %t303 = inttoptr i64 %t302 to %CodeGen*
  %t304 = getelementptr %CodeGen, %CodeGen* %t303, i32 0, i32 7
  %t305 = load i64, i64* %t304
  %t306 = load i64, i64* %t301
  %t307 = call i64 @kore_array_push(i64 %t305, i64 %t306)
  %t308 = load i64, i64* %t0
  %t309 = getelementptr [11 x i8], [11 x i8]* @.str.616, i64 0, i64 0
  %t310 = ptrtoint i8* %t309 to i64
  %t311 = load i64, i64* %t291
  %t312 = call i64 @kore_str_concat(i64 %t310, i64 %t311)
  %t313 = call i64 @CodeGen_write_line(i64 %t308, i64 %t312)
  %t314 = load i64, i64* %t0
  %t315 = load i64, i64* %t291
  %t316 = getelementptr [2 x i8], [2 x i8]* @.str.617, i64 0, i64 0
  %t317 = ptrtoint i8* %t316 to i64
  %t318 = call i64 @kore_str_concat(i64 %t315, i64 %t317)
  %t319 = call i64 @CodeGen_write_line(i64 %t314, i64 %t318)
  %t320 = load i64, i64* %t0
  %t321 = load i64, i64* %t283
  %t322 = call i64 @CodeGen_gen_expr(i64 %t320, i64 %t321)
  %t323 = alloca i64
  store i64 %t322, i64* %t323
  %t324 = load i64, i64* %t0
  %t325 = call i64 @CodeGen_fresh_local(i64 %t324)
  %t326 = alloca i64
  store i64 %t325, i64* %t326
  %t327 = load i64, i64* %t0
  %t328 = load i64, i64* %t326
  %t329 = getelementptr [16 x i8], [16 x i8]* @.str.618, i64 0, i64 0
  %t330 = ptrtoint i8* %t329 to i64
  %t331 = call i64 @kore_str_concat(i64 %t328, i64 %t330)
  %t332 = load i64, i64* %t323
  %t333 = call i64 @kore_str_concat(i64 %t331, i64 %t332)
  %t334 = getelementptr [4 x i8], [4 x i8]* @.str.619, i64 0, i64 0
  %t335 = ptrtoint i8* %t334 to i64
  %t336 = call i64 @kore_str_concat(i64 %t333, i64 %t335)
  %t337 = call i64 @CodeGen_write_line(i64 %t327, i64 %t336)
  %t338 = load i64, i64* %t0
  %t339 = getelementptr [7 x i8], [7 x i8]* @.str.620, i64 0, i64 0
  %t340 = ptrtoint i8* %t339 to i64
  %t341 = load i64, i64* %t326
  %t342 = call i64 @kore_str_concat(i64 %t340, i64 %t341)
  %t343 = getelementptr [10 x i8], [10 x i8]* @.str.621, i64 0, i64 0
  %t344 = ptrtoint i8* %t343 to i64
  %t345 = call i64 @kore_str_concat(i64 %t342, i64 %t344)
  %t346 = load i64, i64* %t296
  %t347 = call i64 @kore_str_concat(i64 %t345, i64 %t346)
  %t348 = getelementptr [10 x i8], [10 x i8]* @.str.622, i64 0, i64 0
  %t349 = ptrtoint i8* %t348 to i64
  %t350 = call i64 @kore_str_concat(i64 %t347, i64 %t349)
  %t351 = load i64, i64* %t301
  %t352 = call i64 @kore_str_concat(i64 %t350, i64 %t351)
  %t353 = call i64 @CodeGen_write_line(i64 %t338, i64 %t352)
  %t354 = load i64, i64* %t0
  %t355 = load i64, i64* %t296
  %t356 = getelementptr [2 x i8], [2 x i8]* @.str.623, i64 0, i64 0
  %t357 = ptrtoint i8* %t356 to i64
  %t358 = call i64 @kore_str_concat(i64 %t355, i64 %t357)
  %t359 = call i64 @CodeGen_write_line(i64 %t354, i64 %t358)
  ; for s in ...
  %t360 = load i64, i64* %t286
  %t361 = call i64 @kore_array_len(i64 %t360)
  %t362 = alloca i64
  store i64 0, i64* %t362
  br label %for_cond757
  for_cond757:
  %t363 = load i64, i64* %t362
  %t364 = icmp slt i64 %t363, %t361
  br i1 %t364, label %for_body758, label %for_end760
  for_body758:
  %t365 = call i64 @kore_array_get(i64 %t360, i64 %t363)
  %t366 = alloca i64
  store i64 %t365, i64* %t366
  %t367 = load i64, i64* %t0
  %t368 = load i64, i64* %t366
  %t369 = call i64 @CodeGen_gen_stmt(i64 %t367, i64 %t368)
  br label %for_update759
  for_update759:
  %t370 = load i64, i64* %t362
  %t371 = add i64 %t370, 1
  store i64 %t371, i64* %t362
  br label %for_cond757
  for_end760:
  %t372 = load i64, i64* %t0
  %t373 = getelementptr [11 x i8], [11 x i8]* @.str.624, i64 0, i64 0
  %t374 = ptrtoint i8* %t373 to i64
  %t375 = load i64, i64* %t291
  %t376 = call i64 @kore_str_concat(i64 %t374, i64 %t375)
  %t377 = call i64 @CodeGen_write_line(i64 %t372, i64 %t376)
  %t378 = load i64, i64* %t0
  %t379 = load i64, i64* %t301
  %t380 = getelementptr [2 x i8], [2 x i8]* @.str.625, i64 0, i64 0
  %t381 = ptrtoint i8* %t380 to i64
  %t382 = call i64 @kore_str_concat(i64 %t379, i64 %t381)
  %t383 = call i64 @CodeGen_write_line(i64 %t378, i64 %t382)
  %t384 = load i64, i64* %t0
  %t385 = inttoptr i64 %t384 to %CodeGen*
  %t386 = getelementptr %CodeGen, %CodeGen* %t385, i32 0, i32 7
  %t387 = load i64, i64* %t386
  %t388 = call i64 @kore_array_pop(i64 %t387)
  ret i64 0
  endif756:
  %t389 = load i64, i64* %t4
  %t390 = getelementptr [4 x i8], [4 x i8]* @.str.626, i64 0, i64 0
  %t391 = ptrtoint i8* %t390 to i64
  %t392 = call i64 @kore_str_eq(i64 %t389, i64 %t391)
  %t393 = icmp ne i64 %t392, 0
  br i1 %t393, label %then761, label %endif763
  then761:
  %t394 = load i64, i64* %t0
  %t395 = getelementptr [37 x i8], [37 x i8]* @.str.627, i64 0, i64 0
  %t396 = ptrtoint i8* %t395 to i64
  %t397 = call i64 @CodeGen_write_line(i64 %t394, i64 %t396)
  ret i64 0
  endif763:
  %t398 = load i64, i64* %t4
  %t399 = getelementptr [5 x i8], [5 x i8]* @.str.628, i64 0, i64 0
  %t400 = ptrtoint i8* %t399 to i64
  %t401 = call i64 @kore_str_eq(i64 %t398, i64 %t400)
  %t402 = icmp ne i64 %t401, 0
  br i1 %t402, label %then764, label %endif766
  then764:
  %t403 = load i64, i64* %t1
  %t404 = call i64 @kore_variant_field(i64 %t403, i64 0)
  %t405 = alloca i64
  store i64 %t404, i64* %t405
  %t406 = load i64, i64* %t0
  %t407 = getelementptr [5 x i8], [5 x i8]* @.str.629, i64 0, i64 0
  %t408 = ptrtoint i8* %t407 to i64
  %t409 = call i64 @CodeGen_fresh_label(i64 %t406, i64 %t408)
  %t410 = alloca i64
  store i64 %t409, i64* %t410
  %t411 = load i64, i64* %t0
  %t412 = getelementptr [9 x i8], [9 x i8]* @.str.630, i64 0, i64 0
  %t413 = ptrtoint i8* %t412 to i64
  %t414 = call i64 @CodeGen_fresh_label(i64 %t411, i64 %t413)
  %t415 = alloca i64
  store i64 %t414, i64* %t415
  %t416 = load i64, i64* %t0
  %t417 = inttoptr i64 %t416 to %CodeGen*
  %t418 = getelementptr %CodeGen, %CodeGen* %t417, i32 0, i32 7
  %t419 = load i64, i64* %t418
  %t420 = load i64, i64* %t415
  %t421 = call i64 @kore_array_push(i64 %t419, i64 %t420)
  %t422 = load i64, i64* %t0
  %t423 = getelementptr [11 x i8], [11 x i8]* @.str.631, i64 0, i64 0
  %t424 = ptrtoint i8* %t423 to i64
  %t425 = load i64, i64* %t410
  %t426 = call i64 @kore_str_concat(i64 %t424, i64 %t425)
  %t427 = call i64 @CodeGen_write_line(i64 %t422, i64 %t426)
  %t428 = load i64, i64* %t0
  %t429 = load i64, i64* %t410
  %t430 = getelementptr [2 x i8], [2 x i8]* @.str.632, i64 0, i64 0
  %t431 = ptrtoint i8* %t430 to i64
  %t432 = call i64 @kore_str_concat(i64 %t429, i64 %t431)
  %t433 = call i64 @CodeGen_write_line(i64 %t428, i64 %t432)
  ; for s in ...
  %t434 = load i64, i64* %t405
  %t435 = call i64 @kore_array_len(i64 %t434)
  %t436 = alloca i64
  store i64 0, i64* %t436
  br label %for_cond767
  for_cond767:
  %t437 = load i64, i64* %t436
  %t438 = icmp slt i64 %t437, %t435
  br i1 %t438, label %for_body768, label %for_end770
  for_body768:
  %t439 = call i64 @kore_array_get(i64 %t434, i64 %t437)
  %t440 = alloca i64
  store i64 %t439, i64* %t440
  %t441 = load i64, i64* %t0
  %t442 = load i64, i64* %t440
  %t443 = call i64 @CodeGen_gen_stmt(i64 %t441, i64 %t442)
  br label %for_update769
  for_update769:
  %t444 = load i64, i64* %t436
  %t445 = add i64 %t444, 1
  store i64 %t445, i64* %t436
  br label %for_cond767
  for_end770:
  %t446 = load i64, i64* %t0
  %t447 = getelementptr [11 x i8], [11 x i8]* @.str.633, i64 0, i64 0
  %t448 = ptrtoint i8* %t447 to i64
  %t449 = load i64, i64* %t410
  %t450 = call i64 @kore_str_concat(i64 %t448, i64 %t449)
  %t451 = call i64 @CodeGen_write_line(i64 %t446, i64 %t450)
  %t452 = load i64, i64* %t0
  %t453 = load i64, i64* %t415
  %t454 = getelementptr [2 x i8], [2 x i8]* @.str.634, i64 0, i64 0
  %t455 = ptrtoint i8* %t454 to i64
  %t456 = call i64 @kore_str_concat(i64 %t453, i64 %t455)
  %t457 = call i64 @CodeGen_write_line(i64 %t452, i64 %t456)
  %t458 = load i64, i64* %t0
  %t459 = inttoptr i64 %t458 to %CodeGen*
  %t460 = getelementptr %CodeGen, %CodeGen* %t459, i32 0, i32 7
  %t461 = load i64, i64* %t460
  %t462 = call i64 @kore_array_pop(i64 %t461)
  ret i64 0
  endif766:
  %t463 = load i64, i64* %t4
  %t464 = getelementptr [6 x i8], [6 x i8]* @.str.635, i64 0, i64 0
  %t465 = ptrtoint i8* %t464 to i64
  %t466 = call i64 @kore_str_eq(i64 %t463, i64 %t465)
  %t467 = icmp ne i64 %t466, 0
  br i1 %t467, label %then771, label %endif773
  then771:
  %t468 = load i64, i64* %t0
  %t469 = getelementptr [33 x i8], [33 x i8]* @.str.636, i64 0, i64 0
  %t470 = ptrtoint i8* %t469 to i64
  %t471 = call i64 @CodeGen_write_line(i64 %t468, i64 %t470)
  ret i64 0
  endif773:
  %t472 = load i64, i64* %t4
  %t473 = getelementptr [6 x i8], [6 x i8]* @.str.637, i64 0, i64 0
  %t474 = ptrtoint i8* %t473 to i64
  %t475 = call i64 @kore_str_eq(i64 %t472, i64 %t474)
  %t476 = icmp ne i64 %t475, 0
  br i1 %t476, label %then774, label %endif776
  then774:
  %t477 = load i64, i64* %t0
  %t478 = inttoptr i64 %t477 to %CodeGen*
  %t479 = getelementptr %CodeGen, %CodeGen* %t478, i32 0, i32 7
  %t480 = load i64, i64* %t479
  %t481 = call i64 @kore_array_len(i64 %t480)
  %t483 = icmp sgt i64 %t481, 0
  %t482 = zext i1 %t483 to i64
  %t484 = icmp ne i64 %t482, 0
  br i1 %t484, label %then777, label %else778
  then777:
  %t485 = load i64, i64* %t0
  %t486 = inttoptr i64 %t485 to %CodeGen*
  %t487 = getelementptr %CodeGen, %CodeGen* %t486, i32 0, i32 7
  %t488 = load i64, i64* %t487
  %t489 = load i64, i64* %t0
  %t490 = inttoptr i64 %t489 to %CodeGen*
  %t491 = getelementptr %CodeGen, %CodeGen* %t490, i32 0, i32 7
  %t492 = load i64, i64* %t491
  %t493 = call i64 @kore_array_len(i64 %t492)
  %t494 = sub i64 %t493, 1
  %t495 = call i64 @kore_array_get(i64 %t488, i64 %t494)
  %t496 = alloca i64
  store i64 %t495, i64* %t496
  %t497 = load i64, i64* %t0
  %t498 = getelementptr [11 x i8], [11 x i8]* @.str.638, i64 0, i64 0
  %t499 = ptrtoint i8* %t498 to i64
  %t500 = load i64, i64* %t496
  %t501 = call i64 @kore_str_concat(i64 %t499, i64 %t500)
  %t502 = call i64 @CodeGen_write_line(i64 %t497, i64 %t501)
  br label %endif779
  else778:
  %t503 = load i64, i64* %t0
  %t504 = getelementptr [28 x i8], [28 x i8]* @.str.639, i64 0, i64 0
  %t505 = ptrtoint i8* %t504 to i64
  %t506 = call i64 @CodeGen_write_line(i64 %t503, i64 %t505)
  br label %endif779
  endif779:
  ret i64 0
  endif776:
  %t507 = load i64, i64* %t4
  %t508 = getelementptr [9 x i8], [9 x i8]* @.str.640, i64 0, i64 0
  %t509 = ptrtoint i8* %t508 to i64
  %t510 = call i64 @kore_str_eq(i64 %t507, i64 %t509)
  %t511 = icmp ne i64 %t510, 0
  br i1 %t511, label %then780, label %endif782
  then780:
  %t512 = load i64, i64* %t0
  %t513 = getelementptr [11 x i8], [11 x i8]* @.str.641, i64 0, i64 0
  %t514 = ptrtoint i8* %t513 to i64
  %t515 = call i64 @CodeGen_write_line(i64 %t512, i64 %t514)
  ret i64 0
  endif782:
  %t516 = load i64, i64* %t4
  %t517 = getelementptr [7 x i8], [7 x i8]* @.str.642, i64 0, i64 0
  %t518 = ptrtoint i8* %t517 to i64
  %t519 = call i64 @kore_str_eq(i64 %t516, i64 %t518)
  %t520 = icmp ne i64 %t519, 0
  br i1 %t520, label %then783, label %endif785
  then783:
  %t521 = load i64, i64* %t1
  %t522 = call i64 @kore_variant_field(i64 %t521, i64 0)
  %t523 = alloca i64
  store i64 %t522, i64* %t523
  %t524 = load i64, i64* %t1
  %t525 = call i64 @kore_variant_field(i64 %t524, i64 1)
  %t526 = alloca i64
  store i64 %t525, i64* %t526
  %t527 = load i64, i64* %t0
  %t528 = load i64, i64* %t526
  %t529 = call i64 @CodeGen_gen_expr(i64 %t527, i64 %t528)
  %t530 = alloca i64
  store i64 %t529, i64* %t530
  %t531 = load i64, i64* %t523
  %t532 = call i64 @kore_variant_of(i64 %t531)
  %t533 = alloca i64
  store i64 %t532, i64* %t533
  %t534 = load i64, i64* %t533
  %t535 = getelementptr [6 x i8], [6 x i8]* @.str.643, i64 0, i64 0
  %t536 = ptrtoint i8* %t535 to i64
  %t537 = call i64 @kore_str_eq(i64 %t534, i64 %t536)
  %t538 = icmp ne i64 %t537, 0
  br i1 %t538, label %then786, label %else787
  then786:
  %t539 = load i64, i64* %t523
  %t540 = call i64 @kore_variant_field(i64 %t539, i64 0)
  %t541 = alloca i64
  store i64 %t540, i64* %t541
  %t542 = load i64, i64* %t0
  %t543 = inttoptr i64 %t542 to %CodeGen*
  %t544 = getelementptr %CodeGen, %CodeGen* %t543, i32 0, i32 6
  %t545 = load i64, i64* %t544
  %t546 = load i64, i64* %t541
  %t547 = call i64 @kore_contains_key(i64 %t545, i64 %t546)
  %t548 = icmp ne i64 %t547, 0
  br i1 %t548, label %then789, label %endif791
  then789:
  %t549 = load i64, i64* %t0
  %t550 = inttoptr i64 %t549 to %CodeGen*
  %t551 = getelementptr %CodeGen, %CodeGen* %t550, i32 0, i32 6
  %t552 = load i64, i64* %t551
  %t553 = load i64, i64* %t541
  %t554 = call i64 @kore_array_get(i64 %t552, i64 %t553)
  %t555 = alloca i64
  store i64 %t554, i64* %t555
  %t556 = load i64, i64* %t0
  %t557 = getelementptr [11 x i8], [11 x i8]* @.str.644, i64 0, i64 0
  %t558 = ptrtoint i8* %t557 to i64
  %t559 = load i64, i64* %t530
  %t560 = call i64 @kore_str_concat(i64 %t558, i64 %t559)
  %t561 = getelementptr [8 x i8], [8 x i8]* @.str.645, i64 0, i64 0
  %t562 = ptrtoint i8* %t561 to i64
  %t563 = call i64 @kore_str_concat(i64 %t560, i64 %t562)
  %t564 = load i64, i64* %t555
  %t565 = call i64 @kore_str_concat(i64 %t563, i64 %t564)
  %t566 = call i64 @CodeGen_write_line(i64 %t556, i64 %t565)
  br label %endif791
  endif791:
  br label %endif788
  else787:
  %t567 = load i64, i64* %t533
  %t568 = getelementptr [6 x i8], [6 x i8]* @.str.646, i64 0, i64 0
  %t569 = ptrtoint i8* %t568 to i64
  %t570 = call i64 @kore_str_eq(i64 %t567, i64 %t569)
  %t571 = icmp ne i64 %t570, 0
  br i1 %t571, label %then792, label %endif794
  then792:
  %t572 = load i64, i64* %t523
  %t573 = call i64 @kore_variant_field(i64 %t572, i64 0)
  %t574 = alloca i64
  store i64 %t573, i64* %t574
  %t575 = load i64, i64* %t523
  %t576 = call i64 @kore_variant_field(i64 %t575, i64 1)
  %t577 = alloca i64
  store i64 %t576, i64* %t577
  %t578 = load i64, i64* %t0
  %t579 = load i64, i64* %t574
  %t580 = call i64 @CodeGen_gen_expr(i64 %t578, i64 %t579)
  %t581 = alloca i64
  store i64 %t580, i64* %t581
  %t582 = load i64, i64* %t0
  %t583 = inttoptr i64 %t582 to %CodeGen*
  %t584 = getelementptr %CodeGen, %CodeGen* %t583, i32 0, i32 9
  %t585 = load i64, i64* %t584
  %t586 = load i64, i64* %t577
  %t587 = call i64 @kore_contains_key(i64 %t585, i64 %t586)
  %t588 = icmp ne i64 %t587, 0
  br i1 %t588, label %then795, label %else796
  then795:
  %t589 = load i64, i64* %t0
  %t590 = inttoptr i64 %t589 to %CodeGen*
  %t591 = getelementptr %CodeGen, %CodeGen* %t590, i32 0, i32 9
  %t592 = load i64, i64* %t591
  %t593 = load i64, i64* %t577
  %t594 = call i64 @kore_array_get(i64 %t592, i64 %t593)
  %t595 = alloca i64
  store i64 %t594, i64* %t595
  %t596 = load i64, i64* %t0
  %t597 = inttoptr i64 %t596 to %CodeGen*
  %t598 = getelementptr %CodeGen, %CodeGen* %t597, i32 0, i32 8
  %t599 = load i64, i64* %t598
  %t600 = load i64, i64* %t595
  %t601 = call i64 @kore_array_get(i64 %t599, i64 %t600)
  %t602 = alloca i64
  store i64 %t601, i64* %t602
  %t603 = sub i64 0, 1
  %t604 = alloca i64
  store i64 %t603, i64* %t604
  ; for i in ...
  %t605 = load i64, i64* %t602
  %t606 = call i64 @kore_array_len(i64 %t605)
  %t607 = call i64 @kore_range(i64 0, i64 %t606)
  %t608 = call i64 @kore_array_len(i64 %t607)
  %t609 = alloca i64
  store i64 0, i64* %t609
  br label %for_cond798
  for_cond798:
  %t610 = load i64, i64* %t609
  %t611 = icmp slt i64 %t610, %t608
  br i1 %t611, label %for_body799, label %for_end801
  for_body799:
  %t612 = call i64 @kore_array_get(i64 %t607, i64 %t610)
  %t613 = alloca i64
  store i64 %t612, i64* %t613
  %t614 = load i64, i64* %t602
  %t615 = load i64, i64* %t613
  %t616 = call i64 @kore_array_get(i64 %t614, i64 %t615)
  %t617 = load i64, i64* %t577
  %t618 = call i64 @kore_str_eq(i64 %t616, i64 %t617)
  %t619 = icmp ne i64 %t618, 0
  br i1 %t619, label %then802, label %endif804
  then802:
  %t620 = load i64, i64* %t613
  store i64 %t620, i64* %t604
  br label %for_end801
  endif804:
  br label %for_update800
  for_update800:
  %t621 = load i64, i64* %t609
  %t622 = add i64 %t621, 1
  store i64 %t622, i64* %t609
  br label %for_cond798
  for_end801:
  %t623 = load i64, i64* %t0
  %t624 = getelementptr [25 x i8], [25 x i8]* @.str.647, i64 0, i64 0
  %t625 = ptrtoint i8* %t624 to i64
  %t626 = load i64, i64* %t577
  %t627 = call i64 @kore_str_concat(i64 %t625, i64 %t626)
  %t628 = getelementptr [5 x i8], [5 x i8]* @.str.648, i64 0, i64 0
  %t629 = ptrtoint i8* %t628 to i64
  %t630 = call i64 @kore_str_concat(i64 %t627, i64 %t629)
  %t631 = load i64, i64* %t595
  %t632 = call i64 @kore_str_concat(i64 %t630, i64 %t631)
  %t633 = getelementptr [11 x i8], [11 x i8]* @.str.649, i64 0, i64 0
  %t634 = ptrtoint i8* %t633 to i64
  %t635 = call i64 @kore_str_concat(i64 %t632, i64 %t634)
  %t636 = load i64, i64* %t604
  %t637 = call i64 @kore_to_string(i64 %t636)
  %t638 = call i64 @kore_str_concat(i64 %t635, i64 %t637)
  %t639 = call i64 @CodeGen_write_line(i64 %t623, i64 %t638)
  %t640 = load i64, i64* %t604
  %t641 = sub i64 0, 1
  %t643 = call i64 @kore_str_eq(i64 %t640, i64 %t641)
  %t644 = icmp eq i64 %t643, 0
  %t642 = zext i1 %t644 to i64
  %t645 = icmp ne i64 %t642, 0
  br i1 %t645, label %then805, label %else806
  then805:
  %t646 = load i64, i64* %t0
  %t647 = call i64 @CodeGen_fresh_local(i64 %t646)
  %t648 = alloca i64
  store i64 %t647, i64* %t648
  %t649 = load i64, i64* %t0
  %t650 = load i64, i64* %t648
  %t651 = getelementptr [17 x i8], [17 x i8]* @.str.650, i64 0, i64 0
  %t652 = ptrtoint i8* %t651 to i64
  %t653 = call i64 @kore_str_concat(i64 %t650, i64 %t652)
  %t654 = load i64, i64* %t581
  %t655 = call i64 @kore_str_concat(i64 %t653, i64 %t654)
  %t656 = getelementptr [6 x i8], [6 x i8]* @.str.651, i64 0, i64 0
  %t657 = ptrtoint i8* %t656 to i64
  %t658 = call i64 @kore_str_concat(i64 %t655, i64 %t657)
  %t659 = load i64, i64* %t595
  %t660 = call i64 @kore_str_concat(i64 %t658, i64 %t659)
  %t661 = getelementptr [2 x i8], [2 x i8]* @.str.652, i64 0, i64 0
  %t662 = ptrtoint i8* %t661 to i64
  %t663 = call i64 @kore_str_concat(i64 %t660, i64 %t662)
  %t664 = call i64 @CodeGen_write_line(i64 %t649, i64 %t663)
  %t665 = load i64, i64* %t0
  %t666 = call i64 @CodeGen_fresh_local(i64 %t665)
  %t667 = alloca i64
  store i64 %t666, i64* %t667
  %t668 = load i64, i64* %t0
  %t669 = load i64, i64* %t667
  %t670 = getelementptr [19 x i8], [19 x i8]* @.str.653, i64 0, i64 0
  %t671 = ptrtoint i8* %t670 to i64
  %t672 = call i64 @kore_str_concat(i64 %t669, i64 %t671)
  %t673 = load i64, i64* %t595
  %t674 = call i64 @kore_str_concat(i64 %t672, i64 %t673)
  %t675 = getelementptr [4 x i8], [4 x i8]* @.str.654, i64 0, i64 0
  %t676 = ptrtoint i8* %t675 to i64
  %t677 = call i64 @kore_str_concat(i64 %t674, i64 %t676)
  %t678 = load i64, i64* %t595
  %t679 = call i64 @kore_str_concat(i64 %t677, i64 %t678)
  %t680 = getelementptr [3 x i8], [3 x i8]* @.str.655, i64 0, i64 0
  %t681 = ptrtoint i8* %t680 to i64
  %t682 = call i64 @kore_str_concat(i64 %t679, i64 %t681)
  %t683 = load i64, i64* %t648
  %t684 = call i64 @kore_str_concat(i64 %t682, i64 %t683)
  %t685 = getelementptr [14 x i8], [14 x i8]* @.str.656, i64 0, i64 0
  %t686 = ptrtoint i8* %t685 to i64
  %t687 = call i64 @kore_str_concat(i64 %t684, i64 %t686)
  %t688 = load i64, i64* %t604
  %t689 = call i64 @kore_to_string(i64 %t688)
  %t690 = call i64 @kore_str_concat(i64 %t687, i64 %t689)
  %t691 = call i64 @CodeGen_write_line(i64 %t668, i64 %t690)
  %t692 = load i64, i64* %t0
  %t693 = getelementptr [11 x i8], [11 x i8]* @.str.657, i64 0, i64 0
  %t694 = ptrtoint i8* %t693 to i64
  %t695 = load i64, i64* %t530
  %t696 = call i64 @kore_str_concat(i64 %t694, i64 %t695)
  %t697 = getelementptr [8 x i8], [8 x i8]* @.str.658, i64 0, i64 0
  %t698 = ptrtoint i8* %t697 to i64
  %t699 = call i64 @kore_str_concat(i64 %t696, i64 %t698)
  %t700 = load i64, i64* %t667
  %t701 = call i64 @kore_str_concat(i64 %t699, i64 %t700)
  %t702 = call i64 @CodeGen_write_line(i64 %t692, i64 %t701)
  br label %endif807
  else806:
  %t703 = load i64, i64* %t0
  %t704 = getelementptr [16 x i8], [16 x i8]* @.str.659, i64 0, i64 0
  %t705 = ptrtoint i8* %t704 to i64
  %t706 = load i64, i64* %t577
  %t707 = call i64 @kore_str_concat(i64 %t705, i64 %t706)
  %t708 = getelementptr [22 x i8], [22 x i8]* @.str.660, i64 0, i64 0
  %t709 = ptrtoint i8* %t708 to i64
  %t710 = call i64 @kore_str_concat(i64 %t707, i64 %t709)
  %t711 = load i64, i64* %t595
  %t712 = call i64 @kore_str_concat(i64 %t710, i64 %t711)
  %t713 = call i64 @CodeGen_write_line(i64 %t703, i64 %t712)
  br label %endif807
  endif807:
  br label %endif797
  else796:
  %t714 = load i64, i64* %t0
  %t715 = getelementptr [24 x i8], [24 x i8]* @.str.661, i64 0, i64 0
  %t716 = ptrtoint i8* %t715 to i64
  %t717 = load i64, i64* %t577
  %t718 = call i64 @kore_str_concat(i64 %t716, i64 %t717)
  %t719 = call i64 @CodeGen_write_line(i64 %t714, i64 %t718)
  br label %endif797
  endif797:
  br label %endif794
  endif794:
  br label %endif788
  endif788:
  ret i64 0
  endif785:
  ret i64 0
}
define i64 @CodeGen_gen_expr(i64 %self, i64 %expr) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %expr, i64* %t1
  %t2 = load i64, i64* %t1
  %t3 = call i64 @kore_variant_of(i64 %t2)
  %t4 = alloca i64
  store i64 %t3, i64* %t4
  %t5 = load i64, i64* %t4
  %t6 = getelementptr [4 x i8], [4 x i8]* @.str.662, i64 0, i64 0
  %t7 = ptrtoint i8* %t6 to i64
  %t8 = call i64 @kore_str_eq(i64 %t5, i64 %t7)
  %t9 = icmp ne i64 %t8, 0
  br i1 %t9, label %then808, label %endif810
  then808:
  %t10 = load i64, i64* %t1
  %t11 = call i64 @kore_variant_field(i64 %t10, i64 0)
  %t12 = alloca i64
  store i64 %t11, i64* %t12
  %t13 = load i64, i64* %t12
  %t14 = call i64 @kore_to_string(i64 %t13)
  ret i64 %t14
  endif810:
  %t15 = load i64, i64* %t4
  %t16 = getelementptr [6 x i8], [6 x i8]* @.str.663, i64 0, i64 0
  %t17 = ptrtoint i8* %t16 to i64
  %t18 = call i64 @kore_str_eq(i64 %t15, i64 %t17)
  %t19 = icmp ne i64 %t18, 0
  br i1 %t19, label %then811, label %endif813
  then811:
  %t20 = load i64, i64* %t1
  %t21 = call i64 @kore_variant_field(i64 %t20, i64 0)
  %t22 = alloca i64
  store i64 %t21, i64* %t22
  %t23 = load i64, i64* %t22
  %t24 = call i64 @kore_to_string(i64 %t23)
  ret i64 %t24
  endif813:
  %t25 = load i64, i64* %t4
  %t26 = getelementptr [5 x i8], [5 x i8]* @.str.664, i64 0, i64 0
  %t27 = ptrtoint i8* %t26 to i64
  %t28 = call i64 @kore_str_eq(i64 %t25, i64 %t27)
  %t29 = icmp ne i64 %t28, 0
  br i1 %t29, label %then814, label %endif816
  then814:
  %t30 = load i64, i64* %t1
  %t31 = call i64 @kore_variant_field(i64 %t30, i64 0)
  %t32 = alloca i64
  store i64 %t31, i64* %t32
  %t33 = load i64, i64* %t32
  %t34 = icmp ne i64 %t33, 0
  br i1 %t34, label %then817, label %endif819
  then817:
  %t35 = getelementptr [2 x i8], [2 x i8]* @.str.665, i64 0, i64 0
  %t36 = ptrtoint i8* %t35 to i64
  ret i64 %t36
  endif819:
  %t37 = getelementptr [2 x i8], [2 x i8]* @.str.666, i64 0, i64 0
  %t38 = ptrtoint i8* %t37 to i64
  ret i64 %t38
  endif816:
  %t39 = load i64, i64* %t4
  %t40 = getelementptr [7 x i8], [7 x i8]* @.str.667, i64 0, i64 0
  %t41 = ptrtoint i8* %t40 to i64
  %t42 = call i64 @kore_str_eq(i64 %t39, i64 %t41)
  %t43 = icmp ne i64 %t42, 0
  br i1 %t43, label %then820, label %endif822
  then820:
  %t44 = load i64, i64* %t1
  %t45 = call i64 @kore_variant_field(i64 %t44, i64 0)
  %t46 = alloca i64
  store i64 %t45, i64* %t46
  %t47 = load i64, i64* %t0
  %t48 = inttoptr i64 %t47 to %CodeGen*
  %t49 = getelementptr %CodeGen, %CodeGen* %t48, i32 0, i32 5
  %t50 = load i64, i64* %t49
  %t51 = load i64, i64* %t46
  %t52 = call i64 @kore_array_push(i64 %t50, i64 %t51)
  %t53 = getelementptr [7 x i8], [7 x i8]* @.str.668, i64 0, i64 0
  %t54 = ptrtoint i8* %t53 to i64
  %t55 = load i64, i64* %t0
  %t56 = inttoptr i64 %t55 to %CodeGen*
  %t57 = getelementptr %CodeGen, %CodeGen* %t56, i32 0, i32 5
  %t58 = load i64, i64* %t57
  %t59 = call i64 @kore_array_len(i64 %t58)
  %t60 = sub i64 %t59, 1
  %t61 = call i64 @kore_to_string(i64 %t60)
  %t62 = call i64 @kore_str_concat(i64 %t54, i64 %t61)
  %t63 = alloca i64
  store i64 %t62, i64* %t63
  %t64 = load i64, i64* %t0
  %t65 = call i64 @CodeGen_fresh_local(i64 %t64)
  %t66 = alloca i64
  store i64 %t65, i64* %t66
  %t67 = load i64, i64* %t0
  %t68 = load i64, i64* %t66
  %t69 = getelementptr [19 x i8], [19 x i8]* @.str.669, i64 0, i64 0
  %t70 = ptrtoint i8* %t69 to i64
  %t71 = call i64 @kore_str_concat(i64 %t68, i64 %t70)
  %t72 = load i64, i64* %t46
  %t73 = call i64 @kore_str_len(i64 %t72)
  %t74 = call i64 @kore_add_op(i64 %t73, i64 1)
  %t75 = call i64 @kore_to_string(i64 %t74)
  %t76 = call i64 @kore_str_concat(i64 %t71, i64 %t75)
  %t77 = getelementptr [10 x i8], [10 x i8]* @.str.670, i64 0, i64 0
  %t78 = ptrtoint i8* %t77 to i64
  %t79 = call i64 @kore_str_concat(i64 %t76, i64 %t78)
  %t80 = load i64, i64* %t46
  %t81 = call i64 @kore_str_len(i64 %t80)
  %t82 = call i64 @kore_add_op(i64 %t81, i64 1)
  %t83 = call i64 @kore_to_string(i64 %t82)
  %t84 = call i64 @kore_str_concat(i64 %t79, i64 %t83)
  %t85 = getelementptr [9 x i8], [9 x i8]* @.str.671, i64 0, i64 0
  %t86 = ptrtoint i8* %t85 to i64
  %t87 = call i64 @kore_str_concat(i64 %t84, i64 %t86)
  %t88 = load i64, i64* %t63
  %t89 = call i64 @kore_str_concat(i64 %t87, i64 %t88)
  %t90 = getelementptr [15 x i8], [15 x i8]* @.str.672, i64 0, i64 0
  %t91 = ptrtoint i8* %t90 to i64
  %t92 = call i64 @kore_str_concat(i64 %t89, i64 %t91)
  %t93 = call i64 @CodeGen_write_line(i64 %t67, i64 %t92)
  %t94 = load i64, i64* %t0
  %t95 = call i64 @CodeGen_fresh_local(i64 %t94)
  %t96 = alloca i64
  store i64 %t95, i64* %t96
  %t97 = load i64, i64* %t0
  %t98 = load i64, i64* %t96
  %t99 = getelementptr [17 x i8], [17 x i8]* @.str.673, i64 0, i64 0
  %t100 = ptrtoint i8* %t99 to i64
  %t101 = call i64 @kore_str_concat(i64 %t98, i64 %t100)
  %t102 = load i64, i64* %t66
  %t103 = call i64 @kore_str_concat(i64 %t101, i64 %t102)
  %t104 = getelementptr [8 x i8], [8 x i8]* @.str.674, i64 0, i64 0
  %t105 = ptrtoint i8* %t104 to i64
  %t106 = call i64 @kore_str_concat(i64 %t103, i64 %t105)
  %t107 = call i64 @CodeGen_write_line(i64 %t97, i64 %t106)
  %t108 = load i64, i64* %t96
  ret i64 %t108
  endif822:
  %t109 = load i64, i64* %t4
  %t110 = getelementptr [6 x i8], [6 x i8]* @.str.675, i64 0, i64 0
  %t111 = ptrtoint i8* %t110 to i64
  %t112 = call i64 @kore_str_eq(i64 %t109, i64 %t111)
  %t113 = icmp ne i64 %t112, 0
  br i1 %t113, label %then823, label %endif825
  then823:
  %t114 = load i64, i64* %t1
  %t115 = call i64 @kore_variant_field(i64 %t114, i64 0)
  %t116 = alloca i64
  store i64 %t115, i64* %t116
  %t117 = load i64, i64* %t0
  %t118 = inttoptr i64 %t117 to %CodeGen*
  %t119 = getelementptr %CodeGen, %CodeGen* %t118, i32 0, i32 6
  %t120 = load i64, i64* %t119
  %t121 = load i64, i64* %t116
  %t122 = call i64 @kore_contains_key(i64 %t120, i64 %t121)
  %t123 = icmp ne i64 %t122, 0
  br i1 %t123, label %then826, label %endif828
  then826:
  %t124 = load i64, i64* %t0
  %t125 = inttoptr i64 %t124 to %CodeGen*
  %t126 = getelementptr %CodeGen, %CodeGen* %t125, i32 0, i32 6
  %t127 = load i64, i64* %t126
  %t128 = load i64, i64* %t116
  %t129 = call i64 @kore_map_get(i64 %t127, i64 %t128)
  %t130 = alloca i64
  store i64 %t129, i64* %t130
  %t131 = load i64, i64* %t0
  %t132 = call i64 @CodeGen_fresh_local(i64 %t131)
  %t133 = alloca i64
  store i64 %t132, i64* %t133
  %t134 = load i64, i64* %t0
  %t135 = load i64, i64* %t133
  %t136 = getelementptr [19 x i8], [19 x i8]* @.str.676, i64 0, i64 0
  %t137 = ptrtoint i8* %t136 to i64
  %t138 = call i64 @kore_str_concat(i64 %t135, i64 %t137)
  %t139 = load i64, i64* %t130
  %t140 = call i64 @kore_str_concat(i64 %t138, i64 %t139)
  %t141 = call i64 @CodeGen_write_line(i64 %t134, i64 %t140)
  %t142 = load i64, i64* %t133
  ret i64 %t142
  endif828:
  %t143 = getelementptr [2 x i8], [2 x i8]* @.str.677, i64 0, i64 0
  %t144 = ptrtoint i8* %t143 to i64
  %t145 = load i64, i64* %t116
  %t146 = call i64 @kore_str_concat(i64 %t144, i64 %t145)
  ret i64 %t146
  endif825:
  %t147 = load i64, i64* %t4
  %t148 = getelementptr [7 x i8], [7 x i8]* @.str.678, i64 0, i64 0
  %t149 = ptrtoint i8* %t148 to i64
  %t150 = call i64 @kore_str_eq(i64 %t147, i64 %t149)
  %t151 = icmp ne i64 %t150, 0
  br i1 %t151, label %then829, label %endif831
  then829:
  %t152 = load i64, i64* %t1
  %t153 = call i64 @kore_variant_field(i64 %t152, i64 0)
  %t154 = alloca i64
  store i64 %t153, i64* %t154
  %t155 = load i64, i64* %t1
  %t156 = call i64 @kore_variant_field(i64 %t155, i64 1)
  %t157 = alloca i64
  store i64 %t156, i64* %t157
  %t158 = load i64, i64* %t1
  %t159 = call i64 @kore_variant_field(i64 %t158, i64 2)
  %t160 = alloca i64
  store i64 %t159, i64* %t160
  %t161 = load i64, i64* %t0
  %t162 = load i64, i64* %t154
  %t163 = call i64 @CodeGen_gen_expr(i64 %t161, i64 %t162)
  %t164 = alloca i64
  store i64 %t163, i64* %t164
  %t165 = load i64, i64* %t0
  %t166 = load i64, i64* %t160
  %t167 = call i64 @CodeGen_gen_expr(i64 %t165, i64 %t166)
  %t168 = alloca i64
  store i64 %t167, i64* %t168
  %t169 = load i64, i64* %t0
  %t170 = call i64 @CodeGen_fresh_local(i64 %t169)
  %t171 = alloca i64
  store i64 %t170, i64* %t171
  %t172 = load i64, i64* %t157
  %t173 = getelementptr [2 x i8], [2 x i8]* @.str.679, i64 0, i64 0
  %t174 = ptrtoint i8* %t173 to i64
  %t175 = call i64 @kore_str_eq(i64 %t172, i64 %t174)
  %t176 = icmp ne i64 %t175, 0
  br i1 %t176, label %then832, label %else833
  then832:
  %t177 = load i64, i64* %t0
  %t178 = load i64, i64* %t171
  %t179 = getelementptr [12 x i8], [12 x i8]* @.str.680, i64 0, i64 0
  %t180 = ptrtoint i8* %t179 to i64
  %t181 = call i64 @kore_str_concat(i64 %t178, i64 %t180)
  %t182 = load i64, i64* %t164
  %t183 = call i64 @kore_str_concat(i64 %t181, i64 %t182)
  %t184 = getelementptr [3 x i8], [3 x i8]* @.str.681, i64 0, i64 0
  %t185 = ptrtoint i8* %t184 to i64
  %t186 = call i64 @kore_str_concat(i64 %t183, i64 %t185)
  %t187 = load i64, i64* %t168
  %t188 = call i64 @kore_str_concat(i64 %t186, i64 %t187)
  %t189 = call i64 @CodeGen_write_line(i64 %t177, i64 %t188)
  br label %endif834
  else833:
  %t190 = load i64, i64* %t157
  %t191 = getelementptr [2 x i8], [2 x i8]* @.str.682, i64 0, i64 0
  %t192 = ptrtoint i8* %t191 to i64
  %t193 = call i64 @kore_str_eq(i64 %t190, i64 %t192)
  %t194 = icmp ne i64 %t193, 0
  br i1 %t194, label %then835, label %else836
  then835:
  %t195 = load i64, i64* %t0
  %t196 = load i64, i64* %t171
  %t197 = getelementptr [12 x i8], [12 x i8]* @.str.683, i64 0, i64 0
  %t198 = ptrtoint i8* %t197 to i64
  %t199 = call i64 @kore_str_concat(i64 %t196, i64 %t198)
  %t200 = load i64, i64* %t164
  %t201 = call i64 @kore_str_concat(i64 %t199, i64 %t200)
  %t202 = getelementptr [3 x i8], [3 x i8]* @.str.684, i64 0, i64 0
  %t203 = ptrtoint i8* %t202 to i64
  %t204 = call i64 @kore_str_concat(i64 %t201, i64 %t203)
  %t205 = load i64, i64* %t168
  %t206 = call i64 @kore_str_concat(i64 %t204, i64 %t205)
  %t207 = call i64 @CodeGen_write_line(i64 %t195, i64 %t206)
  br label %endif837
  else836:
  %t208 = load i64, i64* %t157
  %t209 = getelementptr [2 x i8], [2 x i8]* @.str.685, i64 0, i64 0
  %t210 = ptrtoint i8* %t209 to i64
  %t211 = call i64 @kore_str_eq(i64 %t208, i64 %t210)
  %t212 = icmp ne i64 %t211, 0
  br i1 %t212, label %then838, label %else839
  then838:
  %t213 = load i64, i64* %t0
  %t214 = load i64, i64* %t171
  %t215 = getelementptr [12 x i8], [12 x i8]* @.str.686, i64 0, i64 0
  %t216 = ptrtoint i8* %t215 to i64
  %t217 = call i64 @kore_str_concat(i64 %t214, i64 %t216)
  %t218 = load i64, i64* %t164
  %t219 = call i64 @kore_str_concat(i64 %t217, i64 %t218)
  %t220 = getelementptr [3 x i8], [3 x i8]* @.str.687, i64 0, i64 0
  %t221 = ptrtoint i8* %t220 to i64
  %t222 = call i64 @kore_str_concat(i64 %t219, i64 %t221)
  %t223 = load i64, i64* %t168
  %t224 = call i64 @kore_str_concat(i64 %t222, i64 %t223)
  %t225 = call i64 @CodeGen_write_line(i64 %t213, i64 %t224)
  br label %endif840
  else839:
  %t226 = load i64, i64* %t157
  %t227 = getelementptr [2 x i8], [2 x i8]* @.str.688, i64 0, i64 0
  %t228 = ptrtoint i8* %t227 to i64
  %t229 = call i64 @kore_str_eq(i64 %t226, i64 %t228)
  %t230 = icmp ne i64 %t229, 0
  br i1 %t230, label %then841, label %else842
  then841:
  %t231 = load i64, i64* %t0
  %t232 = load i64, i64* %t171
  %t233 = getelementptr [13 x i8], [13 x i8]* @.str.689, i64 0, i64 0
  %t234 = ptrtoint i8* %t233 to i64
  %t235 = call i64 @kore_str_concat(i64 %t232, i64 %t234)
  %t236 = load i64, i64* %t164
  %t237 = call i64 @kore_str_concat(i64 %t235, i64 %t236)
  %t238 = getelementptr [3 x i8], [3 x i8]* @.str.690, i64 0, i64 0
  %t239 = ptrtoint i8* %t238 to i64
  %t240 = call i64 @kore_str_concat(i64 %t237, i64 %t239)
  %t241 = load i64, i64* %t168
  %t242 = call i64 @kore_str_concat(i64 %t240, i64 %t241)
  %t243 = call i64 @CodeGen_write_line(i64 %t231, i64 %t242)
  br label %endif843
  else842:
  %t244 = load i64, i64* %t157
  %t245 = getelementptr [2 x i8], [2 x i8]* @.str.691, i64 0, i64 0
  %t246 = ptrtoint i8* %t245 to i64
  %t247 = call i64 @kore_str_eq(i64 %t244, i64 %t246)
  %t248 = icmp ne i64 %t247, 0
  br i1 %t248, label %then844, label %else845
  then844:
  %t249 = load i64, i64* %t0
  %t250 = load i64, i64* %t171
  %t251 = getelementptr [13 x i8], [13 x i8]* @.str.692, i64 0, i64 0
  %t252 = ptrtoint i8* %t251 to i64
  %t253 = call i64 @kore_str_concat(i64 %t250, i64 %t252)
  %t254 = load i64, i64* %t164
  %t255 = call i64 @kore_str_concat(i64 %t253, i64 %t254)
  %t256 = getelementptr [3 x i8], [3 x i8]* @.str.693, i64 0, i64 0
  %t257 = ptrtoint i8* %t256 to i64
  %t258 = call i64 @kore_str_concat(i64 %t255, i64 %t257)
  %t259 = load i64, i64* %t168
  %t260 = call i64 @kore_str_concat(i64 %t258, i64 %t259)
  %t261 = call i64 @CodeGen_write_line(i64 %t249, i64 %t260)
  br label %endif846
  else845:
  %t262 = load i64, i64* %t157
  %t263 = getelementptr [3 x i8], [3 x i8]* @.str.694, i64 0, i64 0
  %t264 = ptrtoint i8* %t263 to i64
  %t265 = call i64 @kore_str_eq(i64 %t262, i64 %t264)
  %t266 = load i64, i64* %t157
  %t267 = getelementptr [3 x i8], [3 x i8]* @.str.695, i64 0, i64 0
  %t268 = ptrtoint i8* %t267 to i64
  %t269 = call i64 @kore_str_eq(i64 %t266, i64 %t268)
  %t270 = or i64 %t265, %t269
  %t271 = icmp ne i64 %t270, 0
  br i1 %t271, label %then847, label %else848
  then847:
  %t272 = load i64, i64* %t0
  %t273 = call i64 @CodeGen_fresh_local(i64 %t272)
  %t274 = alloca i64
  store i64 %t273, i64* %t274
  %t275 = load i64, i64* %t0
  %t276 = load i64, i64* %t274
  %t277 = getelementptr [16 x i8], [16 x i8]* @.str.696, i64 0, i64 0
  %t278 = ptrtoint i8* %t277 to i64
  %t279 = call i64 @kore_str_concat(i64 %t276, i64 %t278)
  %t280 = load i64, i64* %t164
  %t281 = call i64 @kore_str_concat(i64 %t279, i64 %t280)
  %t282 = getelementptr [3 x i8], [3 x i8]* @.str.697, i64 0, i64 0
  %t283 = ptrtoint i8* %t282 to i64
  %t284 = call i64 @kore_str_concat(i64 %t281, i64 %t283)
  %t285 = load i64, i64* %t168
  %t286 = call i64 @kore_str_concat(i64 %t284, i64 %t285)
  %t287 = call i64 @CodeGen_write_line(i64 %t275, i64 %t286)
  %t288 = load i64, i64* %t0
  %t289 = load i64, i64* %t171
  %t290 = getelementptr [12 x i8], [12 x i8]* @.str.698, i64 0, i64 0
  %t291 = ptrtoint i8* %t290 to i64
  %t292 = call i64 @kore_str_concat(i64 %t289, i64 %t291)
  %t293 = load i64, i64* %t274
  %t294 = call i64 @kore_str_concat(i64 %t292, i64 %t293)
  %t295 = getelementptr [8 x i8], [8 x i8]* @.str.699, i64 0, i64 0
  %t296 = ptrtoint i8* %t295 to i64
  %t297 = call i64 @kore_str_concat(i64 %t294, i64 %t296)
  %t298 = call i64 @CodeGen_write_line(i64 %t288, i64 %t297)
  br label %endif849
  else848:
  %t299 = load i64, i64* %t157
  %t300 = getelementptr [3 x i8], [3 x i8]* @.str.700, i64 0, i64 0
  %t301 = ptrtoint i8* %t300 to i64
  %t302 = call i64 @kore_str_eq(i64 %t299, i64 %t301)
  %t303 = load i64, i64* %t157
  %t304 = getelementptr [3 x i8], [3 x i8]* @.str.701, i64 0, i64 0
  %t305 = ptrtoint i8* %t304 to i64
  %t306 = call i64 @kore_str_eq(i64 %t303, i64 %t305)
  %t307 = or i64 %t302, %t306
  %t308 = icmp ne i64 %t307, 0
  br i1 %t308, label %then850, label %else851
  then850:
  %t309 = load i64, i64* %t0
  %t310 = call i64 @CodeGen_fresh_local(i64 %t309)
  %t311 = alloca i64
  store i64 %t310, i64* %t311
  %t312 = load i64, i64* %t0
  %t313 = load i64, i64* %t311
  %t314 = getelementptr [16 x i8], [16 x i8]* @.str.702, i64 0, i64 0
  %t315 = ptrtoint i8* %t314 to i64
  %t316 = call i64 @kore_str_concat(i64 %t313, i64 %t315)
  %t317 = load i64, i64* %t164
  %t318 = call i64 @kore_str_concat(i64 %t316, i64 %t317)
  %t319 = getelementptr [3 x i8], [3 x i8]* @.str.703, i64 0, i64 0
  %t320 = ptrtoint i8* %t319 to i64
  %t321 = call i64 @kore_str_concat(i64 %t318, i64 %t320)
  %t322 = load i64, i64* %t168
  %t323 = call i64 @kore_str_concat(i64 %t321, i64 %t322)
  %t324 = call i64 @CodeGen_write_line(i64 %t312, i64 %t323)
  %t325 = load i64, i64* %t0
  %t326 = load i64, i64* %t171
  %t327 = getelementptr [12 x i8], [12 x i8]* @.str.704, i64 0, i64 0
  %t328 = ptrtoint i8* %t327 to i64
  %t329 = call i64 @kore_str_concat(i64 %t326, i64 %t328)
  %t330 = load i64, i64* %t311
  %t331 = call i64 @kore_str_concat(i64 %t329, i64 %t330)
  %t332 = getelementptr [8 x i8], [8 x i8]* @.str.705, i64 0, i64 0
  %t333 = ptrtoint i8* %t332 to i64
  %t334 = call i64 @kore_str_concat(i64 %t331, i64 %t333)
  %t335 = call i64 @CodeGen_write_line(i64 %t325, i64 %t334)
  br label %endif852
  else851:
  %t336 = load i64, i64* %t157
  %t337 = getelementptr [2 x i8], [2 x i8]* @.str.706, i64 0, i64 0
  %t338 = ptrtoint i8* %t337 to i64
  %t339 = call i64 @kore_str_eq(i64 %t336, i64 %t338)
  %t340 = load i64, i64* %t157
  %t341 = getelementptr [3 x i8], [3 x i8]* @.str.707, i64 0, i64 0
  %t342 = ptrtoint i8* %t341 to i64
  %t343 = call i64 @kore_str_eq(i64 %t340, i64 %t342)
  %t344 = or i64 %t339, %t343
  %t345 = icmp ne i64 %t344, 0
  br i1 %t345, label %then853, label %else854
  then853:
  %t346 = load i64, i64* %t0
  %t347 = call i64 @CodeGen_fresh_local(i64 %t346)
  %t348 = alloca i64
  store i64 %t347, i64* %t348
  %t349 = load i64, i64* %t0
  %t350 = load i64, i64* %t348
  %t351 = getelementptr [17 x i8], [17 x i8]* @.str.708, i64 0, i64 0
  %t352 = ptrtoint i8* %t351 to i64
  %t353 = call i64 @kore_str_concat(i64 %t350, i64 %t352)
  %t354 = load i64, i64* %t164
  %t355 = call i64 @kore_str_concat(i64 %t353, i64 %t354)
  %t356 = getelementptr [3 x i8], [3 x i8]* @.str.709, i64 0, i64 0
  %t357 = ptrtoint i8* %t356 to i64
  %t358 = call i64 @kore_str_concat(i64 %t355, i64 %t357)
  %t359 = load i64, i64* %t168
  %t360 = call i64 @kore_str_concat(i64 %t358, i64 %t359)
  %t361 = call i64 @CodeGen_write_line(i64 %t349, i64 %t360)
  %t362 = load i64, i64* %t0
  %t363 = load i64, i64* %t171
  %t364 = getelementptr [12 x i8], [12 x i8]* @.str.710, i64 0, i64 0
  %t365 = ptrtoint i8* %t364 to i64
  %t366 = call i64 @kore_str_concat(i64 %t363, i64 %t365)
  %t367 = load i64, i64* %t348
  %t368 = call i64 @kore_str_concat(i64 %t366, i64 %t367)
  %t369 = getelementptr [8 x i8], [8 x i8]* @.str.711, i64 0, i64 0
  %t370 = ptrtoint i8* %t369 to i64
  %t371 = call i64 @kore_str_concat(i64 %t368, i64 %t370)
  %t372 = call i64 @CodeGen_write_line(i64 %t362, i64 %t371)
  br label %endif855
  else854:
  %t373 = load i64, i64* %t157
  %t374 = getelementptr [3 x i8], [3 x i8]* @.str.712, i64 0, i64 0
  %t375 = ptrtoint i8* %t374 to i64
  %t376 = call i64 @kore_str_eq(i64 %t373, i64 %t375)
  %t377 = load i64, i64* %t157
  %t378 = getelementptr [3 x i8], [3 x i8]* @.str.713, i64 0, i64 0
  %t379 = ptrtoint i8* %t378 to i64
  %t380 = call i64 @kore_str_eq(i64 %t377, i64 %t379)
  %t381 = or i64 %t376, %t380
  %t382 = icmp ne i64 %t381, 0
  br i1 %t382, label %then856, label %else857
  then856:
  %t383 = load i64, i64* %t0
  %t384 = call i64 @CodeGen_fresh_local(i64 %t383)
  %t385 = alloca i64
  store i64 %t384, i64* %t385
  %t386 = load i64, i64* %t0
  %t387 = load i64, i64* %t385
  %t388 = getelementptr [17 x i8], [17 x i8]* @.str.714, i64 0, i64 0
  %t389 = ptrtoint i8* %t388 to i64
  %t390 = call i64 @kore_str_concat(i64 %t387, i64 %t389)
  %t391 = load i64, i64* %t164
  %t392 = call i64 @kore_str_concat(i64 %t390, i64 %t391)
  %t393 = getelementptr [3 x i8], [3 x i8]* @.str.715, i64 0, i64 0
  %t394 = ptrtoint i8* %t393 to i64
  %t395 = call i64 @kore_str_concat(i64 %t392, i64 %t394)
  %t396 = load i64, i64* %t168
  %t397 = call i64 @kore_str_concat(i64 %t395, i64 %t396)
  %t398 = call i64 @CodeGen_write_line(i64 %t386, i64 %t397)
  %t399 = load i64, i64* %t0
  %t400 = load i64, i64* %t171
  %t401 = getelementptr [12 x i8], [12 x i8]* @.str.716, i64 0, i64 0
  %t402 = ptrtoint i8* %t401 to i64
  %t403 = call i64 @kore_str_concat(i64 %t400, i64 %t402)
  %t404 = load i64, i64* %t385
  %t405 = call i64 @kore_str_concat(i64 %t403, i64 %t404)
  %t406 = getelementptr [8 x i8], [8 x i8]* @.str.717, i64 0, i64 0
  %t407 = ptrtoint i8* %t406 to i64
  %t408 = call i64 @kore_str_concat(i64 %t405, i64 %t407)
  %t409 = call i64 @CodeGen_write_line(i64 %t399, i64 %t408)
  br label %endif858
  else857:
  %t410 = load i64, i64* %t157
  %t411 = getelementptr [2 x i8], [2 x i8]* @.str.718, i64 0, i64 0
  %t412 = ptrtoint i8* %t411 to i64
  %t413 = call i64 @kore_str_eq(i64 %t410, i64 %t412)
  %t414 = load i64, i64* %t157
  %t415 = getelementptr [3 x i8], [3 x i8]* @.str.719, i64 0, i64 0
  %t416 = ptrtoint i8* %t415 to i64
  %t417 = call i64 @kore_str_eq(i64 %t414, i64 %t416)
  %t418 = or i64 %t413, %t417
  %t419 = icmp ne i64 %t418, 0
  br i1 %t419, label %then859, label %else860
  then859:
  %t420 = load i64, i64* %t0
  %t421 = call i64 @CodeGen_fresh_local(i64 %t420)
  %t422 = alloca i64
  store i64 %t421, i64* %t422
  %t423 = load i64, i64* %t0
  %t424 = load i64, i64* %t422
  %t425 = getelementptr [17 x i8], [17 x i8]* @.str.720, i64 0, i64 0
  %t426 = ptrtoint i8* %t425 to i64
  %t427 = call i64 @kore_str_concat(i64 %t424, i64 %t426)
  %t428 = load i64, i64* %t164
  %t429 = call i64 @kore_str_concat(i64 %t427, i64 %t428)
  %t430 = getelementptr [3 x i8], [3 x i8]* @.str.721, i64 0, i64 0
  %t431 = ptrtoint i8* %t430 to i64
  %t432 = call i64 @kore_str_concat(i64 %t429, i64 %t431)
  %t433 = load i64, i64* %t168
  %t434 = call i64 @kore_str_concat(i64 %t432, i64 %t433)
  %t435 = call i64 @CodeGen_write_line(i64 %t423, i64 %t434)
  %t436 = load i64, i64* %t0
  %t437 = load i64, i64* %t171
  %t438 = getelementptr [12 x i8], [12 x i8]* @.str.722, i64 0, i64 0
  %t439 = ptrtoint i8* %t438 to i64
  %t440 = call i64 @kore_str_concat(i64 %t437, i64 %t439)
  %t441 = load i64, i64* %t422
  %t442 = call i64 @kore_str_concat(i64 %t440, i64 %t441)
  %t443 = getelementptr [8 x i8], [8 x i8]* @.str.723, i64 0, i64 0
  %t444 = ptrtoint i8* %t443 to i64
  %t445 = call i64 @kore_str_concat(i64 %t442, i64 %t444)
  %t446 = call i64 @CodeGen_write_line(i64 %t436, i64 %t445)
  br label %endif861
  else860:
  %t447 = load i64, i64* %t157
  %t448 = getelementptr [3 x i8], [3 x i8]* @.str.724, i64 0, i64 0
  %t449 = ptrtoint i8* %t448 to i64
  %t450 = call i64 @kore_str_eq(i64 %t447, i64 %t449)
  %t451 = load i64, i64* %t157
  %t452 = getelementptr [3 x i8], [3 x i8]* @.str.725, i64 0, i64 0
  %t453 = ptrtoint i8* %t452 to i64
  %t454 = call i64 @kore_str_eq(i64 %t451, i64 %t453)
  %t455 = or i64 %t450, %t454
  %t456 = icmp ne i64 %t455, 0
  br i1 %t456, label %then862, label %else863
  then862:
  %t457 = load i64, i64* %t0
  %t458 = call i64 @CodeGen_fresh_local(i64 %t457)
  %t459 = alloca i64
  store i64 %t458, i64* %t459
  %t460 = load i64, i64* %t0
  %t461 = load i64, i64* %t459
  %t462 = getelementptr [17 x i8], [17 x i8]* @.str.726, i64 0, i64 0
  %t463 = ptrtoint i8* %t462 to i64
  %t464 = call i64 @kore_str_concat(i64 %t461, i64 %t463)
  %t465 = load i64, i64* %t164
  %t466 = call i64 @kore_str_concat(i64 %t464, i64 %t465)
  %t467 = getelementptr [3 x i8], [3 x i8]* @.str.727, i64 0, i64 0
  %t468 = ptrtoint i8* %t467 to i64
  %t469 = call i64 @kore_str_concat(i64 %t466, i64 %t468)
  %t470 = load i64, i64* %t168
  %t471 = call i64 @kore_str_concat(i64 %t469, i64 %t470)
  %t472 = call i64 @CodeGen_write_line(i64 %t460, i64 %t471)
  %t473 = load i64, i64* %t0
  %t474 = load i64, i64* %t171
  %t475 = getelementptr [12 x i8], [12 x i8]* @.str.728, i64 0, i64 0
  %t476 = ptrtoint i8* %t475 to i64
  %t477 = call i64 @kore_str_concat(i64 %t474, i64 %t476)
  %t478 = load i64, i64* %t459
  %t479 = call i64 @kore_str_concat(i64 %t477, i64 %t478)
  %t480 = getelementptr [8 x i8], [8 x i8]* @.str.729, i64 0, i64 0
  %t481 = ptrtoint i8* %t480 to i64
  %t482 = call i64 @kore_str_concat(i64 %t479, i64 %t481)
  %t483 = call i64 @CodeGen_write_line(i64 %t473, i64 %t482)
  br label %endif864
  else863:
  %t484 = load i64, i64* %t157
  %t485 = getelementptr [3 x i8], [3 x i8]* @.str.730, i64 0, i64 0
  %t486 = ptrtoint i8* %t485 to i64
  %t487 = call i64 @kore_str_eq(i64 %t484, i64 %t486)
  %t488 = load i64, i64* %t157
  %t489 = getelementptr [4 x i8], [4 x i8]* @.str.731, i64 0, i64 0
  %t490 = ptrtoint i8* %t489 to i64
  %t491 = call i64 @kore_str_eq(i64 %t488, i64 %t490)
  %t492 = or i64 %t487, %t491
  %t493 = icmp ne i64 %t492, 0
  br i1 %t493, label %then865, label %else866
  then865:
  %t494 = load i64, i64* %t0
  %t495 = load i64, i64* %t171
  %t496 = getelementptr [12 x i8], [12 x i8]* @.str.732, i64 0, i64 0
  %t497 = ptrtoint i8* %t496 to i64
  %t498 = call i64 @kore_str_concat(i64 %t495, i64 %t497)
  %t499 = load i64, i64* %t164
  %t500 = call i64 @kore_str_concat(i64 %t498, i64 %t499)
  %t501 = getelementptr [3 x i8], [3 x i8]* @.str.733, i64 0, i64 0
  %t502 = ptrtoint i8* %t501 to i64
  %t503 = call i64 @kore_str_concat(i64 %t500, i64 %t502)
  %t504 = load i64, i64* %t168
  %t505 = call i64 @kore_str_concat(i64 %t503, i64 %t504)
  %t506 = call i64 @CodeGen_write_line(i64 %t494, i64 %t505)
  br label %endif867
  else866:
  %t507 = load i64, i64* %t157
  %t508 = getelementptr [3 x i8], [3 x i8]* @.str.734, i64 0, i64 0
  %t509 = ptrtoint i8* %t508 to i64
  %t510 = call i64 @kore_str_eq(i64 %t507, i64 %t509)
  %t511 = load i64, i64* %t157
  %t512 = getelementptr [3 x i8], [3 x i8]* @.str.735, i64 0, i64 0
  %t513 = ptrtoint i8* %t512 to i64
  %t514 = call i64 @kore_str_eq(i64 %t511, i64 %t513)
  %t515 = or i64 %t510, %t514
  %t516 = icmp ne i64 %t515, 0
  br i1 %t516, label %then868, label %else869
  then868:
  %t517 = load i64, i64* %t0
  %t518 = load i64, i64* %t171
  %t519 = getelementptr [11 x i8], [11 x i8]* @.str.736, i64 0, i64 0
  %t520 = ptrtoint i8* %t519 to i64
  %t521 = call i64 @kore_str_concat(i64 %t518, i64 %t520)
  %t522 = load i64, i64* %t164
  %t523 = call i64 @kore_str_concat(i64 %t521, i64 %t522)
  %t524 = getelementptr [3 x i8], [3 x i8]* @.str.737, i64 0, i64 0
  %t525 = ptrtoint i8* %t524 to i64
  %t526 = call i64 @kore_str_concat(i64 %t523, i64 %t525)
  %t527 = load i64, i64* %t168
  %t528 = call i64 @kore_str_concat(i64 %t526, i64 %t527)
  %t529 = call i64 @CodeGen_write_line(i64 %t517, i64 %t528)
  br label %endif870
  else869:
  %t530 = load i64, i64* %t0
  %t531 = getelementptr [15 x i8], [15 x i8]* @.str.738, i64 0, i64 0
  %t532 = ptrtoint i8* %t531 to i64
  %t533 = load i64, i64* %t157
  %t534 = call i64 @kore_str_concat(i64 %t532, i64 %t533)
  %t535 = call i64 @CodeGen_write_line(i64 %t530, i64 %t534)
  %t536 = getelementptr [2 x i8], [2 x i8]* @.str.739, i64 0, i64 0
  %t537 = ptrtoint i8* %t536 to i64
  ret i64 %t537
  endif870:
  br label %endif867
  endif867:
  br label %endif864
  endif864:
  br label %endif861
  endif861:
  br label %endif858
  endif858:
  br label %endif855
  endif855:
  br label %endif852
  endif852:
  br label %endif849
  endif849:
  br label %endif846
  endif846:
  br label %endif843
  endif843:
  br label %endif840
  endif840:
  br label %endif837
  endif837:
  br label %endif834
  endif834:
  %t538 = load i64, i64* %t171
  ret i64 %t538
  endif831:
  %t539 = load i64, i64* %t4
  %t540 = getelementptr [6 x i8], [6 x i8]* @.str.740, i64 0, i64 0
  %t541 = ptrtoint i8* %t540 to i64
  %t542 = call i64 @kore_str_eq(i64 %t539, i64 %t541)
  %t543 = icmp ne i64 %t542, 0
  br i1 %t543, label %then871, label %endif873
  then871:
  %t544 = load i64, i64* %t1
  %t545 = call i64 @kore_variant_field(i64 %t544, i64 0)
  %t546 = alloca i64
  store i64 %t545, i64* %t546
  %t547 = load i64, i64* %t1
  %t548 = call i64 @kore_variant_field(i64 %t547, i64 1)
  %t549 = alloca i64
  store i64 %t548, i64* %t549
  %t550 = load i64, i64* %t0
  %t551 = load i64, i64* %t549
  %t552 = call i64 @CodeGen_gen_expr(i64 %t550, i64 %t551)
  %t553 = alloca i64
  store i64 %t552, i64* %t553
  %t554 = load i64, i64* %t0
  %t555 = call i64 @CodeGen_fresh_local(i64 %t554)
  %t556 = alloca i64
  store i64 %t555, i64* %t556
  %t557 = load i64, i64* %t546
  %t558 = getelementptr [2 x i8], [2 x i8]* @.str.741, i64 0, i64 0
  %t559 = ptrtoint i8* %t558 to i64
  %t560 = call i64 @kore_str_eq(i64 %t557, i64 %t559)
  %t561 = icmp ne i64 %t560, 0
  br i1 %t561, label %then874, label %else875
  then874:
  %t562 = load i64, i64* %t0
  %t563 = load i64, i64* %t556
  %t564 = getelementptr [15 x i8], [15 x i8]* @.str.742, i64 0, i64 0
  %t565 = ptrtoint i8* %t564 to i64
  %t566 = call i64 @kore_str_concat(i64 %t563, i64 %t565)
  %t567 = load i64, i64* %t553
  %t568 = call i64 @kore_str_concat(i64 %t566, i64 %t567)
  %t569 = call i64 @CodeGen_write_line(i64 %t562, i64 %t568)
  br label %endif876
  else875:
  %t570 = load i64, i64* %t546
  %t571 = getelementptr [2 x i8], [2 x i8]* @.str.743, i64 0, i64 0
  %t572 = ptrtoint i8* %t571 to i64
  %t573 = call i64 @kore_str_eq(i64 %t570, i64 %t572)
  %t574 = load i64, i64* %t546
  %t575 = getelementptr [4 x i8], [4 x i8]* @.str.744, i64 0, i64 0
  %t576 = ptrtoint i8* %t575 to i64
  %t577 = call i64 @kore_str_eq(i64 %t574, i64 %t576)
  %t578 = or i64 %t573, %t577
  %t579 = icmp ne i64 %t578, 0
  br i1 %t579, label %then877, label %else878
  then877:
  %t580 = load i64, i64* %t0
  %t581 = call i64 @CodeGen_fresh_local(i64 %t580)
  %t582 = alloca i64
  store i64 %t581, i64* %t582
  %t583 = load i64, i64* %t0
  %t584 = load i64, i64* %t582
  %t585 = getelementptr [16 x i8], [16 x i8]* @.str.745, i64 0, i64 0
  %t586 = ptrtoint i8* %t585 to i64
  %t587 = call i64 @kore_str_concat(i64 %t584, i64 %t586)
  %t588 = load i64, i64* %t553
  %t589 = call i64 @kore_str_concat(i64 %t587, i64 %t588)
  %t590 = getelementptr [4 x i8], [4 x i8]* @.str.746, i64 0, i64 0
  %t591 = ptrtoint i8* %t590 to i64
  %t592 = call i64 @kore_str_concat(i64 %t589, i64 %t591)
  %t593 = call i64 @CodeGen_write_line(i64 %t583, i64 %t592)
  %t594 = load i64, i64* %t0
  %t595 = load i64, i64* %t556
  %t596 = getelementptr [12 x i8], [12 x i8]* @.str.747, i64 0, i64 0
  %t597 = ptrtoint i8* %t596 to i64
  %t598 = call i64 @kore_str_concat(i64 %t595, i64 %t597)
  %t599 = load i64, i64* %t582
  %t600 = call i64 @kore_str_concat(i64 %t598, i64 %t599)
  %t601 = getelementptr [8 x i8], [8 x i8]* @.str.748, i64 0, i64 0
  %t602 = ptrtoint i8* %t601 to i64
  %t603 = call i64 @kore_str_concat(i64 %t600, i64 %t602)
  %t604 = call i64 @CodeGen_write_line(i64 %t594, i64 %t603)
  br label %endif879
  else878:
  %t605 = load i64, i64* %t553
  ret i64 %t605
  endif879:
  br label %endif876
  endif876:
  %t606 = load i64, i64* %t556
  ret i64 %t606
  endif873:
  %t607 = load i64, i64* %t4
  %t608 = getelementptr [5 x i8], [5 x i8]* @.str.749, i64 0, i64 0
  %t609 = ptrtoint i8* %t608 to i64
  %t610 = call i64 @kore_str_eq(i64 %t607, i64 %t609)
  %t611 = icmp ne i64 %t610, 0
  br i1 %t611, label %then880, label %endif882
  then880:
  %t612 = load i64, i64* %t1
  %t613 = call i64 @kore_variant_field(i64 %t612, i64 0)
  %t614 = alloca i64
  store i64 %t613, i64* %t614
  %t615 = load i64, i64* %t1
  %t616 = call i64 @kore_variant_field(i64 %t615, i64 1)
  %t617 = alloca i64
  store i64 %t616, i64* %t617
  %t618 = call i64 @kore_array_new()
  %t619 = alloca i64
  store i64 %t618, i64* %t619
  ; for arg in ...
  %t620 = load i64, i64* %t617
  %t621 = call i64 @kore_array_len(i64 %t620)
  %t622 = alloca i64
  store i64 0, i64* %t622
  br label %for_cond883
  for_cond883:
  %t623 = load i64, i64* %t622
  %t624 = icmp slt i64 %t623, %t621
  br i1 %t624, label %for_body884, label %for_end886
  for_body884:
  %t625 = call i64 @kore_array_get(i64 %t620, i64 %t623)
  %t626 = alloca i64
  store i64 %t625, i64* %t626
  %t627 = load i64, i64* %t619
  %t628 = load i64, i64* %t0
  %t629 = load i64, i64* %t626
  %t630 = call i64 @CodeGen_gen_expr(i64 %t628, i64 %t629)
  %t631 = call i64 @kore_array_push(i64 %t627, i64 %t630)
  br label %for_update885
  for_update885:
  %t632 = load i64, i64* %t622
  %t633 = add i64 %t632, 1
  store i64 %t633, i64* %t622
  br label %for_cond883
  for_end886:
  %t634 = load i64, i64* %t614
  %t635 = call i64 @kore_variant_of(i64 %t634)
  %t636 = alloca i64
  store i64 %t635, i64* %t636
  %t637 = load i64, i64* %t636
  %t638 = getelementptr [6 x i8], [6 x i8]* @.str.750, i64 0, i64 0
  %t639 = ptrtoint i8* %t638 to i64
  %t640 = call i64 @kore_str_eq(i64 %t637, i64 %t639)
  %t641 = icmp ne i64 %t640, 0
  br i1 %t641, label %then887, label %endif889
  then887:
  %t642 = load i64, i64* %t614
  %t643 = call i64 @kore_variant_field(i64 %t642, i64 0)
  %t644 = alloca i64
  store i64 %t643, i64* %t644
  %t645 = load i64, i64* %t644
  %t646 = getelementptr [8 x i8], [8 x i8]* @.str.751, i64 0, i64 0
  %t647 = ptrtoint i8* %t646 to i64
  %t648 = call i64 @kore_str_eq(i64 %t645, i64 %t647)
  %t649 = load i64, i64* %t644
  %t650 = getelementptr [6 x i8], [6 x i8]* @.str.752, i64 0, i64 0
  %t651 = ptrtoint i8* %t650 to i64
  %t652 = call i64 @kore_str_eq(i64 %t649, i64 %t651)
  %t653 = or i64 %t648, %t652
  %t654 = icmp ne i64 %t653, 0
  br i1 %t654, label %then890, label %endif892
  then890:
  %t655 = load i64, i64* %t619
  %t656 = call i64 @kore_array_len(i64 %t655)
  %t658 = icmp sgt i64 %t656, 0
  %t657 = zext i1 %t658 to i64
  %t659 = icmp ne i64 %t657, 0
  br i1 %t659, label %then893, label %endif895
  then893:
  %t660 = load i64, i64* %t0
  %t661 = getelementptr [31 x i8], [31 x i8]* @.str.753, i64 0, i64 0
  %t662 = ptrtoint i8* %t661 to i64
  %t663 = load i64, i64* %t619
  %t664 = call i64 @kore_array_get(i64 %t663, i64 0)
  %t665 = call i64 @kore_str_concat(i64 %t662, i64 %t664)
  %t666 = getelementptr [2 x i8], [2 x i8]* @.str.754, i64 0, i64 0
  %t667 = ptrtoint i8* %t666 to i64
  %t668 = call i64 @kore_str_concat(i64 %t665, i64 %t667)
  %t669 = call i64 @CodeGen_write_line(i64 %t660, i64 %t668)
  br label %endif895
  endif895:
  %t670 = getelementptr [2 x i8], [2 x i8]* @.str.755, i64 0, i64 0
  %t671 = ptrtoint i8* %t670 to i64
  ret i64 %t671
  endif892:
  %t672 = load i64, i64* %t0
  %t673 = call i64 @CodeGen_fresh_local(i64 %t672)
  %t674 = alloca i64
  store i64 %t673, i64* %t674
  %t675 = getelementptr [1 x i8], [1 x i8]* @.str.756, i64 0, i64 0
  %t676 = ptrtoint i8* %t675 to i64
  %t677 = alloca i64
  store i64 %t676, i64* %t677
  %t678 = alloca i64
  store i64 1, i64* %t678
  ; for reg in ...
  %t679 = load i64, i64* %t619
  %t680 = call i64 @kore_array_len(i64 %t679)
  %t681 = alloca i64
  store i64 0, i64* %t681
  br label %for_cond896
  for_cond896:
  %t682 = load i64, i64* %t681
  %t683 = icmp slt i64 %t682, %t680
  br i1 %t683, label %for_body897, label %for_end899
  for_body897:
  %t684 = call i64 @kore_array_get(i64 %t679, i64 %t682)
  %t685 = alloca i64
  store i64 %t684, i64* %t685
  %t686 = load i64, i64* %t678
  %t688 = icmp eq i64 %t686, 0
  %t687 = zext i1 %t688 to i64
  %t689 = icmp ne i64 %t687, 0
  br i1 %t689, label %then900, label %endif902
  then900:
  %t690 = load i64, i64* %t677
  %t691 = getelementptr [3 x i8], [3 x i8]* @.str.757, i64 0, i64 0
  %t692 = ptrtoint i8* %t691 to i64
  %t693 = call i64 @kore_str_concat(i64 %t690, i64 %t692)
  store i64 %t693, i64* %t677
  br label %endif902
  endif902:
  store i64 0, i64* %t678
  %t694 = load i64, i64* %t677
  %t695 = getelementptr [5 x i8], [5 x i8]* @.str.758, i64 0, i64 0
  %t696 = ptrtoint i8* %t695 to i64
  %t697 = call i64 @kore_str_concat(i64 %t694, i64 %t696)
  %t698 = load i64, i64* %t685
  %t699 = call i64 @kore_str_concat(i64 %t697, i64 %t698)
  store i64 %t699, i64* %t677
  br label %for_update898
  for_update898:
  %t700 = load i64, i64* %t681
  %t701 = add i64 %t700, 1
  store i64 %t701, i64* %t681
  br label %for_cond896
  for_end899:
  %t702 = load i64, i64* %t0
  %t703 = load i64, i64* %t674
  %t704 = getelementptr [14 x i8], [14 x i8]* @.str.759, i64 0, i64 0
  %t705 = ptrtoint i8* %t704 to i64
  %t706 = call i64 @kore_str_concat(i64 %t703, i64 %t705)
  %t707 = load i64, i64* %t644
  %t708 = call i64 @kore_str_concat(i64 %t706, i64 %t707)
  %t709 = getelementptr [2 x i8], [2 x i8]* @.str.760, i64 0, i64 0
  %t710 = ptrtoint i8* %t709 to i64
  %t711 = call i64 @kore_str_concat(i64 %t708, i64 %t710)
  %t712 = load i64, i64* %t677
  %t713 = call i64 @kore_str_concat(i64 %t711, i64 %t712)
  %t714 = getelementptr [2 x i8], [2 x i8]* @.str.761, i64 0, i64 0
  %t715 = ptrtoint i8* %t714 to i64
  %t716 = call i64 @kore_str_concat(i64 %t713, i64 %t715)
  %t717 = call i64 @CodeGen_write_line(i64 %t702, i64 %t716)
  %t718 = load i64, i64* %t674
  ret i64 %t718
  endif889:
  %t719 = load i64, i64* %t0
  %t720 = getelementptr [23 x i8], [23 x i8]* @.str.762, i64 0, i64 0
  %t721 = ptrtoint i8* %t720 to i64
  %t722 = call i64 @CodeGen_write_line(i64 %t719, i64 %t721)
  %t723 = getelementptr [2 x i8], [2 x i8]* @.str.763, i64 0, i64 0
  %t724 = ptrtoint i8* %t723 to i64
  ret i64 %t724
  endif882:
  %t725 = load i64, i64* %t4
  %t726 = getelementptr [5 x i8], [5 x i8]* @.str.764, i64 0, i64 0
  %t727 = ptrtoint i8* %t726 to i64
  %t728 = call i64 @kore_str_eq(i64 %t725, i64 %t727)
  %t729 = icmp ne i64 %t728, 0
  br i1 %t729, label %then903, label %endif905
  then903:
  %t730 = getelementptr [2 x i8], [2 x i8]* @.str.765, i64 0, i64 0
  %t731 = ptrtoint i8* %t730 to i64
  ret i64 %t731
  endif905:
  %t732 = load i64, i64* %t4
  %t733 = getelementptr [6 x i8], [6 x i8]* @.str.766, i64 0, i64 0
  %t734 = ptrtoint i8* %t733 to i64
  %t735 = call i64 @kore_str_eq(i64 %t732, i64 %t734)
  %t736 = icmp ne i64 %t735, 0
  br i1 %t736, label %then906, label %endif908
  then906:
  %t737 = load i64, i64* %t0
  %t738 = getelementptr [23 x i8], [23 x i8]* @.str.767, i64 0, i64 0
  %t739 = ptrtoint i8* %t738 to i64
  %t740 = call i64 @CodeGen_write_line(i64 %t737, i64 %t739)
  %t741 = getelementptr [2 x i8], [2 x i8]* @.str.768, i64 0, i64 0
  %t742 = ptrtoint i8* %t741 to i64
  ret i64 %t742
  endif908:
  %t743 = load i64, i64* %t4
  %t744 = getelementptr [6 x i8], [6 x i8]* @.str.769, i64 0, i64 0
  %t745 = ptrtoint i8* %t744 to i64
  %t746 = call i64 @kore_str_eq(i64 %t743, i64 %t745)
  %t747 = icmp ne i64 %t746, 0
  br i1 %t747, label %then909, label %endif911
  then909:
  %t748 = load i64, i64* %t1
  %t749 = call i64 @kore_variant_field(i64 %t748, i64 0)
  %t750 = alloca i64
  store i64 %t749, i64* %t750
  %t751 = load i64, i64* %t1
  %t752 = call i64 @kore_variant_field(i64 %t751, i64 1)
  %t753 = alloca i64
  store i64 %t752, i64* %t753
  %t754 = load i64, i64* %t0
  %t755 = load i64, i64* %t750
  %t756 = call i64 @CodeGen_gen_expr(i64 %t754, i64 %t755)
  %t757 = alloca i64
  store i64 %t756, i64* %t757
  %t758 = load i64, i64* %t0
  %t759 = load i64, i64* %t753
  %t760 = call i64 @CodeGen_gen_expr(i64 %t758, i64 %t759)
  %t761 = alloca i64
  store i64 %t760, i64* %t761
  %t762 = load i64, i64* %t0
  %t763 = call i64 @CodeGen_fresh_local(i64 %t762)
  %t764 = alloca i64
  store i64 %t763, i64* %t764
  %t765 = load i64, i64* %t0
  %t766 = load i64, i64* %t764
  %t767 = getelementptr [33 x i8], [33 x i8]* @.str.770, i64 0, i64 0
  %t768 = ptrtoint i8* %t767 to i64
  %t769 = call i64 @kore_str_concat(i64 %t766, i64 %t768)
  %t770 = load i64, i64* %t757
  %t771 = call i64 @kore_str_concat(i64 %t769, i64 %t770)
  %t772 = getelementptr [7 x i8], [7 x i8]* @.str.771, i64 0, i64 0
  %t773 = ptrtoint i8* %t772 to i64
  %t774 = call i64 @kore_str_concat(i64 %t771, i64 %t773)
  %t775 = load i64, i64* %t761
  %t776 = call i64 @kore_str_concat(i64 %t774, i64 %t775)
  %t777 = getelementptr [2 x i8], [2 x i8]* @.str.772, i64 0, i64 0
  %t778 = ptrtoint i8* %t777 to i64
  %t779 = call i64 @kore_str_concat(i64 %t776, i64 %t778)
  %t780 = call i64 @CodeGen_write_line(i64 %t765, i64 %t779)
  %t781 = load i64, i64* %t764
  ret i64 %t781
  endif911:
  %t782 = load i64, i64* %t4
  %t783 = getelementptr [6 x i8], [6 x i8]* @.str.773, i64 0, i64 0
  %t784 = ptrtoint i8* %t783 to i64
  %t785 = call i64 @kore_str_eq(i64 %t782, i64 %t784)
  %t786 = icmp ne i64 %t785, 0
  br i1 %t786, label %then912, label %endif914
  then912:
  %t787 = load i64, i64* %t1
  %t788 = call i64 @kore_variant_field(i64 %t787, i64 0)
  %t789 = alloca i64
  store i64 %t788, i64* %t789
  %t790 = load i64, i64* %t1
  %t791 = call i64 @kore_variant_field(i64 %t790, i64 1)
  %t792 = alloca i64
  store i64 %t791, i64* %t792
  %t793 = load i64, i64* %t0
  %t794 = load i64, i64* %t789
  %t795 = call i64 @CodeGen_gen_expr(i64 %t793, i64 %t794)
  %t796 = alloca i64
  store i64 %t795, i64* %t796
  %t797 = load i64, i64* %t0
  %t798 = inttoptr i64 %t797 to %CodeGen*
  %t799 = getelementptr %CodeGen, %CodeGen* %t798, i32 0, i32 9
  %t800 = load i64, i64* %t799
  %t801 = load i64, i64* %t792
  %t802 = call i64 @kore_contains_key(i64 %t800, i64 %t801)
  %t803 = icmp ne i64 %t802, 0
  br i1 %t803, label %then915, label %else916
  then915:
  %t804 = load i64, i64* %t0
  %t805 = inttoptr i64 %t804 to %CodeGen*
  %t806 = getelementptr %CodeGen, %CodeGen* %t805, i32 0, i32 9
  %t807 = load i64, i64* %t806
  %t808 = load i64, i64* %t792
  %t809 = call i64 @kore_map_get(i64 %t807, i64 %t808)
  %t810 = alloca i64
  store i64 %t809, i64* %t810
  %t811 = load i64, i64* %t0
  %t812 = inttoptr i64 %t811 to %CodeGen*
  %t813 = getelementptr %CodeGen, %CodeGen* %t812, i32 0, i32 8
  %t814 = load i64, i64* %t813
  %t815 = load i64, i64* %t810
  %t816 = call i64 @kore_map_get(i64 %t814, i64 %t815)
  %t817 = alloca i64
  store i64 %t816, i64* %t817
  %t818 = sub i64 0, 1
  %t819 = alloca i64
  store i64 %t818, i64* %t819
  ; for i in ...
  %t820 = load i64, i64* %t817
  %t821 = call i64 @kore_array_len(i64 %t820)
  %t822 = call i64 @kore_range(i64 0, i64 %t821)
  %t823 = call i64 @kore_array_len(i64 %t822)
  %t824 = alloca i64
  store i64 0, i64* %t824
  br label %for_cond918
  for_cond918:
  %t825 = load i64, i64* %t824
  %t826 = icmp slt i64 %t825, %t823
  br i1 %t826, label %for_body919, label %for_end921
  for_body919:
  %t827 = call i64 @kore_array_get(i64 %t822, i64 %t825)
  %t828 = alloca i64
  store i64 %t827, i64* %t828
  %t829 = load i64, i64* %t817
  %t830 = load i64, i64* %t828
  %t831 = call i64 @kore_array_get(i64 %t829, i64 %t830)
  %t832 = load i64, i64* %t792
  %t833 = call i64 @kore_str_eq(i64 %t831, i64 %t832)
  %t834 = icmp ne i64 %t833, 0
  br i1 %t834, label %then922, label %endif924
  then922:
  %t835 = load i64, i64* %t828
  store i64 %t835, i64* %t819
  br label %for_end921
  endif924:
  br label %for_update920
  for_update920:
  %t836 = load i64, i64* %t824
  %t837 = add i64 %t836, 1
  store i64 %t837, i64* %t824
  br label %for_cond918
  for_end921:
  %t838 = load i64, i64* %t0
  %t839 = getelementptr [25 x i8], [25 x i8]* @.str.774, i64 0, i64 0
  %t840 = ptrtoint i8* %t839 to i64
  %t841 = load i64, i64* %t792
  %t842 = call i64 @kore_str_concat(i64 %t840, i64 %t841)
  %t843 = getelementptr [5 x i8], [5 x i8]* @.str.775, i64 0, i64 0
  %t844 = ptrtoint i8* %t843 to i64
  %t845 = call i64 @kore_str_concat(i64 %t842, i64 %t844)
  %t846 = load i64, i64* %t810
  %t847 = call i64 @kore_str_concat(i64 %t845, i64 %t846)
  %t848 = getelementptr [11 x i8], [11 x i8]* @.str.776, i64 0, i64 0
  %t849 = ptrtoint i8* %t848 to i64
  %t850 = call i64 @kore_str_concat(i64 %t847, i64 %t849)
  %t851 = load i64, i64* %t819
  %t852 = call i64 @kore_to_string(i64 %t851)
  %t853 = call i64 @kore_str_concat(i64 %t850, i64 %t852)
  %t854 = call i64 @CodeGen_write_line(i64 %t838, i64 %t853)
  %t855 = load i64, i64* %t819
  %t856 = sub i64 0, 1
  %t858 = call i64 @kore_str_eq(i64 %t855, i64 %t856)
  %t859 = icmp eq i64 %t858, 0
  %t857 = zext i1 %t859 to i64
  %t860 = icmp ne i64 %t857, 0
  br i1 %t860, label %then925, label %else926
  then925:
  %t861 = load i64, i64* %t0
  %t862 = call i64 @CodeGen_fresh_local(i64 %t861)
  %t863 = alloca i64
  store i64 %t862, i64* %t863
  %t864 = load i64, i64* %t0
  %t865 = load i64, i64* %t863
  %t866 = getelementptr [17 x i8], [17 x i8]* @.str.777, i64 0, i64 0
  %t867 = ptrtoint i8* %t866 to i64
  %t868 = call i64 @kore_str_concat(i64 %t865, i64 %t867)
  %t869 = load i64, i64* %t796
  %t870 = call i64 @kore_str_concat(i64 %t868, i64 %t869)
  %t871 = getelementptr [6 x i8], [6 x i8]* @.str.778, i64 0, i64 0
  %t872 = ptrtoint i8* %t871 to i64
  %t873 = call i64 @kore_str_concat(i64 %t870, i64 %t872)
  %t874 = load i64, i64* %t810
  %t875 = call i64 @kore_str_concat(i64 %t873, i64 %t874)
  %t876 = getelementptr [2 x i8], [2 x i8]* @.str.779, i64 0, i64 0
  %t877 = ptrtoint i8* %t876 to i64
  %t878 = call i64 @kore_str_concat(i64 %t875, i64 %t877)
  %t879 = call i64 @CodeGen_write_line(i64 %t864, i64 %t878)
  %t880 = load i64, i64* %t0
  %t881 = call i64 @CodeGen_fresh_local(i64 %t880)
  %t882 = alloca i64
  store i64 %t881, i64* %t882
  %t883 = load i64, i64* %t0
  %t884 = load i64, i64* %t882
  %t885 = getelementptr [19 x i8], [19 x i8]* @.str.780, i64 0, i64 0
  %t886 = ptrtoint i8* %t885 to i64
  %t887 = call i64 @kore_str_concat(i64 %t884, i64 %t886)
  %t888 = load i64, i64* %t810
  %t889 = call i64 @kore_str_concat(i64 %t887, i64 %t888)
  %t890 = getelementptr [4 x i8], [4 x i8]* @.str.781, i64 0, i64 0
  %t891 = ptrtoint i8* %t890 to i64
  %t892 = call i64 @kore_str_concat(i64 %t889, i64 %t891)
  %t893 = load i64, i64* %t810
  %t894 = call i64 @kore_str_concat(i64 %t892, i64 %t893)
  %t895 = getelementptr [3 x i8], [3 x i8]* @.str.782, i64 0, i64 0
  %t896 = ptrtoint i8* %t895 to i64
  %t897 = call i64 @kore_str_concat(i64 %t894, i64 %t896)
  %t898 = load i64, i64* %t863
  %t899 = call i64 @kore_str_concat(i64 %t897, i64 %t898)
  %t900 = getelementptr [14 x i8], [14 x i8]* @.str.783, i64 0, i64 0
  %t901 = ptrtoint i8* %t900 to i64
  %t902 = call i64 @kore_str_concat(i64 %t899, i64 %t901)
  %t903 = load i64, i64* %t819
  %t904 = call i64 @kore_to_string(i64 %t903)
  %t905 = call i64 @kore_str_concat(i64 %t902, i64 %t904)
  %t906 = call i64 @CodeGen_write_line(i64 %t883, i64 %t905)
  %t907 = load i64, i64* %t0
  %t908 = call i64 @CodeGen_fresh_local(i64 %t907)
  %t909 = alloca i64
  store i64 %t908, i64* %t909
  %t910 = load i64, i64* %t0
  %t911 = load i64, i64* %t909
  %t912 = getelementptr [19 x i8], [19 x i8]* @.str.784, i64 0, i64 0
  %t913 = ptrtoint i8* %t912 to i64
  %t914 = call i64 @kore_str_concat(i64 %t911, i64 %t913)
  %t915 = load i64, i64* %t882
  %t916 = call i64 @kore_str_concat(i64 %t914, i64 %t915)
  %t917 = call i64 @CodeGen_write_line(i64 %t910, i64 %t916)
  %t918 = load i64, i64* %t909
  ret i64 %t918
  else926:
  %t919 = load i64, i64* %t0
  %t920 = getelementptr [16 x i8], [16 x i8]* @.str.785, i64 0, i64 0
  %t921 = ptrtoint i8* %t920 to i64
  %t922 = load i64, i64* %t792
  %t923 = call i64 @kore_str_concat(i64 %t921, i64 %t922)
  %t924 = getelementptr [22 x i8], [22 x i8]* @.str.786, i64 0, i64 0
  %t925 = ptrtoint i8* %t924 to i64
  %t926 = call i64 @kore_str_concat(i64 %t923, i64 %t925)
  %t927 = load i64, i64* %t810
  %t928 = call i64 @kore_str_concat(i64 %t926, i64 %t927)
  %t929 = call i64 @CodeGen_write_line(i64 %t919, i64 %t928)
  br label %endif927
  endif927:
  br label %endif917
  else916:
  %t930 = load i64, i64* %t0
  %t931 = getelementptr [24 x i8], [24 x i8]* @.str.787, i64 0, i64 0
  %t932 = ptrtoint i8* %t931 to i64
  %t933 = load i64, i64* %t792
  %t934 = call i64 @kore_str_concat(i64 %t932, i64 %t933)
  %t935 = call i64 @CodeGen_write_line(i64 %t930, i64 %t934)
  br label %endif917
  endif917:
  %t936 = getelementptr [2 x i8], [2 x i8]* @.str.788, i64 0, i64 0
  %t937 = ptrtoint i8* %t936 to i64
  ret i64 %t937
  endif914:
  %t938 = load i64, i64* %t4
  %t939 = getelementptr [7 x i8], [7 x i8]* @.str.789, i64 0, i64 0
  %t940 = ptrtoint i8* %t939 to i64
  %t941 = call i64 @kore_str_eq(i64 %t938, i64 %t940)
  %t942 = icmp ne i64 %t941, 0
  br i1 %t942, label %then928, label %endif930
  then928:
  %t943 = load i64, i64* %t1
  %t944 = call i64 @kore_variant_field(i64 %t943, i64 0)
  %t945 = alloca i64
  store i64 %t944, i64* %t945
  %t946 = load i64, i64* %t1
  %t947 = call i64 @kore_variant_field(i64 %t946, i64 1)
  %t948 = alloca i64
  store i64 %t947, i64* %t948
  %t949 = load i64, i64* %t0
  %t950 = inttoptr i64 %t949 to %CodeGen*
  %t951 = getelementptr %CodeGen, %CodeGen* %t950, i32 0, i32 8
  %t952 = load i64, i64* %t951
  %t953 = load i64, i64* %t945
  %t954 = call i64 @kore_contains_key(i64 %t952, i64 %t953)
  %t955 = icmp ne i64 %t954, 0
  br i1 %t955, label %then931, label %endif933
  then931:
  %t956 = load i64, i64* %t0
  %t957 = inttoptr i64 %t956 to %CodeGen*
  %t958 = getelementptr %CodeGen, %CodeGen* %t957, i32 0, i32 8
  %t959 = load i64, i64* %t958
  %t960 = load i64, i64* %t945
  %t961 = call i64 @kore_map_get(i64 %t959, i64 %t960)
  %t962 = alloca i64
  store i64 %t961, i64* %t962
  %t963 = load i64, i64* %t962
  %t964 = call i64 @kore_array_len(i64 %t963)
  %t965 = mul i64 %t964, 8
  %t966 = alloca i64
  store i64 %t965, i64* %t966
  %t967 = load i64, i64* %t966
  %t968 = call i64 @kore_str_eq(i64 %t967, i64 0)
  %t969 = icmp ne i64 %t968, 0
  br i1 %t969, label %then934, label %endif936
  then934:
  store i64 8, i64* %t966
  br label %endif936
  endif936:
  %t970 = load i64, i64* %t0
  %t971 = call i64 @CodeGen_fresh_local(i64 %t970)
  %t972 = alloca i64
  store i64 %t971, i64* %t972
  %t973 = load i64, i64* %t0
  %t974 = load i64, i64* %t972
  %t975 = getelementptr [25 x i8], [25 x i8]* @.str.790, i64 0, i64 0
  %t976 = ptrtoint i8* %t975 to i64
  %t977 = call i64 @kore_str_concat(i64 %t974, i64 %t976)
  %t978 = load i64, i64* %t966
  %t979 = call i64 @kore_to_string(i64 %t978)
  %t980 = call i64 @kore_str_concat(i64 %t977, i64 %t979)
  %t981 = getelementptr [2 x i8], [2 x i8]* @.str.791, i64 0, i64 0
  %t982 = ptrtoint i8* %t981 to i64
  %t983 = call i64 @kore_str_concat(i64 %t980, i64 %t982)
  %t984 = call i64 @CodeGen_write_line(i64 %t973, i64 %t983)
  %t985 = load i64, i64* %t0
  %t986 = call i64 @CodeGen_fresh_local(i64 %t985)
  %t987 = alloca i64
  store i64 %t986, i64* %t987
  %t988 = load i64, i64* %t0
  %t989 = load i64, i64* %t987
  %t990 = getelementptr [16 x i8], [16 x i8]* @.str.792, i64 0, i64 0
  %t991 = ptrtoint i8* %t990 to i64
  %t992 = call i64 @kore_str_concat(i64 %t989, i64 %t991)
  %t993 = load i64, i64* %t972
  %t994 = call i64 @kore_str_concat(i64 %t992, i64 %t993)
  %t995 = getelementptr [6 x i8], [6 x i8]* @.str.793, i64 0, i64 0
  %t996 = ptrtoint i8* %t995 to i64
  %t997 = call i64 @kore_str_concat(i64 %t994, i64 %t996)
  %t998 = load i64, i64* %t945
  %t999 = call i64 @kore_str_concat(i64 %t997, i64 %t998)
  %t1000 = getelementptr [2 x i8], [2 x i8]* @.str.794, i64 0, i64 0
  %t1001 = ptrtoint i8* %t1000 to i64
  %t1002 = call i64 @kore_str_concat(i64 %t999, i64 %t1001)
  %t1003 = call i64 @CodeGen_write_line(i64 %t988, i64 %t1002)
  ; for init in ...
  %t1004 = load i64, i64* %t948
  %t1005 = call i64 @kore_array_len(i64 %t1004)
  %t1006 = alloca i64
  store i64 0, i64* %t1006
  br label %for_cond937
  for_cond937:
  %t1007 = load i64, i64* %t1006
  %t1008 = icmp slt i64 %t1007, %t1005
  br i1 %t1008, label %for_body938, label %for_end940
  for_body938:
  %t1009 = call i64 @kore_array_get(i64 %t1004, i64 %t1007)
  %t1010 = alloca i64
  store i64 %t1009, i64* %t1010
  %t1011 = load i64, i64* %t1010
  %t1012 = inttoptr i64 %t1011 to %FieldInit*
  %t1013 = getelementptr %FieldInit, %FieldInit* %t1012, i32 0, i32 0
  %t1014 = load i64, i64* %t1013
  %t1015 = alloca i64
  store i64 %t1014, i64* %t1015
  %t1016 = load i64, i64* %t0
  %t1017 = load i64, i64* %t1010
  %t1018 = inttoptr i64 %t1017 to %FieldInit*
  %t1019 = getelementptr %FieldInit, %FieldInit* %t1018, i32 0, i32 1
  %t1020 = load i64, i64* %t1019
  %t1021 = call i64 @CodeGen_gen_expr(i64 %t1016, i64 %t1020)
  %t1022 = alloca i64
  store i64 %t1021, i64* %t1022
  %t1023 = sub i64 0, 1
  %t1024 = alloca i64
  store i64 %t1023, i64* %t1024
  ; for i in ...
  %t1025 = load i64, i64* %t962
  %t1026 = call i64 @kore_array_len(i64 %t1025)
  %t1027 = call i64 @kore_range(i64 0, i64 %t1026)
  %t1028 = call i64 @kore_array_len(i64 %t1027)
  %t1029 = alloca i64
  store i64 0, i64* %t1029
  br label %for_cond941
  for_cond941:
  %t1030 = load i64, i64* %t1029
  %t1031 = icmp slt i64 %t1030, %t1028
  br i1 %t1031, label %for_body942, label %for_end944
  for_body942:
  %t1032 = call i64 @kore_array_get(i64 %t1027, i64 %t1030)
  %t1033 = alloca i64
  store i64 %t1032, i64* %t1033
  %t1034 = load i64, i64* %t962
  %t1035 = load i64, i64* %t1033
  %t1036 = call i64 @kore_array_get(i64 %t1034, i64 %t1035)
  %t1037 = load i64, i64* %t1015
  %t1038 = call i64 @kore_str_eq(i64 %t1036, i64 %t1037)
  %t1039 = icmp ne i64 %t1038, 0
  br i1 %t1039, label %then945, label %endif947
  then945:
  %t1040 = load i64, i64* %t1033
  store i64 %t1040, i64* %t1024
  br label %for_end944
  endif947:
  br label %for_update943
  for_update943:
  %t1041 = load i64, i64* %t1029
  %t1042 = add i64 %t1041, 1
  store i64 %t1042, i64* %t1029
  br label %for_cond941
  for_end944:
  %t1043 = load i64, i64* %t1024
  %t1044 = sub i64 0, 1
  %t1046 = call i64 @kore_str_eq(i64 %t1043, i64 %t1044)
  %t1047 = icmp eq i64 %t1046, 0
  %t1045 = zext i1 %t1047 to i64
  %t1048 = icmp ne i64 %t1045, 0
  br i1 %t1048, label %then948, label %endif950
  then948:
  %t1049 = load i64, i64* %t0
  %t1050 = call i64 @CodeGen_fresh_local(i64 %t1049)
  %t1051 = alloca i64
  store i64 %t1050, i64* %t1051
  %t1052 = load i64, i64* %t0
  %t1053 = load i64, i64* %t1051
  %t1054 = getelementptr [19 x i8], [19 x i8]* @.str.795, i64 0, i64 0
  %t1055 = ptrtoint i8* %t1054 to i64
  %t1056 = call i64 @kore_str_concat(i64 %t1053, i64 %t1055)
  %t1057 = load i64, i64* %t945
  %t1058 = call i64 @kore_str_concat(i64 %t1056, i64 %t1057)
  %t1059 = getelementptr [4 x i8], [4 x i8]* @.str.796, i64 0, i64 0
  %t1060 = ptrtoint i8* %t1059 to i64
  %t1061 = call i64 @kore_str_concat(i64 %t1058, i64 %t1060)
  %t1062 = load i64, i64* %t945
  %t1063 = call i64 @kore_str_concat(i64 %t1061, i64 %t1062)
  %t1064 = getelementptr [3 x i8], [3 x i8]* @.str.797, i64 0, i64 0
  %t1065 = ptrtoint i8* %t1064 to i64
  %t1066 = call i64 @kore_str_concat(i64 %t1063, i64 %t1065)
  %t1067 = load i64, i64* %t987
  %t1068 = call i64 @kore_str_concat(i64 %t1066, i64 %t1067)
  %t1069 = getelementptr [14 x i8], [14 x i8]* @.str.798, i64 0, i64 0
  %t1070 = ptrtoint i8* %t1069 to i64
  %t1071 = call i64 @kore_str_concat(i64 %t1068, i64 %t1070)
  %t1072 = load i64, i64* %t1024
  %t1073 = call i64 @kore_to_string(i64 %t1072)
  %t1074 = call i64 @kore_str_concat(i64 %t1071, i64 %t1073)
  %t1075 = call i64 @CodeGen_write_line(i64 %t1052, i64 %t1074)
  %t1076 = load i64, i64* %t0
  %t1077 = getelementptr [11 x i8], [11 x i8]* @.str.799, i64 0, i64 0
  %t1078 = ptrtoint i8* %t1077 to i64
  %t1079 = load i64, i64* %t1022
  %t1080 = call i64 @kore_str_concat(i64 %t1078, i64 %t1079)
  %t1081 = getelementptr [8 x i8], [8 x i8]* @.str.800, i64 0, i64 0
  %t1082 = ptrtoint i8* %t1081 to i64
  %t1083 = call i64 @kore_str_concat(i64 %t1080, i64 %t1082)
  %t1084 = load i64, i64* %t1051
  %t1085 = call i64 @kore_str_concat(i64 %t1083, i64 %t1084)
  %t1086 = call i64 @CodeGen_write_line(i64 %t1076, i64 %t1085)
  br label %endif950
  endif950:
  br label %for_update939
  for_update939:
  %t1087 = load i64, i64* %t1006
  %t1088 = add i64 %t1087, 1
  store i64 %t1088, i64* %t1006
  br label %for_cond937
  for_end940:
  %t1089 = load i64, i64* %t0
  %t1090 = call i64 @CodeGen_fresh_local(i64 %t1089)
  %t1091 = alloca i64
  store i64 %t1090, i64* %t1091
  %t1092 = load i64, i64* %t0
  %t1093 = load i64, i64* %t1091
  %t1094 = getelementptr [14 x i8], [14 x i8]* @.str.801, i64 0, i64 0
  %t1095 = ptrtoint i8* %t1094 to i64
  %t1096 = call i64 @kore_str_concat(i64 %t1093, i64 %t1095)
  %t1097 = load i64, i64* %t945
  %t1098 = call i64 @kore_str_concat(i64 %t1096, i64 %t1097)
  %t1099 = getelementptr [3 x i8], [3 x i8]* @.str.802, i64 0, i64 0
  %t1100 = ptrtoint i8* %t1099 to i64
  %t1101 = call i64 @kore_str_concat(i64 %t1098, i64 %t1100)
  %t1102 = load i64, i64* %t987
  %t1103 = call i64 @kore_str_concat(i64 %t1101, i64 %t1102)
  %t1104 = getelementptr [8 x i8], [8 x i8]* @.str.803, i64 0, i64 0
  %t1105 = ptrtoint i8* %t1104 to i64
  %t1106 = call i64 @kore_str_concat(i64 %t1103, i64 %t1105)
  %t1107 = call i64 @CodeGen_write_line(i64 %t1092, i64 %t1106)
  %t1108 = load i64, i64* %t1091
  ret i64 %t1108
  endif933:
  %t1109 = getelementptr [2 x i8], [2 x i8]* @.str.804, i64 0, i64 0
  %t1110 = ptrtoint i8* %t1109 to i64
  ret i64 %t1110
  endif930:
  %t1111 = load i64, i64* %t4
  %t1112 = getelementptr [11 x i8], [11 x i8]* @.str.805, i64 0, i64 0
  %t1113 = ptrtoint i8* %t1112 to i64
  %t1114 = call i64 @kore_str_eq(i64 %t1111, i64 %t1113)
  %t1115 = icmp ne i64 %t1114, 0
  br i1 %t1115, label %then951, label %endif953
  then951:
  %t1116 = load i64, i64* %t1
  %t1117 = call i64 @kore_variant_field(i64 %t1116, i64 0)
  %t1118 = alloca i64
  store i64 %t1117, i64* %t1118
  %t1119 = load i64, i64* %t1
  %t1120 = call i64 @kore_variant_field(i64 %t1119, i64 1)
  %t1121 = alloca i64
  store i64 %t1120, i64* %t1121
  %t1122 = load i64, i64* %t1
  %t1123 = call i64 @kore_variant_field(i64 %t1122, i64 2)
  %t1124 = alloca i64
  store i64 %t1123, i64* %t1124
  %t1125 = load i64, i64* %t0
  %t1126 = load i64, i64* %t1118
  %t1127 = call i64 @CodeGen_gen_expr(i64 %t1125, i64 %t1126)
  %t1128 = alloca i64
  store i64 %t1127, i64* %t1128
  %t1129 = load i64, i64* %t0
  %t1130 = inttoptr i64 %t1129 to %CodeGen*
  %t1131 = getelementptr %CodeGen, %CodeGen* %t1130, i32 0, i32 10
  %t1132 = load i64, i64* %t1131
  %t1133 = load i64, i64* %t1121
  %t1134 = call i64 @kore_contains_key(i64 %t1132, i64 %t1133)
  %t1135 = icmp ne i64 %t1134, 0
  br i1 %t1135, label %then954, label %else955
  then954:
  %t1136 = load i64, i64* %t0
  %t1137 = inttoptr i64 %t1136 to %CodeGen*
  %t1138 = getelementptr %CodeGen, %CodeGen* %t1137, i32 0, i32 10
  %t1139 = load i64, i64* %t1138
  %t1140 = load i64, i64* %t1121
  %t1141 = call i64 @kore_map_get(i64 %t1139, i64 %t1140)
  %t1142 = alloca i64
  store i64 %t1141, i64* %t1142
  %t1143 = load i64, i64* %t1142
  %t1144 = getelementptr [2 x i8], [2 x i8]* @.str.806, i64 0, i64 0
  %t1145 = ptrtoint i8* %t1144 to i64
  %t1146 = call i64 @kore_str_concat(i64 %t1143, i64 %t1145)
  %t1147 = load i64, i64* %t1121
  %t1148 = call i64 @kore_str_concat(i64 %t1146, i64 %t1147)
  %t1149 = alloca i64
  store i64 %t1148, i64* %t1149
  %t1150 = call i64 @kore_array_new()
  %t1151 = alloca i64
  store i64 %t1150, i64* %t1151
  %t1152 = load i64, i64* %t1151
  %t1153 = load i64, i64* %t1128
  %t1154 = call i64 @kore_array_push(i64 %t1152, i64 %t1153)
  ; for arg in ...
  %t1155 = load i64, i64* %t1124
  %t1156 = call i64 @kore_array_len(i64 %t1155)
  %t1157 = alloca i64
  store i64 0, i64* %t1157
  br label %for_cond957
  for_cond957:
  %t1158 = load i64, i64* %t1157
  %t1159 = icmp slt i64 %t1158, %t1156
  br i1 %t1159, label %for_body958, label %for_end960
  for_body958:
  %t1160 = call i64 @kore_array_get(i64 %t1155, i64 %t1158)
  %t1161 = alloca i64
  store i64 %t1160, i64* %t1161
  %t1162 = load i64, i64* %t1151
  %t1163 = load i64, i64* %t0
  %t1164 = load i64, i64* %t1161
  %t1165 = call i64 @CodeGen_gen_expr(i64 %t1163, i64 %t1164)
  %t1166 = call i64 @kore_array_push(i64 %t1162, i64 %t1165)
  br label %for_update959
  for_update959:
  %t1167 = load i64, i64* %t1157
  %t1168 = add i64 %t1167, 1
  store i64 %t1168, i64* %t1157
  br label %for_cond957
  for_end960:
  %t1169 = getelementptr [1 x i8], [1 x i8]* @.str.807, i64 0, i64 0
  %t1170 = ptrtoint i8* %t1169 to i64
  %t1171 = alloca i64
  store i64 %t1170, i64* %t1171
  %t1172 = alloca i64
  store i64 1, i64* %t1172
  ; for reg in ...
  %t1173 = load i64, i64* %t1151
  %t1174 = call i64 @kore_array_len(i64 %t1173)
  %t1175 = alloca i64
  store i64 0, i64* %t1175
  br label %for_cond961
  for_cond961:
  %t1176 = load i64, i64* %t1175
  %t1177 = icmp slt i64 %t1176, %t1174
  br i1 %t1177, label %for_body962, label %for_end964
  for_body962:
  %t1178 = call i64 @kore_array_get(i64 %t1173, i64 %t1176)
  %t1179 = alloca i64
  store i64 %t1178, i64* %t1179
  %t1180 = load i64, i64* %t1172
  %t1182 = icmp eq i64 %t1180, 0
  %t1181 = zext i1 %t1182 to i64
  %t1183 = icmp ne i64 %t1181, 0
  br i1 %t1183, label %then965, label %endif967
  then965:
  %t1184 = load i64, i64* %t1171
  %t1185 = getelementptr [3 x i8], [3 x i8]* @.str.808, i64 0, i64 0
  %t1186 = ptrtoint i8* %t1185 to i64
  %t1187 = call i64 @kore_str_concat(i64 %t1184, i64 %t1186)
  store i64 %t1187, i64* %t1171
  br label %endif967
  endif967:
  store i64 0, i64* %t1172
  %t1188 = load i64, i64* %t1171
  %t1189 = getelementptr [5 x i8], [5 x i8]* @.str.809, i64 0, i64 0
  %t1190 = ptrtoint i8* %t1189 to i64
  %t1191 = call i64 @kore_str_concat(i64 %t1188, i64 %t1190)
  %t1192 = load i64, i64* %t1179
  %t1193 = call i64 @kore_str_concat(i64 %t1191, i64 %t1192)
  store i64 %t1193, i64* %t1171
  br label %for_update963
  for_update963:
  %t1194 = load i64, i64* %t1175
  %t1195 = add i64 %t1194, 1
  store i64 %t1195, i64* %t1175
  br label %for_cond961
  for_end964:
  %t1196 = load i64, i64* %t0
  %t1197 = call i64 @CodeGen_fresh_local(i64 %t1196)
  %t1198 = alloca i64
  store i64 %t1197, i64* %t1198
  %t1199 = load i64, i64* %t0
  %t1200 = load i64, i64* %t1198
  %t1201 = getelementptr [14 x i8], [14 x i8]* @.str.810, i64 0, i64 0
  %t1202 = ptrtoint i8* %t1201 to i64
  %t1203 = call i64 @kore_str_concat(i64 %t1200, i64 %t1202)
  %t1204 = load i64, i64* %t1149
  %t1205 = call i64 @kore_str_concat(i64 %t1203, i64 %t1204)
  %t1206 = getelementptr [2 x i8], [2 x i8]* @.str.811, i64 0, i64 0
  %t1207 = ptrtoint i8* %t1206 to i64
  %t1208 = call i64 @kore_str_concat(i64 %t1205, i64 %t1207)
  %t1209 = load i64, i64* %t1171
  %t1210 = call i64 @kore_str_concat(i64 %t1208, i64 %t1209)
  %t1211 = getelementptr [2 x i8], [2 x i8]* @.str.812, i64 0, i64 0
  %t1212 = ptrtoint i8* %t1211 to i64
  %t1213 = call i64 @kore_str_concat(i64 %t1210, i64 %t1212)
  %t1214 = call i64 @CodeGen_write_line(i64 %t1199, i64 %t1213)
  %t1215 = load i64, i64* %t1198
  ret i64 %t1215
  else955:
  %t1216 = load i64, i64* %t0
  %t1217 = getelementptr [25 x i8], [25 x i8]* @.str.813, i64 0, i64 0
  %t1218 = ptrtoint i8* %t1217 to i64
  %t1219 = load i64, i64* %t1121
  %t1220 = call i64 @kore_str_concat(i64 %t1218, i64 %t1219)
  %t1221 = call i64 @CodeGen_write_line(i64 %t1216, i64 %t1220)
  br label %endif956
  endif956:
  %t1222 = getelementptr [2 x i8], [2 x i8]* @.str.814, i64 0, i64 0
  %t1223 = ptrtoint i8* %t1222 to i64
  ret i64 %t1223
  endif953:
  %t1224 = load i64, i64* %t4
  %t1225 = getelementptr [12 x i8], [12 x i8]* @.str.815, i64 0, i64 0
  %t1226 = ptrtoint i8* %t1225 to i64
  %t1227 = call i64 @kore_str_eq(i64 %t1224, i64 %t1226)
  %t1228 = icmp ne i64 %t1227, 0
  br i1 %t1228, label %then968, label %endif970
  then968:
  %t1229 = load i64, i64* %t0
  %t1230 = getelementptr [22 x i8], [22 x i8]* @.str.816, i64 0, i64 0
  %t1231 = ptrtoint i8* %t1230 to i64
  %t1232 = call i64 @CodeGen_write_line(i64 %t1229, i64 %t1231)
  %t1233 = getelementptr [2 x i8], [2 x i8]* @.str.817, i64 0, i64 0
  %t1234 = ptrtoint i8* %t1233 to i64
  ret i64 %t1234
  endif970:
  %t1235 = load i64, i64* %t0
  %t1236 = getelementptr [17 x i8], [17 x i8]* @.str.818, i64 0, i64 0
  %t1237 = ptrtoint i8* %t1236 to i64
  %t1238 = load i64, i64* %t4
  %t1239 = call i64 @kore_str_concat(i64 %t1237, i64 %t1238)
  %t1240 = call i64 @CodeGen_write_line(i64 %t1235, i64 %t1239)
  %t1241 = getelementptr [2 x i8], [2 x i8]* @.str.819, i64 0, i64 0
  %t1242 = ptrtoint i8* %t1241 to i64
  ret i64 %t1242
}

; impl StringBuilder
define i64 @StringBuilder_new() {
  entry:
  ; struct literal: StringBuilder
  %t0 = call i8* @malloc(i64 8)
  %t1 = bitcast i8* %t0 to %StringBuilder*
  %t2 = call i64 @kore_array_new()
  %t3 = getelementptr %StringBuilder, %StringBuilder* %t1, i32 0, i32 0
  store i64 %t2, i64* %t3
  %t4 = ptrtoint %StringBuilder* %t1 to i64
  ret i64 %t4
}
define i64 @StringBuilder_push(i64 %self, i64 %text) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %text, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = inttoptr i64 %t2 to %StringBuilder*
  %t4 = getelementptr %StringBuilder, %StringBuilder* %t3, i32 0, i32 0
  %t5 = load i64, i64* %t4
  %t6 = load i64, i64* %t1
  %t7 = call i64 @kore_array_push(i64 %t5, i64 %t6)
  ret i64 0
}
define i64 @StringBuilder_push_line(i64 %self, i64 %text) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %text, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = inttoptr i64 %t2 to %StringBuilder*
  %t4 = getelementptr %StringBuilder, %StringBuilder* %t3, i32 0, i32 0
  %t5 = load i64, i64* %t4
  %t6 = load i64, i64* %t1
  %t7 = getelementptr [2 x i8], [2 x i8]* @.str.820, i64 0, i64 0
  %t8 = ptrtoint i8* %t7 to i64
  %t9 = call i64 @kore_str_concat(i64 %t6, i64 %t8)
  %t10 = call i64 @kore_array_push(i64 %t5, i64 %t9)
  ret i64 0
}
define i64 @StringBuilder_build(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %StringBuilder*
  %t3 = getelementptr %StringBuilder, %StringBuilder* %t2, i32 0, i32 0
  %t4 = load i64, i64* %t3
  %t5 = getelementptr [1 x i8], [1 x i8]* @.str.821, i64 0, i64 0
  %t6 = ptrtoint i8* %t5 to i64
  %t7 = call i64 @kore_join(i64 %t4, i64 %t6)
  ret i64 %t7
}

; impl RustGen
define i64 @RustGen_new() {
  entry:
  ; struct literal: RustGen
  %t0 = call i8* @malloc(i64 32)
  %t1 = bitcast i8* %t0 to %RustGen*
  %t2 = call i64 @StringBuilder_new()
  %t3 = getelementptr %RustGen, %RustGen* %t1, i32 0, i32 0
  store i64 %t2, i64* %t3
  %t4 = getelementptr %RustGen, %RustGen* %t1, i32 0, i32 1
  store i64 0, i64* %t4
  %t5 = call i64 @kore_array_new()
  %t6 = getelementptr %RustGen, %RustGen* %t1, i32 0, i32 2
  store i64 %t5, i64* %t6
  %t7 = call i64 @StringBuilder_new()
  %t8 = getelementptr %RustGen, %RustGen* %t1, i32 0, i32 3
  store i64 %t7, i64* %t8
  %t9 = ptrtoint %RustGen* %t1 to i64
  ret i64 %t9
}
define i64 @RustGen_push_indent(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %RustGen*
  %t3 = getelementptr %RustGen, %RustGen* %t2, i32 0, i32 1
  %t4 = load i64, i64* %t3
  %t5 = add i64 %t4, 1
  %t6 = load i64, i64* %t0
  %t7 = inttoptr i64 %t6 to %RustGen*
  %t8 = getelementptr %RustGen, %RustGen* %t7, i32 0, i32 1
  store i64 %t5, i64* %t8
  ret i64 0
}
define i64 @RustGen_pop_indent(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %RustGen*
  %t3 = getelementptr %RustGen, %RustGen* %t2, i32 0, i32 1
  %t4 = load i64, i64* %t3
  %t6 = icmp sgt i64 %t4, 0
  %t5 = zext i1 %t6 to i64
  %t7 = icmp ne i64 %t5, 0
  br i1 %t7, label %then971, label %endif973
  then971:
  %t8 = load i64, i64* %t0
  %t9 = inttoptr i64 %t8 to %RustGen*
  %t10 = getelementptr %RustGen, %RustGen* %t9, i32 0, i32 1
  %t11 = load i64, i64* %t10
  %t12 = sub i64 %t11, 1
  %t13 = load i64, i64* %t0
  %t14 = inttoptr i64 %t13 to %RustGen*
  %t15 = getelementptr %RustGen, %RustGen* %t14, i32 0, i32 1
  store i64 %t12, i64* %t15
  br label %endif973
  endif973:
  ret i64 0
}
define i64 @RustGen_indent_str(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = getelementptr [1 x i8], [1 x i8]* @.str.822, i64 0, i64 0
  %t2 = ptrtoint i8* %t1 to i64
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  ; for i in ...
  %t4 = load i64, i64* %t0
  %t5 = inttoptr i64 %t4 to %RustGen*
  %t6 = getelementptr %RustGen, %RustGen* %t5, i32 0, i32 1
  %t7 = load i64, i64* %t6
  %t8 = call i64 @kore_range(i64 0, i64 %t7)
  %t9 = call i64 @kore_array_len(i64 %t8)
  %t10 = alloca i64
  store i64 0, i64* %t10
  br label %for_cond974
  for_cond974:
  %t11 = load i64, i64* %t10
  %t12 = icmp slt i64 %t11, %t9
  br i1 %t12, label %for_body975, label %for_end977
  for_body975:
  %t13 = call i64 @kore_array_get(i64 %t8, i64 %t11)
  %t14 = alloca i64
  store i64 %t13, i64* %t14
  %t15 = load i64, i64* %t3
  %t16 = getelementptr [5 x i8], [5 x i8]* @.str.823, i64 0, i64 0
  %t17 = ptrtoint i8* %t16 to i64
  %t18 = call i64 @kore_str_concat(i64 %t15, i64 %t17)
  store i64 %t18, i64* %t3
  br label %for_update976
  for_update976:
  %t19 = load i64, i64* %t10
  %t20 = add i64 %t19, 1
  store i64 %t20, i64* %t10
  br label %for_cond974
  for_end977:
  %t21 = load i64, i64* %t3
  ret i64 %t21
}
define i64 @RustGen_write_line(i64 %self, i64 %line) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %line, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = inttoptr i64 %t2 to %RustGen*
  %t4 = getelementptr %RustGen, %RustGen* %t3, i32 0, i32 0
  %t5 = load i64, i64* %t4
  %t6 = load i64, i64* %t0
  %t7 = call i64 @RustGen_indent_str(i64 %t6)
  %t8 = call i64 @StringBuilder_push(i64 %t5, i64 %t7)
  %t9 = load i64, i64* %t0
  %t10 = inttoptr i64 %t9 to %RustGen*
  %t11 = getelementptr %RustGen, %RustGen* %t10, i32 0, i32 0
  %t12 = load i64, i64* %t11
  %t13 = load i64, i64* %t1
  %t14 = call i64 @StringBuilder_push_line(i64 %t12, i64 %t13)
  ret i64 0
}
define i64 @RustGen_write_raw(i64 %self, i64 %text) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %text, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = inttoptr i64 %t2 to %RustGen*
  %t4 = getelementptr %RustGen, %RustGen* %t3, i32 0, i32 0
  %t5 = load i64, i64* %t4
  %t6 = load i64, i64* %t1
  %t7 = call i64 @StringBuilder_push(i64 %t5, i64 %t6)
  ret i64 0
}
define i64 @RustGen_write_blank(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %RustGen*
  %t3 = getelementptr %RustGen, %RustGen* %t2, i32 0, i32 0
  %t4 = load i64, i64* %t3
  %t5 = getelementptr [1 x i8], [1 x i8]* @.str.824, i64 0, i64 0
  %t6 = ptrtoint i8* %t5 to i64
  %t7 = call i64 @StringBuilder_push_line(i64 %t4, i64 %t6)
  ret i64 0
}
define i64 @RustGen_gen_program(i64 %self, i64 %program) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %program, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = getelementptr [50 x i8], [50 x i8]* @.str.825, i64 0, i64 0
  %t4 = ptrtoint i8* %t3 to i64
  %t5 = call i64 @RustGen_write_line(i64 %t2, i64 %t4)
  %t6 = load i64, i64* %t0
  %t7 = getelementptr [44 x i8], [44 x i8]* @.str.826, i64 0, i64 0
  %t8 = ptrtoint i8* %t7 to i64
  %t9 = call i64 @RustGen_write_line(i64 %t6, i64 %t8)
  %t10 = load i64, i64* %t0
  %t11 = call i64 @RustGen_write_blank(i64 %t10)
  %t12 = load i64, i64* %t0
  %t13 = getelementptr [28 x i8], [28 x i8]* @.str.827, i64 0, i64 0
  %t14 = ptrtoint i8* %t13 to i64
  %t15 = call i64 @RustGen_write_line(i64 %t12, i64 %t14)
  %t16 = load i64, i64* %t0
  %t17 = getelementptr [22 x i8], [22 x i8]* @.str.828, i64 0, i64 0
  %t18 = ptrtoint i8* %t17 to i64
  %t19 = call i64 @RustGen_write_line(i64 %t16, i64 %t18)
  %t20 = load i64, i64* %t0
  %t21 = getelementptr [21 x i8], [21 x i8]* @.str.829, i64 0, i64 0
  %t22 = ptrtoint i8* %t21 to i64
  %t23 = call i64 @RustGen_write_line(i64 %t20, i64 %t22)
  %t24 = load i64, i64* %t0
  %t25 = getelementptr [25 x i8], [25 x i8]* @.str.830, i64 0, i64 0
  %t26 = ptrtoint i8* %t25 to i64
  %t27 = call i64 @RustGen_write_line(i64 %t24, i64 %t26)
  %t28 = load i64, i64* %t0
  %t29 = call i64 @RustGen_write_blank(i64 %t28)
  %t30 = load i64, i64* %t0
  %t31 = getelementptr [31 x i8], [31 x i8]* @.str.831, i64 0, i64 0
  %t32 = ptrtoint i8* %t31 to i64
  %t33 = call i64 @RustGen_write_line(i64 %t30, i64 %t32)
  %t34 = load i64, i64* %t0
  %t35 = getelementptr [17 x i8], [17 x i8]* @.str.832, i64 0, i64 0
  %t36 = ptrtoint i8* %t35 to i64
  %t37 = call i64 @RustGen_write_line(i64 %t34, i64 %t36)
  %t38 = load i64, i64* %t0
  %t39 = getelementptr [24 x i8], [24 x i8]* @.str.833, i64 0, i64 0
  %t40 = ptrtoint i8* %t39 to i64
  %t41 = call i64 @RustGen_write_line(i64 %t38, i64 %t40)
  %t42 = load i64, i64* %t0
  %t43 = call i64 @RustGen_write_blank(i64 %t42)
  ; for item in ...
  %t44 = load i64, i64* %t1
  %t45 = inttoptr i64 %t44 to %Program*
  %t46 = getelementptr %Program, %Program* %t45, i32 0, i32 0
  %t47 = load i64, i64* %t46
  %t48 = call i64 @kore_array_len(i64 %t47)
  %t49 = alloca i64
  store i64 0, i64* %t49
  br label %for_cond978
  for_cond978:
  %t50 = load i64, i64* %t49
  %t51 = icmp slt i64 %t50, %t48
  br i1 %t51, label %for_body979, label %for_end981
  for_body979:
  %t52 = call i64 @kore_array_get(i64 %t47, i64 %t50)
  %t53 = alloca i64
  store i64 %t52, i64* %t53
  %t54 = load i64, i64* %t0
  %t55 = load i64, i64* %t53
  %t56 = call i64 @RustGen_gen_item(i64 %t54, i64 %t55)
  %t57 = load i64, i64* %t0
  %t58 = call i64 @RustGen_write_blank(i64 %t57)
  br label %for_update980
  for_update980:
  %t59 = load i64, i64* %t49
  %t60 = add i64 %t59, 1
  store i64 %t60, i64* %t49
  br label %for_cond978
  for_end981:
  %t61 = load i64, i64* %t0
  %t62 = inttoptr i64 %t61 to %RustGen*
  %t63 = getelementptr %RustGen, %RustGen* %t62, i32 0, i32 3
  %t64 = load i64, i64* %t63
  %t65 = call i64 @StringBuilder_build(i64 %t64)
  %t66 = alloca i64
  store i64 %t65, i64* %t66
  %t67 = load i64, i64* %t66
  %t68 = call i64 @kore_array_len(i64 %t67)
  %t70 = icmp sgt i64 %t68, 0
  %t69 = zext i1 %t70 to i64
  %t71 = icmp ne i64 %t69, 0
  br i1 %t71, label %then982, label %endif984
  then982:
  %t72 = load i64, i64* %t0
  %t73 = inttoptr i64 %t72 to %RustGen*
  %t74 = getelementptr %RustGen, %RustGen* %t73, i32 0, i32 0
  %t75 = load i64, i64* %t74
  %t76 = load i64, i64* %t66
  %t77 = call i64 @StringBuilder_push(i64 %t75, i64 %t76)
  br label %endif984
  endif984:
  %t78 = load i64, i64* %t0
  %t79 = inttoptr i64 %t78 to %RustGen*
  %t80 = getelementptr %RustGen, %RustGen* %t79, i32 0, i32 0
  %t81 = load i64, i64* %t80
  %t82 = call i64 @StringBuilder_build(i64 %t81)
  ret i64 %t82
}
define i64 @RustGen_gen_item(i64 %self, i64 %item) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %item, i64* %t1
  ; match
  %t2 = load i64, i64* %t1
  %t3 = inttoptr i64 %t2 to { i64, i8* }*
  %t4 = getelementptr { i64, i8* }, { i64, i8* }* %t3, i32 0, i32 0
  %t5 = load i64, i64* %t4
  %t6 = icmp eq i64 %t5, 0
  br i1 %t6, label %match_body987, label %match_next986
  match_body987:
  %t7 = getelementptr { i64, i8* }, { i64, i8* }* %t3, i32 0, i32 1
  %t8 = load i8*, i8** %t7
  %t9 = ptrtoint i8* %t8 to i64
  %t10 = inttoptr i64 %t9 to i64*
  %t11 = getelementptr i64, i64* %t10, i32 0
  %t12 = load i64, i64* %t11
  %t13 = alloca i64
  store i64 %t12, i64* %t13
  %t14 = load i64, i64* %t0
  %t15 = load i64, i64* %t13
  %t16 = call i64 @RustGen_gen_function(i64 %t14, i64 %t15)
  br label %match_end985
  match_next986:
  %t17 = inttoptr i64 %t2 to { i64, i8* }*
  %t18 = getelementptr { i64, i8* }, { i64, i8* }* %t17, i32 0, i32 0
  %t19 = load i64, i64* %t18
  %t20 = icmp eq i64 %t19, 1
  br i1 %t20, label %match_body989, label %match_next988
  match_body989:
  %t21 = getelementptr { i64, i8* }, { i64, i8* }* %t17, i32 0, i32 1
  %t22 = load i8*, i8** %t21
  %t23 = ptrtoint i8* %t22 to i64
  %t24 = inttoptr i64 %t23 to i64*
  %t25 = getelementptr i64, i64* %t24, i32 0
  %t26 = load i64, i64* %t25
  %t27 = alloca i64
  store i64 %t26, i64* %t27
  %t28 = load i64, i64* %t0
  %t29 = load i64, i64* %t27
  %t30 = call i64 @RustGen_gen_struct(i64 %t28, i64 %t29)
  br label %match_end985
  match_next988:
  %t31 = inttoptr i64 %t2 to { i64, i8* }*
  %t32 = getelementptr { i64, i8* }, { i64, i8* }* %t31, i32 0, i32 0
  %t33 = load i64, i64* %t32
  %t34 = icmp eq i64 %t33, 2
  br i1 %t34, label %match_body991, label %match_next990
  match_body991:
  %t35 = getelementptr { i64, i8* }, { i64, i8* }* %t31, i32 0, i32 1
  %t36 = load i8*, i8** %t35
  %t37 = ptrtoint i8* %t36 to i64
  %t38 = inttoptr i64 %t37 to i64*
  %t39 = getelementptr i64, i64* %t38, i32 0
  %t40 = load i64, i64* %t39
  %t41 = alloca i64
  store i64 %t40, i64* %t41
  %t42 = load i64, i64* %t0
  %t43 = load i64, i64* %t41
  %t44 = call i64 @RustGen_gen_enum(i64 %t42, i64 %t43)
  br label %match_end985
  match_next990:
  %t45 = inttoptr i64 %t2 to { i64, i8* }*
  %t46 = getelementptr { i64, i8* }, { i64, i8* }* %t45, i32 0, i32 0
  %t47 = load i64, i64* %t46
  %t48 = icmp eq i64 %t47, 3
  br i1 %t48, label %match_body993, label %match_next992
  match_body993:
  %t49 = getelementptr { i64, i8* }, { i64, i8* }* %t45, i32 0, i32 1
  %t50 = load i8*, i8** %t49
  %t51 = ptrtoint i8* %t50 to i64
  %t52 = inttoptr i64 %t51 to i64*
  %t53 = getelementptr i64, i64* %t52, i32 0
  %t54 = load i64, i64* %t53
  %t55 = alloca i64
  store i64 %t54, i64* %t55
  %t56 = load i64, i64* %t0
  %t57 = load i64, i64* %t55
  %t58 = call i64 @RustGen_gen_impl(i64 %t56, i64 %t57)
  br label %match_end985
  match_next992:
  %t59 = inttoptr i64 %t2 to { i64, i8* }*
  %t60 = getelementptr { i64, i8* }, { i64, i8* }* %t59, i32 0, i32 0
  %t61 = load i64, i64* %t60
  %t62 = icmp eq i64 %t61, 4
  br i1 %t62, label %match_body995, label %match_next994
  match_body995:
  %t63 = getelementptr { i64, i8* }, { i64, i8* }* %t59, i32 0, i32 1
  %t64 = load i8*, i8** %t63
  %t65 = ptrtoint i8* %t64 to i64
  %t66 = inttoptr i64 %t65 to i64*
  %t67 = getelementptr i64, i64* %t66, i32 0
  %t68 = load i64, i64* %t67
  %t69 = alloca i64
  store i64 %t68, i64* %t69
  %t70 = load i64, i64* %t0
  %t71 = load i64, i64* %t69
  %t72 = call i64 @RustGen_gen_use(i64 %t70, i64 %t71)
  br label %match_end985
  match_next994:
  br label %match_end985
  match_end985:
  ret i64 0
}
define i64 @RustGen_gen_function(i64 %self, i64 %fn_def) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %fn_def, i64* %t1
  %t2 = getelementptr [1 x i8], [1 x i8]* @.str.834, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = alloca i64
  store i64 %t3, i64* %t4
  %t5 = load i64, i64* %t1
  %t6 = inttoptr i64 %t5 to %FnDef*
  %t7 = getelementptr %FnDef, %FnDef* %t6, i32 0, i32 4
  %t8 = load i64, i64* %t7
  %t9 = icmp ne i64 %t8, 0
  br i1 %t9, label %then996, label %endif998
  then996:
  %t10 = getelementptr [5 x i8], [5 x i8]* @.str.835, i64 0, i64 0
  %t11 = ptrtoint i8* %t10 to i64
  store i64 %t11, i64* %t4
  br label %endif998
  endif998:
  %t12 = getelementptr [1 x i8], [1 x i8]* @.str.836, i64 0, i64 0
  %t13 = ptrtoint i8* %t12 to i64
  %t14 = alloca i64
  store i64 %t13, i64* %t14
  %t15 = load i64, i64* %t1
  %t16 = inttoptr i64 %t15 to %FnDef*
  %t17 = getelementptr %FnDef, %FnDef* %t16, i32 0, i32 5
  %t18 = load i64, i64* %t17
  %t19 = icmp ne i64 %t18, 0
  br i1 %t19, label %then999, label %endif1001
  then999:
  %t20 = getelementptr [7 x i8], [7 x i8]* @.str.837, i64 0, i64 0
  %t21 = ptrtoint i8* %t20 to i64
  store i64 %t21, i64* %t14
  br label %endif1001
  endif1001:
  %t22 = load i64, i64* %t0
  %t23 = load i64, i64* %t1
  %t24 = inttoptr i64 %t23 to %FnDef*
  %t25 = getelementptr %FnDef, %FnDef* %t24, i32 0, i32 1
  %t26 = load i64, i64* %t25
  %t27 = call i64 @RustGen_gen_params(i64 %t22, i64 %t26)
  %t28 = alloca i64
  store i64 %t27, i64* %t28
  %t29 = getelementptr [1 x i8], [1 x i8]* @.str.838, i64 0, i64 0
  %t30 = ptrtoint i8* %t29 to i64
  %t31 = alloca i64
  store i64 %t30, i64* %t31
  %t32 = load i64, i64* %t1
  %t33 = inttoptr i64 %t32 to %FnDef*
  %t34 = getelementptr %FnDef, %FnDef* %t33, i32 0, i32 2
  %t35 = load i64, i64* %t34
  %t37 = call i64 @kore_str_eq(i64 %t35, i64 0)
  %t38 = icmp eq i64 %t37, 0
  %t36 = zext i1 %t38 to i64
  %t39 = icmp ne i64 %t36, 0
  br i1 %t39, label %then1002, label %else1003
  then1002:
  %t40 = getelementptr [5 x i8], [5 x i8]* @.str.839, i64 0, i64 0
  %t41 = ptrtoint i8* %t40 to i64
  %t42 = load i64, i64* %t0
  %t43 = load i64, i64* %t1
  %t44 = inttoptr i64 %t43 to %FnDef*
  %t45 = getelementptr %FnDef, %FnDef* %t44, i32 0, i32 2
  %t46 = load i64, i64* %t45
  %t47 = call i64 @RustGen_map_type(i64 %t42, i64 %t46)
  %t48 = call i64 @kore_str_concat(i64 %t41, i64 %t47)
  store i64 %t48, i64* %t31
  br label %endif1004
  else1003:
  %t49 = load i64, i64* %t1
  %t50 = inttoptr i64 %t49 to %FnDef*
  %t51 = getelementptr %FnDef, %FnDef* %t50, i32 0, i32 0
  %t52 = load i64, i64* %t51
  %t53 = getelementptr [5 x i8], [5 x i8]* @.str.840, i64 0, i64 0
  %t54 = ptrtoint i8* %t53 to i64
  %t56 = call i64 @kore_str_eq(i64 %t52, i64 %t54)
  %t57 = icmp eq i64 %t56, 0
  %t55 = zext i1 %t57 to i64
  %t58 = icmp ne i64 %t55, 0
  br i1 %t58, label %then1005, label %endif1007
  then1005:
  %t59 = getelementptr [1 x i8], [1 x i8]* @.str.841, i64 0, i64 0
  %t60 = ptrtoint i8* %t59 to i64
  store i64 %t60, i64* %t31
  br label %endif1007
  endif1007:
  br label %endif1004
  endif1004:
  %t61 = load i64, i64* %t0
  %t62 = load i64, i64* %t4
  %t63 = load i64, i64* %t14
  %t64 = call i64 @kore_str_concat(i64 %t62, i64 %t63)
  %t65 = getelementptr [4 x i8], [4 x i8]* @.str.842, i64 0, i64 0
  %t66 = ptrtoint i8* %t65 to i64
  %t67 = call i64 @kore_str_concat(i64 %t64, i64 %t66)
  %t68 = load i64, i64* %t1
  %t69 = inttoptr i64 %t68 to %FnDef*
  %t70 = getelementptr %FnDef, %FnDef* %t69, i32 0, i32 0
  %t71 = load i64, i64* %t70
  %t72 = call i64 @kore_str_concat(i64 %t67, i64 %t71)
  %t73 = getelementptr [2 x i8], [2 x i8]* @.str.843, i64 0, i64 0
  %t74 = ptrtoint i8* %t73 to i64
  %t75 = call i64 @kore_str_concat(i64 %t72, i64 %t74)
  %t76 = load i64, i64* %t28
  %t77 = call i64 @kore_str_concat(i64 %t75, i64 %t76)
  %t78 = getelementptr [2 x i8], [2 x i8]* @.str.844, i64 0, i64 0
  %t79 = ptrtoint i8* %t78 to i64
  %t80 = call i64 @kore_str_concat(i64 %t77, i64 %t79)
  %t81 = load i64, i64* %t31
  %t82 = call i64 @kore_str_concat(i64 %t80, i64 %t81)
  %t83 = getelementptr [3 x i8], [3 x i8]* @.str.845, i64 0, i64 0
  %t84 = ptrtoint i8* %t83 to i64
  %t85 = call i64 @kore_str_concat(i64 %t82, i64 %t84)
  %t86 = call i64 @RustGen_write_line(i64 %t61, i64 %t85)
  %t87 = load i64, i64* %t0
  %t88 = call i64 @RustGen_push_indent(i64 %t87)
  ; for stmt in ...
  %t89 = load i64, i64* %t1
  %t90 = inttoptr i64 %t89 to %FnDef*
  %t91 = getelementptr %FnDef, %FnDef* %t90, i32 0, i32 3
  %t92 = load i64, i64* %t91
  %t93 = call i64 @kore_array_len(i64 %t92)
  %t94 = alloca i64
  store i64 0, i64* %t94
  br label %for_cond1008
  for_cond1008:
  %t95 = load i64, i64* %t94
  %t96 = icmp slt i64 %t95, %t93
  br i1 %t96, label %for_body1009, label %for_end1011
  for_body1009:
  %t97 = call i64 @kore_array_get(i64 %t92, i64 %t95)
  %t98 = alloca i64
  store i64 %t97, i64* %t98
  %t99 = load i64, i64* %t0
  %t100 = load i64, i64* %t98
  %t101 = call i64 @RustGen_gen_stmt(i64 %t99, i64 %t100)
  br label %for_update1010
  for_update1010:
  %t102 = load i64, i64* %t94
  %t103 = add i64 %t102, 1
  store i64 %t103, i64* %t94
  br label %for_cond1008
  for_end1011:
  %t104 = load i64, i64* %t0
  %t105 = call i64 @RustGen_pop_indent(i64 %t104)
  %t106 = load i64, i64* %t0
  %t107 = getelementptr [2 x i8], [2 x i8]* @.str.846, i64 0, i64 0
  %t108 = ptrtoint i8* %t107 to i64
  %t109 = call i64 @RustGen_write_line(i64 %t106, i64 %t108)
  ret i64 0
}
define i64 @RustGen_gen_params(i64 %self, i64 %params) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %params, i64* %t1
  %t2 = call i64 @kore_array_new()
  %t3 = alloca i64
  store i64 %t2, i64* %t3
  ; for param in ...
  %t4 = load i64, i64* %t1
  %t5 = call i64 @kore_array_len(i64 %t4)
  %t6 = alloca i64
  store i64 0, i64* %t6
  br label %for_cond1012
  for_cond1012:
  %t7 = load i64, i64* %t6
  %t8 = icmp slt i64 %t7, %t5
  br i1 %t8, label %for_body1013, label %for_end1015
  for_body1013:
  %t9 = call i64 @kore_array_get(i64 %t4, i64 %t7)
  %t10 = alloca i64
  store i64 %t9, i64* %t10
  %t11 = getelementptr [4 x i8], [4 x i8]* @.str.847, i64 0, i64 0
  %t12 = ptrtoint i8* %t11 to i64
  %t13 = alloca i64
  store i64 %t12, i64* %t13
  %t14 = load i64, i64* %t10
  %t15 = inttoptr i64 %t14 to %Field*
  %t16 = getelementptr %Field, %Field* %t15, i32 0, i32 1
  %t17 = load i64, i64* %t16
  %t19 = call i64 @kore_str_eq(i64 %t17, i64 0)
  %t20 = icmp eq i64 %t19, 0
  %t18 = zext i1 %t20 to i64
  %t21 = icmp ne i64 %t18, 0
  br i1 %t21, label %then1016, label %endif1018
  then1016:
  %t22 = load i64, i64* %t0
  %t23 = load i64, i64* %t10
  %t24 = inttoptr i64 %t23 to %Field*
  %t25 = getelementptr %Field, %Field* %t24, i32 0, i32 1
  %t26 = load i64, i64* %t25
  %t27 = call i64 @RustGen_map_type(i64 %t22, i64 %t26)
  store i64 %t27, i64* %t13
  br label %endif1018
  endif1018:
  %t28 = load i64, i64* %t3
  %t29 = load i64, i64* %t10
  %t30 = inttoptr i64 %t29 to %FieldInit*
  %t31 = getelementptr %FieldInit, %FieldInit* %t30, i32 0, i32 0
  %t32 = load i64, i64* %t31
  %t33 = getelementptr [3 x i8], [3 x i8]* @.str.848, i64 0, i64 0
  %t34 = ptrtoint i8* %t33 to i64
  %t35 = call i64 @kore_str_concat(i64 %t32, i64 %t34)
  %t36 = load i64, i64* %t13
  %t37 = call i64 @kore_str_concat(i64 %t35, i64 %t36)
  %t38 = call i64 @kore_array_push(i64 %t28, i64 %t37)
  br label %for_update1014
  for_update1014:
  %t39 = load i64, i64* %t6
  %t40 = add i64 %t39, 1
  store i64 %t40, i64* %t6
  br label %for_cond1012
  for_end1015:
  %t41 = load i64, i64* %t3
  %t42 = getelementptr [3 x i8], [3 x i8]* @.str.849, i64 0, i64 0
  %t43 = ptrtoint i8* %t42 to i64
  %t44 = call i64 @kore_join(i64 %t41, i64 %t43)
  ret i64 %t44
}
define i64 @RustGen_gen_struct(i64 %self, i64 %struct_def) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %struct_def, i64* %t1
  %t2 = getelementptr [1 x i8], [1 x i8]* @.str.850, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = alloca i64
  store i64 %t3, i64* %t4
  %t5 = load i64, i64* %t1
  %t6 = inttoptr i64 %t5 to %StructDef*
  %t7 = getelementptr %StructDef, %StructDef* %t6, i32 0, i32 2
  %t8 = load i64, i64* %t7
  %t9 = icmp ne i64 %t8, 0
  br i1 %t9, label %then1019, label %endif1021
  then1019:
  %t10 = getelementptr [5 x i8], [5 x i8]* @.str.851, i64 0, i64 0
  %t11 = ptrtoint i8* %t10 to i64
  store i64 %t11, i64* %t4
  br label %endif1021
  endif1021:
  %t12 = load i64, i64* %t0
  %t13 = getelementptr [24 x i8], [24 x i8]* @.str.852, i64 0, i64 0
  %t14 = ptrtoint i8* %t13 to i64
  %t15 = call i64 @RustGen_write_line(i64 %t12, i64 %t14)
  %t16 = load i64, i64* %t0
  %t17 = load i64, i64* %t4
  %t18 = getelementptr [8 x i8], [8 x i8]* @.str.853, i64 0, i64 0
  %t19 = ptrtoint i8* %t18 to i64
  %t20 = call i64 @kore_str_concat(i64 %t17, i64 %t19)
  %t21 = load i64, i64* %t1
  %t22 = inttoptr i64 %t21 to %StructDef*
  %t23 = getelementptr %StructDef, %StructDef* %t22, i32 0, i32 0
  %t24 = load i64, i64* %t23
  %t25 = call i64 @kore_str_concat(i64 %t20, i64 %t24)
  %t26 = getelementptr [3 x i8], [3 x i8]* @.str.854, i64 0, i64 0
  %t27 = ptrtoint i8* %t26 to i64
  %t28 = call i64 @kore_str_concat(i64 %t25, i64 %t27)
  %t29 = call i64 @RustGen_write_line(i64 %t16, i64 %t28)
  %t30 = load i64, i64* %t0
  %t31 = call i64 @RustGen_push_indent(i64 %t30)
  ; for field in ...
  %t32 = load i64, i64* %t1
  %t33 = inttoptr i64 %t32 to %StructDef*
  %t34 = getelementptr %StructDef, %StructDef* %t33, i32 0, i32 1
  %t35 = load i64, i64* %t34
  %t36 = call i64 @kore_array_len(i64 %t35)
  %t37 = alloca i64
  store i64 0, i64* %t37
  br label %for_cond1022
  for_cond1022:
  %t38 = load i64, i64* %t37
  %t39 = icmp slt i64 %t38, %t36
  br i1 %t39, label %for_body1023, label %for_end1025
  for_body1023:
  %t40 = call i64 @kore_array_get(i64 %t35, i64 %t38)
  %t41 = alloca i64
  store i64 %t40, i64* %t41
  %t42 = load i64, i64* %t0
  %t43 = getelementptr [5 x i8], [5 x i8]* @.str.855, i64 0, i64 0
  %t44 = ptrtoint i8* %t43 to i64
  %t45 = load i64, i64* %t41
  %t46 = inttoptr i64 %t45 to %FieldInit*
  %t47 = getelementptr %FieldInit, %FieldInit* %t46, i32 0, i32 0
  %t48 = load i64, i64* %t47
  %t49 = call i64 @kore_str_concat(i64 %t44, i64 %t48)
  %t50 = getelementptr [3 x i8], [3 x i8]* @.str.856, i64 0, i64 0
  %t51 = ptrtoint i8* %t50 to i64
  %t52 = call i64 @kore_str_concat(i64 %t49, i64 %t51)
  %t53 = load i64, i64* %t0
  %t54 = load i64, i64* %t41
  %t55 = inttoptr i64 %t54 to %Field*
  %t56 = getelementptr %Field, %Field* %t55, i32 0, i32 1
  %t57 = load i64, i64* %t56
  %t58 = call i64 @RustGen_map_type(i64 %t53, i64 %t57)
  %t59 = call i64 @kore_str_concat(i64 %t52, i64 %t58)
  %t60 = getelementptr [2 x i8], [2 x i8]* @.str.857, i64 0, i64 0
  %t61 = ptrtoint i8* %t60 to i64
  %t62 = call i64 @kore_str_concat(i64 %t59, i64 %t61)
  %t63 = call i64 @RustGen_write_line(i64 %t42, i64 %t62)
  br label %for_update1024
  for_update1024:
  %t64 = load i64, i64* %t37
  %t65 = add i64 %t64, 1
  store i64 %t65, i64* %t37
  br label %for_cond1022
  for_end1025:
  %t66 = load i64, i64* %t0
  %t67 = call i64 @RustGen_pop_indent(i64 %t66)
  %t68 = load i64, i64* %t0
  %t69 = getelementptr [2 x i8], [2 x i8]* @.str.858, i64 0, i64 0
  %t70 = ptrtoint i8* %t69 to i64
  %t71 = call i64 @RustGen_write_line(i64 %t68, i64 %t70)
  ret i64 0
}
define i64 @RustGen_gen_enum(i64 %self, i64 %enum_def) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %enum_def, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = getelementptr [35 x i8], [35 x i8]* @.str.859, i64 0, i64 0
  %t4 = ptrtoint i8* %t3 to i64
  %t5 = call i64 @RustGen_write_line(i64 %t2, i64 %t4)
  %t6 = load i64, i64* %t0
  %t7 = getelementptr [10 x i8], [10 x i8]* @.str.860, i64 0, i64 0
  %t8 = ptrtoint i8* %t7 to i64
  %t9 = load i64, i64* %t1
  %t10 = inttoptr i64 %t9 to %EnumDef*
  %t11 = getelementptr %EnumDef, %EnumDef* %t10, i32 0, i32 0
  %t12 = load i64, i64* %t11
  %t13 = call i64 @kore_str_concat(i64 %t8, i64 %t12)
  %t14 = getelementptr [3 x i8], [3 x i8]* @.str.861, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  %t16 = call i64 @kore_str_concat(i64 %t13, i64 %t15)
  %t17 = call i64 @RustGen_write_line(i64 %t6, i64 %t16)
  %t18 = load i64, i64* %t0
  %t19 = call i64 @RustGen_push_indent(i64 %t18)
  ; for variant in ...
  %t20 = load i64, i64* %t1
  %t21 = inttoptr i64 %t20 to %EnumDef*
  %t22 = getelementptr %EnumDef, %EnumDef* %t21, i32 0, i32 1
  %t23 = load i64, i64* %t22
  %t24 = call i64 @kore_array_len(i64 %t23)
  %t25 = alloca i64
  store i64 0, i64* %t25
  br label %for_cond1026
  for_cond1026:
  %t26 = load i64, i64* %t25
  %t27 = icmp slt i64 %t26, %t24
  br i1 %t27, label %for_body1027, label %for_end1029
  for_body1027:
  %t28 = call i64 @kore_array_get(i64 %t23, i64 %t26)
  %t29 = alloca i64
  store i64 %t28, i64* %t29
  %t30 = load i64, i64* %t29
  %t31 = inttoptr i64 %t30 to %Variant*
  %t32 = getelementptr %Variant, %Variant* %t31, i32 0, i32 1
  %t33 = load i64, i64* %t32
  %t34 = call i64 @kore_array_len(i64 %t33)
  %t35 = call i64 @kore_str_eq(i64 %t34, i64 0)
  %t36 = icmp ne i64 %t35, 0
  br i1 %t36, label %then1030, label %else1031
  then1030:
  %t37 = load i64, i64* %t0
  %t38 = load i64, i64* %t29
  %t39 = inttoptr i64 %t38 to %FieldInit*
  %t40 = getelementptr %FieldInit, %FieldInit* %t39, i32 0, i32 0
  %t41 = load i64, i64* %t40
  %t42 = getelementptr [2 x i8], [2 x i8]* @.str.862, i64 0, i64 0
  %t43 = ptrtoint i8* %t42 to i64
  %t44 = call i64 @kore_str_concat(i64 %t41, i64 %t43)
  %t45 = call i64 @RustGen_write_line(i64 %t37, i64 %t44)
  br label %endif1032
  else1031:
  %t46 = load i64, i64* %t29
  %t47 = inttoptr i64 %t46 to %Variant*
  %t48 = getelementptr %Variant, %Variant* %t47, i32 0, i32 1
  %t49 = load i64, i64* %t48
  %t50 = getelementptr [3 x i8], [3 x i8]* @.str.863, i64 0, i64 0
  %t51 = ptrtoint i8* %t50 to i64
  %t52 = call i64 @kore_join(i64 %t49, i64 %t51)
  %t53 = alloca i64
  store i64 %t52, i64* %t53
  %t54 = load i64, i64* %t0
  %t55 = load i64, i64* %t29
  %t56 = inttoptr i64 %t55 to %FieldInit*
  %t57 = getelementptr %FieldInit, %FieldInit* %t56, i32 0, i32 0
  %t58 = load i64, i64* %t57
  %t59 = getelementptr [2 x i8], [2 x i8]* @.str.864, i64 0, i64 0
  %t60 = ptrtoint i8* %t59 to i64
  %t61 = call i64 @kore_str_concat(i64 %t58, i64 %t60)
  %t62 = load i64, i64* %t53
  %t63 = call i64 @kore_str_concat(i64 %t61, i64 %t62)
  %t64 = getelementptr [3 x i8], [3 x i8]* @.str.865, i64 0, i64 0
  %t65 = ptrtoint i8* %t64 to i64
  %t66 = call i64 @kore_str_concat(i64 %t63, i64 %t65)
  %t67 = call i64 @RustGen_write_line(i64 %t54, i64 %t66)
  br label %endif1032
  endif1032:
  br label %for_update1028
  for_update1028:
  %t68 = load i64, i64* %t25
  %t69 = add i64 %t68, 1
  store i64 %t69, i64* %t25
  br label %for_cond1026
  for_end1029:
  %t70 = load i64, i64* %t0
  %t71 = call i64 @RustGen_pop_indent(i64 %t70)
  %t72 = load i64, i64* %t0
  %t73 = getelementptr [2 x i8], [2 x i8]* @.str.866, i64 0, i64 0
  %t74 = ptrtoint i8* %t73 to i64
  %t75 = call i64 @RustGen_write_line(i64 %t72, i64 %t74)
  ret i64 0
}
define i64 @RustGen_gen_impl(i64 %self, i64 %impl_def) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %impl_def, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = getelementptr [6 x i8], [6 x i8]* @.str.867, i64 0, i64 0
  %t4 = ptrtoint i8* %t3 to i64
  %t5 = load i64, i64* %t1
  %t6 = inttoptr i64 %t5 to %ImplDef*
  %t7 = getelementptr %ImplDef, %ImplDef* %t6, i32 0, i32 0
  %t8 = load i64, i64* %t7
  %t9 = call i64 @kore_str_concat(i64 %t4, i64 %t8)
  %t10 = getelementptr [3 x i8], [3 x i8]* @.str.868, i64 0, i64 0
  %t11 = ptrtoint i8* %t10 to i64
  %t12 = call i64 @kore_str_concat(i64 %t9, i64 %t11)
  %t13 = call i64 @RustGen_write_line(i64 %t2, i64 %t12)
  %t14 = load i64, i64* %t0
  %t15 = call i64 @RustGen_push_indent(i64 %t14)
  ; for method in ...
  %t16 = load i64, i64* %t1
  %t17 = inttoptr i64 %t16 to %ImplDef*
  %t18 = getelementptr %ImplDef, %ImplDef* %t17, i32 0, i32 1
  %t19 = load i64, i64* %t18
  %t20 = call i64 @kore_array_len(i64 %t19)
  %t21 = alloca i64
  store i64 0, i64* %t21
  br label %for_cond1033
  for_cond1033:
  %t22 = load i64, i64* %t21
  %t23 = icmp slt i64 %t22, %t20
  br i1 %t23, label %for_body1034, label %for_end1036
  for_body1034:
  %t24 = call i64 @kore_array_get(i64 %t19, i64 %t22)
  %t25 = alloca i64
  store i64 %t24, i64* %t25
  %t26 = call i64 @kore_array_new()
  %t27 = alloca i64
  store i64 %t26, i64* %t27
  %t28 = load i64, i64* %t27
  %t29 = getelementptr [6 x i8], [6 x i8]* @.str.869, i64 0, i64 0
  %t30 = ptrtoint i8* %t29 to i64
  %t31 = call i64 @kore_array_push(i64 %t28, i64 %t30)
  ; for param in ...
  %t32 = load i64, i64* %t25
  %t33 = inttoptr i64 %t32 to %FnDef*
  %t34 = getelementptr %FnDef, %FnDef* %t33, i32 0, i32 1
  %t35 = load i64, i64* %t34
  %t36 = call i64 @kore_array_len(i64 %t35)
  %t37 = alloca i64
  store i64 0, i64* %t37
  br label %for_cond1037
  for_cond1037:
  %t38 = load i64, i64* %t37
  %t39 = icmp slt i64 %t38, %t36
  br i1 %t39, label %for_body1038, label %for_end1040
  for_body1038:
  %t40 = call i64 @kore_array_get(i64 %t35, i64 %t38)
  %t41 = alloca i64
  store i64 %t40, i64* %t41
  %t42 = getelementptr [4 x i8], [4 x i8]* @.str.870, i64 0, i64 0
  %t43 = ptrtoint i8* %t42 to i64
  %t44 = alloca i64
  store i64 %t43, i64* %t44
  ; match
  %t45 = load i64, i64* %t41
  %t46 = inttoptr i64 %t45 to %Field*
  %t47 = getelementptr %Field, %Field* %t46, i32 0, i32 1
  %t48 = load i64, i64* %t47
  %t49 = inttoptr i64 %t48 to { i64, i8* }*
  %t50 = getelementptr { i64, i8* }, { i64, i8* }* %t49, i32 0, i32 0
  %t51 = load i64, i64* %t50
  %t52 = icmp eq i64 %t51, 1
  br i1 %t52, label %match_body1043, label %match_next1042
  match_body1043:
  %t53 = getelementptr { i64, i8* }, { i64, i8* }* %t49, i32 0, i32 1
  %t54 = load i8*, i8** %t53
  %t55 = ptrtoint i8* %t54 to i64
  %t56 = inttoptr i64 %t55 to i64*
  %t57 = getelementptr i64, i64* %t56, i32 0
  %t58 = load i64, i64* %t57
  %t59 = alloca i64
  store i64 %t58, i64* %t59
  %t60 = load i64, i64* %t0
  %t61 = load i64, i64* %t59
  %t62 = call i64 @RustGen_map_type(i64 %t60, i64 %t61)
  store i64 %t62, i64* %t44
  br label %match_end1041
  match_next1042:
  %t63 = inttoptr i64 %t48 to { i64, i8* }*
  %t64 = getelementptr { i64, i8* }, { i64, i8* }* %t63, i32 0, i32 0
  %t65 = load i64, i64* %t64
  %t66 = icmp eq i64 %t65, 0
  br i1 %t66, label %match_body1045, label %match_next1044
  match_body1045:
  %t67 = getelementptr [4 x i8], [4 x i8]* @.str.871, i64 0, i64 0
  %t68 = ptrtoint i8* %t67 to i64
  store i64 %t68, i64* %t44
  br label %match_end1041
  match_next1044:
  br label %match_end1041
  match_end1041:
  %t69 = load i64, i64* %t27
  %t70 = load i64, i64* %t41
  %t71 = inttoptr i64 %t70 to %FieldInit*
  %t72 = getelementptr %FieldInit, %FieldInit* %t71, i32 0, i32 0
  %t73 = load i64, i64* %t72
  %t74 = getelementptr [3 x i8], [3 x i8]* @.str.872, i64 0, i64 0
  %t75 = ptrtoint i8* %t74 to i64
  %t76 = call i64 @kore_str_concat(i64 %t73, i64 %t75)
  %t77 = load i64, i64* %t44
  %t78 = call i64 @kore_str_concat(i64 %t76, i64 %t77)
  %t79 = call i64 @kore_array_push(i64 %t69, i64 %t78)
  br label %for_update1039
  for_update1039:
  %t80 = load i64, i64* %t37
  %t81 = add i64 %t80, 1
  store i64 %t81, i64* %t37
  br label %for_cond1037
  for_end1040:
  %t82 = load i64, i64* %t27
  %t83 = getelementptr [3 x i8], [3 x i8]* @.str.873, i64 0, i64 0
  %t84 = ptrtoint i8* %t83 to i64
  %t85 = call i64 @kore_join(i64 %t82, i64 %t84)
  %t86 = alloca i64
  store i64 %t85, i64* %t86
  %t87 = getelementptr [1 x i8], [1 x i8]* @.str.874, i64 0, i64 0
  %t88 = ptrtoint i8* %t87 to i64
  %t89 = alloca i64
  store i64 %t88, i64* %t89
  ; match
  %t90 = load i64, i64* %t25
  %t91 = inttoptr i64 %t90 to %FnDef*
  %t92 = getelementptr %FnDef, %FnDef* %t91, i32 0, i32 2
  %t93 = load i64, i64* %t92
  %t94 = inttoptr i64 %t93 to { i64, i8* }*
  %t95 = getelementptr { i64, i8* }, { i64, i8* }* %t94, i32 0, i32 0
  %t96 = load i64, i64* %t95
  %t97 = icmp eq i64 %t96, 1
  br i1 %t97, label %match_body1048, label %match_next1047
  match_body1048:
  %t98 = getelementptr { i64, i8* }, { i64, i8* }* %t94, i32 0, i32 1
  %t99 = load i8*, i8** %t98
  %t100 = ptrtoint i8* %t99 to i64
  %t101 = inttoptr i64 %t100 to i64*
  %t102 = getelementptr i64, i64* %t101, i32 0
  %t103 = load i64, i64* %t102
  %t104 = alloca i64
  store i64 %t103, i64* %t104
  %t105 = getelementptr [5 x i8], [5 x i8]* @.str.875, i64 0, i64 0
  %t106 = ptrtoint i8* %t105 to i64
  %t107 = load i64, i64* %t0
  %t108 = load i64, i64* %t104
  %t109 = call i64 @RustGen_map_type(i64 %t107, i64 %t108)
  %t110 = call i64 @kore_str_concat(i64 %t106, i64 %t109)
  store i64 %t110, i64* %t89
  br label %match_end1046
  match_next1047:
  %t111 = inttoptr i64 %t93 to { i64, i8* }*
  %t112 = getelementptr { i64, i8* }, { i64, i8* }* %t111, i32 0, i32 0
  %t113 = load i64, i64* %t112
  %t114 = icmp eq i64 %t113, 0
  br i1 %t114, label %match_body1050, label %match_next1049
  match_body1050:
  %t115 = getelementptr [1 x i8], [1 x i8]* @.str.876, i64 0, i64 0
  %t116 = ptrtoint i8* %t115 to i64
  store i64 %t116, i64* %t89
  br label %match_end1046
  match_next1049:
  br label %match_end1046
  match_end1046:
  %t117 = getelementptr [1 x i8], [1 x i8]* @.str.877, i64 0, i64 0
  %t118 = ptrtoint i8* %t117 to i64
  %t119 = alloca i64
  store i64 %t118, i64* %t119
  %t120 = load i64, i64* %t25
  %t121 = inttoptr i64 %t120 to %StructDef*
  %t122 = getelementptr %StructDef, %StructDef* %t121, i32 0, i32 2
  %t123 = load i64, i64* %t122
  %t124 = icmp ne i64 %t123, 0
  br i1 %t124, label %then1051, label %endif1053
  then1051:
  %t125 = getelementptr [5 x i8], [5 x i8]* @.str.878, i64 0, i64 0
  %t126 = ptrtoint i8* %t125 to i64
  store i64 %t126, i64* %t119
  br label %endif1053
  endif1053:
  %t127 = load i64, i64* %t0
  %t128 = load i64, i64* %t119
  %t129 = getelementptr [4 x i8], [4 x i8]* @.str.879, i64 0, i64 0
  %t130 = ptrtoint i8* %t129 to i64
  %t131 = call i64 @kore_str_concat(i64 %t128, i64 %t130)
  %t132 = load i64, i64* %t25
  %t133 = inttoptr i64 %t132 to %FieldInit*
  %t134 = getelementptr %FieldInit, %FieldInit* %t133, i32 0, i32 0
  %t135 = load i64, i64* %t134
  %t136 = call i64 @kore_str_concat(i64 %t131, i64 %t135)
  %t137 = getelementptr [2 x i8], [2 x i8]* @.str.880, i64 0, i64 0
  %t138 = ptrtoint i8* %t137 to i64
  %t139 = call i64 @kore_str_concat(i64 %t136, i64 %t138)
  %t140 = load i64, i64* %t86
  %t141 = call i64 @kore_str_concat(i64 %t139, i64 %t140)
  %t142 = getelementptr [2 x i8], [2 x i8]* @.str.881, i64 0, i64 0
  %t143 = ptrtoint i8* %t142 to i64
  %t144 = call i64 @kore_str_concat(i64 %t141, i64 %t143)
  %t145 = load i64, i64* %t89
  %t146 = call i64 @kore_str_concat(i64 %t144, i64 %t145)
  %t147 = getelementptr [3 x i8], [3 x i8]* @.str.882, i64 0, i64 0
  %t148 = ptrtoint i8* %t147 to i64
  %t149 = call i64 @kore_str_concat(i64 %t146, i64 %t148)
  %t150 = call i64 @RustGen_write_line(i64 %t127, i64 %t149)
  %t151 = load i64, i64* %t0
  %t152 = call i64 @RustGen_push_indent(i64 %t151)
  ; for stmt in ...
  %t153 = load i64, i64* %t25
  %t154 = inttoptr i64 %t153 to %MatchArm*
  %t155 = getelementptr %MatchArm, %MatchArm* %t154, i32 0, i32 1
  %t156 = load i64, i64* %t155
  %t157 = call i64 @kore_array_len(i64 %t156)
  %t158 = alloca i64
  store i64 0, i64* %t158
  br label %for_cond1054
  for_cond1054:
  %t159 = load i64, i64* %t158
  %t160 = icmp slt i64 %t159, %t157
  br i1 %t160, label %for_body1055, label %for_end1057
  for_body1055:
  %t161 = call i64 @kore_array_get(i64 %t156, i64 %t159)
  %t162 = alloca i64
  store i64 %t161, i64* %t162
  %t163 = load i64, i64* %t0
  %t164 = load i64, i64* %t162
  %t165 = call i64 @RustGen_gen_stmt(i64 %t163, i64 %t164)
  br label %for_update1056
  for_update1056:
  %t166 = load i64, i64* %t158
  %t167 = add i64 %t166, 1
  store i64 %t167, i64* %t158
  br label %for_cond1054
  for_end1057:
  %t168 = load i64, i64* %t0
  %t169 = call i64 @RustGen_pop_indent(i64 %t168)
  %t170 = load i64, i64* %t0
  %t171 = getelementptr [2 x i8], [2 x i8]* @.str.883, i64 0, i64 0
  %t172 = ptrtoint i8* %t171 to i64
  %t173 = call i64 @RustGen_write_line(i64 %t170, i64 %t172)
  %t174 = load i64, i64* %t0
  %t175 = call i64 @RustGen_write_blank(i64 %t174)
  br label %for_update1035
  for_update1035:
  %t176 = load i64, i64* %t21
  %t177 = add i64 %t176, 1
  store i64 %t177, i64* %t21
  br label %for_cond1033
  for_end1036:
  %t178 = load i64, i64* %t0
  %t179 = call i64 @RustGen_pop_indent(i64 %t178)
  %t180 = load i64, i64* %t0
  %t181 = getelementptr [2 x i8], [2 x i8]* @.str.884, i64 0, i64 0
  %t182 = ptrtoint i8* %t181 to i64
  %t183 = call i64 @RustGen_write_line(i64 %t180, i64 %t182)
  ret i64 0
}
define i64 @RustGen_gen_use(i64 %self, i64 %path) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %path, i64* %t1
  %t2 = load i64, i64* %t1
  %t3 = getelementptr [2 x i8], [2 x i8]* @.str.885, i64 0, i64 0
  %t4 = ptrtoint i8* %t3 to i64
  %t5 = getelementptr [3 x i8], [3 x i8]* @.str.886, i64 0, i64 0
  %t6 = ptrtoint i8* %t5 to i64
  %t7 = call i64 @replace(i64 %t2, i64 %t4, i64 %t6)
  %t8 = alloca i64
  store i64 %t7, i64* %t8
  %t9 = load i64, i64* %t0
  %t10 = getelementptr [5 x i8], [5 x i8]* @.str.887, i64 0, i64 0
  %t11 = ptrtoint i8* %t10 to i64
  %t12 = load i64, i64* %t8
  %t13 = call i64 @kore_str_concat(i64 %t11, i64 %t12)
  %t14 = getelementptr [2 x i8], [2 x i8]* @.str.888, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  %t16 = call i64 @kore_str_concat(i64 %t13, i64 %t15)
  %t17 = call i64 @RustGen_write_line(i64 %t9, i64 %t16)
  ret i64 0
}
define i64 @RustGen_gen_stmt(i64 %self, i64 %stmt) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %stmt, i64* %t1
  %t2 = load i64, i64* %t1
  %t3 = call i64 @kore_variant_of(i64 %t2)
  %t4 = alloca i64
  store i64 %t3, i64* %t4
  %t5 = load i64, i64* %t4
  %t6 = getelementptr [4 x i8], [4 x i8]* @.str.889, i64 0, i64 0
  %t7 = ptrtoint i8* %t6 to i64
  %t8 = call i64 @kore_str_eq(i64 %t5, i64 %t7)
  %t9 = icmp ne i64 %t8, 0
  br i1 %t9, label %then1058, label %endif1060
  then1058:
  %t10 = load i64, i64* %t1
  %t11 = call i64 @kore_variant_field(i64 %t10, i64 0)
  %t12 = alloca i64
  store i64 %t11, i64* %t12
  %t13 = load i64, i64* %t1
  %t14 = call i64 @kore_variant_field(i64 %t13, i64 1)
  %t15 = alloca i64
  store i64 %t14, i64* %t15
  %t16 = load i64, i64* %t1
  %t17 = call i64 @kore_variant_field(i64 %t16, i64 2)
  %t18 = alloca i64
  store i64 %t17, i64* %t18
  %t19 = getelementptr [1 x i8], [1 x i8]* @.str.890, i64 0, i64 0
  %t20 = ptrtoint i8* %t19 to i64
  %t21 = alloca i64
  store i64 %t20, i64* %t21
  %t22 = load i64, i64* %t15
  %t24 = call i64 @kore_str_eq(i64 %t22, i64 0)
  %t25 = icmp eq i64 %t24, 0
  %t23 = zext i1 %t25 to i64
  %t26 = icmp ne i64 %t23, 0
  br i1 %t26, label %then1061, label %endif1063
  then1061:
  %t27 = getelementptr [3 x i8], [3 x i8]* @.str.891, i64 0, i64 0
  %t28 = ptrtoint i8* %t27 to i64
  %t29 = load i64, i64* %t0
  %t30 = load i64, i64* %t15
  %t31 = call i64 @RustGen_map_type(i64 %t29, i64 %t30)
  %t32 = call i64 @kore_str_concat(i64 %t28, i64 %t31)
  store i64 %t32, i64* %t21
  br label %endif1063
  endif1063:
  %t33 = load i64, i64* %t0
  %t34 = getelementptr [5 x i8], [5 x i8]* @.str.892, i64 0, i64 0
  %t35 = ptrtoint i8* %t34 to i64
  %t36 = load i64, i64* %t12
  %t37 = call i64 @kore_str_concat(i64 %t35, i64 %t36)
  %t38 = load i64, i64* %t21
  %t39 = call i64 @kore_str_concat(i64 %t37, i64 %t38)
  %t40 = getelementptr [4 x i8], [4 x i8]* @.str.893, i64 0, i64 0
  %t41 = ptrtoint i8* %t40 to i64
  %t42 = call i64 @kore_str_concat(i64 %t39, i64 %t41)
  %t43 = load i64, i64* %t0
  %t44 = load i64, i64* %t18
  %t45 = call i64 @RustGen_gen_expr(i64 %t43, i64 %t44)
  %t46 = call i64 @kore_str_concat(i64 %t42, i64 %t45)
  %t47 = getelementptr [2 x i8], [2 x i8]* @.str.894, i64 0, i64 0
  %t48 = ptrtoint i8* %t47 to i64
  %t49 = call i64 @kore_str_concat(i64 %t46, i64 %t48)
  %t50 = call i64 @RustGen_write_line(i64 %t33, i64 %t49)
  ret i64 0
  endif1060:
  %t51 = load i64, i64* %t4
  %t52 = getelementptr [4 x i8], [4 x i8]* @.str.895, i64 0, i64 0
  %t53 = ptrtoint i8* %t52 to i64
  %t54 = call i64 @kore_str_eq(i64 %t51, i64 %t53)
  %t55 = icmp ne i64 %t54, 0
  br i1 %t55, label %then1064, label %endif1066
  then1064:
  %t56 = load i64, i64* %t1
  %t57 = call i64 @kore_variant_field(i64 %t56, i64 0)
  %t58 = alloca i64
  store i64 %t57, i64* %t58
  %t59 = load i64, i64* %t1
  %t60 = call i64 @kore_variant_field(i64 %t59, i64 1)
  %t61 = alloca i64
  store i64 %t60, i64* %t61
  %t62 = load i64, i64* %t1
  %t63 = call i64 @kore_variant_field(i64 %t62, i64 2)
  %t64 = alloca i64
  store i64 %t63, i64* %t64
  %t65 = getelementptr [1 x i8], [1 x i8]* @.str.896, i64 0, i64 0
  %t66 = ptrtoint i8* %t65 to i64
  %t67 = alloca i64
  store i64 %t66, i64* %t67
  %t68 = load i64, i64* %t61
  %t70 = call i64 @kore_str_eq(i64 %t68, i64 0)
  %t71 = icmp eq i64 %t70, 0
  %t69 = zext i1 %t71 to i64
  %t72 = icmp ne i64 %t69, 0
  br i1 %t72, label %then1067, label %endif1069
  then1067:
  %t73 = getelementptr [3 x i8], [3 x i8]* @.str.897, i64 0, i64 0
  %t74 = ptrtoint i8* %t73 to i64
  %t75 = load i64, i64* %t0
  %t76 = load i64, i64* %t61
  %t77 = call i64 @RustGen_map_type(i64 %t75, i64 %t76)
  %t78 = call i64 @kore_str_concat(i64 %t74, i64 %t77)
  store i64 %t78, i64* %t67
  br label %endif1069
  endif1069:
  %t79 = load i64, i64* %t0
  %t80 = getelementptr [9 x i8], [9 x i8]* @.str.898, i64 0, i64 0
  %t81 = ptrtoint i8* %t80 to i64
  %t82 = load i64, i64* %t58
  %t83 = call i64 @kore_str_concat(i64 %t81, i64 %t82)
  %t84 = load i64, i64* %t67
  %t85 = call i64 @kore_str_concat(i64 %t83, i64 %t84)
  %t86 = getelementptr [4 x i8], [4 x i8]* @.str.899, i64 0, i64 0
  %t87 = ptrtoint i8* %t86 to i64
  %t88 = call i64 @kore_str_concat(i64 %t85, i64 %t87)
  %t89 = load i64, i64* %t0
  %t90 = load i64, i64* %t64
  %t91 = call i64 @RustGen_gen_expr(i64 %t89, i64 %t90)
  %t92 = call i64 @kore_str_concat(i64 %t88, i64 %t91)
  %t93 = getelementptr [2 x i8], [2 x i8]* @.str.900, i64 0, i64 0
  %t94 = ptrtoint i8* %t93 to i64
  %t95 = call i64 @kore_str_concat(i64 %t92, i64 %t94)
  %t96 = call i64 @RustGen_write_line(i64 %t79, i64 %t95)
  ret i64 0
  endif1066:
  %t97 = load i64, i64* %t4
  %t98 = getelementptr [7 x i8], [7 x i8]* @.str.901, i64 0, i64 0
  %t99 = ptrtoint i8* %t98 to i64
  %t100 = call i64 @kore_str_eq(i64 %t97, i64 %t99)
  %t101 = icmp ne i64 %t100, 0
  br i1 %t101, label %then1070, label %endif1072
  then1070:
  %t102 = load i64, i64* %t1
  %t103 = call i64 @kore_variant_field(i64 %t102, i64 0)
  %t104 = alloca i64
  store i64 %t103, i64* %t104
  %t105 = load i64, i64* %t1
  %t106 = call i64 @kore_variant_field(i64 %t105, i64 1)
  %t107 = alloca i64
  store i64 %t106, i64* %t107
  %t108 = load i64, i64* %t0
  %t109 = load i64, i64* %t0
  %t110 = load i64, i64* %t104
  %t111 = call i64 @RustGen_gen_expr(i64 %t109, i64 %t110)
  %t112 = getelementptr [4 x i8], [4 x i8]* @.str.902, i64 0, i64 0
  %t113 = ptrtoint i8* %t112 to i64
  %t114 = call i64 @kore_str_concat(i64 %t111, i64 %t113)
  %t115 = load i64, i64* %t0
  %t116 = load i64, i64* %t107
  %t117 = call i64 @RustGen_gen_expr(i64 %t115, i64 %t116)
  %t118 = call i64 @kore_str_concat(i64 %t114, i64 %t117)
  %t119 = getelementptr [2 x i8], [2 x i8]* @.str.903, i64 0, i64 0
  %t120 = ptrtoint i8* %t119 to i64
  %t121 = call i64 @kore_str_concat(i64 %t118, i64 %t120)
  %t122 = call i64 @RustGen_write_line(i64 %t108, i64 %t121)
  ret i64 0
  endif1072:
  %t123 = load i64, i64* %t4
  %t124 = getelementptr [7 x i8], [7 x i8]* @.str.904, i64 0, i64 0
  %t125 = ptrtoint i8* %t124 to i64
  %t126 = call i64 @kore_str_eq(i64 %t123, i64 %t125)
  %t127 = icmp ne i64 %t126, 0
  br i1 %t127, label %then1073, label %endif1075
  then1073:
  %t128 = load i64, i64* %t1
  %t129 = call i64 @kore_variant_field(i64 %t128, i64 0)
  %t130 = alloca i64
  store i64 %t129, i64* %t130
  %t131 = load i64, i64* %t130
  %t133 = call i64 @kore_str_eq(i64 %t131, i64 0)
  %t134 = icmp eq i64 %t133, 0
  %t132 = zext i1 %t134 to i64
  %t135 = icmp ne i64 %t132, 0
  br i1 %t135, label %then1076, label %else1077
  then1076:
  %t136 = load i64, i64* %t0
  %t137 = getelementptr [8 x i8], [8 x i8]* @.str.905, i64 0, i64 0
  %t138 = ptrtoint i8* %t137 to i64
  %t139 = load i64, i64* %t0
  %t140 = load i64, i64* %t130
  %t141 = call i64 @RustGen_gen_expr(i64 %t139, i64 %t140)
  %t142 = call i64 @kore_str_concat(i64 %t138, i64 %t141)
  %t143 = getelementptr [2 x i8], [2 x i8]* @.str.906, i64 0, i64 0
  %t144 = ptrtoint i8* %t143 to i64
  %t145 = call i64 @kore_str_concat(i64 %t142, i64 %t144)
  %t146 = call i64 @RustGen_write_line(i64 %t136, i64 %t145)
  br label %endif1078
  else1077:
  %t147 = load i64, i64* %t0
  %t148 = getelementptr [8 x i8], [8 x i8]* @.str.907, i64 0, i64 0
  %t149 = ptrtoint i8* %t148 to i64
  %t150 = call i64 @RustGen_write_line(i64 %t147, i64 %t149)
  br label %endif1078
  endif1078:
  ret i64 0
  endif1075:
  %t151 = load i64, i64* %t4
  %t152 = getelementptr [3 x i8], [3 x i8]* @.str.908, i64 0, i64 0
  %t153 = ptrtoint i8* %t152 to i64
  %t154 = call i64 @kore_str_eq(i64 %t151, i64 %t153)
  %t155 = icmp ne i64 %t154, 0
  br i1 %t155, label %then1079, label %endif1081
  then1079:
  %t156 = load i64, i64* %t1
  %t157 = call i64 @kore_variant_field(i64 %t156, i64 0)
  %t158 = alloca i64
  store i64 %t157, i64* %t158
  %t159 = load i64, i64* %t1
  %t160 = call i64 @kore_variant_field(i64 %t159, i64 1)
  %t161 = alloca i64
  store i64 %t160, i64* %t161
  %t162 = load i64, i64* %t1
  %t163 = call i64 @kore_variant_field(i64 %t162, i64 2)
  %t164 = alloca i64
  store i64 %t163, i64* %t164
  %t165 = load i64, i64* %t0
  %t166 = getelementptr [4 x i8], [4 x i8]* @.str.909, i64 0, i64 0
  %t167 = ptrtoint i8* %t166 to i64
  %t168 = load i64, i64* %t0
  %t169 = load i64, i64* %t158
  %t170 = call i64 @RustGen_gen_expr(i64 %t168, i64 %t169)
  %t171 = call i64 @kore_str_concat(i64 %t167, i64 %t170)
  %t172 = getelementptr [3 x i8], [3 x i8]* @.str.910, i64 0, i64 0
  %t173 = ptrtoint i8* %t172 to i64
  %t174 = call i64 @kore_str_concat(i64 %t171, i64 %t173)
  %t175 = call i64 @RustGen_write_line(i64 %t165, i64 %t174)
  %t176 = load i64, i64* %t0
  %t177 = call i64 @RustGen_push_indent(i64 %t176)
  ; for s in ...
  %t178 = load i64, i64* %t161
  %t179 = call i64 @kore_array_len(i64 %t178)
  %t180 = alloca i64
  store i64 0, i64* %t180
  br label %for_cond1082
  for_cond1082:
  %t181 = load i64, i64* %t180
  %t182 = icmp slt i64 %t181, %t179
  br i1 %t182, label %for_body1083, label %for_end1085
  for_body1083:
  %t183 = call i64 @kore_array_get(i64 %t178, i64 %t181)
  %t184 = alloca i64
  store i64 %t183, i64* %t184
  %t185 = load i64, i64* %t0
  %t186 = load i64, i64* %t184
  %t187 = call i64 @RustGen_gen_stmt(i64 %t185, i64 %t186)
  br label %for_update1084
  for_update1084:
  %t188 = load i64, i64* %t180
  %t189 = add i64 %t188, 1
  store i64 %t189, i64* %t180
  br label %for_cond1082
  for_end1085:
  %t190 = load i64, i64* %t0
  %t191 = call i64 @RustGen_pop_indent(i64 %t190)
  %t192 = load i64, i64* %t164
  %t194 = call i64 @kore_str_eq(i64 %t192, i64 0)
  %t195 = icmp eq i64 %t194, 0
  %t193 = zext i1 %t195 to i64
  %t196 = icmp ne i64 %t193, 0
  br i1 %t196, label %then1086, label %else1087
  then1086:
  %t197 = load i64, i64* %t0
  %t198 = getelementptr [9 x i8], [9 x i8]* @.str.911, i64 0, i64 0
  %t199 = ptrtoint i8* %t198 to i64
  %t200 = call i64 @RustGen_write_line(i64 %t197, i64 %t199)
  %t201 = load i64, i64* %t0
  %t202 = call i64 @RustGen_push_indent(i64 %t201)
  ; for s in ...
  %t203 = load i64, i64* %t164
  %t204 = call i64 @kore_array_len(i64 %t203)
  %t205 = alloca i64
  store i64 0, i64* %t205
  br label %for_cond1089
  for_cond1089:
  %t206 = load i64, i64* %t205
  %t207 = icmp slt i64 %t206, %t204
  br i1 %t207, label %for_body1090, label %for_end1092
  for_body1090:
  %t208 = call i64 @kore_array_get(i64 %t203, i64 %t206)
  %t209 = alloca i64
  store i64 %t208, i64* %t209
  %t210 = load i64, i64* %t0
  %t211 = load i64, i64* %t209
  %t212 = call i64 @RustGen_gen_stmt(i64 %t210, i64 %t211)
  br label %for_update1091
  for_update1091:
  %t213 = load i64, i64* %t205
  %t214 = add i64 %t213, 1
  store i64 %t214, i64* %t205
  br label %for_cond1089
  for_end1092:
  %t215 = load i64, i64* %t0
  %t216 = call i64 @RustGen_pop_indent(i64 %t215)
  %t217 = load i64, i64* %t0
  %t218 = getelementptr [2 x i8], [2 x i8]* @.str.912, i64 0, i64 0
  %t219 = ptrtoint i8* %t218 to i64
  %t220 = call i64 @RustGen_write_line(i64 %t217, i64 %t219)
  br label %endif1088
  else1087:
  %t221 = load i64, i64* %t0
  %t222 = getelementptr [2 x i8], [2 x i8]* @.str.913, i64 0, i64 0
  %t223 = ptrtoint i8* %t222 to i64
  %t224 = call i64 @RustGen_write_line(i64 %t221, i64 %t223)
  br label %endif1088
  endif1088:
  ret i64 0
  endif1081:
  %t225 = load i64, i64* %t4
  %t226 = getelementptr [6 x i8], [6 x i8]* @.str.914, i64 0, i64 0
  %t227 = ptrtoint i8* %t226 to i64
  %t228 = call i64 @kore_str_eq(i64 %t225, i64 %t227)
  %t229 = icmp ne i64 %t228, 0
  br i1 %t229, label %then1093, label %endif1095
  then1093:
  %t230 = load i64, i64* %t1
  %t231 = call i64 @kore_variant_field(i64 %t230, i64 0)
  %t232 = alloca i64
  store i64 %t231, i64* %t232
  %t233 = load i64, i64* %t1
  %t234 = call i64 @kore_variant_field(i64 %t233, i64 1)
  %t235 = alloca i64
  store i64 %t234, i64* %t235
  %t236 = load i64, i64* %t0
  %t237 = getelementptr [7 x i8], [7 x i8]* @.str.915, i64 0, i64 0
  %t238 = ptrtoint i8* %t237 to i64
  %t239 = load i64, i64* %t0
  %t240 = load i64, i64* %t232
  %t241 = call i64 @RustGen_gen_expr(i64 %t239, i64 %t240)
  %t242 = call i64 @kore_str_concat(i64 %t238, i64 %t241)
  %t243 = getelementptr [3 x i8], [3 x i8]* @.str.916, i64 0, i64 0
  %t244 = ptrtoint i8* %t243 to i64
  %t245 = call i64 @kore_str_concat(i64 %t242, i64 %t244)
  %t246 = call i64 @RustGen_write_line(i64 %t236, i64 %t245)
  %t247 = load i64, i64* %t0
  %t248 = call i64 @RustGen_push_indent(i64 %t247)
  ; for s in ...
  %t249 = load i64, i64* %t235
  %t250 = call i64 @kore_array_len(i64 %t249)
  %t251 = alloca i64
  store i64 0, i64* %t251
  br label %for_cond1096
  for_cond1096:
  %t252 = load i64, i64* %t251
  %t253 = icmp slt i64 %t252, %t250
  br i1 %t253, label %for_body1097, label %for_end1099
  for_body1097:
  %t254 = call i64 @kore_array_get(i64 %t249, i64 %t252)
  %t255 = alloca i64
  store i64 %t254, i64* %t255
  %t256 = load i64, i64* %t0
  %t257 = load i64, i64* %t255
  %t258 = call i64 @RustGen_gen_stmt(i64 %t256, i64 %t257)
  br label %for_update1098
  for_update1098:
  %t259 = load i64, i64* %t251
  %t260 = add i64 %t259, 1
  store i64 %t260, i64* %t251
  br label %for_cond1096
  for_end1099:
  %t261 = load i64, i64* %t0
  %t262 = call i64 @RustGen_pop_indent(i64 %t261)
  %t263 = load i64, i64* %t0
  %t264 = getelementptr [2 x i8], [2 x i8]* @.str.917, i64 0, i64 0
  %t265 = ptrtoint i8* %t264 to i64
  %t266 = call i64 @RustGen_write_line(i64 %t263, i64 %t265)
  ret i64 0
  endif1095:
  %t267 = load i64, i64* %t4
  %t268 = getelementptr [4 x i8], [4 x i8]* @.str.918, i64 0, i64 0
  %t269 = ptrtoint i8* %t268 to i64
  %t270 = call i64 @kore_str_eq(i64 %t267, i64 %t269)
  %t271 = icmp ne i64 %t270, 0
  br i1 %t271, label %then1100, label %endif1102
  then1100:
  %t272 = load i64, i64* %t1
  %t273 = call i64 @kore_variant_field(i64 %t272, i64 0)
  %t274 = alloca i64
  store i64 %t273, i64* %t274
  %t275 = load i64, i64* %t1
  %t276 = call i64 @kore_variant_field(i64 %t275, i64 1)
  %t277 = alloca i64
  store i64 %t276, i64* %t277
  %t278 = load i64, i64* %t1
  %t279 = call i64 @kore_variant_field(i64 %t278, i64 2)
  %t280 = alloca i64
  store i64 %t279, i64* %t280
  %t281 = load i64, i64* %t0
  %t282 = getelementptr [5 x i8], [5 x i8]* @.str.919, i64 0, i64 0
  %t283 = ptrtoint i8* %t282 to i64
  %t284 = load i64, i64* %t274
  %t285 = call i64 @kore_str_concat(i64 %t283, i64 %t284)
  %t286 = getelementptr [5 x i8], [5 x i8]* @.str.920, i64 0, i64 0
  %t287 = ptrtoint i8* %t286 to i64
  %t288 = call i64 @kore_str_concat(i64 %t285, i64 %t287)
  %t289 = load i64, i64* %t0
  %t290 = load i64, i64* %t277
  %t291 = call i64 @RustGen_gen_expr(i64 %t289, i64 %t290)
  %t292 = call i64 @kore_str_concat(i64 %t288, i64 %t291)
  %t293 = getelementptr [3 x i8], [3 x i8]* @.str.921, i64 0, i64 0
  %t294 = ptrtoint i8* %t293 to i64
  %t295 = call i64 @kore_str_concat(i64 %t292, i64 %t294)
  %t296 = call i64 @RustGen_write_line(i64 %t281, i64 %t295)
  %t297 = load i64, i64* %t0
  %t298 = call i64 @RustGen_push_indent(i64 %t297)
  ; for s in ...
  %t299 = load i64, i64* %t280
  %t300 = call i64 @kore_array_len(i64 %t299)
  %t301 = alloca i64
  store i64 0, i64* %t301
  br label %for_cond1103
  for_cond1103:
  %t302 = load i64, i64* %t301
  %t303 = icmp slt i64 %t302, %t300
  br i1 %t303, label %for_body1104, label %for_end1106
  for_body1104:
  %t304 = call i64 @kore_array_get(i64 %t299, i64 %t302)
  %t305 = alloca i64
  store i64 %t304, i64* %t305
  %t306 = load i64, i64* %t0
  %t307 = load i64, i64* %t305
  %t308 = call i64 @RustGen_gen_stmt(i64 %t306, i64 %t307)
  br label %for_update1105
  for_update1105:
  %t309 = load i64, i64* %t301
  %t310 = add i64 %t309, 1
  store i64 %t310, i64* %t301
  br label %for_cond1103
  for_end1106:
  %t311 = load i64, i64* %t0
  %t312 = call i64 @RustGen_pop_indent(i64 %t311)
  %t313 = load i64, i64* %t0
  %t314 = getelementptr [2 x i8], [2 x i8]* @.str.922, i64 0, i64 0
  %t315 = ptrtoint i8* %t314 to i64
  %t316 = call i64 @RustGen_write_line(i64 %t313, i64 %t315)
  ret i64 0
  endif1102:
  %t317 = load i64, i64* %t4
  %t318 = getelementptr [5 x i8], [5 x i8]* @.str.923, i64 0, i64 0
  %t319 = ptrtoint i8* %t318 to i64
  %t320 = call i64 @kore_str_eq(i64 %t317, i64 %t319)
  %t321 = icmp ne i64 %t320, 0
  br i1 %t321, label %then1107, label %endif1109
  then1107:
  %t322 = load i64, i64* %t1
  %t323 = call i64 @kore_variant_field(i64 %t322, i64 0)
  %t324 = alloca i64
  store i64 %t323, i64* %t324
  %t325 = load i64, i64* %t0
  %t326 = getelementptr [7 x i8], [7 x i8]* @.str.924, i64 0, i64 0
  %t327 = ptrtoint i8* %t326 to i64
  %t328 = call i64 @RustGen_write_line(i64 %t325, i64 %t327)
  %t329 = load i64, i64* %t0
  %t330 = call i64 @RustGen_push_indent(i64 %t329)
  ; for s in ...
  %t331 = load i64, i64* %t324
  %t332 = call i64 @kore_array_len(i64 %t331)
  %t333 = alloca i64
  store i64 0, i64* %t333
  br label %for_cond1110
  for_cond1110:
  %t334 = load i64, i64* %t333
  %t335 = icmp slt i64 %t334, %t332
  br i1 %t335, label %for_body1111, label %for_end1113
  for_body1111:
  %t336 = call i64 @kore_array_get(i64 %t331, i64 %t334)
  %t337 = alloca i64
  store i64 %t336, i64* %t337
  %t338 = load i64, i64* %t0
  %t339 = load i64, i64* %t337
  %t340 = call i64 @RustGen_gen_stmt(i64 %t338, i64 %t339)
  br label %for_update1112
  for_update1112:
  %t341 = load i64, i64* %t333
  %t342 = add i64 %t341, 1
  store i64 %t342, i64* %t333
  br label %for_cond1110
  for_end1113:
  %t343 = load i64, i64* %t0
  %t344 = call i64 @RustGen_pop_indent(i64 %t343)
  %t345 = load i64, i64* %t0
  %t346 = getelementptr [2 x i8], [2 x i8]* @.str.925, i64 0, i64 0
  %t347 = ptrtoint i8* %t346 to i64
  %t348 = call i64 @RustGen_write_line(i64 %t345, i64 %t347)
  ret i64 0
  endif1109:
  %t349 = load i64, i64* %t4
  %t350 = getelementptr [6 x i8], [6 x i8]* @.str.926, i64 0, i64 0
  %t351 = ptrtoint i8* %t350 to i64
  %t352 = call i64 @kore_str_eq(i64 %t349, i64 %t351)
  %t353 = icmp ne i64 %t352, 0
  br i1 %t353, label %then1114, label %endif1116
  then1114:
  %t354 = load i64, i64* %t1
  %t355 = call i64 @kore_variant_field(i64 %t354, i64 0)
  %t356 = alloca i64
  store i64 %t355, i64* %t356
  %t357 = load i64, i64* %t1
  %t358 = call i64 @kore_variant_field(i64 %t357, i64 1)
  %t359 = alloca i64
  store i64 %t358, i64* %t359
  %t360 = load i64, i64* %t0
  %t361 = getelementptr [7 x i8], [7 x i8]* @.str.927, i64 0, i64 0
  %t362 = ptrtoint i8* %t361 to i64
  %t363 = load i64, i64* %t0
  %t364 = load i64, i64* %t356
  %t365 = call i64 @RustGen_gen_expr(i64 %t363, i64 %t364)
  %t366 = call i64 @kore_str_concat(i64 %t362, i64 %t365)
  %t367 = getelementptr [3 x i8], [3 x i8]* @.str.928, i64 0, i64 0
  %t368 = ptrtoint i8* %t367 to i64
  %t369 = call i64 @kore_str_concat(i64 %t366, i64 %t368)
  %t370 = call i64 @RustGen_write_line(i64 %t360, i64 %t369)
  %t371 = load i64, i64* %t0
  %t372 = call i64 @RustGen_push_indent(i64 %t371)
  ; for arm in ...
  %t373 = load i64, i64* %t359
  %t374 = call i64 @kore_array_len(i64 %t373)
  %t375 = alloca i64
  store i64 0, i64* %t375
  br label %for_cond1117
  for_cond1117:
  %t376 = load i64, i64* %t375
  %t377 = icmp slt i64 %t376, %t374
  br i1 %t377, label %for_body1118, label %for_end1120
  for_body1118:
  %t378 = call i64 @kore_array_get(i64 %t373, i64 %t376)
  %t379 = alloca i64
  store i64 %t378, i64* %t379
  %t380 = load i64, i64* %t0
  %t381 = load i64, i64* %t379
  %t382 = inttoptr i64 %t381 to %MatchArm*
  %t383 = getelementptr %MatchArm, %MatchArm* %t382, i32 0, i32 0
  %t384 = load i64, i64* %t383
  %t385 = call i64 @RustGen_gen_pattern(i64 %t380, i64 %t384)
  %t386 = alloca i64
  store i64 %t385, i64* %t386
  %t387 = load i64, i64* %t0
  %t388 = load i64, i64* %t386
  %t389 = getelementptr [6 x i8], [6 x i8]* @.str.929, i64 0, i64 0
  %t390 = ptrtoint i8* %t389 to i64
  %t391 = call i64 @kore_str_concat(i64 %t388, i64 %t390)
  %t392 = call i64 @RustGen_write_line(i64 %t387, i64 %t391)
  %t393 = load i64, i64* %t0
  %t394 = call i64 @RustGen_push_indent(i64 %t393)
  ; for s in ...
  %t395 = load i64, i64* %t379
  %t396 = inttoptr i64 %t395 to %MatchArm*
  %t397 = getelementptr %MatchArm, %MatchArm* %t396, i32 0, i32 1
  %t398 = load i64, i64* %t397
  %t399 = call i64 @kore_array_len(i64 %t398)
  %t400 = alloca i64
  store i64 0, i64* %t400
  br label %for_cond1121
  for_cond1121:
  %t401 = load i64, i64* %t400
  %t402 = icmp slt i64 %t401, %t399
  br i1 %t402, label %for_body1122, label %for_end1124
  for_body1122:
  %t403 = call i64 @kore_array_get(i64 %t398, i64 %t401)
  %t404 = alloca i64
  store i64 %t403, i64* %t404
  %t405 = load i64, i64* %t0
  %t406 = load i64, i64* %t404
  %t407 = call i64 @RustGen_gen_stmt(i64 %t405, i64 %t406)
  br label %for_update1123
  for_update1123:
  %t408 = load i64, i64* %t400
  %t409 = add i64 %t408, 1
  store i64 %t409, i64* %t400
  br label %for_cond1121
  for_end1124:
  %t410 = load i64, i64* %t0
  %t411 = call i64 @RustGen_pop_indent(i64 %t410)
  %t412 = load i64, i64* %t0
  %t413 = getelementptr [2 x i8], [2 x i8]* @.str.930, i64 0, i64 0
  %t414 = ptrtoint i8* %t413 to i64
  %t415 = call i64 @RustGen_write_line(i64 %t412, i64 %t414)
  br label %for_update1119
  for_update1119:
  %t416 = load i64, i64* %t375
  %t417 = add i64 %t416, 1
  store i64 %t417, i64* %t375
  br label %for_cond1117
  for_end1120:
  %t418 = load i64, i64* %t0
  %t419 = call i64 @RustGen_pop_indent(i64 %t418)
  %t420 = load i64, i64* %t0
  %t421 = getelementptr [2 x i8], [2 x i8]* @.str.931, i64 0, i64 0
  %t422 = ptrtoint i8* %t421 to i64
  %t423 = call i64 @RustGen_write_line(i64 %t420, i64 %t422)
  ret i64 0
  endif1116:
  %t424 = load i64, i64* %t4
  %t425 = getelementptr [5 x i8], [5 x i8]* @.str.932, i64 0, i64 0
  %t426 = ptrtoint i8* %t425 to i64
  %t427 = call i64 @kore_str_eq(i64 %t424, i64 %t426)
  %t428 = icmp ne i64 %t427, 0
  br i1 %t428, label %then1125, label %endif1127
  then1125:
  %t429 = load i64, i64* %t1
  %t430 = call i64 @kore_variant_field(i64 %t429, i64 0)
  %t431 = alloca i64
  store i64 %t430, i64* %t431
  %t432 = load i64, i64* %t0
  %t433 = load i64, i64* %t0
  %t434 = load i64, i64* %t431
  %t435 = call i64 @RustGen_gen_expr(i64 %t433, i64 %t434)
  %t436 = getelementptr [2 x i8], [2 x i8]* @.str.933, i64 0, i64 0
  %t437 = ptrtoint i8* %t436 to i64
  %t438 = call i64 @kore_str_concat(i64 %t435, i64 %t437)
  %t439 = call i64 @RustGen_write_line(i64 %t432, i64 %t438)
  ret i64 0
  endif1127:
  %t440 = load i64, i64* %t4
  %t441 = getelementptr [6 x i8], [6 x i8]* @.str.934, i64 0, i64 0
  %t442 = ptrtoint i8* %t441 to i64
  %t443 = call i64 @kore_str_eq(i64 %t440, i64 %t442)
  %t444 = icmp ne i64 %t443, 0
  br i1 %t444, label %then1128, label %endif1130
  then1128:
  %t445 = load i64, i64* %t0
  %t446 = getelementptr [7 x i8], [7 x i8]* @.str.935, i64 0, i64 0
  %t447 = ptrtoint i8* %t446 to i64
  %t448 = call i64 @RustGen_write_line(i64 %t445, i64 %t447)
  ret i64 0
  endif1130:
  %t449 = load i64, i64* %t4
  %t450 = getelementptr [9 x i8], [9 x i8]* @.str.936, i64 0, i64 0
  %t451 = ptrtoint i8* %t450 to i64
  %t452 = call i64 @kore_str_eq(i64 %t449, i64 %t451)
  %t453 = icmp ne i64 %t452, 0
  br i1 %t453, label %then1131, label %endif1133
  then1131:
  %t454 = load i64, i64* %t0
  %t455 = getelementptr [10 x i8], [10 x i8]* @.str.937, i64 0, i64 0
  %t456 = ptrtoint i8* %t455 to i64
  %t457 = call i64 @RustGen_write_line(i64 %t454, i64 %t456)
  ret i64 0
  endif1133:
  ret i64 0
}
define i64 @RustGen_gen_expr(i64 %self, i64 %expr) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %expr, i64* %t1
  %t2 = load i64, i64* %t1
  %t3 = call i64 @kore_variant_of(i64 %t2)
  %t4 = alloca i64
  store i64 %t3, i64* %t4
  %t5 = load i64, i64* %t4
  %t6 = getelementptr [4 x i8], [4 x i8]* @.str.938, i64 0, i64 0
  %t7 = ptrtoint i8* %t6 to i64
  %t8 = call i64 @kore_str_eq(i64 %t5, i64 %t7)
  %t9 = icmp ne i64 %t8, 0
  br i1 %t9, label %then1134, label %endif1136
  then1134:
  %t10 = load i64, i64* %t1
  %t11 = call i64 @kore_variant_field(i64 %t10, i64 0)
  %t12 = alloca i64
  store i64 %t11, i64* %t12
  %t13 = load i64, i64* %t12
  %t14 = call i64 @kore_to_string(i64 %t13)
  ret i64 %t14
  endif1136:
  %t15 = load i64, i64* %t4
  %t16 = getelementptr [6 x i8], [6 x i8]* @.str.939, i64 0, i64 0
  %t17 = ptrtoint i8* %t16 to i64
  %t18 = call i64 @kore_str_eq(i64 %t15, i64 %t17)
  %t19 = icmp ne i64 %t18, 0
  br i1 %t19, label %then1137, label %endif1139
  then1137:
  %t20 = load i64, i64* %t1
  %t21 = call i64 @kore_variant_field(i64 %t20, i64 0)
  %t22 = alloca i64
  store i64 %t21, i64* %t22
  %t23 = load i64, i64* %t22
  %t24 = call i64 @kore_to_string(i64 %t23)
  ret i64 %t24
  endif1139:
  %t25 = load i64, i64* %t4
  %t26 = getelementptr [7 x i8], [7 x i8]* @.str.940, i64 0, i64 0
  %t27 = ptrtoint i8* %t26 to i64
  %t28 = call i64 @kore_str_eq(i64 %t25, i64 %t27)
  %t29 = icmp ne i64 %t28, 0
  br i1 %t29, label %then1140, label %endif1142
  then1140:
  %t30 = load i64, i64* %t1
  %t31 = call i64 @kore_variant_field(i64 %t30, i64 0)
  %t32 = alloca i64
  store i64 %t31, i64* %t32
  %t33 = getelementptr [1 x i8], [1 x i8]* @.str.941, i64 0, i64 0
  %t34 = ptrtoint i8* %t33 to i64
  %t35 = load i64, i64* %t0
  %t36 = load i64, i64* %t32
  %t37 = call i64 @RustGen_escape_string(i64 %t35, i64 %t36)
  %t38 = call i64 @kore_str_concat(i64 %t34, i64 %t37)
  %t39 = getelementptr [13 x i8], [13 x i8]* @.str.942, i64 0, i64 0
  %t40 = ptrtoint i8* %t39 to i64
  %t41 = call i64 @kore_str_concat(i64 %t38, i64 %t40)
  ret i64 %t41
  endif1142:
  %t42 = load i64, i64* %t4
  %t43 = getelementptr [5 x i8], [5 x i8]* @.str.943, i64 0, i64 0
  %t44 = ptrtoint i8* %t43 to i64
  %t45 = call i64 @kore_str_eq(i64 %t42, i64 %t44)
  %t46 = icmp ne i64 %t45, 0
  br i1 %t46, label %then1143, label %endif1145
  then1143:
  %t47 = load i64, i64* %t1
  %t48 = call i64 @kore_variant_field(i64 %t47, i64 0)
  %t49 = alloca i64
  store i64 %t48, i64* %t49
  %t50 = load i64, i64* %t49
  %t51 = icmp ne i64 %t50, 0
  br i1 %t51, label %then1146, label %endif1148
  then1146:
  %t52 = getelementptr [5 x i8], [5 x i8]* @.str.944, i64 0, i64 0
  %t53 = ptrtoint i8* %t52 to i64
  ret i64 %t53
  endif1148:
  %t54 = getelementptr [6 x i8], [6 x i8]* @.str.945, i64 0, i64 0
  %t55 = ptrtoint i8* %t54 to i64
  ret i64 %t55
  endif1145:
  %t56 = load i64, i64* %t4
  %t57 = getelementptr [5 x i8], [5 x i8]* @.str.946, i64 0, i64 0
  %t58 = ptrtoint i8* %t57 to i64
  %t59 = call i64 @kore_str_eq(i64 %t56, i64 %t58)
  %t60 = icmp ne i64 %t59, 0
  br i1 %t60, label %then1149, label %endif1151
  then1149:
  %t61 = getelementptr [5 x i8], [5 x i8]* @.str.947, i64 0, i64 0
  %t62 = ptrtoint i8* %t61 to i64
  ret i64 %t62
  endif1151:
  %t63 = load i64, i64* %t4
  %t64 = getelementptr [6 x i8], [6 x i8]* @.str.948, i64 0, i64 0
  %t65 = ptrtoint i8* %t64 to i64
  %t66 = call i64 @kore_str_eq(i64 %t63, i64 %t65)
  %t67 = icmp ne i64 %t66, 0
  br i1 %t67, label %then1152, label %endif1154
  then1152:
  %t68 = load i64, i64* %t1
  %t69 = call i64 @kore_variant_field(i64 %t68, i64 0)
  %t70 = alloca i64
  store i64 %t69, i64* %t70
  %t71 = load i64, i64* %t70
  ret i64 %t71
  endif1154:
  %t72 = load i64, i64* %t4
  %t73 = getelementptr [7 x i8], [7 x i8]* @.str.949, i64 0, i64 0
  %t74 = ptrtoint i8* %t73 to i64
  %t75 = call i64 @kore_str_eq(i64 %t72, i64 %t74)
  %t76 = icmp ne i64 %t75, 0
  br i1 %t76, label %then1155, label %endif1157
  then1155:
  %t77 = load i64, i64* %t1
  %t78 = call i64 @kore_variant_field(i64 %t77, i64 0)
  %t79 = alloca i64
  store i64 %t78, i64* %t79
  %t80 = load i64, i64* %t1
  %t81 = call i64 @kore_variant_field(i64 %t80, i64 1)
  %t82 = alloca i64
  store i64 %t81, i64* %t82
  %t83 = load i64, i64* %t1
  %t84 = call i64 @kore_variant_field(i64 %t83, i64 2)
  %t85 = alloca i64
  store i64 %t84, i64* %t85
  %t86 = load i64, i64* %t0
  %t87 = load i64, i64* %t79
  %t88 = call i64 @RustGen_gen_expr(i64 %t86, i64 %t87)
  %t89 = alloca i64
  store i64 %t88, i64* %t89
  %t90 = load i64, i64* %t0
  %t91 = load i64, i64* %t85
  %t92 = call i64 @RustGen_gen_expr(i64 %t90, i64 %t91)
  %t93 = alloca i64
  store i64 %t92, i64* %t93
  %t94 = load i64, i64* %t0
  %t95 = load i64, i64* %t82
  %t96 = call i64 @RustGen_map_op(i64 %t94, i64 %t95)
  %t97 = alloca i64
  store i64 %t96, i64* %t97
  %t98 = getelementptr [2 x i8], [2 x i8]* @.str.950, i64 0, i64 0
  %t99 = ptrtoint i8* %t98 to i64
  %t100 = load i64, i64* %t89
  %t101 = call i64 @kore_str_concat(i64 %t99, i64 %t100)
  %t102 = getelementptr [2 x i8], [2 x i8]* @.str.951, i64 0, i64 0
  %t103 = ptrtoint i8* %t102 to i64
  %t104 = call i64 @kore_str_concat(i64 %t101, i64 %t103)
  %t105 = load i64, i64* %t97
  %t106 = call i64 @kore_str_concat(i64 %t104, i64 %t105)
  %t107 = getelementptr [2 x i8], [2 x i8]* @.str.952, i64 0, i64 0
  %t108 = ptrtoint i8* %t107 to i64
  %t109 = call i64 @kore_str_concat(i64 %t106, i64 %t108)
  %t110 = load i64, i64* %t93
  %t111 = call i64 @kore_str_concat(i64 %t109, i64 %t110)
  %t112 = getelementptr [2 x i8], [2 x i8]* @.str.953, i64 0, i64 0
  %t113 = ptrtoint i8* %t112 to i64
  %t114 = call i64 @kore_str_concat(i64 %t111, i64 %t113)
  ret i64 %t114
  endif1157:
  %t115 = load i64, i64* %t4
  %t116 = getelementptr [6 x i8], [6 x i8]* @.str.954, i64 0, i64 0
  %t117 = ptrtoint i8* %t116 to i64
  %t118 = call i64 @kore_str_eq(i64 %t115, i64 %t117)
  %t119 = icmp ne i64 %t118, 0
  br i1 %t119, label %then1158, label %endif1160
  then1158:
  %t120 = load i64, i64* %t1
  %t121 = call i64 @kore_variant_field(i64 %t120, i64 0)
  %t122 = alloca i64
  store i64 %t121, i64* %t122
  %t123 = load i64, i64* %t1
  %t124 = call i64 @kore_variant_field(i64 %t123, i64 1)
  %t125 = alloca i64
  store i64 %t124, i64* %t125
  %t126 = load i64, i64* %t0
  %t127 = load i64, i64* %t125
  %t128 = call i64 @RustGen_gen_expr(i64 %t126, i64 %t127)
  %t129 = alloca i64
  store i64 %t128, i64* %t129
  %t130 = getelementptr [2 x i8], [2 x i8]* @.str.955, i64 0, i64 0
  %t131 = ptrtoint i8* %t130 to i64
  %t132 = load i64, i64* %t122
  %t133 = call i64 @kore_str_concat(i64 %t131, i64 %t132)
  %t134 = load i64, i64* %t129
  %t135 = call i64 @kore_str_concat(i64 %t133, i64 %t134)
  %t136 = getelementptr [2 x i8], [2 x i8]* @.str.956, i64 0, i64 0
  %t137 = ptrtoint i8* %t136 to i64
  %t138 = call i64 @kore_str_concat(i64 %t135, i64 %t137)
  ret i64 %t138
  endif1160:
  %t139 = load i64, i64* %t4
  %t140 = getelementptr [5 x i8], [5 x i8]* @.str.957, i64 0, i64 0
  %t141 = ptrtoint i8* %t140 to i64
  %t142 = call i64 @kore_str_eq(i64 %t139, i64 %t141)
  %t143 = icmp ne i64 %t142, 0
  br i1 %t143, label %then1161, label %endif1163
  then1161:
  %t144 = load i64, i64* %t1
  %t145 = call i64 @kore_variant_field(i64 %t144, i64 0)
  %t146 = alloca i64
  store i64 %t145, i64* %t146
  %t147 = load i64, i64* %t1
  %t148 = call i64 @kore_variant_field(i64 %t147, i64 1)
  %t149 = alloca i64
  store i64 %t148, i64* %t149
  %t150 = load i64, i64* %t0
  %t151 = load i64, i64* %t146
  %t152 = call i64 @RustGen_gen_expr(i64 %t150, i64 %t151)
  %t153 = alloca i64
  store i64 %t152, i64* %t153
  %t154 = load i64, i64* %t153
  %t155 = getelementptr [8 x i8], [8 x i8]* @.str.958, i64 0, i64 0
  %t156 = ptrtoint i8* %t155 to i64
  %t157 = call i64 @kore_str_eq(i64 %t154, i64 %t156)
  %t158 = load i64, i64* %t153
  %t159 = getelementptr [6 x i8], [6 x i8]* @.str.959, i64 0, i64 0
  %t160 = ptrtoint i8* %t159 to i64
  %t161 = call i64 @kore_str_eq(i64 %t158, i64 %t160)
  %t162 = or i64 %t157, %t161
  %t163 = icmp ne i64 %t162, 0
  br i1 %t163, label %then1164, label %endif1166
  then1164:
  %t164 = call i64 @kore_array_new()
  %t165 = alloca i64
  store i64 %t164, i64* %t165
  %t166 = call i64 @kore_array_new()
  %t167 = alloca i64
  store i64 %t166, i64* %t167
  ; for arg in ...
  %t168 = load i64, i64* %t149
  %t169 = call i64 @kore_array_len(i64 %t168)
  %t170 = alloca i64
  store i64 0, i64* %t170
  br label %for_cond1167
  for_cond1167:
  %t171 = load i64, i64* %t170
  %t172 = icmp slt i64 %t171, %t169
  br i1 %t172, label %for_body1168, label %for_end1170
  for_body1168:
  %t173 = call i64 @kore_array_get(i64 %t168, i64 %t171)
  %t174 = alloca i64
  store i64 %t173, i64* %t174
  %t175 = load i64, i64* %t165
  %t176 = load i64, i64* %t0
  %t177 = load i64, i64* %t174
  %t178 = call i64 @RustGen_gen_expr(i64 %t176, i64 %t177)
  %t179 = call i64 @kore_array_push(i64 %t175, i64 %t178)
  %t180 = load i64, i64* %t167
  %t181 = getelementptr [3 x i8], [3 x i8]* @.str.960, i64 0, i64 0
  %t182 = ptrtoint i8* %t181 to i64
  %t183 = call i64 @kore_array_push(i64 %t180, i64 %t182)
  br label %for_update1169
  for_update1169:
  %t184 = load i64, i64* %t170
  %t185 = add i64 %t184, 1
  store i64 %t185, i64* %t170
  br label %for_cond1167
  for_end1170:
  %t186 = getelementptr [1 x i8], [1 x i8]* @.str.961, i64 0, i64 0
  %t187 = ptrtoint i8* %t186 to i64
  %t188 = load i64, i64* %t167
  %t189 = getelementptr [2 x i8], [2 x i8]* @.str.962, i64 0, i64 0
  %t190 = ptrtoint i8* %t189 to i64
  %t191 = call i64 @kore_join(i64 %t188, i64 %t190)
  %t192 = call i64 @kore_str_concat(i64 %t187, i64 %t191)
  %t193 = getelementptr [1 x i8], [1 x i8]* @.str.963, i64 0, i64 0
  %t194 = ptrtoint i8* %t193 to i64
  %t195 = call i64 @kore_str_concat(i64 %t192, i64 %t194)
  %t196 = alloca i64
  store i64 %t195, i64* %t196
  %t197 = load i64, i64* %t165
  %t198 = call i64 @kore_array_len(i64 %t197)
  %t200 = icmp sgt i64 %t198, 0
  %t199 = zext i1 %t200 to i64
  %t201 = icmp ne i64 %t199, 0
  br i1 %t201, label %then1171, label %endif1173
  then1171:
  %t202 = load i64, i64* %t153
  %t203 = getelementptr [3 x i8], [3 x i8]* @.str.964, i64 0, i64 0
  %t204 = ptrtoint i8* %t203 to i64
  %t205 = call i64 @kore_str_concat(i64 %t202, i64 %t204)
  %t206 = load i64, i64* %t196
  %t207 = call i64 @kore_str_concat(i64 %t205, i64 %t206)
  %t208 = getelementptr [3 x i8], [3 x i8]* @.str.965, i64 0, i64 0
  %t209 = ptrtoint i8* %t208 to i64
  %t210 = call i64 @kore_str_concat(i64 %t207, i64 %t209)
  %t211 = load i64, i64* %t165
  %t212 = getelementptr [3 x i8], [3 x i8]* @.str.966, i64 0, i64 0
  %t213 = ptrtoint i8* %t212 to i64
  %t214 = call i64 @kore_join(i64 %t211, i64 %t213)
  %t215 = call i64 @kore_str_concat(i64 %t210, i64 %t214)
  %t216 = getelementptr [2 x i8], [2 x i8]* @.str.967, i64 0, i64 0
  %t217 = ptrtoint i8* %t216 to i64
  %t218 = call i64 @kore_str_concat(i64 %t215, i64 %t217)
  ret i64 %t218
  endif1173:
  %t219 = load i64, i64* %t153
  %t220 = getelementptr [4 x i8], [4 x i8]* @.str.968, i64 0, i64 0
  %t221 = ptrtoint i8* %t220 to i64
  %t222 = call i64 @kore_str_concat(i64 %t219, i64 %t221)
  ret i64 %t222
  endif1166:
  %t223 = call i64 @kore_array_new()
  %t224 = alloca i64
  store i64 %t223, i64* %t224
  ; for arg in ...
  %t225 = load i64, i64* %t149
  %t226 = call i64 @kore_array_len(i64 %t225)
  %t227 = alloca i64
  store i64 0, i64* %t227
  br label %for_cond1174
  for_cond1174:
  %t228 = load i64, i64* %t227
  %t229 = icmp slt i64 %t228, %t226
  br i1 %t229, label %for_body1175, label %for_end1177
  for_body1175:
  %t230 = call i64 @kore_array_get(i64 %t225, i64 %t228)
  %t231 = alloca i64
  store i64 %t230, i64* %t231
  %t232 = load i64, i64* %t224
  %t233 = load i64, i64* %t0
  %t234 = load i64, i64* %t231
  %t235 = call i64 @RustGen_gen_expr(i64 %t233, i64 %t234)
  %t236 = call i64 @kore_array_push(i64 %t232, i64 %t235)
  br label %for_update1176
  for_update1176:
  %t237 = load i64, i64* %t227
  %t238 = add i64 %t237, 1
  store i64 %t238, i64* %t227
  br label %for_cond1174
  for_end1177:
  %t239 = load i64, i64* %t153
  %t240 = getelementptr [2 x i8], [2 x i8]* @.str.969, i64 0, i64 0
  %t241 = ptrtoint i8* %t240 to i64
  %t242 = call i64 @kore_str_concat(i64 %t239, i64 %t241)
  %t243 = load i64, i64* %t224
  %t244 = getelementptr [3 x i8], [3 x i8]* @.str.970, i64 0, i64 0
  %t245 = ptrtoint i8* %t244 to i64
  %t246 = call i64 @kore_join(i64 %t243, i64 %t245)
  %t247 = call i64 @kore_str_concat(i64 %t242, i64 %t246)
  %t248 = getelementptr [2 x i8], [2 x i8]* @.str.971, i64 0, i64 0
  %t249 = ptrtoint i8* %t248 to i64
  %t250 = call i64 @kore_str_concat(i64 %t247, i64 %t249)
  ret i64 %t250
  endif1163:
  %t251 = load i64, i64* %t4
  %t252 = getelementptr [11 x i8], [11 x i8]* @.str.972, i64 0, i64 0
  %t253 = ptrtoint i8* %t252 to i64
  %t254 = call i64 @kore_str_eq(i64 %t251, i64 %t253)
  %t255 = icmp ne i64 %t254, 0
  br i1 %t255, label %then1178, label %endif1180
  then1178:
  %t256 = load i64, i64* %t1
  %t257 = call i64 @kore_variant_field(i64 %t256, i64 0)
  %t258 = alloca i64
  store i64 %t257, i64* %t258
  %t259 = load i64, i64* %t1
  %t260 = call i64 @kore_variant_field(i64 %t259, i64 1)
  %t261 = alloca i64
  store i64 %t260, i64* %t261
  %t262 = load i64, i64* %t1
  %t263 = call i64 @kore_variant_field(i64 %t262, i64 2)
  %t264 = alloca i64
  store i64 %t263, i64* %t264
  %t265 = load i64, i64* %t0
  %t266 = load i64, i64* %t258
  %t267 = call i64 @RustGen_gen_expr(i64 %t265, i64 %t266)
  %t268 = alloca i64
  store i64 %t267, i64* %t268
  %t269 = call i64 @kore_array_new()
  %t270 = alloca i64
  store i64 %t269, i64* %t270
  ; for arg in ...
  %t271 = load i64, i64* %t264
  %t272 = call i64 @kore_array_len(i64 %t271)
  %t273 = alloca i64
  store i64 0, i64* %t273
  br label %for_cond1181
  for_cond1181:
  %t274 = load i64, i64* %t273
  %t275 = icmp slt i64 %t274, %t272
  br i1 %t275, label %for_body1182, label %for_end1184
  for_body1182:
  %t276 = call i64 @kore_array_get(i64 %t271, i64 %t274)
  %t277 = alloca i64
  store i64 %t276, i64* %t277
  %t278 = load i64, i64* %t270
  %t279 = load i64, i64* %t0
  %t280 = load i64, i64* %t277
  %t281 = call i64 @RustGen_gen_expr(i64 %t279, i64 %t280)
  %t282 = call i64 @kore_array_push(i64 %t278, i64 %t281)
  br label %for_update1183
  for_update1183:
  %t283 = load i64, i64* %t273
  %t284 = add i64 %t283, 1
  store i64 %t284, i64* %t273
  br label %for_cond1181
  for_end1184:
  %t285 = load i64, i64* %t268
  %t286 = getelementptr [2 x i8], [2 x i8]* @.str.973, i64 0, i64 0
  %t287 = ptrtoint i8* %t286 to i64
  %t288 = call i64 @kore_str_concat(i64 %t285, i64 %t287)
  %t289 = load i64, i64* %t261
  %t290 = call i64 @kore_str_concat(i64 %t288, i64 %t289)
  %t291 = getelementptr [2 x i8], [2 x i8]* @.str.974, i64 0, i64 0
  %t292 = ptrtoint i8* %t291 to i64
  %t293 = call i64 @kore_str_concat(i64 %t290, i64 %t292)
  %t294 = load i64, i64* %t270
  %t295 = getelementptr [3 x i8], [3 x i8]* @.str.975, i64 0, i64 0
  %t296 = ptrtoint i8* %t295 to i64
  %t297 = call i64 @kore_join(i64 %t294, i64 %t296)
  %t298 = call i64 @kore_str_concat(i64 %t293, i64 %t297)
  %t299 = getelementptr [2 x i8], [2 x i8]* @.str.976, i64 0, i64 0
  %t300 = ptrtoint i8* %t299 to i64
  %t301 = call i64 @kore_str_concat(i64 %t298, i64 %t300)
  ret i64 %t301
  endif1180:
  %t302 = load i64, i64* %t4
  %t303 = getelementptr [6 x i8], [6 x i8]* @.str.977, i64 0, i64 0
  %t304 = ptrtoint i8* %t303 to i64
  %t305 = call i64 @kore_str_eq(i64 %t302, i64 %t304)
  %t306 = icmp ne i64 %t305, 0
  br i1 %t306, label %then1185, label %endif1187
  then1185:
  %t307 = load i64, i64* %t1
  %t308 = call i64 @kore_variant_field(i64 %t307, i64 0)
  %t309 = alloca i64
  store i64 %t308, i64* %t309
  %t310 = load i64, i64* %t1
  %t311 = call i64 @kore_variant_field(i64 %t310, i64 1)
  %t312 = alloca i64
  store i64 %t311, i64* %t312
  %t313 = load i64, i64* %t0
  %t314 = load i64, i64* %t309
  %t315 = call i64 @RustGen_gen_expr(i64 %t313, i64 %t314)
  %t316 = getelementptr [2 x i8], [2 x i8]* @.str.978, i64 0, i64 0
  %t317 = ptrtoint i8* %t316 to i64
  %t318 = call i64 @kore_str_concat(i64 %t315, i64 %t317)
  %t319 = load i64, i64* %t0
  %t320 = load i64, i64* %t312
  %t321 = call i64 @RustGen_gen_expr(i64 %t319, i64 %t320)
  %t322 = call i64 @kore_str_concat(i64 %t318, i64 %t321)
  %t323 = getelementptr [2 x i8], [2 x i8]* @.str.979, i64 0, i64 0
  %t324 = ptrtoint i8* %t323 to i64
  %t325 = call i64 @kore_str_concat(i64 %t322, i64 %t324)
  ret i64 %t325
  endif1187:
  %t326 = load i64, i64* %t4
  %t327 = getelementptr [6 x i8], [6 x i8]* @.str.980, i64 0, i64 0
  %t328 = ptrtoint i8* %t327 to i64
  %t329 = call i64 @kore_str_eq(i64 %t326, i64 %t328)
  %t330 = icmp ne i64 %t329, 0
  br i1 %t330, label %then1188, label %endif1190
  then1188:
  %t331 = load i64, i64* %t1
  %t332 = call i64 @kore_variant_field(i64 %t331, i64 0)
  %t333 = alloca i64
  store i64 %t332, i64* %t333
  %t334 = load i64, i64* %t1
  %t335 = call i64 @kore_variant_field(i64 %t334, i64 1)
  %t336 = alloca i64
  store i64 %t335, i64* %t336
  %t337 = load i64, i64* %t0
  %t338 = load i64, i64* %t333
  %t339 = call i64 @RustGen_gen_expr(i64 %t337, i64 %t338)
  %t340 = getelementptr [2 x i8], [2 x i8]* @.str.981, i64 0, i64 0
  %t341 = ptrtoint i8* %t340 to i64
  %t342 = call i64 @kore_str_concat(i64 %t339, i64 %t341)
  %t343 = load i64, i64* %t336
  %t344 = call i64 @kore_str_concat(i64 %t342, i64 %t343)
  ret i64 %t344
  endif1190:
  %t345 = load i64, i64* %t4
  %t346 = getelementptr [6 x i8], [6 x i8]* @.str.982, i64 0, i64 0
  %t347 = ptrtoint i8* %t346 to i64
  %t348 = call i64 @kore_str_eq(i64 %t345, i64 %t347)
  %t349 = icmp ne i64 %t348, 0
  br i1 %t349, label %then1191, label %endif1193
  then1191:
  %t350 = load i64, i64* %t1
  %t351 = call i64 @kore_variant_field(i64 %t350, i64 0)
  %t352 = alloca i64
  store i64 %t351, i64* %t352
  %t353 = call i64 @kore_array_new()
  %t354 = alloca i64
  store i64 %t353, i64* %t354
  ; for e in ...
  %t355 = load i64, i64* %t352
  %t356 = call i64 @kore_array_len(i64 %t355)
  %t357 = alloca i64
  store i64 0, i64* %t357
  br label %for_cond1194
  for_cond1194:
  %t358 = load i64, i64* %t357
  %t359 = icmp slt i64 %t358, %t356
  br i1 %t359, label %for_body1195, label %for_end1197
  for_body1195:
  %t360 = call i64 @kore_array_get(i64 %t355, i64 %t358)
  %t361 = alloca i64
  store i64 %t360, i64* %t361
  %t362 = load i64, i64* %t354
  %t363 = load i64, i64* %t0
  %t364 = load i64, i64* %t361
  %t365 = call i64 @RustGen_gen_expr(i64 %t363, i64 %t364)
  %t366 = call i64 @kore_array_push(i64 %t362, i64 %t365)
  br label %for_update1196
  for_update1196:
  %t367 = load i64, i64* %t357
  %t368 = add i64 %t367, 1
  store i64 %t368, i64* %t357
  br label %for_cond1194
  for_end1197:
  %t369 = getelementptr [6 x i8], [6 x i8]* @.str.983, i64 0, i64 0
  %t370 = ptrtoint i8* %t369 to i64
  %t371 = load i64, i64* %t354
  %t372 = getelementptr [3 x i8], [3 x i8]* @.str.984, i64 0, i64 0
  %t373 = ptrtoint i8* %t372 to i64
  %t374 = call i64 @kore_join(i64 %t371, i64 %t373)
  %t375 = call i64 @kore_str_concat(i64 %t370, i64 %t374)
  %t376 = getelementptr [2 x i8], [2 x i8]* @.str.985, i64 0, i64 0
  %t377 = ptrtoint i8* %t376 to i64
  %t378 = call i64 @kore_str_concat(i64 %t375, i64 %t377)
  ret i64 %t378
  endif1193:
  %t379 = load i64, i64* %t4
  %t380 = getelementptr [7 x i8], [7 x i8]* @.str.986, i64 0, i64 0
  %t381 = ptrtoint i8* %t380 to i64
  %t382 = call i64 @kore_str_eq(i64 %t379, i64 %t381)
  %t383 = icmp ne i64 %t382, 0
  br i1 %t383, label %then1198, label %endif1200
  then1198:
  %t384 = load i64, i64* %t1
  %t385 = call i64 @kore_variant_field(i64 %t384, i64 0)
  %t386 = alloca i64
  store i64 %t385, i64* %t386
  %t387 = load i64, i64* %t1
  %t388 = call i64 @kore_variant_field(i64 %t387, i64 1)
  %t389 = alloca i64
  store i64 %t388, i64* %t389
  %t390 = call i64 @kore_array_new()
  %t391 = alloca i64
  store i64 %t390, i64* %t391
  ; for fi in ...
  %t392 = load i64, i64* %t389
  %t393 = call i64 @kore_array_len(i64 %t392)
  %t394 = alloca i64
  store i64 0, i64* %t394
  br label %for_cond1201
  for_cond1201:
  %t395 = load i64, i64* %t394
  %t396 = icmp slt i64 %t395, %t393
  br i1 %t396, label %for_body1202, label %for_end1204
  for_body1202:
  %t397 = call i64 @kore_array_get(i64 %t392, i64 %t395)
  %t398 = alloca i64
  store i64 %t397, i64* %t398
  %t399 = load i64, i64* %t391
  %t400 = load i64, i64* %t398
  %t401 = inttoptr i64 %t400 to %FieldInit*
  %t402 = getelementptr %FieldInit, %FieldInit* %t401, i32 0, i32 0
  %t403 = load i64, i64* %t402
  %t404 = getelementptr [3 x i8], [3 x i8]* @.str.987, i64 0, i64 0
  %t405 = ptrtoint i8* %t404 to i64
  %t406 = call i64 @kore_str_concat(i64 %t403, i64 %t405)
  %t407 = load i64, i64* %t0
  %t408 = load i64, i64* %t398
  %t409 = inttoptr i64 %t408 to %FieldInit*
  %t410 = getelementptr %FieldInit, %FieldInit* %t409, i32 0, i32 1
  %t411 = load i64, i64* %t410
  %t412 = call i64 @RustGen_gen_expr(i64 %t407, i64 %t411)
  %t413 = call i64 @kore_str_concat(i64 %t406, i64 %t412)
  %t414 = call i64 @kore_array_push(i64 %t399, i64 %t413)
  br label %for_update1203
  for_update1203:
  %t415 = load i64, i64* %t394
  %t416 = add i64 %t415, 1
  store i64 %t416, i64* %t394
  br label %for_cond1201
  for_end1204:
  %t417 = load i64, i64* %t386
  %t418 = getelementptr [4 x i8], [4 x i8]* @.str.988, i64 0, i64 0
  %t419 = ptrtoint i8* %t418 to i64
  %t420 = call i64 @kore_str_concat(i64 %t417, i64 %t419)
  %t421 = load i64, i64* %t391
  %t422 = getelementptr [3 x i8], [3 x i8]* @.str.989, i64 0, i64 0
  %t423 = ptrtoint i8* %t422 to i64
  %t424 = call i64 @kore_join(i64 %t421, i64 %t423)
  %t425 = call i64 @kore_str_concat(i64 %t420, i64 %t424)
  %t426 = getelementptr [3 x i8], [3 x i8]* @.str.990, i64 0, i64 0
  %t427 = ptrtoint i8* %t426 to i64
  %t428 = call i64 @kore_str_concat(i64 %t425, i64 %t427)
  ret i64 %t428
  endif1200:
  %t429 = load i64, i64* %t4
  %t430 = getelementptr [12 x i8], [12 x i8]* @.str.991, i64 0, i64 0
  %t431 = ptrtoint i8* %t430 to i64
  %t432 = call i64 @kore_str_eq(i64 %t429, i64 %t431)
  %t433 = icmp ne i64 %t432, 0
  br i1 %t433, label %then1205, label %endif1207
  then1205:
  %t434 = load i64, i64* %t1
  %t435 = call i64 @kore_variant_field(i64 %t434, i64 0)
  %t436 = alloca i64
  store i64 %t435, i64* %t436
  %t437 = load i64, i64* %t1
  %t438 = call i64 @kore_variant_field(i64 %t437, i64 1)
  %t439 = alloca i64
  store i64 %t438, i64* %t439
  %t440 = load i64, i64* %t1
  %t441 = call i64 @kore_variant_field(i64 %t440, i64 2)
  %t442 = alloca i64
  store i64 %t441, i64* %t442
  %t443 = load i64, i64* %t442
  %t444 = call i64 @kore_array_len(i64 %t443)
  %t445 = call i64 @kore_str_eq(i64 %t444, i64 0)
  %t446 = icmp ne i64 %t445, 0
  br i1 %t446, label %then1208, label %endif1210
  then1208:
  %t447 = load i64, i64* %t436
  %t448 = getelementptr [3 x i8], [3 x i8]* @.str.992, i64 0, i64 0
  %t449 = ptrtoint i8* %t448 to i64
  %t450 = call i64 @kore_str_concat(i64 %t447, i64 %t449)
  %t451 = load i64, i64* %t439
  %t452 = call i64 @kore_str_concat(i64 %t450, i64 %t451)
  ret i64 %t452
  endif1210:
  %t453 = call i64 @kore_array_new()
  %t454 = alloca i64
  store i64 %t453, i64* %t454
  ; for arg in ...
  %t455 = load i64, i64* %t442
  %t456 = call i64 @kore_array_len(i64 %t455)
  %t457 = alloca i64
  store i64 0, i64* %t457
  br label %for_cond1211
  for_cond1211:
  %t458 = load i64, i64* %t457
  %t459 = icmp slt i64 %t458, %t456
  br i1 %t459, label %for_body1212, label %for_end1214
  for_body1212:
  %t460 = call i64 @kore_array_get(i64 %t455, i64 %t458)
  %t461 = alloca i64
  store i64 %t460, i64* %t461
  %t462 = load i64, i64* %t454
  %t463 = load i64, i64* %t0
  %t464 = load i64, i64* %t461
  %t465 = call i64 @RustGen_gen_expr(i64 %t463, i64 %t464)
  %t466 = call i64 @kore_array_push(i64 %t462, i64 %t465)
  br label %for_update1213
  for_update1213:
  %t467 = load i64, i64* %t457
  %t468 = add i64 %t467, 1
  store i64 %t468, i64* %t457
  br label %for_cond1211
  for_end1214:
  %t469 = load i64, i64* %t436
  %t470 = getelementptr [3 x i8], [3 x i8]* @.str.993, i64 0, i64 0
  %t471 = ptrtoint i8* %t470 to i64
  %t472 = call i64 @kore_str_concat(i64 %t469, i64 %t471)
  %t473 = load i64, i64* %t439
  %t474 = call i64 @kore_str_concat(i64 %t472, i64 %t473)
  %t475 = getelementptr [2 x i8], [2 x i8]* @.str.994, i64 0, i64 0
  %t476 = ptrtoint i8* %t475 to i64
  %t477 = call i64 @kore_str_concat(i64 %t474, i64 %t476)
  %t478 = load i64, i64* %t454
  %t479 = getelementptr [3 x i8], [3 x i8]* @.str.995, i64 0, i64 0
  %t480 = ptrtoint i8* %t479 to i64
  %t481 = call i64 @kore_join(i64 %t478, i64 %t480)
  %t482 = call i64 @kore_str_concat(i64 %t477, i64 %t481)
  %t483 = getelementptr [2 x i8], [2 x i8]* @.str.996, i64 0, i64 0
  %t484 = ptrtoint i8* %t483 to i64
  %t485 = call i64 @kore_str_concat(i64 %t482, i64 %t484)
  ret i64 %t485
  endif1207:
  %t486 = load i64, i64* %t4
  %t487 = getelementptr [3 x i8], [3 x i8]* @.str.997, i64 0, i64 0
  %t488 = ptrtoint i8* %t487 to i64
  %t489 = call i64 @kore_str_eq(i64 %t486, i64 %t488)
  %t490 = icmp ne i64 %t489, 0
  br i1 %t490, label %then1215, label %endif1217
  then1215:
  %t491 = load i64, i64* %t1
  %t492 = call i64 @kore_variant_field(i64 %t491, i64 0)
  %t493 = alloca i64
  store i64 %t492, i64* %t493
  %t494 = load i64, i64* %t1
  %t495 = call i64 @kore_variant_field(i64 %t494, i64 1)
  %t496 = alloca i64
  store i64 %t495, i64* %t496
  %t497 = load i64, i64* %t1
  %t498 = call i64 @kore_variant_field(i64 %t497, i64 2)
  %t499 = alloca i64
  store i64 %t498, i64* %t499
  %t500 = load i64, i64* %t0
  %t501 = load i64, i64* %t493
  %t502 = call i64 @RustGen_gen_expr(i64 %t500, i64 %t501)
  %t503 = alloca i64
  store i64 %t502, i64* %t503
  %t504 = load i64, i64* %t0
  %t505 = load i64, i64* %t496
  %t506 = call i64 @RustGen_gen_expr(i64 %t504, i64 %t505)
  %t507 = alloca i64
  store i64 %t506, i64* %t507
  %t508 = load i64, i64* %t499
  %t510 = call i64 @kore_str_eq(i64 %t508, i64 0)
  %t511 = icmp eq i64 %t510, 0
  %t509 = zext i1 %t511 to i64
  %t512 = icmp ne i64 %t509, 0
  br i1 %t512, label %then1218, label %endif1220
  then1218:
  %t513 = getelementptr [5 x i8], [5 x i8]* @.str.998, i64 0, i64 0
  %t514 = ptrtoint i8* %t513 to i64
  %t515 = load i64, i64* %t503
  %t516 = call i64 @kore_str_concat(i64 %t514, i64 %t515)
  %t517 = getelementptr [4 x i8], [4 x i8]* @.str.999, i64 0, i64 0
  %t518 = ptrtoint i8* %t517 to i64
  %t519 = call i64 @kore_str_concat(i64 %t516, i64 %t518)
  %t520 = load i64, i64* %t507
  %t521 = call i64 @kore_str_concat(i64 %t519, i64 %t520)
  %t522 = getelementptr [11 x i8], [11 x i8]* @.str.1000, i64 0, i64 0
  %t523 = ptrtoint i8* %t522 to i64
  %t524 = call i64 @kore_str_concat(i64 %t521, i64 %t523)
  %t525 = load i64, i64* %t0
  %t526 = load i64, i64* %t499
  %t527 = call i64 @RustGen_gen_expr(i64 %t525, i64 %t526)
  %t528 = call i64 @kore_str_concat(i64 %t524, i64 %t527)
  %t529 = getelementptr [4 x i8], [4 x i8]* @.str.1001, i64 0, i64 0
  %t530 = ptrtoint i8* %t529 to i64
  %t531 = call i64 @kore_str_concat(i64 %t528, i64 %t530)
  ret i64 %t531
  endif1220:
  %t532 = getelementptr [5 x i8], [5 x i8]* @.str.1002, i64 0, i64 0
  %t533 = ptrtoint i8* %t532 to i64
  %t534 = load i64, i64* %t503
  %t535 = call i64 @kore_str_concat(i64 %t533, i64 %t534)
  %t536 = getelementptr [4 x i8], [4 x i8]* @.str.1003, i64 0, i64 0
  %t537 = ptrtoint i8* %t536 to i64
  %t538 = call i64 @kore_str_concat(i64 %t535, i64 %t537)
  %t539 = load i64, i64* %t507
  %t540 = call i64 @kore_str_concat(i64 %t538, i64 %t539)
  %t541 = getelementptr [16 x i8], [16 x i8]* @.str.1004, i64 0, i64 0
  %t542 = ptrtoint i8* %t541 to i64
  %t543 = call i64 @kore_str_concat(i64 %t540, i64 %t542)
  ret i64 %t543
  endif1217:
  %t544 = load i64, i64* %t4
  %t545 = getelementptr [7 x i8], [7 x i8]* @.str.1005, i64 0, i64 0
  %t546 = ptrtoint i8* %t545 to i64
  %t547 = call i64 @kore_str_eq(i64 %t544, i64 %t546)
  %t548 = icmp ne i64 %t547, 0
  br i1 %t548, label %then1221, label %endif1223
  then1221:
  %t549 = load i64, i64* %t1
  %t550 = call i64 @kore_variant_field(i64 %t549, i64 0)
  %t551 = alloca i64
  store i64 %t550, i64* %t551
  %t552 = load i64, i64* %t1
  %t553 = call i64 @kore_variant_field(i64 %t552, i64 1)
  %t554 = alloca i64
  store i64 %t553, i64* %t554
  %t555 = load i64, i64* %t551
  %t556 = getelementptr [3 x i8], [3 x i8]* @.str.1006, i64 0, i64 0
  %t557 = ptrtoint i8* %t556 to i64
  %t558 = call i64 @kore_join(i64 %t555, i64 %t557)
  %t559 = alloca i64
  store i64 %t558, i64* %t559
  %t560 = getelementptr [2 x i8], [2 x i8]* @.str.1007, i64 0, i64 0
  %t561 = ptrtoint i8* %t560 to i64
  %t562 = load i64, i64* %t559
  %t563 = call i64 @kore_str_concat(i64 %t561, i64 %t562)
  %t564 = getelementptr [3 x i8], [3 x i8]* @.str.1008, i64 0, i64 0
  %t565 = ptrtoint i8* %t564 to i64
  %t566 = call i64 @kore_str_concat(i64 %t563, i64 %t565)
  %t567 = load i64, i64* %t0
  %t568 = load i64, i64* %t554
  %t569 = call i64 @RustGen_gen_expr(i64 %t567, i64 %t568)
  %t570 = call i64 @kore_str_concat(i64 %t566, i64 %t569)
  ret i64 %t570
  endif1223:
  %t571 = load i64, i64* %t4
  %t572 = getelementptr [6 x i8], [6 x i8]* @.str.1009, i64 0, i64 0
  %t573 = ptrtoint i8* %t572 to i64
  %t574 = call i64 @kore_str_eq(i64 %t571, i64 %t573)
  %t575 = icmp ne i64 %t574, 0
  br i1 %t575, label %then1224, label %endif1226
  then1224:
  %t576 = load i64, i64* %t1
  %t577 = call i64 @kore_variant_field(i64 %t576, i64 0)
  %t578 = alloca i64
  store i64 %t577, i64* %t578
  %t579 = load i64, i64* %t0
  %t580 = load i64, i64* %t578
  %t581 = call i64 @RustGen_gen_expr(i64 %t579, i64 %t580)
  %t582 = getelementptr [7 x i8], [7 x i8]* @.str.1010, i64 0, i64 0
  %t583 = ptrtoint i8* %t582 to i64
  %t584 = call i64 @kore_str_concat(i64 %t581, i64 %t583)
  ret i64 %t584
  endif1226:
  %t585 = getelementptr [22 x i8], [22 x i8]* @.str.1011, i64 0, i64 0
  %t586 = ptrtoint i8* %t585 to i64
  %t587 = load i64, i64* %t4
  %t588 = call i64 @kore_str_concat(i64 %t586, i64 %t587)
  %t589 = getelementptr [4 x i8], [4 x i8]* @.str.1012, i64 0, i64 0
  %t590 = ptrtoint i8* %t589 to i64
  %t591 = call i64 @kore_str_concat(i64 %t588, i64 %t590)
  ret i64 %t591
}
define i64 @RustGen_gen_pattern(i64 %self, i64 %pattern) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %pattern, i64* %t1
  %t2 = load i64, i64* %t1
  %t3 = call i64 @kore_variant_of(i64 %t2)
  %t4 = alloca i64
  store i64 %t3, i64* %t4
  %t5 = load i64, i64* %t4
  %t6 = getelementptr [9 x i8], [9 x i8]* @.str.1013, i64 0, i64 0
  %t7 = ptrtoint i8* %t6 to i64
  %t8 = call i64 @kore_str_eq(i64 %t5, i64 %t7)
  %t9 = icmp ne i64 %t8, 0
  br i1 %t9, label %then1227, label %endif1229
  then1227:
  %t10 = getelementptr [2 x i8], [2 x i8]* @.str.1014, i64 0, i64 0
  %t11 = ptrtoint i8* %t10 to i64
  ret i64 %t11
  endif1229:
  %t12 = load i64, i64* %t4
  %t13 = getelementptr [6 x i8], [6 x i8]* @.str.1015, i64 0, i64 0
  %t14 = ptrtoint i8* %t13 to i64
  %t15 = call i64 @kore_str_eq(i64 %t12, i64 %t14)
  %t16 = icmp ne i64 %t15, 0
  br i1 %t16, label %then1230, label %endif1232
  then1230:
  %t17 = load i64, i64* %t1
  %t18 = call i64 @kore_variant_field(i64 %t17, i64 0)
  %t19 = alloca i64
  store i64 %t18, i64* %t19
  %t20 = load i64, i64* %t19
  ret i64 %t20
  endif1232:
  %t21 = load i64, i64* %t4
  %t22 = getelementptr [8 x i8], [8 x i8]* @.str.1016, i64 0, i64 0
  %t23 = ptrtoint i8* %t22 to i64
  %t24 = call i64 @kore_str_eq(i64 %t21, i64 %t23)
  %t25 = icmp ne i64 %t24, 0
  br i1 %t25, label %then1233, label %endif1235
  then1233:
  %t26 = load i64, i64* %t1
  %t27 = call i64 @kore_variant_field(i64 %t26, i64 0)
  %t28 = alloca i64
  store i64 %t27, i64* %t28
  %t29 = load i64, i64* %t0
  %t30 = load i64, i64* %t28
  %t31 = call i64 @RustGen_gen_expr(i64 %t29, i64 %t30)
  ret i64 %t31
  endif1235:
  %t32 = load i64, i64* %t4
  %t33 = getelementptr [8 x i8], [8 x i8]* @.str.1017, i64 0, i64 0
  %t34 = ptrtoint i8* %t33 to i64
  %t35 = call i64 @kore_str_eq(i64 %t32, i64 %t34)
  %t36 = icmp ne i64 %t35, 0
  br i1 %t36, label %then1236, label %endif1238
  then1236:
  %t37 = load i64, i64* %t1
  %t38 = call i64 @kore_variant_field(i64 %t37, i64 0)
  %t39 = alloca i64
  store i64 %t38, i64* %t39
  %t40 = load i64, i64* %t1
  %t41 = call i64 @kore_variant_field(i64 %t40, i64 1)
  %t42 = alloca i64
  store i64 %t41, i64* %t42
  %t43 = load i64, i64* %t42
  %t44 = call i64 @kore_array_len(i64 %t43)
  %t45 = call i64 @kore_str_eq(i64 %t44, i64 0)
  %t46 = icmp ne i64 %t45, 0
  br i1 %t46, label %then1239, label %endif1241
  then1239:
  %t47 = load i64, i64* %t39
  ret i64 %t47
  endif1241:
  %t48 = call i64 @kore_array_new()
  %t49 = alloca i64
  store i64 %t48, i64* %t49
  ; for f in ...
  %t50 = load i64, i64* %t42
  %t51 = call i64 @kore_array_len(i64 %t50)
  %t52 = alloca i64
  store i64 0, i64* %t52
  br label %for_cond1242
  for_cond1242:
  %t53 = load i64, i64* %t52
  %t54 = icmp slt i64 %t53, %t51
  br i1 %t54, label %for_body1243, label %for_end1245
  for_body1243:
  %t55 = call i64 @kore_array_get(i64 %t50, i64 %t53)
  %t56 = alloca i64
  store i64 %t55, i64* %t56
  %t57 = load i64, i64* %t49
  %t58 = load i64, i64* %t0
  %t59 = load i64, i64* %t56
  %t60 = call i64 @RustGen_gen_pattern(i64 %t58, i64 %t59)
  %t61 = call i64 @kore_array_push(i64 %t57, i64 %t60)
  br label %for_update1244
  for_update1244:
  %t62 = load i64, i64* %t52
  %t63 = add i64 %t62, 1
  store i64 %t63, i64* %t52
  br label %for_cond1242
  for_end1245:
  %t64 = load i64, i64* %t39
  %t65 = getelementptr [2 x i8], [2 x i8]* @.str.1018, i64 0, i64 0
  %t66 = ptrtoint i8* %t65 to i64
  %t67 = call i64 @kore_str_concat(i64 %t64, i64 %t66)
  %t68 = load i64, i64* %t49
  %t69 = getelementptr [3 x i8], [3 x i8]* @.str.1019, i64 0, i64 0
  %t70 = ptrtoint i8* %t69 to i64
  %t71 = call i64 @kore_join(i64 %t68, i64 %t70)
  %t72 = call i64 @kore_str_concat(i64 %t67, i64 %t71)
  %t73 = getelementptr [2 x i8], [2 x i8]* @.str.1020, i64 0, i64 0
  %t74 = ptrtoint i8* %t73 to i64
  %t75 = call i64 @kore_str_concat(i64 %t72, i64 %t74)
  ret i64 %t75
  endif1238:
  %t76 = getelementptr [26 x i8], [26 x i8]* @.str.1021, i64 0, i64 0
  %t77 = ptrtoint i8* %t76 to i64
  ret i64 %t77
}
define i64 @RustGen_map_type(i64 %self, i64 %ty) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %ty, i64* %t1
  %t2 = load i64, i64* %t1
  %t3 = getelementptr [4 x i8], [4 x i8]* @.str.1022, i64 0, i64 0
  %t4 = ptrtoint i8* %t3 to i64
  %t5 = call i64 @kore_str_eq(i64 %t2, i64 %t4)
  %t6 = icmp ne i64 %t5, 0
  br i1 %t6, label %then1246, label %endif1248
  then1246:
  %t7 = getelementptr [4 x i8], [4 x i8]* @.str.1023, i64 0, i64 0
  %t8 = ptrtoint i8* %t7 to i64
  ret i64 %t8
  endif1248:
  %t9 = load i64, i64* %t1
  %t10 = getelementptr [6 x i8], [6 x i8]* @.str.1024, i64 0, i64 0
  %t11 = ptrtoint i8* %t10 to i64
  %t12 = call i64 @kore_str_eq(i64 %t9, i64 %t11)
  %t13 = icmp ne i64 %t12, 0
  br i1 %t13, label %then1249, label %endif1251
  then1249:
  %t14 = getelementptr [4 x i8], [4 x i8]* @.str.1025, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  ret i64 %t15
  endif1251:
  %t16 = load i64, i64* %t1
  %t17 = getelementptr [5 x i8], [5 x i8]* @.str.1026, i64 0, i64 0
  %t18 = ptrtoint i8* %t17 to i64
  %t19 = call i64 @kore_str_eq(i64 %t16, i64 %t18)
  %t20 = icmp ne i64 %t19, 0
  br i1 %t20, label %then1252, label %endif1254
  then1252:
  %t21 = getelementptr [5 x i8], [5 x i8]* @.str.1027, i64 0, i64 0
  %t22 = ptrtoint i8* %t21 to i64
  ret i64 %t22
  endif1254:
  %t23 = load i64, i64* %t1
  %t24 = getelementptr [7 x i8], [7 x i8]* @.str.1028, i64 0, i64 0
  %t25 = ptrtoint i8* %t24 to i64
  %t26 = call i64 @kore_str_eq(i64 %t23, i64 %t25)
  %t27 = icmp ne i64 %t26, 0
  br i1 %t27, label %then1255, label %endif1257
  then1255:
  %t28 = getelementptr [7 x i8], [7 x i8]* @.str.1029, i64 0, i64 0
  %t29 = ptrtoint i8* %t28 to i64
  ret i64 %t29
  endif1257:
  %t30 = load i64, i64* %t1
  %t31 = getelementptr [5 x i8], [5 x i8]* @.str.1030, i64 0, i64 0
  %t32 = ptrtoint i8* %t31 to i64
  %t33 = call i64 @kore_str_eq(i64 %t30, i64 %t32)
  %t34 = icmp ne i64 %t33, 0
  br i1 %t34, label %then1258, label %endif1260
  then1258:
  %t35 = getelementptr [3 x i8], [3 x i8]* @.str.1031, i64 0, i64 0
  %t36 = ptrtoint i8* %t35 to i64
  ret i64 %t36
  endif1260:
  %t37 = load i64, i64* %t1
  %t38 = getelementptr [6 x i8], [6 x i8]* @.str.1032, i64 0, i64 0
  %t39 = ptrtoint i8* %t38 to i64
  %t40 = call i64 @kore_str_eq(i64 %t37, i64 %t39)
  %t41 = icmp ne i64 %t40, 0
  br i1 %t41, label %then1261, label %endif1263
  then1261:
  %t42 = getelementptr [9 x i8], [9 x i8]* @.str.1033, i64 0, i64 0
  %t43 = ptrtoint i8* %t42 to i64
  ret i64 %t43
  endif1263:
  %t44 = load i64, i64* %t1
  %t45 = getelementptr [7 x i8], [7 x i8]* @.str.1034, i64 0, i64 0
  %t46 = ptrtoint i8* %t45 to i64
  %t47 = call i64 @starts_with(i64 %t44, i64 %t46)
  %t48 = icmp ne i64 %t47, 0
  br i1 %t48, label %then1264, label %endif1266
  then1264:
  %t49 = load i64, i64* %t1
  %t50 = load i64, i64* %t1
  %t51 = call i64 @kore_str_len(i64 %t50)
  %t52 = sub i64 %t51, 1
  %t53 = call i64 @kore_substring(i64 %t49, i64 6, i64 %t52)
  %t54 = alloca i64
  store i64 %t53, i64* %t54
  %t55 = getelementptr [5 x i8], [5 x i8]* @.str.1035, i64 0, i64 0
  %t56 = ptrtoint i8* %t55 to i64
  %t57 = load i64, i64* %t0
  %t58 = load i64, i64* %t54
  %t59 = call i64 @RustGen_map_type(i64 %t57, i64 %t58)
  %t60 = call i64 @kore_str_concat(i64 %t56, i64 %t59)
  %t61 = getelementptr [2 x i8], [2 x i8]* @.str.1036, i64 0, i64 0
  %t62 = ptrtoint i8* %t61 to i64
  %t63 = call i64 @kore_str_concat(i64 %t60, i64 %t62)
  ret i64 %t63
  endif1266:
  %t64 = load i64, i64* %t1
  %t65 = getelementptr [8 x i8], [8 x i8]* @.str.1037, i64 0, i64 0
  %t66 = ptrtoint i8* %t65 to i64
  %t67 = call i64 @starts_with(i64 %t64, i64 %t66)
  %t68 = icmp ne i64 %t67, 0
  br i1 %t68, label %then1267, label %endif1269
  then1267:
  %t69 = load i64, i64* %t1
  %t70 = load i64, i64* %t1
  %t71 = call i64 @kore_str_len(i64 %t70)
  %t72 = sub i64 %t71, 1
  %t73 = call i64 @kore_substring(i64 %t69, i64 7, i64 %t72)
  %t74 = alloca i64
  store i64 %t73, i64* %t74
  %t75 = getelementptr [8 x i8], [8 x i8]* @.str.1038, i64 0, i64 0
  %t76 = ptrtoint i8* %t75 to i64
  %t77 = load i64, i64* %t0
  %t78 = load i64, i64* %t74
  %t79 = call i64 @RustGen_map_type(i64 %t77, i64 %t78)
  %t80 = call i64 @kore_str_concat(i64 %t76, i64 %t79)
  %t81 = getelementptr [2 x i8], [2 x i8]* @.str.1039, i64 0, i64 0
  %t82 = ptrtoint i8* %t81 to i64
  %t83 = call i64 @kore_str_concat(i64 %t80, i64 %t82)
  ret i64 %t83
  endif1269:
  %t84 = load i64, i64* %t1
  ret i64 %t84
}
define i64 @RustGen_map_op(i64 %self, i64 %op) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %op, i64* %t1
  %t2 = load i64, i64* %t1
  %t3 = getelementptr [4 x i8], [4 x i8]* @.str.1040, i64 0, i64 0
  %t4 = ptrtoint i8* %t3 to i64
  %t5 = call i64 @kore_str_eq(i64 %t2, i64 %t4)
  %t6 = icmp ne i64 %t5, 0
  br i1 %t6, label %then1270, label %endif1272
  then1270:
  %t7 = getelementptr [3 x i8], [3 x i8]* @.str.1041, i64 0, i64 0
  %t8 = ptrtoint i8* %t7 to i64
  ret i64 %t8
  endif1272:
  %t9 = load i64, i64* %t1
  %t10 = getelementptr [3 x i8], [3 x i8]* @.str.1042, i64 0, i64 0
  %t11 = ptrtoint i8* %t10 to i64
  %t12 = call i64 @kore_str_eq(i64 %t9, i64 %t11)
  %t13 = icmp ne i64 %t12, 0
  br i1 %t13, label %then1273, label %endif1275
  then1273:
  %t14 = getelementptr [3 x i8], [3 x i8]* @.str.1043, i64 0, i64 0
  %t15 = ptrtoint i8* %t14 to i64
  ret i64 %t15
  endif1275:
  %t16 = load i64, i64* %t1
  %t17 = getelementptr [4 x i8], [4 x i8]* @.str.1044, i64 0, i64 0
  %t18 = ptrtoint i8* %t17 to i64
  %t19 = call i64 @kore_str_eq(i64 %t16, i64 %t18)
  %t20 = icmp ne i64 %t19, 0
  br i1 %t20, label %then1276, label %endif1278
  then1276:
  %t21 = getelementptr [2 x i8], [2 x i8]* @.str.1045, i64 0, i64 0
  %t22 = ptrtoint i8* %t21 to i64
  ret i64 %t22
  endif1278:
  %t23 = load i64, i64* %t1
  ret i64 %t23
}
define i64 @RustGen_escape_string(i64 %self, i64 %s) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %s, i64* %t1
  %t2 = getelementptr [1 x i8], [1 x i8]* @.str.1046, i64 0, i64 0
  %t3 = ptrtoint i8* %t2 to i64
  %t4 = alloca i64
  store i64 %t3, i64* %t4
  %t5 = load i64, i64* %t1
  %t6 = getelementptr [1 x i8], [1 x i8]* @.str.1047, i64 0, i64 0
  %t7 = ptrtoint i8* %t6 to i64
  %t8 = call i64 @kore_split(i64 %t5, i64 %t7)
  %t9 = alloca i64
  store i64 %t8, i64* %t9
  ; for c in ...
  %t10 = load i64, i64* %t9
  %t11 = call i64 @kore_array_len(i64 %t10)
  %t12 = alloca i64
  store i64 0, i64* %t12
  br label %for_cond1279
  for_cond1279:
  %t13 = load i64, i64* %t12
  %t14 = icmp slt i64 %t13, %t11
  br i1 %t14, label %for_body1280, label %for_end1282
  for_body1280:
  %t15 = call i64 @kore_array_get(i64 %t10, i64 %t13)
  %t16 = alloca i64
  store i64 %t15, i64* %t16
  %t17 = load i64, i64* %t16
  %t18 = getelementptr [2 x i8], [2 x i8]* @.str.1048, i64 0, i64 0
  %t19 = ptrtoint i8* %t18 to i64
  %t20 = call i64 @kore_str_eq(i64 %t17, i64 %t19)
  %t21 = icmp ne i64 %t20, 0
  br i1 %t21, label %then1283, label %else1284
  then1283:
  %t22 = load i64, i64* %t4
  %t23 = getelementptr [3 x i8], [3 x i8]* @.str.1049, i64 0, i64 0
  %t24 = ptrtoint i8* %t23 to i64
  %t25 = call i64 @kore_str_concat(i64 %t22, i64 %t24)
  store i64 %t25, i64* %t4
  br label %endif1285
  else1284:
  %t26 = load i64, i64* %t16
  %t27 = getelementptr [2 x i8], [2 x i8]* @.str.1050, i64 0, i64 0
  %t28 = ptrtoint i8* %t27 to i64
  %t29 = call i64 @kore_str_eq(i64 %t26, i64 %t28)
  %t30 = icmp ne i64 %t29, 0
  br i1 %t30, label %then1286, label %else1287
  then1286:
  %t31 = load i64, i64* %t4
  %t32 = getelementptr [3 x i8], [3 x i8]* @.str.1051, i64 0, i64 0
  %t33 = ptrtoint i8* %t32 to i64
  %t34 = call i64 @kore_str_concat(i64 %t31, i64 %t33)
  store i64 %t34, i64* %t4
  br label %endif1288
  else1287:
  %t35 = load i64, i64* %t16
  %t36 = getelementptr [2 x i8], [2 x i8]* @.str.1052, i64 0, i64 0
  %t37 = ptrtoint i8* %t36 to i64
  %t38 = call i64 @kore_str_eq(i64 %t35, i64 %t37)
  %t39 = icmp ne i64 %t38, 0
  br i1 %t39, label %then1289, label %else1290
  then1289:
  %t40 = load i64, i64* %t4
  %t41 = getelementptr [3 x i8], [3 x i8]* @.str.1053, i64 0, i64 0
  %t42 = ptrtoint i8* %t41 to i64
  %t43 = call i64 @kore_str_concat(i64 %t40, i64 %t42)
  store i64 %t43, i64* %t4
  br label %endif1291
  else1290:
  %t44 = load i64, i64* %t16
  %t45 = getelementptr [1 x i8], [1 x i8]* @.str.1054, i64 0, i64 0
  %t46 = ptrtoint i8* %t45 to i64
  %t47 = call i64 @kore_str_eq(i64 %t44, i64 %t46)
  %t48 = icmp ne i64 %t47, 0
  br i1 %t48, label %then1292, label %else1293
  then1292:
  %t49 = load i64, i64* %t4
  %t50 = getelementptr [2 x i8], [2 x i8]* @.str.1055, i64 0, i64 0
  %t51 = ptrtoint i8* %t50 to i64
  %t52 = call i64 @kore_str_concat(i64 %t49, i64 %t51)
  store i64 %t52, i64* %t4
  br label %endif1294
  else1293:
  %t53 = load i64, i64* %t4
  %t54 = load i64, i64* %t16
  %t55 = call i64 @kore_str_concat(i64 %t53, i64 %t54)
  store i64 %t55, i64* %t4
  br label %endif1294
  endif1294:
  br label %endif1291
  endif1291:
  br label %endif1288
  endif1288:
  br label %endif1285
  endif1285:
  br label %for_update1281
  for_update1281:
  %t56 = load i64, i64* %t12
  %t57 = add i64 %t56, 1
  store i64 %t57, i64* %t12
  br label %for_cond1279
  for_end1282:
  %t58 = load i64, i64* %t4
  ret i64 %t58
}

; impl Path
define i64 @Path_new(i64 %path) {
  entry:
  %t0 = alloca i64
  store i64 %path, i64* %t0
  ; struct literal: Path
  %t1 = call i8* @malloc(i64 8)
  %t2 = bitcast i8* %t1 to %Path*
  %t3 = load i64, i64* %t0
  %t4 = getelementptr %Path, %Path* %t2, i32 0, i32 0
  store i64 %t3, i64* %t4
  %t5 = ptrtoint %Path* %t2 to i64
  ret i64 %t5
}
define i64 @Path_with_extension(i64 %self, i64 %ext) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %ext, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = inttoptr i64 %t2 to %Path*
  %t4 = getelementptr %Path, %Path* %t3, i32 0, i32 0
  %t5 = load i64, i64* %t4
  %t6 = alloca i64
  store i64 %t5, i64* %t6
  %t7 = load i64, i64* %t6
  %t8 = getelementptr [2 x i8], [2 x i8]* @.str.1056, i64 0, i64 0
  %t9 = ptrtoint i8* %t8 to i64
  %t10 = call i64 @kore_str_concat(i64 %t7, i64 %t9)
  %t11 = load i64, i64* %t1
  %t12 = call i64 @kore_str_concat(i64 %t10, i64 %t11)
  ret i64 %t12
}
define i64 @Path_parent(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = getelementptr [2 x i8], [2 x i8]* @.str.1057, i64 0, i64 0
  %t2 = ptrtoint i8* %t1 to i64
  ret i64 %t2
}
define i64 @Path_stem(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = getelementptr [8 x i8], [8 x i8]* @.str.1058, i64 0, i64 0
  %t2 = ptrtoint i8* %t1 to i64
  ret i64 %t2
}

; impl ArgParser
define i64 @ArgParser_new() {
  entry:
  ; struct literal: ArgParser
  %t0 = call i8* @malloc(i64 8)
  %t1 = bitcast i8* %t0 to %ArgParser*
  %t2 = call i64 @args()
  %t3 = getelementptr %ArgParser, %ArgParser* %t1, i32 0, i32 0
  store i64 %t2, i64* %t3
  %t4 = ptrtoint %ArgParser* %t1 to i64
  ret i64 %t4
}
define i64 @ArgParser_get_value(i64 %self, i64 %flag) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %flag, i64* %t1
  %t2 = alloca i64
  store i64 0, i64* %t2
  br label %while_cond1295
  while_cond1295:
  %t3 = load i64, i64* %t2
  %t4 = load i64, i64* %t0
  %t5 = inttoptr i64 %t4 to %ArgParser*
  %t6 = getelementptr %ArgParser, %ArgParser* %t5, i32 0, i32 0
  %t7 = load i64, i64* %t6
  %t8 = call i64 @kore_array_len(i64 %t7)
  %t9 = sub i64 %t8, 1
  %t11 = icmp slt i64 %t3, %t9
  %t10 = zext i1 %t11 to i64
  %t12 = icmp ne i64 %t10, 0
  br i1 %t12, label %while_body1296, label %while_end1297
  while_body1296:
  %t13 = load i64, i64* %t0
  %t14 = inttoptr i64 %t13 to %ArgParser*
  %t15 = getelementptr %ArgParser, %ArgParser* %t14, i32 0, i32 0
  %t16 = load i64, i64* %t15
  %t17 = load i64, i64* %t2
  %t18 = call i64 @kore_array_get(i64 %t16, i64 %t17)
  %t19 = load i64, i64* %t1
  %t20 = call i64 @kore_str_eq(i64 %t18, i64 %t19)
  %t21 = icmp ne i64 %t20, 0
  br i1 %t21, label %then1298, label %endif1300
  then1298:
  ; enum variant: Option::Some
  %t22 = call i8* @malloc(i64 24)
  %t23 = bitcast i8* %t22 to %Option*
  %t24 = getelementptr %Option, %Option* %t23, i32 0, i32 0
  store i64 1, i64* %t24
  %t25 = call i8* @malloc(i64 8)
  %t26 = bitcast i8* %t25 to i64*
  %t27 = load i64, i64* %t0
  %t28 = inttoptr i64 %t27 to %ArgParser*
  %t29 = getelementptr %ArgParser, %ArgParser* %t28, i32 0, i32 0
  %t30 = load i64, i64* %t29
  %t31 = load i64, i64* %t2
  %t32 = add i64 %t31, 1
  %t33 = call i64 @kore_array_get(i64 %t30, i64 %t32)
  %t34 = getelementptr i64, i64* %t26, i32 0
  store i64 %t33, i64* %t34
  %t35 = getelementptr %Option, %Option* %t23, i32 0, i32 1
  store i8* %t25, i8** %t35
  %t36 = getelementptr %Option, %Option* %t23, i32 0, i32 2
  %t37 = getelementptr [5 x i8], [5 x i8]* @.str.1059, i64 0, i64 0
  store i8* %t37, i8** %t36
  %t38 = ptrtoint %Option* %t23 to i64
  ret i64 %t38
  endif1300:
  %t39 = load i64, i64* %t2
  %t40 = add i64 %t39, 1
  store i64 %t40, i64* %t2
  br label %while_cond1295
  while_end1297:
  ; enum variant: Option::None
  %t41 = call i8* @malloc(i64 24)
  %t42 = bitcast i8* %t41 to %Option*
  %t43 = getelementptr %Option, %Option* %t42, i32 0, i32 0
  store i64 0, i64* %t43
  %t44 = getelementptr %Option, %Option* %t42, i32 0, i32 1
  store i8* null, i8** %t44
  %t45 = getelementptr %Option, %Option* %t42, i32 0, i32 2
  %t46 = getelementptr [5 x i8], [5 x i8]* @.str.1060, i64 0, i64 0
  store i8* %t46, i8** %t45
  %t47 = ptrtoint %Option* %t42 to i64
  ret i64 %t47
}
define i64 @ArgParser_has_flag(i64 %self, i64 %flag) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 %flag, i64* %t1
  ; for arg in ...
  %t2 = load i64, i64* %t0
  %t3 = inttoptr i64 %t2 to %ArgParser*
  %t4 = getelementptr %ArgParser, %ArgParser* %t3, i32 0, i32 0
  %t5 = load i64, i64* %t4
  %t6 = call i64 @kore_array_len(i64 %t5)
  %t7 = alloca i64
  store i64 0, i64* %t7
  br label %for_cond1301
  for_cond1301:
  %t8 = load i64, i64* %t7
  %t9 = icmp slt i64 %t8, %t6
  br i1 %t9, label %for_body1302, label %for_end1304
  for_body1302:
  %t10 = call i64 @kore_array_get(i64 %t5, i64 %t8)
  %t11 = alloca i64
  store i64 %t10, i64* %t11
  %t12 = load i64, i64* %t11
  %t13 = load i64, i64* %t1
  %t14 = call i64 @kore_str_eq(i64 %t12, i64 %t13)
  %t15 = icmp ne i64 %t14, 0
  br i1 %t15, label %then1305, label %endif1307
  then1305:
  ret i64 1
  endif1307:
  br label %for_update1303
  for_update1303:
  %t16 = load i64, i64* %t7
  %t17 = add i64 %t16, 1
  store i64 %t17, i64* %t7
  br label %for_cond1301
  for_end1304:
  ret i64 0
}
define i64 @ArgParser_input_file(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = alloca i64
  store i64 1, i64* %t1
  br label %while_cond1308
  while_cond1308:
  %t2 = load i64, i64* %t1
  %t3 = load i64, i64* %t0
  %t4 = inttoptr i64 %t3 to %ArgParser*
  %t5 = getelementptr %ArgParser, %ArgParser* %t4, i32 0, i32 0
  %t6 = load i64, i64* %t5
  %t7 = call i64 @kore_array_len(i64 %t6)
  %t9 = icmp slt i64 %t2, %t7
  %t8 = zext i1 %t9 to i64
  %t10 = icmp ne i64 %t8, 0
  br i1 %t10, label %while_body1309, label %while_end1310
  while_body1309:
  %t11 = load i64, i64* %t0
  %t12 = inttoptr i64 %t11 to %ArgParser*
  %t13 = getelementptr %ArgParser, %ArgParser* %t12, i32 0, i32 0
  %t14 = load i64, i64* %t13
  %t15 = load i64, i64* %t1
  %t16 = call i64 @kore_array_get(i64 %t14, i64 %t15)
  %t17 = alloca i64
  store i64 %t16, i64* %t17
  %t18 = load i64, i64* %t17
  %t19 = call i64 @kore_substring(i64 %t18, i64 0, i64 1)
  %t20 = alloca i64
  store i64 %t19, i64* %t20
  %t21 = load i64, i64* %t20
  %t22 = getelementptr [2 x i8], [2 x i8]* @.str.1061, i64 0, i64 0
  %t23 = ptrtoint i8* %t22 to i64
  %t24 = call i64 @kore_str_eq(i64 %t21, i64 %t23)
  %t26 = icmp eq i64 %t24, 0
  %t25 = zext i1 %t26 to i64
  %t27 = icmp ne i64 %t25, 0
  br i1 %t27, label %then1311, label %endif1313
  then1311:
  %t28 = load i64, i64* %t0
  %t29 = inttoptr i64 %t28 to %ArgParser*
  %t30 = getelementptr %ArgParser, %ArgParser* %t29, i32 0, i32 0
  %t31 = load i64, i64* %t30
  %t32 = load i64, i64* %t1
  %t33 = sub i64 %t32, 1
  %t34 = call i64 @kore_array_get(i64 %t31, i64 %t33)
  %t35 = alloca i64
  store i64 %t34, i64* %t35
  %t36 = load i64, i64* %t35
  %t37 = getelementptr [3 x i8], [3 x i8]* @.str.1062, i64 0, i64 0
  %t38 = ptrtoint i8* %t37 to i64
  %t39 = call i64 @kore_str_eq(i64 %t36, i64 %t38)
  %t41 = icmp eq i64 %t39, 0
  %t40 = zext i1 %t41 to i64
  %t42 = load i64, i64* %t35
  %t43 = getelementptr [9 x i8], [9 x i8]* @.str.1063, i64 0, i64 0
  %t44 = ptrtoint i8* %t43 to i64
  %t45 = call i64 @kore_str_eq(i64 %t42, i64 %t44)
  %t47 = icmp eq i64 %t45, 0
  %t46 = zext i1 %t47 to i64
  %t48 = and i64 %t40, %t46
  %t49 = icmp ne i64 %t48, 0
  br i1 %t49, label %then1314, label %endif1316
  then1314:
  ; enum variant: Option::Some
  %t50 = call i8* @malloc(i64 24)
  %t51 = bitcast i8* %t50 to %Option*
  %t52 = getelementptr %Option, %Option* %t51, i32 0, i32 0
  store i64 1, i64* %t52
  %t53 = call i8* @malloc(i64 8)
  %t54 = bitcast i8* %t53 to i64*
  %t55 = load i64, i64* %t17
  %t56 = getelementptr i64, i64* %t54, i32 0
  store i64 %t55, i64* %t56
  %t57 = getelementptr %Option, %Option* %t51, i32 0, i32 1
  store i8* %t53, i8** %t57
  %t58 = getelementptr %Option, %Option* %t51, i32 0, i32 2
  %t59 = getelementptr [5 x i8], [5 x i8]* @.str.1064, i64 0, i64 0
  store i8* %t59, i8** %t58
  %t60 = ptrtoint %Option* %t51 to i64
  ret i64 %t60
  endif1316:
  br label %endif1313
  endif1313:
  %t61 = load i64, i64* %t1
  %t62 = add i64 %t61, 1
  store i64 %t62, i64* %t1
  br label %while_cond1308
  while_end1310:
  ; enum variant: Option::None
  %t63 = call i8* @malloc(i64 24)
  %t64 = bitcast i8* %t63 to %Option*
  %t65 = getelementptr %Option, %Option* %t64, i32 0, i32 0
  store i64 0, i64* %t65
  %t66 = getelementptr %Option, %Option* %t64, i32 0, i32 1
  store i8* null, i8** %t66
  %t67 = getelementptr %Option, %Option* %t64, i32 0, i32 2
  %t68 = getelementptr [5 x i8], [5 x i8]* @.str.1065, i64 0, i64 0
  store i8* %t68, i8** %t67
  %t69 = ptrtoint %Option* %t64 to i64
  ret i64 %t69
}

; impl CompilerConfig
define i64 @CompilerConfig_from_args() {
  entry:
  %t0 = call i64 @ArgParser_new()
  %t1 = alloca i64
  store i64 %t0, i64* %t1
  %t2 = load i64, i64* %t1
  %t3 = getelementptr [3 x i8], [3 x i8]* @.str.1066, i64 0, i64 0
  %t4 = ptrtoint i8* %t3 to i64
  %t5 = call i64 @ArgParser_get_value(i64 %t2, i64 %t4)
  %t6 = alloca i64
  store i64 %t5, i64* %t6
  %t7 = load i64, i64* %t1
  %t8 = getelementptr [10 x i8], [10 x i8]* @.str.1067, i64 0, i64 0
  %t9 = ptrtoint i8* %t8 to i64
  %t10 = call i64 @ArgParser_has_flag(i64 %t7, i64 %t9)
  %t11 = load i64, i64* %t1
  %t12 = getelementptr [3 x i8], [3 x i8]* @.str.1068, i64 0, i64 0
  %t13 = ptrtoint i8* %t12 to i64
  %t14 = call i64 @ArgParser_has_flag(i64 %t11, i64 %t13)
  %t15 = or i64 %t10, %t14
  %t16 = alloca i64
  store i64 %t15, i64* %t16
  %t17 = getelementptr [1 x i8], [1 x i8]* @.str.1069, i64 0, i64 0
  %t18 = ptrtoint i8* %t17 to i64
  %t19 = alloca i64
  store i64 %t18, i64* %t19
  ; match
  %t20 = load i64, i64* %t1
  %t21 = call i64 @ArgParser_input_file(i64 %t20)
  %t22 = inttoptr i64 %t21 to { i64, i8* }*
  %t23 = getelementptr { i64, i8* }, { i64, i8* }* %t22, i32 0, i32 0
  %t24 = load i64, i64* %t23
  %t25 = icmp eq i64 %t24, 1
  br i1 %t25, label %match_body1319, label %match_next1318
  match_body1319:
  %t26 = getelementptr { i64, i8* }, { i64, i8* }* %t22, i32 0, i32 1
  %t27 = load i8*, i8** %t26
  %t28 = ptrtoint i8* %t27 to i64
  %t29 = inttoptr i64 %t28 to i64*
  %t30 = getelementptr i64, i64* %t29, i32 0
  %t31 = load i64, i64* %t30
  %t32 = alloca i64
  store i64 %t31, i64* %t32
  %t33 = load i64, i64* %t32
  store i64 %t33, i64* %t19
  br label %match_end1317
  match_next1318:
  %t34 = inttoptr i64 %t21 to { i64, i8* }*
  %t35 = getelementptr { i64, i8* }, { i64, i8* }* %t34, i32 0, i32 0
  %t36 = load i64, i64* %t35
  %t37 = icmp eq i64 %t36, 0
  br i1 %t37, label %match_body1321, label %match_next1320
  match_body1321:
  %t38 = getelementptr [31 x i8], [31 x i8]* @.str.1070, i64 0, i64 0
  %t39 = ptrtoint i8* %t38 to i64
  %t40 = inttoptr i64 %t39 to i8*
  call void @kore_println_str(i8* %t40)
  %t41 = call i64 @exit(i64 1)
  br label %match_end1317
  match_next1320:
  br label %match_end1317
  match_end1317:
  ; enum variant: Target::LLVM
  %t42 = call i8* @malloc(i64 24)
  %t43 = bitcast i8* %t42 to %Target*
  %t44 = getelementptr %Target, %Target* %t43, i32 0, i32 0
  store i64 0, i64* %t44
  %t45 = getelementptr %Target, %Target* %t43, i32 0, i32 1
  store i8* null, i8** %t45
  %t46 = getelementptr %Target, %Target* %t43, i32 0, i32 2
  %t47 = getelementptr [5 x i8], [5 x i8]* @.str.1071, i64 0, i64 0
  store i8* %t47, i8** %t46
  %t48 = ptrtoint %Target* %t43 to i64
  %t49 = alloca i64
  store i64 %t48, i64* %t49
  ; match
  %t50 = load i64, i64* %t1
  %t51 = getelementptr [9 x i8], [9 x i8]* @.str.1072, i64 0, i64 0
  %t52 = ptrtoint i8* %t51 to i64
  %t53 = call i64 @ArgParser_get_value(i64 %t50, i64 %t52)
  %t54 = inttoptr i64 %t53 to { i64, i8* }*
  %t55 = getelementptr { i64, i8* }, { i64, i8* }* %t54, i32 0, i32 0
  %t56 = load i64, i64* %t55
  %t57 = icmp eq i64 %t56, 1
  br i1 %t57, label %match_body1324, label %match_next1323
  match_body1324:
  %t58 = getelementptr { i64, i8* }, { i64, i8* }* %t54, i32 0, i32 1
  %t59 = load i8*, i8** %t58
  %t60 = ptrtoint i8* %t59 to i64
  %t61 = inttoptr i64 %t60 to i64*
  %t62 = getelementptr i64, i64* %t61, i32 0
  %t63 = load i64, i64* %t62
  %t64 = alloca i64
  store i64 %t63, i64* %t64
  %t65 = load i64, i64* %t64
  %t66 = getelementptr [5 x i8], [5 x i8]* @.str.1073, i64 0, i64 0
  %t67 = ptrtoint i8* %t66 to i64
  %t68 = call i64 @kore_str_eq(i64 %t65, i64 %t67)
  %t69 = icmp ne i64 %t68, 0
  br i1 %t69, label %then1325, label %else1326
  then1325:
  ; enum variant: Target::Rust
  %t70 = call i8* @malloc(i64 24)
  %t71 = bitcast i8* %t70 to %Target*
  %t72 = getelementptr %Target, %Target* %t71, i32 0, i32 0
  store i64 1, i64* %t72
  %t73 = getelementptr %Target, %Target* %t71, i32 0, i32 1
  store i8* null, i8** %t73
  %t74 = getelementptr %Target, %Target* %t71, i32 0, i32 2
  %t75 = getelementptr [5 x i8], [5 x i8]* @.str.1074, i64 0, i64 0
  store i8* %t75, i8** %t74
  %t76 = ptrtoint %Target* %t71 to i64
  store i64 %t76, i64* %t49
  br label %endif1327
  else1326:
  %t77 = load i64, i64* %t64
  %t78 = getelementptr [5 x i8], [5 x i8]* @.str.1075, i64 0, i64 0
  %t79 = ptrtoint i8* %t78 to i64
  %t80 = call i64 @kore_str_eq(i64 %t77, i64 %t79)
  %t81 = icmp ne i64 %t80, 0
  br i1 %t81, label %then1328, label %else1329
  then1328:
  ; enum variant: Target::WASM
  %t82 = call i8* @malloc(i64 24)
  %t83 = bitcast i8* %t82 to %Target*
  %t84 = getelementptr %Target, %Target* %t83, i32 0, i32 0
  store i64 2, i64* %t84
  %t85 = getelementptr %Target, %Target* %t83, i32 0, i32 1
  store i8* null, i8** %t85
  %t86 = getelementptr %Target, %Target* %t83, i32 0, i32 2
  %t87 = getelementptr [5 x i8], [5 x i8]* @.str.1076, i64 0, i64 0
  store i8* %t87, i8** %t86
  %t88 = ptrtoint %Target* %t83 to i64
  store i64 %t88, i64* %t49
  br label %endif1330
  else1329:
  ; enum variant: Target::LLVM
  %t89 = call i8* @malloc(i64 24)
  %t90 = bitcast i8* %t89 to %Target*
  %t91 = getelementptr %Target, %Target* %t90, i32 0, i32 0
  store i64 0, i64* %t91
  %t92 = getelementptr %Target, %Target* %t90, i32 0, i32 1
  store i8* null, i8** %t92
  %t93 = getelementptr %Target, %Target* %t90, i32 0, i32 2
  %t94 = getelementptr [5 x i8], [5 x i8]* @.str.1077, i64 0, i64 0
  store i8* %t94, i8** %t93
  %t95 = ptrtoint %Target* %t90 to i64
  store i64 %t95, i64* %t49
  br label %endif1330
  endif1330:
  br label %endif1327
  endif1327:
  br label %match_end1322
  match_next1323:
  %t96 = inttoptr i64 %t53 to { i64, i8* }*
  %t97 = getelementptr { i64, i8* }, { i64, i8* }* %t96, i32 0, i32 0
  %t98 = load i64, i64* %t97
  %t99 = icmp eq i64 %t98, 0
  br i1 %t99, label %match_body1332, label %match_next1331
  match_body1332:
  ; enum variant: Target::LLVM
  %t100 = call i8* @malloc(i64 24)
  %t101 = bitcast i8* %t100 to %Target*
  %t102 = getelementptr %Target, %Target* %t101, i32 0, i32 0
  store i64 0, i64* %t102
  %t103 = getelementptr %Target, %Target* %t101, i32 0, i32 1
  store i8* null, i8** %t103
  %t104 = getelementptr %Target, %Target* %t101, i32 0, i32 2
  %t105 = getelementptr [5 x i8], [5 x i8]* @.str.1078, i64 0, i64 0
  store i8* %t105, i8** %t104
  %t106 = ptrtoint %Target* %t101 to i64
  store i64 %t106, i64* %t49
  br label %match_end1322
  match_next1331:
  br label %match_end1322
  match_end1322:
  ; struct literal: CompilerConfig
  %t107 = call i8* @malloc(i64 32)
  %t108 = bitcast i8* %t107 to %CompilerConfig*
  %t109 = load i64, i64* %t19
  %t110 = getelementptr %CompilerConfig, %CompilerConfig* %t108, i32 0, i32 0
  store i64 %t109, i64* %t110
  %t111 = load i64, i64* %t6
  %t112 = getelementptr %CompilerConfig, %CompilerConfig* %t108, i32 0, i32 1
  store i64 %t111, i64* %t112
  %t113 = load i64, i64* %t49
  %t114 = getelementptr %CompilerConfig, %CompilerConfig* %t108, i32 0, i32 2
  store i64 %t113, i64* %t114
  %t115 = load i64, i64* %t16
  %t116 = getelementptr %CompilerConfig, %CompilerConfig* %t108, i32 0, i32 3
  store i64 %t115, i64* %t116
  %t117 = ptrtoint %CompilerConfig* %t108 to i64
  ret i64 %t117
}

; impl Compiler
define i64 @Compiler_new(i64 %config) {
  entry:
  %t0 = alloca i64
  store i64 %config, i64* %t0
  ; struct literal: Compiler
  %t1 = call i8* @malloc(i64 8)
  %t2 = bitcast i8* %t1 to %Compiler*
  %t3 = load i64, i64* %t0
  %t4 = getelementptr %Compiler, %Compiler* %t2, i32 0, i32 0
  store i64 %t3, i64* %t4
  %t5 = ptrtoint %Compiler* %t2 to i64
  ret i64 %t5
}
define i64 @Compiler_compile(i64 %self) {
  entry:
  %t0 = alloca i64
  store i64 %self, i64* %t0
  %t1 = load i64, i64* %t0
  %t2 = inttoptr i64 %t1 to %Compiler*
  %t3 = getelementptr %Compiler, %Compiler* %t2, i32 0, i32 0
  %t4 = load i64, i64* %t3
  %t5 = inttoptr i64 %t4 to %CompilerConfig*
  %t6 = getelementptr %CompilerConfig, %CompilerConfig* %t5, i32 0, i32 3
  %t7 = load i64, i64* %t6
  %t8 = icmp ne i64 %t7, 0
  br i1 %t8, label %then1333, label %endif1335
  then1333:
  %t9 = getelementptr [30 x i8], [30 x i8]* @.str.1079, i64 0, i64 0
  %t10 = ptrtoint i8* %t9 to i64
  %t11 = inttoptr i64 %t10 to i8*
  call void @kore_println_str(i8* %t11)
  %t12 = getelementptr [1 x i8], [1 x i8]* @.str.1080, i64 0, i64 0
  %t13 = ptrtoint i8* %t12 to i64
  %t14 = inttoptr i64 %t13 to i8*
  call void @kore_println_str(i8* %t14)
  br label %endif1335
  endif1335:
  %t15 = load i64, i64* %t0
  %t16 = inttoptr i64 %t15 to %Compiler*
  %t17 = getelementptr %Compiler, %Compiler* %t16, i32 0, i32 0
  %t18 = load i64, i64* %t17
  %t19 = inttoptr i64 %t18 to %CompilerConfig*
  %t20 = getelementptr %CompilerConfig, %CompilerConfig* %t19, i32 0, i32 3
  %t21 = load i64, i64* %t20
  %t22 = icmp ne i64 %t21, 0
  br i1 %t22, label %then1336, label %endif1338
  then1336:
  %t23 = getelementptr [15 x i8], [15 x i8]* @.str.1081, i64 0, i64 0
  %t24 = ptrtoint i8* %t23 to i64
  %t25 = load i64, i64* %t0
  %t26 = inttoptr i64 %t25 to %Compiler*
  %t27 = getelementptr %Compiler, %Compiler* %t26, i32 0, i32 0
  %t28 = load i64, i64* %t27
  %t29 = inttoptr i64 %t28 to %CompilerConfig*
  %t30 = getelementptr %CompilerConfig, %CompilerConfig* %t29, i32 0, i32 0
  %t31 = load i64, i64* %t30
  %t32 = call i64 @kore_str_concat(i64 %t24, i64 %t31)
  %t33 = inttoptr i64 %t32 to i8*
  call void @kore_println_str(i8* %t33)
  br label %endif1338
  endif1338:
  %t34 = load i64, i64* %t0
  %t35 = inttoptr i64 %t34 to %Compiler*
  %t36 = getelementptr %Compiler, %Compiler* %t35, i32 0, i32 0
  %t37 = load i64, i64* %t36
  %t38 = inttoptr i64 %t37 to %CompilerConfig*
  %t39 = getelementptr %CompilerConfig, %CompilerConfig* %t38, i32 0, i32 0
  %t40 = load i64, i64* %t39
  %t41 = call i64 @read_file(i64 %t40)
  %t42 = alloca i64
  store i64 %t41, i64* %t42
  %t43 = load i64, i64* %t0
  %t44 = inttoptr i64 %t43 to %Compiler*
  %t45 = getelementptr %Compiler, %Compiler* %t44, i32 0, i32 0
  %t46 = load i64, i64* %t45
  %t47 = inttoptr i64 %t46 to %CompilerConfig*
  %t48 = getelementptr %CompilerConfig, %CompilerConfig* %t47, i32 0, i32 3
  %t49 = load i64, i64* %t48
  %t50 = icmp ne i64 %t49, 0
  br i1 %t50, label %then1339, label %endif1341
  then1339:
  %t51 = getelementptr [19 x i8], [19 x i8]* @.str.1082, i64 0, i64 0
  %t52 = ptrtoint i8* %t51 to i64
  %t53 = inttoptr i64 %t52 to i8*
  call void @kore_println_str(i8* %t53)
  br label %endif1341
  endif1341:
  %t54 = load i64, i64* %t42
  %t55 = call i64 @Lexer_new(i64 %t54)
  %t56 = alloca i64
  store i64 %t55, i64* %t56
  %t57 = load i64, i64* %t56
  %t58 = call i64 @Lexer_tokenize(i64 %t57)
  %t59 = alloca i64
  store i64 %t58, i64* %t59
  %t60 = load i64, i64* %t0
  %t61 = inttoptr i64 %t60 to %Compiler*
  %t62 = getelementptr %Compiler, %Compiler* %t61, i32 0, i32 0
  %t63 = load i64, i64* %t62
  %t64 = inttoptr i64 %t63 to %CompilerConfig*
  %t65 = getelementptr %CompilerConfig, %CompilerConfig* %t64, i32 0, i32 3
  %t66 = load i64, i64* %t65
  %t67 = icmp ne i64 %t66, 0
  br i1 %t67, label %then1342, label %endif1344
  then1342:
  %t68 = getelementptr [4 x i8], [4 x i8]* @.str.1083, i64 0, i64 0
  %t69 = ptrtoint i8* %t68 to i64
  %t70 = load i64, i64* %t59
  %t71 = call i64 @kore_array_len(i64 %t70)
  %t72 = call i64 @kore_to_string(i64 %t71)
  %t73 = call i64 @kore_str_concat(i64 %t69, i64 %t72)
  %t74 = getelementptr [8 x i8], [8 x i8]* @.str.1084, i64 0, i64 0
  %t75 = ptrtoint i8* %t74 to i64
  %t76 = call i64 @kore_str_concat(i64 %t73, i64 %t75)
  %t77 = inttoptr i64 %t76 to i8*
  call void @kore_println_str(i8* %t77)
  br label %endif1344
  endif1344:
  %t78 = load i64, i64* %t0
  %t79 = inttoptr i64 %t78 to %Compiler*
  %t80 = getelementptr %Compiler, %Compiler* %t79, i32 0, i32 0
  %t81 = load i64, i64* %t80
  %t82 = inttoptr i64 %t81 to %CompilerConfig*
  %t83 = getelementptr %CompilerConfig, %CompilerConfig* %t82, i32 0, i32 3
  %t84 = load i64, i64* %t83
  %t85 = icmp ne i64 %t84, 0
  br i1 %t85, label %then1345, label %endif1347
  then1345:
  %t86 = getelementptr [16 x i8], [16 x i8]* @.str.1085, i64 0, i64 0
  %t87 = ptrtoint i8* %t86 to i64
  %t88 = inttoptr i64 %t87 to i8*
  call void @kore_println_str(i8* %t88)
  br label %endif1347
  endif1347:
  %t89 = load i64, i64* %t59
  %t90 = call i64 @Parser_new(i64 %t89)
  %t91 = alloca i64
  store i64 %t90, i64* %t91
  %t92 = load i64, i64* %t91
  %t93 = call i64 @Parser_parse_program(i64 %t92)
  %t94 = alloca i64
  store i64 %t93, i64* %t94
  %t95 = load i64, i64* %t0
  %t96 = inttoptr i64 %t95 to %Compiler*
  %t97 = getelementptr %Compiler, %Compiler* %t96, i32 0, i32 0
  %t98 = load i64, i64* %t97
  %t99 = inttoptr i64 %t98 to %CompilerConfig*
  %t100 = getelementptr %CompilerConfig, %CompilerConfig* %t99, i32 0, i32 3
  %t101 = load i64, i64* %t100
  %t102 = icmp ne i64 %t101, 0
  br i1 %t102, label %then1348, label %endif1350
  then1348:
  %t103 = getelementptr [4 x i8], [4 x i8]* @.str.1086, i64 0, i64 0
  %t104 = ptrtoint i8* %t103 to i64
  %t105 = load i64, i64* %t94
  %t106 = inttoptr i64 %t105 to %Parser*
  ; field access failed for .items
  %t107 = call i64 @kore_array_len(i64 0)
  %t108 = call i64 @kore_to_string(i64 %t107)
  %t109 = call i64 @kore_str_concat(i64 %t104, i64 %t108)
  %t110 = getelementptr [7 x i8], [7 x i8]* @.str.1087, i64 0, i64 0
  %t111 = ptrtoint i8* %t110 to i64
  %t112 = call i64 @kore_str_concat(i64 %t109, i64 %t111)
  %t113 = inttoptr i64 %t112 to i8*
  call void @kore_println_str(i8* %t113)
  br label %endif1350
  endif1350:
  %t114 = getelementptr [1 x i8], [1 x i8]* @.str.1088, i64 0, i64 0
  %t115 = ptrtoint i8* %t114 to i64
  %t116 = alloca i64
  store i64 %t115, i64* %t116
  %t117 = getelementptr [1 x i8], [1 x i8]* @.str.1089, i64 0, i64 0
  %t118 = ptrtoint i8* %t117 to i64
  %t119 = alloca i64
  store i64 %t118, i64* %t119
  ; match
  %t120 = load i64, i64* %t0
  %t121 = inttoptr i64 %t120 to %Compiler*
  %t122 = getelementptr %Compiler, %Compiler* %t121, i32 0, i32 0
  %t123 = load i64, i64* %t122
  %t124 = inttoptr i64 %t123 to %CompilerConfig*
  %t125 = getelementptr %CompilerConfig, %CompilerConfig* %t124, i32 0, i32 2
  %t126 = load i64, i64* %t125
  %t127 = inttoptr i64 %t126 to { i64, i8* }*
  %t128 = getelementptr { i64, i8* }, { i64, i8* }* %t127, i32 0, i32 0
  %t129 = load i64, i64* %t128
  %t130 = icmp eq i64 %t129, 0
  br i1 %t130, label %match_body1353, label %match_next1352
  match_body1353:
  %t131 = load i64, i64* %t0
  %t132 = inttoptr i64 %t131 to %Compiler*
  %t133 = getelementptr %Compiler, %Compiler* %t132, i32 0, i32 0
  %t134 = load i64, i64* %t133
  %t135 = inttoptr i64 %t134 to %CompilerConfig*
  %t136 = getelementptr %CompilerConfig, %CompilerConfig* %t135, i32 0, i32 3
  %t137 = load i64, i64* %t136
  %t138 = icmp ne i64 %t137, 0
  br i1 %t138, label %then1354, label %endif1356
  then1354:
  %t139 = getelementptr [29 x i8], [29 x i8]* @.str.1090, i64 0, i64 0
  %t140 = ptrtoint i8* %t139 to i64
  %t141 = inttoptr i64 %t140 to i8*
  call void @kore_println_str(i8* %t141)
  br label %endif1356
  endif1356:
  %t142 = call i64 @CodeGen_new()
  %t143 = alloca i64
  store i64 %t142, i64* %t143
  %t144 = load i64, i64* %t143
  %t145 = load i64, i64* %t94
  %t146 = call i64 @CodeGen_gen_program(i64 %t144, i64 %t145)
  store i64 %t146, i64* %t116
  %t147 = getelementptr [4 x i8], [4 x i8]* @.str.1091, i64 0, i64 0
  %t148 = ptrtoint i8* %t147 to i64
  store i64 %t148, i64* %t119
  br label %match_end1351
  match_next1352:
  %t149 = inttoptr i64 %t126 to { i64, i8* }*
  %t150 = getelementptr { i64, i8* }, { i64, i8* }* %t149, i32 0, i32 0
  %t151 = load i64, i64* %t150
  %t152 = icmp eq i64 %t151, 1
  br i1 %t152, label %match_body1358, label %match_next1357
  match_body1358:
  %t153 = load i64, i64* %t0
  %t154 = inttoptr i64 %t153 to %Compiler*
  %t155 = getelementptr %Compiler, %Compiler* %t154, i32 0, i32 0
  %t156 = load i64, i64* %t155
  %t157 = inttoptr i64 %t156 to %CompilerConfig*
  %t158 = getelementptr %CompilerConfig, %CompilerConfig* %t157, i32 0, i32 3
  %t159 = load i64, i64* %t158
  %t160 = icmp ne i64 %t159, 0
  br i1 %t160, label %then1359, label %endif1361
  then1359:
  %t161 = getelementptr [24 x i8], [24 x i8]* @.str.1092, i64 0, i64 0
  %t162 = ptrtoint i8* %t161 to i64
  %t163 = inttoptr i64 %t162 to i8*
  call void @kore_println_str(i8* %t163)
  br label %endif1361
  endif1361:
  %t164 = call i64 @RustGen_new()
  %t165 = alloca i64
  store i64 %t164, i64* %t165
  %t166 = load i64, i64* %t165
  %t167 = load i64, i64* %t94
  %t168 = call i64 @RustGen_gen_program(i64 %t166, i64 %t167)
  store i64 %t168, i64* %t116
  %t169 = getelementptr [4 x i8], [4 x i8]* @.str.1093, i64 0, i64 0
  %t170 = ptrtoint i8* %t169 to i64
  store i64 %t170, i64* %t119
  br label %match_end1351
  match_next1357:
  %t171 = inttoptr i64 %t126 to { i64, i8* }*
  %t172 = getelementptr { i64, i8* }, { i64, i8* }* %t171, i32 0, i32 0
  %t173 = load i64, i64* %t172
  %t174 = icmp eq i64 %t173, 2
  br i1 %t174, label %match_body1363, label %match_next1362
  match_body1363:
  %t175 = load i64, i64* %t0
  %t176 = inttoptr i64 %t175 to %Compiler*
  %t177 = getelementptr %Compiler, %Compiler* %t176, i32 0, i32 0
  %t178 = load i64, i64* %t177
  %t179 = inttoptr i64 %t178 to %CompilerConfig*
  %t180 = getelementptr %CompilerConfig, %CompilerConfig* %t179, i32 0, i32 3
  %t181 = load i64, i64* %t180
  %t182 = icmp ne i64 %t181, 0
  br i1 %t182, label %then1364, label %endif1366
  then1364:
  %t183 = getelementptr [24 x i8], [24 x i8]* @.str.1094, i64 0, i64 0
  %t184 = ptrtoint i8* %t183 to i64
  %t185 = inttoptr i64 %t184 to i8*
  call void @kore_println_str(i8* %t185)
  br label %endif1366
  endif1366:
  %t186 = getelementptr [55 x i8], [55 x i8]* @.str.1095, i64 0, i64 0
  %t187 = ptrtoint i8* %t186 to i64
  %t188 = inttoptr i64 %t187 to i8*
  call void @kore_println_str(i8* %t188)
  ret i64 0
  match_next1362:
  br label %match_end1351
  match_end1351:
  %t189 = getelementptr [1 x i8], [1 x i8]* @.str.1096, i64 0, i64 0
  %t190 = ptrtoint i8* %t189 to i64
  %t191 = alloca i64
  store i64 %t190, i64* %t191
  ; match
  %t192 = load i64, i64* %t0
  %t193 = inttoptr i64 %t192 to %Compiler*
  %t194 = getelementptr %Compiler, %Compiler* %t193, i32 0, i32 0
  %t195 = load i64, i64* %t194
  %t196 = inttoptr i64 %t195 to %CompilerConfig*
  %t197 = getelementptr %CompilerConfig, %CompilerConfig* %t196, i32 0, i32 1
  %t198 = load i64, i64* %t197
  %t199 = inttoptr i64 %t198 to { i64, i8* }*
  %t200 = getelementptr { i64, i8* }, { i64, i8* }* %t199, i32 0, i32 0
  %t201 = load i64, i64* %t200
  %t202 = icmp eq i64 %t201, 1
  br i1 %t202, label %match_body1369, label %match_next1368
  match_body1369:
  %t203 = getelementptr { i64, i8* }, { i64, i8* }* %t199, i32 0, i32 1
  %t204 = load i8*, i8** %t203
  %t205 = ptrtoint i8* %t204 to i64
  %t206 = inttoptr i64 %t205 to i64*
  %t207 = getelementptr i64, i64* %t206, i32 0
  %t208 = load i64, i64* %t207
  %t209 = alloca i64
  store i64 %t208, i64* %t209
  %t210 = load i64, i64* %t209
  store i64 %t210, i64* %t191
  br label %match_end1367
  match_next1368:
  %t211 = inttoptr i64 %t198 to { i64, i8* }*
  %t212 = getelementptr { i64, i8* }, { i64, i8* }* %t211, i32 0, i32 0
  %t213 = load i64, i64* %t212
  %t214 = icmp eq i64 %t213, 0
  br i1 %t214, label %match_body1371, label %match_next1370
  match_body1371:
  %t215 = load i64, i64* %t0
  %t216 = inttoptr i64 %t215 to %Compiler*
  %t217 = getelementptr %Compiler, %Compiler* %t216, i32 0, i32 0
  %t218 = load i64, i64* %t217
  %t219 = inttoptr i64 %t218 to %CompilerConfig*
  %t220 = getelementptr %CompilerConfig, %CompilerConfig* %t219, i32 0, i32 0
  %t221 = load i64, i64* %t220
  %t222 = call i64 @Path_new(i64 %t221)
  %t223 = alloca i64
  store i64 %t222, i64* %t223
  %t224 = load i64, i64* %t223
  %t225 = load i64, i64* %t119
  %t226 = load i64, i64* %t119
  %t227 = call i64 @kore_str_len(i64 %t226)
  %t228 = call i64 @kore_substring(i64 %t225, i64 1, i64 %t227)
  %t229 = call i64 @Path_with_extension(i64 %t224, i64 %t228)
  store i64 %t229, i64* %t191
  br label %match_end1367
  match_next1370:
  br label %match_end1367
  match_end1367:
  %t230 = load i64, i64* %t0
  %t231 = inttoptr i64 %t230 to %Compiler*
  %t232 = getelementptr %Compiler, %Compiler* %t231, i32 0, i32 0
  %t233 = load i64, i64* %t232
  %t234 = inttoptr i64 %t233 to %CompilerConfig*
  %t235 = getelementptr %CompilerConfig, %CompilerConfig* %t234, i32 0, i32 3
  %t236 = load i64, i64* %t235
  %t237 = icmp ne i64 %t236, 0
  br i1 %t237, label %then1372, label %endif1374
  then1372:
  %t238 = getelementptr [15 x i8], [15 x i8]* @.str.1097, i64 0, i64 0
  %t239 = ptrtoint i8* %t238 to i64
  %t240 = load i64, i64* %t191
  %t241 = call i64 @kore_str_concat(i64 %t239, i64 %t240)
  %t242 = inttoptr i64 %t241 to i8*
  call void @kore_println_str(i8* %t242)
  br label %endif1374
  endif1374:
  %t243 = load i64, i64* %t191
  %t244 = load i64, i64* %t116
  %t245 = call i64 @write_file(i64 %t243, i64 %t244)
  %t246 = getelementptr [18 x i8], [18 x i8]* @.str.1098, i64 0, i64 0
  %t247 = ptrtoint i8* %t246 to i64
  %t248 = load i64, i64* %t191
  %t249 = call i64 @kore_str_concat(i64 %t247, i64 %t248)
  %t250 = inttoptr i64 %t249 to i8*
  call void @kore_println_str(i8* %t250)
  ; match
  %t251 = load i64, i64* %t0
  %t252 = inttoptr i64 %t251 to %Compiler*
  %t253 = getelementptr %Compiler, %Compiler* %t252, i32 0, i32 0
  %t254 = load i64, i64* %t253
  %t255 = inttoptr i64 %t254 to %CompilerConfig*
  %t256 = getelementptr %CompilerConfig, %CompilerConfig* %t255, i32 0, i32 2
  %t257 = load i64, i64* %t256
  %t258 = inttoptr i64 %t257 to { i64, i8* }*
  %t259 = getelementptr { i64, i8* }, { i64, i8* }* %t258, i32 0, i32 0
  %t260 = load i64, i64* %t259
  %t261 = icmp eq i64 %t260, 1
  br i1 %t261, label %match_body1377, label %match_next1376
  match_body1377:
  %t262 = load i64, i64* %t191
  %t263 = call i64 @Path_new(i64 %t262)
  %t264 = call i64 @Path_parent(i64 %t263)
  %t265 = getelementptr [12 x i8], [12 x i8]* @.str.1099, i64 0, i64 0
  %t266 = ptrtoint i8* %t265 to i64
  %t267 = call i64 @kore_str_concat(i64 %t264, i64 %t266)
  %t268 = alloca i64
  store i64 %t267, i64* %t268
  %t269 = load i64, i64* %t0
  %t270 = inttoptr i64 %t269 to %Compiler*
  %t271 = getelementptr %Compiler, %Compiler* %t270, i32 0, i32 0
  %t272 = load i64, i64* %t271
  %t273 = inttoptr i64 %t272 to %CompilerConfig*
  %t274 = getelementptr %CompilerConfig, %CompilerConfig* %t273, i32 0, i32 0
  %t275 = load i64, i64* %t274
  %t276 = call i64 @Path_new(i64 %t275)
  %t277 = alloca i64
  store i64 %t276, i64* %t277
  %t278 = load i64, i64* %t277
  %t279 = call i64 @Path_stem(i64 %t278)
  %t280 = call i64 @kore_array_new()
  %t281 = call i64 @gen_cargo_toml(i64 %t279, i64 %t280)
  %t282 = alloca i64
  store i64 %t281, i64* %t282
  %t283 = load i64, i64* %t268
  %t284 = load i64, i64* %t282
  %t285 = call i64 @write_file(i64 %t283, i64 %t284)
  %t286 = getelementptr [15 x i8], [15 x i8]* @.str.1100, i64 0, i64 0
  %t287 = ptrtoint i8* %t286 to i64
  %t288 = load i64, i64* %t268
  %t289 = call i64 @kore_str_concat(i64 %t287, i64 %t288)
  %t290 = inttoptr i64 %t289 to i8*
  call void @kore_println_str(i8* %t290)
  br label %match_end1375
  match_next1376:
  br label %match_body1379
  match_body1379:
  br label %match_end1375
  match_next1378:
  br label %match_end1375
  match_end1375:
  ret i64 1
}

; String Constants
@.str.0 = private unnamed_addr constant [2 x i8] c"_\00"
@.str.1 = private unnamed_addr constant [2 x i8] c"_\00"
@.str.2 = private unnamed_addr constant [1 x i8] c"\00"
@.str.3 = private unnamed_addr constant [1 x i8] c"\00"
@.str.4 = private unnamed_addr constant [10 x i8] c"[package]\00"
@.str.5 = private unnamed_addr constant [8 x i8] c"name = \00"
@.str.6 = private unnamed_addr constant [1 x i8] c"\00"
@.str.7 = private unnamed_addr constant [17 x i8] c"version = \220.1.0\00"
@.str.8 = private unnamed_addr constant [16 x i8] c"edition = \222021\00"
@.str.9 = private unnamed_addr constant [1 x i8] c"\00"
@.str.10 = private unnamed_addr constant [29 x i8] c"# Generated by KORE Compiler\00"
@.str.11 = private unnamed_addr constant [1 x i8] c"\00"
@.str.12 = private unnamed_addr constant [15 x i8] c"[dependencies]\00"
@.str.13 = private unnamed_addr constant [6 x i8] c" = \22*\00"
@.str.14 = private unnamed_addr constant [7 x i8] c"--help\00"
@.str.15 = private unnamed_addr constant [3 x i8] c"-h\00"
@.str.16 = private unnamed_addr constant [52 x i8] c" KORE Compiler (Ouroboros) - Self-Hosted Edition\00"
@.str.17 = private unnamed_addr constant [1 x i8] c"\00"
@.str.18 = private unnamed_addr constant [7 x i8] c"USAGE:\00"
@.str.19 = private unnamed_addr constant [31 x i8] c"    korec <input.kr> [OPTIONS]\00"
@.str.20 = private unnamed_addr constant [1 x i8] c"\00"
@.str.21 = private unnamed_addr constant [9 x i8] c"OPTIONS:\00"
@.str.22 = private unnamed_addr constant [48 x i8] c"    --target <TARGET>   Set compilation target:\00"
@.str.23 = private unnamed_addr constant [52 x i8] c"                        - llvm  : LLVM IR (default)\00"
@.str.24 = private unnamed_addr constant [51 x i8] c"                        - rust  : Rust source code\00"
@.str.25 = private unnamed_addr constant [46 x i8] c"                        - wasm  : WebAssembly\00"
@.str.26 = private unnamed_addr constant [41 x i8] c"    -o <FILE>           Output file path\00"
@.str.27 = private unnamed_addr constant [39 x i8] c"    -v, --verbose       Verbose output\00"
@.str.28 = private unnamed_addr constant [39 x i8] c"    -h, --help          Show this help\00"
@.str.29 = private unnamed_addr constant [1 x i8] c"\00"
@.str.30 = private unnamed_addr constant [10 x i8] c"EXAMPLES:\00"
@.str.31 = private unnamed_addr constant [59 x i8] c"    korec main.kr                     # Compile to LLVM IR\00"
@.str.32 = private unnamed_addr constant [58 x i8] c"    korec main.kr --target rust       # Transpile to Rust\00"
@.str.33 = private unnamed_addr constant [55 x i8] c"    korec main.kr -o out.ll           # Specify output\00"
@.str.34 = private unnamed_addr constant [1 x i8] c"\00"
@.str.35 = private unnamed_addr constant [18 x i8] c"PROJECT OUROBOROS\00"
@.str.36 = private unnamed_addr constant [45 x i8] c"    This compiler is written in KORE itself!\00"
@.str.37 = private unnamed_addr constant [29 x i8] c"    github.com/ephemara/Kore\00"
@.str.38 = private unnamed_addr constant [3 x i8] c"fn\00"
@.str.39 = private unnamed_addr constant [4 x i8] c"let\00"
@.str.40 = private unnamed_addr constant [4 x i8] c"var\00"
@.str.41 = private unnamed_addr constant [3 x i8] c"if\00"
@.str.42 = private unnamed_addr constant [5 x i8] c"else\00"
@.str.43 = private unnamed_addr constant [6 x i8] c"while\00"
@.str.44 = private unnamed_addr constant [4 x i8] c"for\00"
@.str.45 = private unnamed_addr constant [3 x i8] c"in\00"
@.str.46 = private unnamed_addr constant [7 x i8] c"return\00"
@.str.47 = private unnamed_addr constant [6 x i8] c"match\00"
@.str.48 = private unnamed_addr constant [7 x i8] c"struct\00"
@.str.49 = private unnamed_addr constant [5 x i8] c"enum\00"
@.str.50 = private unnamed_addr constant [5 x i8] c"impl\00"
@.str.51 = private unnamed_addr constant [4 x i8] c"use\00"
@.str.52 = private unnamed_addr constant [4 x i8] c"pub\00"
@.str.53 = private unnamed_addr constant [6 x i8] c"async\00"
@.str.54 = private unnamed_addr constant [6 x i8] c"await\00"
@.str.55 = private unnamed_addr constant [6 x i8] c"spawn\00"
@.str.56 = private unnamed_addr constant [6 x i8] c"actor\00"
@.str.57 = private unnamed_addr constant [3 x i8] c"on\00"
@.str.58 = private unnamed_addr constant [5 x i8] c"send\00"
@.str.59 = private unnamed_addr constant [5 x i8] c"true\00"
@.str.60 = private unnamed_addr constant [6 x i8] c"false\00"
@.str.61 = private unnamed_addr constant [5 x i8] c"none\00"
@.str.62 = private unnamed_addr constant [5 x i8] c"self\00"
@.str.63 = private unnamed_addr constant [5 x i8] c"test\00"
@.str.64 = private unnamed_addr constant [9 x i8] c"comptime\00"
@.str.65 = private unnamed_addr constant [5 x i8] c"with\00"
@.str.66 = private unnamed_addr constant [6 x i8] c"break\00"
@.str.67 = private unnamed_addr constant [9 x i8] c"continue\00"
@.str.68 = private unnamed_addr constant [5 x i8] c"loop\00"
@.str.69 = private unnamed_addr constant [3 x i8] c"fn\00"
@.str.70 = private unnamed_addr constant [4 x i8] c"let\00"
@.str.71 = private unnamed_addr constant [4 x i8] c"var\00"
@.str.72 = private unnamed_addr constant [3 x i8] c"if\00"
@.str.73 = private unnamed_addr constant [5 x i8] c"else\00"
@.str.74 = private unnamed_addr constant [6 x i8] c"while\00"
@.str.75 = private unnamed_addr constant [4 x i8] c"for\00"
@.str.76 = private unnamed_addr constant [3 x i8] c"in\00"
@.str.77 = private unnamed_addr constant [7 x i8] c"return\00"
@.str.78 = private unnamed_addr constant [6 x i8] c"match\00"
@.str.79 = private unnamed_addr constant [7 x i8] c"struct\00"
@.str.80 = private unnamed_addr constant [5 x i8] c"enum\00"
@.str.81 = private unnamed_addr constant [5 x i8] c"impl\00"
@.str.82 = private unnamed_addr constant [4 x i8] c"use\00"
@.str.83 = private unnamed_addr constant [4 x i8] c"pub\00"
@.str.84 = private unnamed_addr constant [6 x i8] c"async\00"
@.str.85 = private unnamed_addr constant [6 x i8] c"await\00"
@.str.86 = private unnamed_addr constant [6 x i8] c"spawn\00"
@.str.87 = private unnamed_addr constant [6 x i8] c"actor\00"
@.str.88 = private unnamed_addr constant [3 x i8] c"on\00"
@.str.89 = private unnamed_addr constant [5 x i8] c"send\00"
@.str.90 = private unnamed_addr constant [5 x i8] c"true\00"
@.str.91 = private unnamed_addr constant [6 x i8] c"false\00"
@.str.92 = private unnamed_addr constant [5 x i8] c"none\00"
@.str.93 = private unnamed_addr constant [5 x i8] c"self\00"
@.str.94 = private unnamed_addr constant [5 x i8] c"test\00"
@.str.95 = private unnamed_addr constant [9 x i8] c"comptime\00"
@.str.96 = private unnamed_addr constant [5 x i8] c"with\00"
@.str.97 = private unnamed_addr constant [6 x i8] c"break\00"
@.str.98 = private unnamed_addr constant [9 x i8] c"continue\00"
@.str.99 = private unnamed_addr constant [5 x i8] c"loop\00"
@.str.100 = private unnamed_addr constant [5 x i8] c"    \00"
@.str.101 = private unnamed_addr constant [7 x i8] c"INDENT\00"
@.str.102 = private unnamed_addr constant [7 x i8] c"DEDENT\00"
@.str.103 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.104 = private unnamed_addr constant [3 x i8] c"\0D\0A\00"
@.str.105 = private unnamed_addr constant [1 x i8] c"\00"
@.str.106 = private unnamed_addr constant [1 x i8] c"\00"
@.str.107 = private unnamed_addr constant [1 x i8] c"\00"
@.str.108 = private unnamed_addr constant [1 x i8] c"\00"
@.str.109 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.110 = private unnamed_addr constant [2 x i8] c" \00"
@.str.111 = private unnamed_addr constant [2 x i8] c"\0D\00"
@.str.112 = private unnamed_addr constant [2 x i8] c".\00"
@.str.113 = private unnamed_addr constant [6 x i8] c"Float\00"
@.str.114 = private unnamed_addr constant [4 x i8] c"Int\00"
@.str.115 = private unnamed_addr constant [2 x i8] c"\5C\00"
@.str.116 = private unnamed_addr constant [2 x i8] c"n\00"
@.str.117 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.118 = private unnamed_addr constant [2 x i8] c"t\00"
@.str.119 = private unnamed_addr constant [2 x i8] c"\09\00"
@.str.120 = private unnamed_addr constant [2 x i8] c"\5C\00"
@.str.121 = private unnamed_addr constant [2 x i8] c"\5C\00"
@.str.122 = private unnamed_addr constant [1 x i8] c"\00"
@.str.123 = private unnamed_addr constant [1 x i8] c"\00"
@.str.124 = private unnamed_addr constant [1 x i8] c"\00"
@.str.125 = private unnamed_addr constant [1 x i8] c"\00"
@.str.126 = private unnamed_addr constant [1 x i8] c"\00"
@.str.127 = private unnamed_addr constant [1 x i8] c"\00"
@.str.128 = private unnamed_addr constant [7 x i8] c"String\00"
@.str.129 = private unnamed_addr constant [3 x i8] c"fn\00"
@.str.130 = private unnamed_addr constant [4 x i8] c"let\00"
@.str.131 = private unnamed_addr constant [4 x i8] c"var\00"
@.str.132 = private unnamed_addr constant [3 x i8] c"if\00"
@.str.133 = private unnamed_addr constant [5 x i8] c"else\00"
@.str.134 = private unnamed_addr constant [6 x i8] c"while\00"
@.str.135 = private unnamed_addr constant [4 x i8] c"for\00"
@.str.136 = private unnamed_addr constant [3 x i8] c"in\00"
@.str.137 = private unnamed_addr constant [7 x i8] c"return\00"
@.str.138 = private unnamed_addr constant [6 x i8] c"match\00"
@.str.139 = private unnamed_addr constant [7 x i8] c"struct\00"
@.str.140 = private unnamed_addr constant [5 x i8] c"enum\00"
@.str.141 = private unnamed_addr constant [5 x i8] c"impl\00"
@.str.142 = private unnamed_addr constant [4 x i8] c"use\00"
@.str.143 = private unnamed_addr constant [4 x i8] c"pub\00"
@.str.144 = private unnamed_addr constant [6 x i8] c"async\00"
@.str.145 = private unnamed_addr constant [6 x i8] c"await\00"
@.str.146 = private unnamed_addr constant [6 x i8] c"spawn\00"
@.str.147 = private unnamed_addr constant [6 x i8] c"actor\00"
@.str.148 = private unnamed_addr constant [3 x i8] c"on\00"
@.str.149 = private unnamed_addr constant [5 x i8] c"send\00"
@.str.150 = private unnamed_addr constant [5 x i8] c"true\00"
@.str.151 = private unnamed_addr constant [6 x i8] c"false\00"
@.str.152 = private unnamed_addr constant [5 x i8] c"none\00"
@.str.153 = private unnamed_addr constant [5 x i8] c"self\00"
@.str.154 = private unnamed_addr constant [5 x i8] c"test\00"
@.str.155 = private unnamed_addr constant [9 x i8] c"comptime\00"
@.str.156 = private unnamed_addr constant [5 x i8] c"with\00"
@.str.157 = private unnamed_addr constant [5 x i8] c"true\00"
@.str.158 = private unnamed_addr constant [5 x i8] c"Bool\00"
@.str.159 = private unnamed_addr constant [6 x i8] c"false\00"
@.str.160 = private unnamed_addr constant [5 x i8] c"Bool\00"
@.str.161 = private unnamed_addr constant [8 x i8] c"Keyword\00"
@.str.162 = private unnamed_addr constant [6 x i8] c"Ident\00"
@.str.163 = private unnamed_addr constant [4 x i8] c"Eof\00"
@.str.164 = private unnamed_addr constant [1 x i8] c"\00"
@.str.165 = private unnamed_addr constant [2 x i8] c"#\00"
@.str.166 = private unnamed_addr constant [2 x i8] c"/\00"
@.str.167 = private unnamed_addr constant [2 x i8] c"/\00"
@.str.168 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.169 = private unnamed_addr constant [2 x i8] c"\0D\00"
@.str.170 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.171 = private unnamed_addr constant [8 x i8] c"Newline\00"
@.str.172 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.173 = private unnamed_addr constant [2 x i8] c"+\00"
@.str.174 = private unnamed_addr constant [5 x i8] c"Plus\00"
@.str.175 = private unnamed_addr constant [2 x i8] c"+\00"
@.str.176 = private unnamed_addr constant [2 x i8] c"-\00"
@.str.177 = private unnamed_addr constant [2 x i8] c">\00"
@.str.178 = private unnamed_addr constant [6 x i8] c"Arrow\00"
@.str.179 = private unnamed_addr constant [3 x i8] c"->\00"
@.str.180 = private unnamed_addr constant [6 x i8] c"Minus\00"
@.str.181 = private unnamed_addr constant [2 x i8] c"-\00"
@.str.182 = private unnamed_addr constant [2 x i8] c"*\00"
@.str.183 = private unnamed_addr constant [5 x i8] c"Star\00"
@.str.184 = private unnamed_addr constant [2 x i8] c"*\00"
@.str.185 = private unnamed_addr constant [2 x i8] c"/\00"
@.str.186 = private unnamed_addr constant [6 x i8] c"Slash\00"
@.str.187 = private unnamed_addr constant [2 x i8] c"/\00"
@.str.188 = private unnamed_addr constant [2 x i8] c"%\00"
@.str.189 = private unnamed_addr constant [8 x i8] c"Percent\00"
@.str.190 = private unnamed_addr constant [2 x i8] c"%\00"
@.str.191 = private unnamed_addr constant [2 x i8] c"=\00"
@.str.192 = private unnamed_addr constant [2 x i8] c"=\00"
@.str.193 = private unnamed_addr constant [5 x i8] c"EqEq\00"
@.str.194 = private unnamed_addr constant [3 x i8] c"==\00"
@.str.195 = private unnamed_addr constant [2 x i8] c">\00"
@.str.196 = private unnamed_addr constant [9 x i8] c"FatArrow\00"
@.str.197 = private unnamed_addr constant [3 x i8] c"=>\00"
@.str.198 = private unnamed_addr constant [3 x i8] c"Eq\00"
@.str.199 = private unnamed_addr constant [2 x i8] c"=\00"
@.str.200 = private unnamed_addr constant [2 x i8] c"!\00"
@.str.201 = private unnamed_addr constant [2 x i8] c"=\00"
@.str.202 = private unnamed_addr constant [6 x i8] c"NotEq\00"
@.str.203 = private unnamed_addr constant [3 x i8] c"!=\00"
@.str.204 = private unnamed_addr constant [4 x i8] c"Not\00"
@.str.205 = private unnamed_addr constant [2 x i8] c"!\00"
@.str.206 = private unnamed_addr constant [2 x i8] c"<\00"
@.str.207 = private unnamed_addr constant [2 x i8] c"=\00"
@.str.208 = private unnamed_addr constant [5 x i8] c"LtEq\00"
@.str.209 = private unnamed_addr constant [3 x i8] c"<=\00"
@.str.210 = private unnamed_addr constant [3 x i8] c"Lt\00"
@.str.211 = private unnamed_addr constant [2 x i8] c"<\00"
@.str.212 = private unnamed_addr constant [2 x i8] c">\00"
@.str.213 = private unnamed_addr constant [2 x i8] c"=\00"
@.str.214 = private unnamed_addr constant [5 x i8] c"GtEq\00"
@.str.215 = private unnamed_addr constant [3 x i8] c">=\00"
@.str.216 = private unnamed_addr constant [3 x i8] c"Gt\00"
@.str.217 = private unnamed_addr constant [2 x i8] c">\00"
@.str.218 = private unnamed_addr constant [2 x i8] c"&\00"
@.str.219 = private unnamed_addr constant [2 x i8] c"&\00"
@.str.220 = private unnamed_addr constant [4 x i8] c"And\00"
@.str.221 = private unnamed_addr constant [3 x i8] c"&&\00"
@.str.222 = private unnamed_addr constant [10 x i8] c"Ampersand\00"
@.str.223 = private unnamed_addr constant [2 x i8] c"&\00"
@.str.224 = private unnamed_addr constant [2 x i8] c"|\00"
@.str.225 = private unnamed_addr constant [2 x i8] c"|\00"
@.str.226 = private unnamed_addr constant [3 x i8] c"Or\00"
@.str.227 = private unnamed_addr constant [3 x i8] c"||\00"
@.str.228 = private unnamed_addr constant [5 x i8] c"Pipe\00"
@.str.229 = private unnamed_addr constant [2 x i8] c"|\00"
@.str.230 = private unnamed_addr constant [2 x i8] c".\00"
@.str.231 = private unnamed_addr constant [2 x i8] c".\00"
@.str.232 = private unnamed_addr constant [7 x i8] c"DotDot\00"
@.str.233 = private unnamed_addr constant [3 x i8] c"..\00"
@.str.234 = private unnamed_addr constant [4 x i8] c"Dot\00"
@.str.235 = private unnamed_addr constant [2 x i8] c".\00"
@.str.236 = private unnamed_addr constant [2 x i8] c":\00"
@.str.237 = private unnamed_addr constant [2 x i8] c":\00"
@.str.238 = private unnamed_addr constant [11 x i8] c"ColonColon\00"
@.str.239 = private unnamed_addr constant [3 x i8] c"::\00"
@.str.240 = private unnamed_addr constant [6 x i8] c"Colon\00"
@.str.241 = private unnamed_addr constant [2 x i8] c":\00"
@.str.242 = private unnamed_addr constant [2 x i8] c",\00"
@.str.243 = private unnamed_addr constant [6 x i8] c"Comma\00"
@.str.244 = private unnamed_addr constant [2 x i8] c",\00"
@.str.245 = private unnamed_addr constant [2 x i8] c";\00"
@.str.246 = private unnamed_addr constant [10 x i8] c"Semicolon\00"
@.str.247 = private unnamed_addr constant [2 x i8] c";\00"
@.str.248 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.249 = private unnamed_addr constant [7 x i8] c"LParen\00"
@.str.250 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.251 = private unnamed_addr constant [2 x i8] c")\00"
@.str.252 = private unnamed_addr constant [7 x i8] c"RParen\00"
@.str.253 = private unnamed_addr constant [2 x i8] c")\00"
@.str.254 = private unnamed_addr constant [2 x i8] c"[\00"
@.str.255 = private unnamed_addr constant [9 x i8] c"LBracket\00"
@.str.256 = private unnamed_addr constant [2 x i8] c"[\00"
@.str.257 = private unnamed_addr constant [2 x i8] c"]\00"
@.str.258 = private unnamed_addr constant [9 x i8] c"RBracket\00"
@.str.259 = private unnamed_addr constant [2 x i8] c"]\00"
@.str.260 = private unnamed_addr constant [2 x i8] c"{\00"
@.str.261 = private unnamed_addr constant [7 x i8] c"LBrace\00"
@.str.262 = private unnamed_addr constant [2 x i8] c"{\00"
@.str.263 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.264 = private unnamed_addr constant [7 x i8] c"RBrace\00"
@.str.265 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.266 = private unnamed_addr constant [20 x i8] c"Unknown character: \00"
@.str.267 = private unnamed_addr constant [6 x i8] c"Error\00"
@.str.268 = private unnamed_addr constant [7 x i8] c"Dedent\00"
@.str.269 = private unnamed_addr constant [7 x i8] c"DEDENT\00"
@.str.270 = private unnamed_addr constant [4 x i8] c"Eof\00"
@.str.271 = private unnamed_addr constant [1 x i8] c"\00"
@.str.272 = private unnamed_addr constant [2 x i8] c" \00"
@.str.273 = private unnamed_addr constant [2 x i8] c"\09\00"
@.str.274 = private unnamed_addr constant [2 x i8] c"\0D\00"
@.str.275 = private unnamed_addr constant [2 x i8] c" \00"
@.str.276 = private unnamed_addr constant [2 x i8] c"\0D\00"
@.str.277 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.278 = private unnamed_addr constant [8 x i8] c"Newline\00"
@.str.279 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.280 = private unnamed_addr constant [2 x i8] c"#\00"
@.str.281 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.282 = private unnamed_addr constant [2 x i8] c"/\00"
@.str.283 = private unnamed_addr constant [2 x i8] c"/\00"
@.str.284 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.285 = private unnamed_addr constant [7 x i8] c"Indent\00"
@.str.286 = private unnamed_addr constant [5 x i8] c"    \00"
@.str.287 = private unnamed_addr constant [7 x i8] c"Dedent\00"
@.str.288 = private unnamed_addr constant [7 x i8] c"DEDENT\00"
@.str.289 = private unnamed_addr constant [1 x i8] c"\00"
@.str.290 = private unnamed_addr constant [4 x i8] c"Eof\00"
@.str.291 = private unnamed_addr constant [1 x i8] c"\00"
@.str.292 = private unnamed_addr constant [18 x i8] c"Expected keyword \00"
@.str.293 = private unnamed_addr constant [8 x i8] c", got: \00"
@.str.294 = private unnamed_addr constant [3 x i8] c"fn\00"
@.str.295 = private unnamed_addr constant [9 x i8] c"Function\00"
@.str.296 = private unnamed_addr constant [4 x i8] c"pub\00"
@.str.297 = private unnamed_addr constant [3 x i8] c"fn\00"
@.str.298 = private unnamed_addr constant [9 x i8] c"Function\00"
@.str.299 = private unnamed_addr constant [7 x i8] c"struct\00"
@.str.300 = private unnamed_addr constant [7 x i8] c"Struct\00"
@.str.301 = private unnamed_addr constant [32 x i8] c"Expected fn or struct after pub\00"
@.str.302 = private unnamed_addr constant [6 x i8] c"async\00"
@.str.303 = private unnamed_addr constant [3 x i8] c"fn\00"
@.str.304 = private unnamed_addr constant [9 x i8] c"Function\00"
@.str.305 = private unnamed_addr constant [7 x i8] c"struct\00"
@.str.306 = private unnamed_addr constant [7 x i8] c"Struct\00"
@.str.307 = private unnamed_addr constant [5 x i8] c"enum\00"
@.str.308 = private unnamed_addr constant [5 x i8] c"Enum\00"
@.str.309 = private unnamed_addr constant [5 x i8] c"impl\00"
@.str.310 = private unnamed_addr constant [5 x i8] c"Impl\00"
@.str.311 = private unnamed_addr constant [4 x i8] c"use\00"
@.str.312 = private unnamed_addr constant [4 x i8] c"Use\00"
@.str.313 = private unnamed_addr constant [8 x i8] c"Unknown\00"
@.str.314 = private unnamed_addr constant [4 x i8] c"Int\00"
@.str.315 = private unnamed_addr constant [7 x i8] c"String\00"
@.str.316 = private unnamed_addr constant [6 x i8] c"Ident\00"
@.str.317 = private unnamed_addr constant [8 x i8] c"Keyword\00"
@.str.318 = private unnamed_addr constant [7 x i8] c"Error(\00"
@.str.319 = private unnamed_addr constant [2 x i8] c")\00"
@.str.320 = private unnamed_addr constant [6 x i8] c"Other\00"
@.str.321 = private unnamed_addr constant [33 x i8] c"Unexpected token at top level: [\00"
@.str.322 = private unnamed_addr constant [9 x i8] c"] Kind: \00"
@.str.323 = private unnamed_addr constant [3 x i8] c"fn\00"
@.str.324 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.325 = private unnamed_addr constant [2 x i8] c")\00"
@.str.326 = private unnamed_addr constant [3 x i8] c"->\00"
@.str.327 = private unnamed_addr constant [5 x i8] c"with\00"
@.str.328 = private unnamed_addr constant [2 x i8] c":\00"
@.str.329 = private unnamed_addr constant [2 x i8] c")\00"
@.str.330 = private unnamed_addr constant [5 x i8] c"self\00"
@.str.331 = private unnamed_addr constant [5 x i8] c"self\00"
@.str.332 = private unnamed_addr constant [5 x i8] c"Self\00"
@.str.333 = private unnamed_addr constant [2 x i8] c",\00"
@.str.334 = private unnamed_addr constant [2 x i8] c":\00"
@.str.335 = private unnamed_addr constant [2 x i8] c",\00"
@.str.336 = private unnamed_addr constant [2 x i8] c"<\00"
@.str.337 = private unnamed_addr constant [2 x i8] c",\00"
@.str.338 = private unnamed_addr constant [3 x i8] c", \00"
@.str.339 = private unnamed_addr constant [2 x i8] c"<\00"
@.str.340 = private unnamed_addr constant [2 x i8] c">\00"
@.str.341 = private unnamed_addr constant [3 x i8] c"fn\00"
@.str.342 = private unnamed_addr constant [4 x i8] c"pub\00"
@.str.343 = private unnamed_addr constant [7 x i8] c"struct\00"
@.str.344 = private unnamed_addr constant [5 x i8] c"enum\00"
@.str.345 = private unnamed_addr constant [5 x i8] c"impl\00"
@.str.346 = private unnamed_addr constant [4 x i8] c"use\00"
@.str.347 = private unnamed_addr constant [5 x i8] c"None\00"
@.str.348 = private unnamed_addr constant [5 x i8] c"Expr\00"
@.str.349 = private unnamed_addr constant [4 x i8] c"let\00"
@.str.350 = private unnamed_addr constant [4 x i8] c"var\00"
@.str.351 = private unnamed_addr constant [7 x i8] c"return\00"
@.str.352 = private unnamed_addr constant [3 x i8] c"if\00"
@.str.353 = private unnamed_addr constant [6 x i8] c"while\00"
@.str.354 = private unnamed_addr constant [4 x i8] c"for\00"
@.str.355 = private unnamed_addr constant [6 x i8] c"match\00"
@.str.356 = private unnamed_addr constant [6 x i8] c"break\00"
@.str.357 = private unnamed_addr constant [6 x i8] c"Break\00"
@.str.358 = private unnamed_addr constant [9 x i8] c"continue\00"
@.str.359 = private unnamed_addr constant [9 x i8] c"Continue\00"
@.str.360 = private unnamed_addr constant [5 x i8] c"loop\00"
@.str.361 = private unnamed_addr constant [2 x i8] c"=\00"
@.str.362 = private unnamed_addr constant [7 x i8] c"Assign\00"
@.str.363 = private unnamed_addr constant [5 x i8] c"Expr\00"
@.str.364 = private unnamed_addr constant [4 x i8] c"let\00"
@.str.365 = private unnamed_addr constant [2 x i8] c"=\00"
@.str.366 = private unnamed_addr constant [4 x i8] c"Let\00"
@.str.367 = private unnamed_addr constant [4 x i8] c"var\00"
@.str.368 = private unnamed_addr constant [2 x i8] c"=\00"
@.str.369 = private unnamed_addr constant [4 x i8] c"Var\00"
@.str.370 = private unnamed_addr constant [7 x i8] c"return\00"
@.str.371 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.372 = private unnamed_addr constant [7 x i8] c"Return\00"
@.str.373 = private unnamed_addr constant [7 x i8] c"Return\00"
@.str.374 = private unnamed_addr constant [3 x i8] c"if\00"
@.str.375 = private unnamed_addr constant [2 x i8] c":\00"
@.str.376 = private unnamed_addr constant [5 x i8] c"else\00"
@.str.377 = private unnamed_addr constant [2 x i8] c":\00"
@.str.378 = private unnamed_addr constant [3 x i8] c"If\00"
@.str.379 = private unnamed_addr constant [6 x i8] c"while\00"
@.str.380 = private unnamed_addr constant [2 x i8] c":\00"
@.str.381 = private unnamed_addr constant [6 x i8] c"While\00"
@.str.382 = private unnamed_addr constant [4 x i8] c"for\00"
@.str.383 = private unnamed_addr constant [3 x i8] c"in\00"
@.str.384 = private unnamed_addr constant [2 x i8] c":\00"
@.str.385 = private unnamed_addr constant [4 x i8] c"For\00"
@.str.386 = private unnamed_addr constant [5 x i8] c"loop\00"
@.str.387 = private unnamed_addr constant [2 x i8] c":\00"
@.str.388 = private unnamed_addr constant [5 x i8] c"Loop\00"
@.str.389 = private unnamed_addr constant [6 x i8] c"match\00"
@.str.390 = private unnamed_addr constant [2 x i8] c":\00"
@.str.391 = private unnamed_addr constant [3 x i8] c"fn\00"
@.str.392 = private unnamed_addr constant [4 x i8] c"let\00"
@.str.393 = private unnamed_addr constant [4 x i8] c"var\00"
@.str.394 = private unnamed_addr constant [7 x i8] c"return\00"
@.str.395 = private unnamed_addr constant [3 x i8] c"if\00"
@.str.396 = private unnamed_addr constant [6 x i8] c"while\00"
@.str.397 = private unnamed_addr constant [4 x i8] c"for\00"
@.str.398 = private unnamed_addr constant [7 x i8] c"struct\00"
@.str.399 = private unnamed_addr constant [5 x i8] c"enum\00"
@.str.400 = private unnamed_addr constant [5 x i8] c"impl\00"
@.str.401 = private unnamed_addr constant [4 x i8] c"use\00"
@.str.402 = private unnamed_addr constant [4 x i8] c"pub\00"
@.str.403 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.404 = private unnamed_addr constant [2 x i8] c"=\00"
@.str.405 = private unnamed_addr constant [2 x i8] c">\00"
@.str.406 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.407 = private unnamed_addr constant [5 x i8] c"Expr\00"
@.str.408 = private unnamed_addr constant [6 x i8] c"Match\00"
@.str.409 = private unnamed_addr constant [2 x i8] c"_\00"
@.str.410 = private unnamed_addr constant [9 x i8] c"Wildcard\00"
@.str.411 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.412 = private unnamed_addr constant [2 x i8] c")\00"
@.str.413 = private unnamed_addr constant [2 x i8] c",\00"
@.str.414 = private unnamed_addr constant [8 x i8] c"Variant\00"
@.str.415 = private unnamed_addr constant [6 x i8] c"Ident\00"
@.str.416 = private unnamed_addr constant [8 x i8] c"Literal\00"
@.str.417 = private unnamed_addr constant [3 x i8] c"||\00"
@.str.418 = private unnamed_addr constant [3 x i8] c"||\00"
@.str.419 = private unnamed_addr constant [7 x i8] c"Binary\00"
@.str.420 = private unnamed_addr constant [3 x i8] c"&&\00"
@.str.421 = private unnamed_addr constant [3 x i8] c"&&\00"
@.str.422 = private unnamed_addr constant [7 x i8] c"Binary\00"
@.str.423 = private unnamed_addr constant [3 x i8] c"==\00"
@.str.424 = private unnamed_addr constant [3 x i8] c"!=\00"
@.str.425 = private unnamed_addr constant [7 x i8] c"Binary\00"
@.str.426 = private unnamed_addr constant [2 x i8] c"<\00"
@.str.427 = private unnamed_addr constant [2 x i8] c">\00"
@.str.428 = private unnamed_addr constant [3 x i8] c"<=\00"
@.str.429 = private unnamed_addr constant [3 x i8] c">=\00"
@.str.430 = private unnamed_addr constant [7 x i8] c"Binary\00"
@.str.431 = private unnamed_addr constant [2 x i8] c"+\00"
@.str.432 = private unnamed_addr constant [2 x i8] c"-\00"
@.str.433 = private unnamed_addr constant [7 x i8] c"Binary\00"
@.str.434 = private unnamed_addr constant [2 x i8] c"*\00"
@.str.435 = private unnamed_addr constant [2 x i8] c"/\00"
@.str.436 = private unnamed_addr constant [2 x i8] c"%\00"
@.str.437 = private unnamed_addr constant [7 x i8] c"Binary\00"
@.str.438 = private unnamed_addr constant [2 x i8] c"!\00"
@.str.439 = private unnamed_addr constant [2 x i8] c"-\00"
@.str.440 = private unnamed_addr constant [6 x i8] c"Unary\00"
@.str.441 = private unnamed_addr constant [2 x i8] c".\00"
@.str.442 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.443 = private unnamed_addr constant [11 x i8] c"MethodCall\00"
@.str.444 = private unnamed_addr constant [6 x i8] c"Field\00"
@.str.445 = private unnamed_addr constant [2 x i8] c"[\00"
@.str.446 = private unnamed_addr constant [6 x i8] c"Index\00"
@.str.447 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.448 = private unnamed_addr constant [5 x i8] c"Call\00"
@.str.449 = private unnamed_addr constant [2 x i8] c")\00"
@.str.450 = private unnamed_addr constant [2 x i8] c",\00"
@.str.451 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.452 = private unnamed_addr constant [2 x i8] c"[\00"
@.str.453 = private unnamed_addr constant [2 x i8] c"]\00"
@.str.454 = private unnamed_addr constant [2 x i8] c",\00"
@.str.455 = private unnamed_addr constant [6 x i8] c"Array\00"
@.str.456 = private unnamed_addr constant [4 x i8] c"Int\00"
@.str.457 = private unnamed_addr constant [1 x i8] c"\00"
@.str.458 = private unnamed_addr constant [2 x i8] c".\00"
@.str.459 = private unnamed_addr constant [6 x i8] c"Float\00"
@.str.460 = private unnamed_addr constant [7 x i8] c"String\00"
@.str.461 = private unnamed_addr constant [5 x i8] c"true\00"
@.str.462 = private unnamed_addr constant [5 x i8] c"Bool\00"
@.str.463 = private unnamed_addr constant [6 x i8] c"false\00"
@.str.464 = private unnamed_addr constant [5 x i8] c"Bool\00"
@.str.465 = private unnamed_addr constant [5 x i8] c"none\00"
@.str.466 = private unnamed_addr constant [5 x i8] c"None\00"
@.str.467 = private unnamed_addr constant [5 x i8] c"None\00"
@.str.468 = private unnamed_addr constant [2 x i8] c":\00"
@.str.469 = private unnamed_addr constant [2 x i8] c":\00"
@.str.470 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.471 = private unnamed_addr constant [12 x i8] c"EnumVariant\00"
@.str.472 = private unnamed_addr constant [12 x i8] c"EnumVariant\00"
@.str.473 = private unnamed_addr constant [2 x i8] c"{\00"
@.str.474 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.475 = private unnamed_addr constant [2 x i8] c":\00"
@.str.476 = private unnamed_addr constant [2 x i8] c",\00"
@.str.477 = private unnamed_addr constant [7 x i8] c"Struct\00"
@.str.478 = private unnamed_addr constant [6 x i8] c"Ident\00"
@.str.479 = private unnamed_addr constant [6 x i8] c"Ident\00"
@.str.480 = private unnamed_addr constant [4 x i8] c"Eof\00"
@.str.481 = private unnamed_addr constant [1 x i8] c"\00"
@.str.482 = private unnamed_addr constant [7 x i8] c"struct\00"
@.str.483 = private unnamed_addr constant [2 x i8] c":\00"
@.str.484 = private unnamed_addr constant [3 x i8] c"fn\00"
@.str.485 = private unnamed_addr constant [4 x i8] c"pub\00"
@.str.486 = private unnamed_addr constant [7 x i8] c"struct\00"
@.str.487 = private unnamed_addr constant [5 x i8] c"enum\00"
@.str.488 = private unnamed_addr constant [5 x i8] c"impl\00"
@.str.489 = private unnamed_addr constant [4 x i8] c"use\00"
@.str.490 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.491 = private unnamed_addr constant [2 x i8] c":\00"
@.str.492 = private unnamed_addr constant [5 x i8] c"enum\00"
@.str.493 = private unnamed_addr constant [2 x i8] c":\00"
@.str.494 = private unnamed_addr constant [3 x i8] c"fn\00"
@.str.495 = private unnamed_addr constant [4 x i8] c"pub\00"
@.str.496 = private unnamed_addr constant [7 x i8] c"struct\00"
@.str.497 = private unnamed_addr constant [5 x i8] c"enum\00"
@.str.498 = private unnamed_addr constant [5 x i8] c"impl\00"
@.str.499 = private unnamed_addr constant [4 x i8] c"use\00"
@.str.500 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.501 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.502 = private unnamed_addr constant [2 x i8] c")\00"
@.str.503 = private unnamed_addr constant [2 x i8] c",\00"
@.str.504 = private unnamed_addr constant [5 x i8] c"impl\00"
@.str.505 = private unnamed_addr constant [2 x i8] c":\00"
@.str.506 = private unnamed_addr constant [7 x i8] c"struct\00"
@.str.507 = private unnamed_addr constant [5 x i8] c"enum\00"
@.str.508 = private unnamed_addr constant [5 x i8] c"impl\00"
@.str.509 = private unnamed_addr constant [4 x i8] c"use\00"
@.str.510 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.511 = private unnamed_addr constant [4 x i8] c"pub\00"
@.str.512 = private unnamed_addr constant [3 x i8] c"fn\00"
@.str.513 = private unnamed_addr constant [3 x i8] c"fn\00"
@.str.514 = private unnamed_addr constant [4 x i8] c"use\00"
@.str.515 = private unnamed_addr constant [3 x i8] c"%t\00"
@.str.516 = private unnamed_addr constant [7 x i8] c"%dummy\00"
@.str.517 = private unnamed_addr constant [7 x i8] c"@.str.\00"
@.str.518 = private unnamed_addr constant [1 x i8] c"\00"
@.str.519 = private unnamed_addr constant [3 x i8] c"  \00"
@.str.520 = private unnamed_addr constant [33 x i8] c"; KORE Compiler Output - LLVM IR\00"
@.str.521 = private unnamed_addr constant [33 x i8] c"; Generated by Project Ouroboros\00"
@.str.522 = private unnamed_addr constant [42 x i8] c"; Compile with: clang output.ll -o output\00"
@.str.523 = private unnamed_addr constant [1 x i8] c"\00"
@.str.524 = private unnamed_addr constant [1 x i8] c"\00"
@.str.525 = private unnamed_addr constant [1 x i8] c"\00"
@.str.526 = private unnamed_addr constant [1 x i8] c"\00"
@.str.527 = private unnamed_addr constant [19 x i8] c"; String Constants\00"
@.str.528 = private unnamed_addr constant [7 x i8] c"@.str.\00"
@.str.529 = private unnamed_addr constant [35 x i8] c" = private unnamed_addr constant [\00"
@.str.530 = private unnamed_addr constant [9 x i8] c" x i8] c\00"
@.str.531 = private unnamed_addr constant [4 x i8] c"\5C00\00"
@.str.532 = private unnamed_addr constant [29 x i8] c"; External Runtime Functions\00"
@.str.533 = private unnamed_addr constant [25 x i8] c"declare i8* @malloc(i64)\00"
@.str.534 = private unnamed_addr constant [24 x i8] c"declare void @free(i8*)\00"
@.str.535 = private unnamed_addr constant [30 x i8] c"declare i32 @printf(i8*, ...)\00"
@.str.536 = private unnamed_addr constant [23 x i8] c"declare i32 @puts(i8*)\00"
@.str.537 = private unnamed_addr constant [1 x i8] c"\00"
@.str.538 = private unnamed_addr constant [15 x i8] c"; Kore Runtime\00"
@.str.539 = private unnamed_addr constant [34 x i8] c"declare void @kore_print_i64(i64)\00"
@.str.540 = private unnamed_addr constant [34 x i8] c"declare void @kore_print_str(i8*)\00"
@.str.541 = private unnamed_addr constant [36 x i8] c"declare void @kore_println_str(i8*)\00"
@.str.542 = private unnamed_addr constant [39 x i8] c"declare i8* @kore_str_concat(i8*, i8*)\00"
@.str.543 = private unnamed_addr constant [30 x i8] c"declare i64 @kore_array_new()\00"
@.str.544 = private unnamed_addr constant [40 x i8] c"declare void @kore_array_push(i64, i64)\00"
@.str.545 = private unnamed_addr constant [38 x i8] c"declare i64 @kore_array_get(i64, i64)\00"
@.str.546 = private unnamed_addr constant [33 x i8] c"declare i64 @kore_array_len(i64)\00"
@.str.547 = private unnamed_addr constant [1 x i8] c"\00"
@.str.548 = private unnamed_addr constant [1 x i8] c"\00"
@.str.549 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.550 = private unnamed_addr constant [4 x i8] c"\5C0A\00"
@.str.551 = private unnamed_addr constant [2 x i8] c"\09\00"
@.str.552 = private unnamed_addr constant [4 x i8] c"\5C09\00"
@.str.553 = private unnamed_addr constant [2 x i8] c"\5C\00"
@.str.554 = private unnamed_addr constant [3 x i8] c"\5C\5C\00"
@.str.555 = private unnamed_addr constant [1 x i8] c"\00"
@.str.556 = private unnamed_addr constant [4 x i8] c"\5C22\00"
@.str.557 = private unnamed_addr constant [7 x i8] c"; use \00"
@.str.558 = private unnamed_addr constant [5 x i8] c"main\00"
@.str.559 = private unnamed_addr constant [10 x i8] c"main_kore\00"
@.str.560 = private unnamed_addr constant [1 x i8] c"\00"
@.str.561 = private unnamed_addr constant [3 x i8] c", \00"
@.str.562 = private unnamed_addr constant [6 x i8] c"i64 %\00"
@.str.563 = private unnamed_addr constant [13 x i8] c"define i64 @\00"
@.str.564 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.565 = private unnamed_addr constant [4 x i8] c") {\00"
@.str.566 = private unnamed_addr constant [7 x i8] c"entry:\00"
@.str.567 = private unnamed_addr constant [10 x i8] c"ret i64 0\00"
@.str.568 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.569 = private unnamed_addr constant [10 x i8] c"; struct \00"
@.str.570 = private unnamed_addr constant [1 x i8] c"\00"
@.str.571 = private unnamed_addr constant [3 x i8] c", \00"
@.str.572 = private unnamed_addr constant [4 x i8] c"i64\00"
@.str.573 = private unnamed_addr constant [1 x i8] c"\00"
@.str.574 = private unnamed_addr constant [4 x i8] c"i64\00"
@.str.575 = private unnamed_addr constant [2 x i8] c"%\00"
@.str.576 = private unnamed_addr constant [11 x i8] c" = type { \00"
@.str.577 = private unnamed_addr constant [3 x i8] c" }\00"
@.str.578 = private unnamed_addr constant [8 x i8] c"; enum \00"
@.str.579 = private unnamed_addr constant [2 x i8] c"%\00"
@.str.580 = private unnamed_addr constant [21 x i8] c" = type { i64, i8* }\00"
@.str.581 = private unnamed_addr constant [8 x i8] c"; impl \00"
@.str.582 = private unnamed_addr constant [2 x i8] c"_\00"
@.str.583 = private unnamed_addr constant [4 x i8] c"Let\00"
@.str.584 = private unnamed_addr constant [14 x i8] c" = alloca i64\00"
@.str.585 = private unnamed_addr constant [11 x i8] c"store i64 \00"
@.str.586 = private unnamed_addr constant [8 x i8] c", i64* \00"
@.str.587 = private unnamed_addr constant [4 x i8] c"Var\00"
@.str.588 = private unnamed_addr constant [14 x i8] c" = alloca i64\00"
@.str.589 = private unnamed_addr constant [11 x i8] c"store i64 \00"
@.str.590 = private unnamed_addr constant [8 x i8] c", i64* \00"
@.str.591 = private unnamed_addr constant [7 x i8] c"Return\00"
@.str.592 = private unnamed_addr constant [9 x i8] c"ret i64 \00"
@.str.593 = private unnamed_addr constant [10 x i8] c"ret i64 0\00"
@.str.594 = private unnamed_addr constant [5 x i8] c"Expr\00"
@.str.595 = private unnamed_addr constant [3 x i8] c"If\00"
@.str.596 = private unnamed_addr constant [16 x i8] c" = icmp ne i64 \00"
@.str.597 = private unnamed_addr constant [4 x i8] c", 0\00"
@.str.598 = private unnamed_addr constant [5 x i8] c"then\00"
@.str.599 = private unnamed_addr constant [5 x i8] c"else\00"
@.str.600 = private unnamed_addr constant [6 x i8] c"endif\00"
@.str.601 = private unnamed_addr constant [7 x i8] c"br i1 \00"
@.str.602 = private unnamed_addr constant [10 x i8] c", label %\00"
@.str.603 = private unnamed_addr constant [10 x i8] c", label %\00"
@.str.604 = private unnamed_addr constant [7 x i8] c"br i1 \00"
@.str.605 = private unnamed_addr constant [10 x i8] c", label %\00"
@.str.606 = private unnamed_addr constant [10 x i8] c", label %\00"
@.str.607 = private unnamed_addr constant [2 x i8] c":\00"
@.str.608 = private unnamed_addr constant [11 x i8] c"br label %\00"
@.str.609 = private unnamed_addr constant [2 x i8] c":\00"
@.str.610 = private unnamed_addr constant [11 x i8] c"br label %\00"
@.str.611 = private unnamed_addr constant [2 x i8] c":\00"
@.str.612 = private unnamed_addr constant [6 x i8] c"While\00"
@.str.613 = private unnamed_addr constant [11 x i8] c"while_cond\00"
@.str.614 = private unnamed_addr constant [11 x i8] c"while_body\00"
@.str.615 = private unnamed_addr constant [10 x i8] c"while_end\00"
@.str.616 = private unnamed_addr constant [11 x i8] c"br label %\00"
@.str.617 = private unnamed_addr constant [2 x i8] c":\00"
@.str.618 = private unnamed_addr constant [16 x i8] c" = icmp ne i64 \00"
@.str.619 = private unnamed_addr constant [4 x i8] c", 0\00"
@.str.620 = private unnamed_addr constant [7 x i8] c"br i1 \00"
@.str.621 = private unnamed_addr constant [10 x i8] c", label %\00"
@.str.622 = private unnamed_addr constant [10 x i8] c", label %\00"
@.str.623 = private unnamed_addr constant [2 x i8] c":\00"
@.str.624 = private unnamed_addr constant [11 x i8] c"br label %\00"
@.str.625 = private unnamed_addr constant [2 x i8] c":\00"
@.str.626 = private unnamed_addr constant [4 x i8] c"For\00"
@.str.627 = private unnamed_addr constant [37 x i8] c"; for loop (simplified as iteration)\00"
@.str.628 = private unnamed_addr constant [5 x i8] c"Loop\00"
@.str.629 = private unnamed_addr constant [5 x i8] c"loop\00"
@.str.630 = private unnamed_addr constant [9 x i8] c"loop_end\00"
@.str.631 = private unnamed_addr constant [11 x i8] c"br label %\00"
@.str.632 = private unnamed_addr constant [2 x i8] c":\00"
@.str.633 = private unnamed_addr constant [11 x i8] c"br label %\00"
@.str.634 = private unnamed_addr constant [2 x i8] c":\00"
@.str.635 = private unnamed_addr constant [6 x i8] c"Match\00"
@.str.636 = private unnamed_addr constant [33 x i8] c"; match (TODO: pattern matching)\00"
@.str.637 = private unnamed_addr constant [6 x i8] c"Break\00"
@.str.638 = private unnamed_addr constant [11 x i8] c"br label %\00"
@.str.639 = private unnamed_addr constant [28 x i8] c"; Error: break outside loop\00"
@.str.640 = private unnamed_addr constant [9 x i8] c"Continue\00"
@.str.641 = private unnamed_addr constant [11 x i8] c"; continue\00"
@.str.642 = private unnamed_addr constant [7 x i8] c"Assign\00"
@.str.643 = private unnamed_addr constant [6 x i8] c"Ident\00"
@.str.644 = private unnamed_addr constant [11 x i8] c"store i64 \00"
@.str.645 = private unnamed_addr constant [8 x i8] c", i64* \00"
@.str.646 = private unnamed_addr constant [6 x i8] c"Field\00"
@.str.647 = private unnamed_addr constant [25 x i8] c"; DEBUG: Resolved field \00"
@.str.648 = private unnamed_addr constant [5 x i8] c" in \00"
@.str.649 = private unnamed_addr constant [11 x i8] c" to index \00"
@.str.650 = private unnamed_addr constant [17 x i8] c" = inttoptr i64 \00"
@.str.651 = private unnamed_addr constant [6 x i8] c" to %\00"
@.str.652 = private unnamed_addr constant [2 x i8] c"*\00"
@.str.653 = private unnamed_addr constant [19 x i8] c" = getelementptr %\00"
@.str.654 = private unnamed_addr constant [4 x i8] c", %\00"
@.str.655 = private unnamed_addr constant [3 x i8] c"* \00"
@.str.656 = private unnamed_addr constant [14 x i8] c", i32 0, i32 \00"
@.str.657 = private unnamed_addr constant [11 x i8] c"store i64 \00"
@.str.658 = private unnamed_addr constant [8 x i8] c", i64* \00"
@.str.659 = private unnamed_addr constant [16 x i8] c"; Error: Field \00"
@.str.660 = private unnamed_addr constant [22 x i8] c" not found in struct \00"
@.str.661 = private unnamed_addr constant [24 x i8] c"; Error: Unknown field \00"
@.str.662 = private unnamed_addr constant [4 x i8] c"Int\00"
@.str.663 = private unnamed_addr constant [6 x i8] c"Float\00"
@.str.664 = private unnamed_addr constant [5 x i8] c"Bool\00"
@.str.665 = private unnamed_addr constant [2 x i8] c"1\00"
@.str.666 = private unnamed_addr constant [2 x i8] c"0\00"
@.str.667 = private unnamed_addr constant [7 x i8] c"String\00"
@.str.668 = private unnamed_addr constant [7 x i8] c"@.str.\00"
@.str.669 = private unnamed_addr constant [19 x i8] c" = getelementptr [\00"
@.str.670 = private unnamed_addr constant [10 x i8] c" x i8], [\00"
@.str.671 = private unnamed_addr constant [9 x i8] c" x i8]* \00"
@.str.672 = private unnamed_addr constant [15 x i8] c", i64 0, i64 0\00"
@.str.673 = private unnamed_addr constant [17 x i8] c" = ptrtoint i8* \00"
@.str.674 = private unnamed_addr constant [8 x i8] c" to i64\00"
@.str.675 = private unnamed_addr constant [6 x i8] c"Ident\00"
@.str.676 = private unnamed_addr constant [19 x i8] c" = load i64, i64* \00"
@.str.677 = private unnamed_addr constant [2 x i8] c"%\00"
@.str.678 = private unnamed_addr constant [7 x i8] c"Binary\00"
@.str.679 = private unnamed_addr constant [2 x i8] c"+\00"
@.str.680 = private unnamed_addr constant [12 x i8] c" = add i64 \00"
@.str.681 = private unnamed_addr constant [3 x i8] c", \00"
@.str.682 = private unnamed_addr constant [2 x i8] c"-\00"
@.str.683 = private unnamed_addr constant [12 x i8] c" = sub i64 \00"
@.str.684 = private unnamed_addr constant [3 x i8] c", \00"
@.str.685 = private unnamed_addr constant [2 x i8] c"*\00"
@.str.686 = private unnamed_addr constant [12 x i8] c" = mul i64 \00"
@.str.687 = private unnamed_addr constant [3 x i8] c", \00"
@.str.688 = private unnamed_addr constant [2 x i8] c"/\00"
@.str.689 = private unnamed_addr constant [13 x i8] c" = sdiv i64 \00"
@.str.690 = private unnamed_addr constant [3 x i8] c", \00"
@.str.691 = private unnamed_addr constant [2 x i8] c"%\00"
@.str.692 = private unnamed_addr constant [13 x i8] c" = srem i64 \00"
@.str.693 = private unnamed_addr constant [3 x i8] c", \00"
@.str.694 = private unnamed_addr constant [3 x i8] c"==\00"
@.str.695 = private unnamed_addr constant [3 x i8] c"eq\00"
@.str.696 = private unnamed_addr constant [16 x i8] c" = icmp eq i64 \00"
@.str.697 = private unnamed_addr constant [3 x i8] c", \00"
@.str.698 = private unnamed_addr constant [12 x i8] c" = zext i1 \00"
@.str.699 = private unnamed_addr constant [8 x i8] c" to i64\00"
@.str.700 = private unnamed_addr constant [3 x i8] c"!=\00"
@.str.701 = private unnamed_addr constant [3 x i8] c"ne\00"
@.str.702 = private unnamed_addr constant [16 x i8] c" = icmp ne i64 \00"
@.str.703 = private unnamed_addr constant [3 x i8] c", \00"
@.str.704 = private unnamed_addr constant [12 x i8] c" = zext i1 \00"
@.str.705 = private unnamed_addr constant [8 x i8] c" to i64\00"
@.str.706 = private unnamed_addr constant [2 x i8] c"<\00"
@.str.707 = private unnamed_addr constant [3 x i8] c"lt\00"
@.str.708 = private unnamed_addr constant [17 x i8] c" = icmp slt i64 \00"
@.str.709 = private unnamed_addr constant [3 x i8] c", \00"
@.str.710 = private unnamed_addr constant [12 x i8] c" = zext i1 \00"
@.str.711 = private unnamed_addr constant [8 x i8] c" to i64\00"
@.str.712 = private unnamed_addr constant [3 x i8] c"<=\00"
@.str.713 = private unnamed_addr constant [3 x i8] c"le\00"
@.str.714 = private unnamed_addr constant [17 x i8] c" = icmp sle i64 \00"
@.str.715 = private unnamed_addr constant [3 x i8] c", \00"
@.str.716 = private unnamed_addr constant [12 x i8] c" = zext i1 \00"
@.str.717 = private unnamed_addr constant [8 x i8] c" to i64\00"
@.str.718 = private unnamed_addr constant [2 x i8] c">\00"
@.str.719 = private unnamed_addr constant [3 x i8] c"gt\00"
@.str.720 = private unnamed_addr constant [17 x i8] c" = icmp sgt i64 \00"
@.str.721 = private unnamed_addr constant [3 x i8] c", \00"
@.str.722 = private unnamed_addr constant [12 x i8] c" = zext i1 \00"
@.str.723 = private unnamed_addr constant [8 x i8] c" to i64\00"
@.str.724 = private unnamed_addr constant [3 x i8] c">=\00"
@.str.725 = private unnamed_addr constant [3 x i8] c"ge\00"
@.str.726 = private unnamed_addr constant [17 x i8] c" = icmp sge i64 \00"
@.str.727 = private unnamed_addr constant [3 x i8] c", \00"
@.str.728 = private unnamed_addr constant [12 x i8] c" = zext i1 \00"
@.str.729 = private unnamed_addr constant [8 x i8] c" to i64\00"
@.str.730 = private unnamed_addr constant [3 x i8] c"&&\00"
@.str.731 = private unnamed_addr constant [4 x i8] c"and\00"
@.str.732 = private unnamed_addr constant [12 x i8] c" = and i64 \00"
@.str.733 = private unnamed_addr constant [3 x i8] c", \00"
@.str.734 = private unnamed_addr constant [3 x i8] c"||\00"
@.str.735 = private unnamed_addr constant [3 x i8] c"or\00"
@.str.736 = private unnamed_addr constant [11 x i8] c" = or i64 \00"
@.str.737 = private unnamed_addr constant [3 x i8] c", \00"
@.str.738 = private unnamed_addr constant [15 x i8] c"; unknown op: \00"
@.str.739 = private unnamed_addr constant [2 x i8] c"0\00"
@.str.740 = private unnamed_addr constant [6 x i8] c"Unary\00"
@.str.741 = private unnamed_addr constant [2 x i8] c"-\00"
@.str.742 = private unnamed_addr constant [15 x i8] c" = sub i64 0, \00"
@.str.743 = private unnamed_addr constant [2 x i8] c"!\00"
@.str.744 = private unnamed_addr constant [4 x i8] c"not\00"
@.str.745 = private unnamed_addr constant [16 x i8] c" = icmp eq i64 \00"
@.str.746 = private unnamed_addr constant [4 x i8] c", 0\00"
@.str.747 = private unnamed_addr constant [12 x i8] c" = zext i1 \00"
@.str.748 = private unnamed_addr constant [8 x i8] c" to i64\00"
@.str.749 = private unnamed_addr constant [5 x i8] c"Call\00"
@.str.750 = private unnamed_addr constant [6 x i8] c"Ident\00"
@.str.751 = private unnamed_addr constant [8 x i8] c"println\00"
@.str.752 = private unnamed_addr constant [6 x i8] c"print\00"
@.str.753 = private unnamed_addr constant [31 x i8] c"call void @kore_print_i64(i64 \00"
@.str.754 = private unnamed_addr constant [2 x i8] c")\00"
@.str.755 = private unnamed_addr constant [2 x i8] c"0\00"
@.str.756 = private unnamed_addr constant [1 x i8] c"\00"
@.str.757 = private unnamed_addr constant [3 x i8] c", \00"
@.str.758 = private unnamed_addr constant [5 x i8] c"i64 \00"
@.str.759 = private unnamed_addr constant [14 x i8] c" = call i64 @\00"
@.str.760 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.761 = private unnamed_addr constant [2 x i8] c")\00"
@.str.762 = private unnamed_addr constant [23 x i8] c"; indirect call (TODO)\00"
@.str.763 = private unnamed_addr constant [2 x i8] c"0\00"
@.str.764 = private unnamed_addr constant [5 x i8] c"None\00"
@.str.765 = private unnamed_addr constant [2 x i8] c"0\00"
@.str.766 = private unnamed_addr constant [6 x i8] c"Array\00"
@.str.767 = private unnamed_addr constant [23 x i8] c"; array literal (TODO)\00"
@.str.768 = private unnamed_addr constant [2 x i8] c"0\00"
@.str.769 = private unnamed_addr constant [6 x i8] c"Index\00"
@.str.770 = private unnamed_addr constant [33 x i8] c" = call i64 @kore_array_get(i64 \00"
@.str.771 = private unnamed_addr constant [7 x i8] c", i64 \00"
@.str.772 = private unnamed_addr constant [2 x i8] c")\00"
@.str.773 = private unnamed_addr constant [6 x i8] c"Field\00"
@.str.774 = private unnamed_addr constant [25 x i8] c"; DEBUG: Resolved field \00"
@.str.775 = private unnamed_addr constant [5 x i8] c" in \00"
@.str.776 = private unnamed_addr constant [11 x i8] c" to index \00"
@.str.777 = private unnamed_addr constant [17 x i8] c" = inttoptr i64 \00"
@.str.778 = private unnamed_addr constant [6 x i8] c" to %\00"
@.str.779 = private unnamed_addr constant [2 x i8] c"*\00"
@.str.780 = private unnamed_addr constant [19 x i8] c" = getelementptr %\00"
@.str.781 = private unnamed_addr constant [4 x i8] c", %\00"
@.str.782 = private unnamed_addr constant [3 x i8] c"* \00"
@.str.783 = private unnamed_addr constant [14 x i8] c", i32 0, i32 \00"
@.str.784 = private unnamed_addr constant [19 x i8] c" = load i64, i64* \00"
@.str.785 = private unnamed_addr constant [16 x i8] c"; Error: Field \00"
@.str.786 = private unnamed_addr constant [22 x i8] c" not found in struct \00"
@.str.787 = private unnamed_addr constant [24 x i8] c"; Error: Unknown field \00"
@.str.788 = private unnamed_addr constant [2 x i8] c"0\00"
@.str.789 = private unnamed_addr constant [7 x i8] c"Struct\00"
@.str.790 = private unnamed_addr constant [25 x i8] c" = call i8* @malloc(i64 \00"
@.str.791 = private unnamed_addr constant [2 x i8] c")\00"
@.str.792 = private unnamed_addr constant [16 x i8] c" = bitcast i8* \00"
@.str.793 = private unnamed_addr constant [6 x i8] c" to %\00"
@.str.794 = private unnamed_addr constant [2 x i8] c"*\00"
@.str.795 = private unnamed_addr constant [19 x i8] c" = getelementptr %\00"
@.str.796 = private unnamed_addr constant [4 x i8] c", %\00"
@.str.797 = private unnamed_addr constant [3 x i8] c"* \00"
@.str.798 = private unnamed_addr constant [14 x i8] c", i32 0, i32 \00"
@.str.799 = private unnamed_addr constant [11 x i8] c"store i64 \00"
@.str.800 = private unnamed_addr constant [8 x i8] c", i64* \00"
@.str.801 = private unnamed_addr constant [14 x i8] c" = ptrtoint %\00"
@.str.802 = private unnamed_addr constant [3 x i8] c"* \00"
@.str.803 = private unnamed_addr constant [8 x i8] c" to i64\00"
@.str.804 = private unnamed_addr constant [2 x i8] c"0\00"
@.str.805 = private unnamed_addr constant [11 x i8] c"MethodCall\00"
@.str.806 = private unnamed_addr constant [2 x i8] c"_\00"
@.str.807 = private unnamed_addr constant [1 x i8] c"\00"
@.str.808 = private unnamed_addr constant [3 x i8] c", \00"
@.str.809 = private unnamed_addr constant [5 x i8] c"i64 \00"
@.str.810 = private unnamed_addr constant [14 x i8] c" = call i64 @\00"
@.str.811 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.812 = private unnamed_addr constant [2 x i8] c")\00"
@.str.813 = private unnamed_addr constant [25 x i8] c"; Error: Unknown method \00"
@.str.814 = private unnamed_addr constant [2 x i8] c"0\00"
@.str.815 = private unnamed_addr constant [12 x i8] c"EnumVariant\00"
@.str.816 = private unnamed_addr constant [22 x i8] c"; enum variant (TODO)\00"
@.str.817 = private unnamed_addr constant [2 x i8] c"0\00"
@.str.818 = private unnamed_addr constant [17 x i8] c"; unknown expr: \00"
@.str.819 = private unnamed_addr constant [2 x i8] c"0\00"
@.str.820 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.821 = private unnamed_addr constant [1 x i8] c"\00"
@.str.822 = private unnamed_addr constant [1 x i8] c"\00"
@.str.823 = private unnamed_addr constant [5 x i8] c"    \00"
@.str.824 = private unnamed_addr constant [1 x i8] c"\00"
@.str.825 = private unnamed_addr constant [50 x i8] c"// Generated by KORE Compiler (Project Ouroboros)\00"
@.str.826 = private unnamed_addr constant [44 x i8] c"// Do not edit - regenerate from .kr source\00"
@.str.827 = private unnamed_addr constant [28 x i8] c"#![allow(unused_variables)]\00"
@.str.828 = private unnamed_addr constant [22 x i8] c"#![allow(unused_mut)]\00"
@.str.829 = private unnamed_addr constant [21 x i8] c"#![allow(dead_code)]\00"
@.str.830 = private unnamed_addr constant [25 x i8] c"#![allow(unused_parens)]\00"
@.str.831 = private unnamed_addr constant [31 x i8] c"use std::collections::HashMap;\00"
@.str.832 = private unnamed_addr constant [17 x i8] c"use std::rc::Rc;\00"
@.str.833 = private unnamed_addr constant [24 x i8] c"use std::cell::RefCell;\00"
@.str.834 = private unnamed_addr constant [1 x i8] c"\00"
@.str.835 = private unnamed_addr constant [5 x i8] c"pub \00"
@.str.836 = private unnamed_addr constant [1 x i8] c"\00"
@.str.837 = private unnamed_addr constant [7 x i8] c"async \00"
@.str.838 = private unnamed_addr constant [1 x i8] c"\00"
@.str.839 = private unnamed_addr constant [5 x i8] c" -> \00"
@.str.840 = private unnamed_addr constant [5 x i8] c"main\00"
@.str.841 = private unnamed_addr constant [1 x i8] c"\00"
@.str.842 = private unnamed_addr constant [4 x i8] c"fn \00"
@.str.843 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.844 = private unnamed_addr constant [2 x i8] c")\00"
@.str.845 = private unnamed_addr constant [3 x i8] c" {\00"
@.str.846 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.847 = private unnamed_addr constant [4 x i8] c"i64\00"
@.str.848 = private unnamed_addr constant [3 x i8] c": \00"
@.str.849 = private unnamed_addr constant [3 x i8] c", \00"
@.str.850 = private unnamed_addr constant [1 x i8] c"\00"
@.str.851 = private unnamed_addr constant [5 x i8] c"pub \00"
@.str.852 = private unnamed_addr constant [24 x i8] c"#[derive(Debug, Clone)]\00"
@.str.853 = private unnamed_addr constant [8 x i8] c"struct \00"
@.str.854 = private unnamed_addr constant [3 x i8] c" {\00"
@.str.855 = private unnamed_addr constant [5 x i8] c"pub \00"
@.str.856 = private unnamed_addr constant [3 x i8] c": \00"
@.str.857 = private unnamed_addr constant [2 x i8] c",\00"
@.str.858 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.859 = private unnamed_addr constant [35 x i8] c"#[derive(Debug, Clone, PartialEq)]\00"
@.str.860 = private unnamed_addr constant [10 x i8] c"pub enum \00"
@.str.861 = private unnamed_addr constant [3 x i8] c" {\00"
@.str.862 = private unnamed_addr constant [2 x i8] c",\00"
@.str.863 = private unnamed_addr constant [3 x i8] c", \00"
@.str.864 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.865 = private unnamed_addr constant [3 x i8] c"),\00"
@.str.866 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.867 = private unnamed_addr constant [6 x i8] c"impl \00"
@.str.868 = private unnamed_addr constant [3 x i8] c" {\00"
@.str.869 = private unnamed_addr constant [6 x i8] c"&self\00"
@.str.870 = private unnamed_addr constant [4 x i8] c"i64\00"
@.str.871 = private unnamed_addr constant [4 x i8] c"i64\00"
@.str.872 = private unnamed_addr constant [3 x i8] c": \00"
@.str.873 = private unnamed_addr constant [3 x i8] c", \00"
@.str.874 = private unnamed_addr constant [1 x i8] c"\00"
@.str.875 = private unnamed_addr constant [5 x i8] c" -> \00"
@.str.876 = private unnamed_addr constant [1 x i8] c"\00"
@.str.877 = private unnamed_addr constant [1 x i8] c"\00"
@.str.878 = private unnamed_addr constant [5 x i8] c"pub \00"
@.str.879 = private unnamed_addr constant [4 x i8] c"fn \00"
@.str.880 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.881 = private unnamed_addr constant [2 x i8] c")\00"
@.str.882 = private unnamed_addr constant [3 x i8] c" {\00"
@.str.883 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.884 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.885 = private unnamed_addr constant [2 x i8] c"/\00"
@.str.886 = private unnamed_addr constant [3 x i8] c"::\00"
@.str.887 = private unnamed_addr constant [5 x i8] c"use \00"
@.str.888 = private unnamed_addr constant [2 x i8] c";\00"
@.str.889 = private unnamed_addr constant [4 x i8] c"Let\00"
@.str.890 = private unnamed_addr constant [1 x i8] c"\00"
@.str.891 = private unnamed_addr constant [3 x i8] c": \00"
@.str.892 = private unnamed_addr constant [5 x i8] c"let \00"
@.str.893 = private unnamed_addr constant [4 x i8] c" = \00"
@.str.894 = private unnamed_addr constant [2 x i8] c";\00"
@.str.895 = private unnamed_addr constant [4 x i8] c"Var\00"
@.str.896 = private unnamed_addr constant [1 x i8] c"\00"
@.str.897 = private unnamed_addr constant [3 x i8] c": \00"
@.str.898 = private unnamed_addr constant [9 x i8] c"let mut \00"
@.str.899 = private unnamed_addr constant [4 x i8] c" = \00"
@.str.900 = private unnamed_addr constant [2 x i8] c";\00"
@.str.901 = private unnamed_addr constant [7 x i8] c"Assign\00"
@.str.902 = private unnamed_addr constant [4 x i8] c" = \00"
@.str.903 = private unnamed_addr constant [2 x i8] c";\00"
@.str.904 = private unnamed_addr constant [7 x i8] c"Return\00"
@.str.905 = private unnamed_addr constant [8 x i8] c"return \00"
@.str.906 = private unnamed_addr constant [2 x i8] c";\00"
@.str.907 = private unnamed_addr constant [8 x i8] c"return;\00"
@.str.908 = private unnamed_addr constant [3 x i8] c"If\00"
@.str.909 = private unnamed_addr constant [4 x i8] c"if \00"
@.str.910 = private unnamed_addr constant [3 x i8] c" {\00"
@.str.911 = private unnamed_addr constant [9 x i8] c"} else {\00"
@.str.912 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.913 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.914 = private unnamed_addr constant [6 x i8] c"While\00"
@.str.915 = private unnamed_addr constant [7 x i8] c"while \00"
@.str.916 = private unnamed_addr constant [3 x i8] c" {\00"
@.str.917 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.918 = private unnamed_addr constant [4 x i8] c"For\00"
@.str.919 = private unnamed_addr constant [5 x i8] c"for \00"
@.str.920 = private unnamed_addr constant [5 x i8] c" in \00"
@.str.921 = private unnamed_addr constant [3 x i8] c" {\00"
@.str.922 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.923 = private unnamed_addr constant [5 x i8] c"Loop\00"
@.str.924 = private unnamed_addr constant [7 x i8] c"loop {\00"
@.str.925 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.926 = private unnamed_addr constant [6 x i8] c"Match\00"
@.str.927 = private unnamed_addr constant [7 x i8] c"match \00"
@.str.928 = private unnamed_addr constant [3 x i8] c" {\00"
@.str.929 = private unnamed_addr constant [6 x i8] c" => {\00"
@.str.930 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.931 = private unnamed_addr constant [2 x i8] c"}\00"
@.str.932 = private unnamed_addr constant [5 x i8] c"Expr\00"
@.str.933 = private unnamed_addr constant [2 x i8] c";\00"
@.str.934 = private unnamed_addr constant [6 x i8] c"Break\00"
@.str.935 = private unnamed_addr constant [7 x i8] c"break;\00"
@.str.936 = private unnamed_addr constant [9 x i8] c"Continue\00"
@.str.937 = private unnamed_addr constant [10 x i8] c"continue;\00"
@.str.938 = private unnamed_addr constant [4 x i8] c"Int\00"
@.str.939 = private unnamed_addr constant [6 x i8] c"Float\00"
@.str.940 = private unnamed_addr constant [7 x i8] c"String\00"
@.str.941 = private unnamed_addr constant [1 x i8] c"\00"
@.str.942 = private unnamed_addr constant [13 x i8] c".to_string()\00"
@.str.943 = private unnamed_addr constant [5 x i8] c"Bool\00"
@.str.944 = private unnamed_addr constant [5 x i8] c"true\00"
@.str.945 = private unnamed_addr constant [6 x i8] c"false\00"
@.str.946 = private unnamed_addr constant [5 x i8] c"None\00"
@.str.947 = private unnamed_addr constant [5 x i8] c"None\00"
@.str.948 = private unnamed_addr constant [6 x i8] c"Ident\00"
@.str.949 = private unnamed_addr constant [7 x i8] c"Binary\00"
@.str.950 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.951 = private unnamed_addr constant [2 x i8] c" \00"
@.str.952 = private unnamed_addr constant [2 x i8] c" \00"
@.str.953 = private unnamed_addr constant [2 x i8] c")\00"
@.str.954 = private unnamed_addr constant [6 x i8] c"Unary\00"
@.str.955 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.956 = private unnamed_addr constant [2 x i8] c")\00"
@.str.957 = private unnamed_addr constant [5 x i8] c"Call\00"
@.str.958 = private unnamed_addr constant [8 x i8] c"println\00"
@.str.959 = private unnamed_addr constant [6 x i8] c"print\00"
@.str.960 = private unnamed_addr constant [3 x i8] c"{}\00"
@.str.961 = private unnamed_addr constant [1 x i8] c"\00"
@.str.962 = private unnamed_addr constant [2 x i8] c" \00"
@.str.963 = private unnamed_addr constant [1 x i8] c"\00"
@.str.964 = private unnamed_addr constant [3 x i8] c"!(\00"
@.str.965 = private unnamed_addr constant [3 x i8] c", \00"
@.str.966 = private unnamed_addr constant [3 x i8] c", \00"
@.str.967 = private unnamed_addr constant [2 x i8] c")\00"
@.str.968 = private unnamed_addr constant [4 x i8] c"!()\00"
@.str.969 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.970 = private unnamed_addr constant [3 x i8] c", \00"
@.str.971 = private unnamed_addr constant [2 x i8] c")\00"
@.str.972 = private unnamed_addr constant [11 x i8] c"MethodCall\00"
@.str.973 = private unnamed_addr constant [2 x i8] c".\00"
@.str.974 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.975 = private unnamed_addr constant [3 x i8] c", \00"
@.str.976 = private unnamed_addr constant [2 x i8] c")\00"
@.str.977 = private unnamed_addr constant [6 x i8] c"Index\00"
@.str.978 = private unnamed_addr constant [2 x i8] c"[\00"
@.str.979 = private unnamed_addr constant [2 x i8] c"]\00"
@.str.980 = private unnamed_addr constant [6 x i8] c"Field\00"
@.str.981 = private unnamed_addr constant [2 x i8] c".\00"
@.str.982 = private unnamed_addr constant [6 x i8] c"Array\00"
@.str.983 = private unnamed_addr constant [6 x i8] c"vec![\00"
@.str.984 = private unnamed_addr constant [3 x i8] c", \00"
@.str.985 = private unnamed_addr constant [2 x i8] c"]\00"
@.str.986 = private unnamed_addr constant [7 x i8] c"Struct\00"
@.str.987 = private unnamed_addr constant [3 x i8] c": \00"
@.str.988 = private unnamed_addr constant [4 x i8] c" { \00"
@.str.989 = private unnamed_addr constant [3 x i8] c", \00"
@.str.990 = private unnamed_addr constant [3 x i8] c" }\00"
@.str.991 = private unnamed_addr constant [12 x i8] c"EnumVariant\00"
@.str.992 = private unnamed_addr constant [3 x i8] c"::\00"
@.str.993 = private unnamed_addr constant [3 x i8] c"::\00"
@.str.994 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.995 = private unnamed_addr constant [3 x i8] c", \00"
@.str.996 = private unnamed_addr constant [2 x i8] c")\00"
@.str.997 = private unnamed_addr constant [3 x i8] c"If\00"
@.str.998 = private unnamed_addr constant [5 x i8] c"(if \00"
@.str.999 = private unnamed_addr constant [4 x i8] c" { \00"
@.str.1000 = private unnamed_addr constant [11 x i8] c" } else { \00"
@.str.1001 = private unnamed_addr constant [4 x i8] c" })\00"
@.str.1002 = private unnamed_addr constant [5 x i8] c"(if \00"
@.str.1003 = private unnamed_addr constant [4 x i8] c" { \00"
@.str.1004 = private unnamed_addr constant [16 x i8] c" } else { () })\00"
@.str.1005 = private unnamed_addr constant [7 x i8] c"Lambda\00"
@.str.1006 = private unnamed_addr constant [3 x i8] c", \00"
@.str.1007 = private unnamed_addr constant [2 x i8] c"|\00"
@.str.1008 = private unnamed_addr constant [3 x i8] c"| \00"
@.str.1009 = private unnamed_addr constant [6 x i8] c"Await\00"
@.str.1010 = private unnamed_addr constant [7 x i8] c".await\00"
@.str.1011 = private unnamed_addr constant [22 x i8] c"/* unsupported expr: \00"
@.str.1012 = private unnamed_addr constant [4 x i8] c" */\00"
@.str.1013 = private unnamed_addr constant [9 x i8] c"Wildcard\00"
@.str.1014 = private unnamed_addr constant [2 x i8] c"_\00"
@.str.1015 = private unnamed_addr constant [6 x i8] c"Ident\00"
@.str.1016 = private unnamed_addr constant [8 x i8] c"Literal\00"
@.str.1017 = private unnamed_addr constant [8 x i8] c"Variant\00"
@.str.1018 = private unnamed_addr constant [2 x i8] c"(\00"
@.str.1019 = private unnamed_addr constant [3 x i8] c", \00"
@.str.1020 = private unnamed_addr constant [2 x i8] c")\00"
@.str.1021 = private unnamed_addr constant [26 x i8] c"/* unsupported pattern */\00"
@.str.1022 = private unnamed_addr constant [4 x i8] c"Int\00"
@.str.1023 = private unnamed_addr constant [4 x i8] c"i64\00"
@.str.1024 = private unnamed_addr constant [6 x i8] c"Float\00"
@.str.1025 = private unnamed_addr constant [4 x i8] c"f64\00"
@.str.1026 = private unnamed_addr constant [5 x i8] c"Bool\00"
@.str.1027 = private unnamed_addr constant [5 x i8] c"bool\00"
@.str.1028 = private unnamed_addr constant [7 x i8] c"String\00"
@.str.1029 = private unnamed_addr constant [7 x i8] c"String\00"
@.str.1030 = private unnamed_addr constant [5 x i8] c"Unit\00"
@.str.1031 = private unnamed_addr constant [3 x i8] c"()\00"
@.str.1032 = private unnamed_addr constant [6 x i8] c"Array\00"
@.str.1033 = private unnamed_addr constant [9 x i8] c"Vec<i64>\00"
@.str.1034 = private unnamed_addr constant [7 x i8] c"Array<\00"
@.str.1035 = private unnamed_addr constant [5 x i8] c"Vec<\00"
@.str.1036 = private unnamed_addr constant [2 x i8] c">\00"
@.str.1037 = private unnamed_addr constant [8 x i8] c"Option<\00"
@.str.1038 = private unnamed_addr constant [8 x i8] c"Option<\00"
@.str.1039 = private unnamed_addr constant [2 x i8] c">\00"
@.str.1040 = private unnamed_addr constant [4 x i8] c"and\00"
@.str.1041 = private unnamed_addr constant [3 x i8] c"&&\00"
@.str.1042 = private unnamed_addr constant [3 x i8] c"or\00"
@.str.1043 = private unnamed_addr constant [3 x i8] c"||\00"
@.str.1044 = private unnamed_addr constant [4 x i8] c"not\00"
@.str.1045 = private unnamed_addr constant [2 x i8] c"!\00"
@.str.1046 = private unnamed_addr constant [1 x i8] c"\00"
@.str.1047 = private unnamed_addr constant [1 x i8] c"\00"
@.str.1048 = private unnamed_addr constant [2 x i8] c"\0A\00"
@.str.1049 = private unnamed_addr constant [3 x i8] c"\5Cn\00"
@.str.1050 = private unnamed_addr constant [2 x i8] c"\09\00"
@.str.1051 = private unnamed_addr constant [3 x i8] c"\5Ct\00"
@.str.1052 = private unnamed_addr constant [2 x i8] c"\5C\00"
@.str.1053 = private unnamed_addr constant [3 x i8] c"\5C\5C\00"
@.str.1054 = private unnamed_addr constant [1 x i8] c"\00"
@.str.1055 = private unnamed_addr constant [2 x i8] c"\5C\00"
@.str.1056 = private unnamed_addr constant [2 x i8] c".\00"
@.str.1057 = private unnamed_addr constant [2 x i8] c".\00"
@.str.1058 = private unnamed_addr constant [8 x i8] c"project\00"
@.str.1059 = private unnamed_addr constant [5 x i8] c"Some\00"
@.str.1060 = private unnamed_addr constant [5 x i8] c"None\00"
@.str.1061 = private unnamed_addr constant [2 x i8] c"-\00"
@.str.1062 = private unnamed_addr constant [3 x i8] c"-o\00"
@.str.1063 = private unnamed_addr constant [9 x i8] c"--target\00"
@.str.1064 = private unnamed_addr constant [5 x i8] c"Some\00"
@.str.1065 = private unnamed_addr constant [5 x i8] c"None\00"
@.str.1066 = private unnamed_addr constant [3 x i8] c"-o\00"
@.str.1067 = private unnamed_addr constant [10 x i8] c"--verbose\00"
@.str.1068 = private unnamed_addr constant [3 x i8] c"-v\00"
@.str.1069 = private unnamed_addr constant [1 x i8] c"\00"
@.str.1070 = private unnamed_addr constant [31 x i8] c"Error: No input file specified\00"
@.str.1071 = private unnamed_addr constant [5 x i8] c"LLVM\00"
@.str.1072 = private unnamed_addr constant [9 x i8] c"--target\00"
@.str.1073 = private unnamed_addr constant [5 x i8] c"rust\00"
@.str.1074 = private unnamed_addr constant [5 x i8] c"Rust\00"
@.str.1075 = private unnamed_addr constant [5 x i8] c"wasm\00"
@.str.1076 = private unnamed_addr constant [5 x i8] c"WASM\00"
@.str.1077 = private unnamed_addr constant [5 x i8] c"LLVM\00"
@.str.1078 = private unnamed_addr constant [5 x i8] c"LLVM\00"
@.str.1079 = private unnamed_addr constant [30 x i8] c" KORE Compiler (Ouroboros)\00"
@.str.1080 = private unnamed_addr constant [1 x i8] c"\00"
@.str.1081 = private unnamed_addr constant [15 x i8] c" Reading: \00"
@.str.1082 = private unnamed_addr constant [19 x i8] c" Tokenizing...\00"
@.str.1083 = private unnamed_addr constant [4 x i8] c"   \00"
@.str.1084 = private unnamed_addr constant [8 x i8] c" tokens\00"
@.str.1085 = private unnamed_addr constant [16 x i8] c" Parsing...\00"
@.str.1086 = private unnamed_addr constant [4 x i8] c"   \00"
@.str.1087 = private unnamed_addr constant [7 x i8] c" items\00"
@.str.1088 = private unnamed_addr constant [1 x i8] c"\00"
@.str.1089 = private unnamed_addr constant [1 x i8] c"\00"
@.str.1090 = private unnamed_addr constant [29 x i8] c" Generating LLVM IR...\00"
@.str.1091 = private unnamed_addr constant [4 x i8] c".ll\00"
@.str.1092 = private unnamed_addr constant [24 x i8] c" Generating Rust...\00"
@.str.1093 = private unnamed_addr constant [4 x i8] c".rs\00"
@.str.1094 = private unnamed_addr constant [24 x i8] c" Generating WASM...\00"
@.str.1095 = private unnamed_addr constant [55 x i8] c"WASM backend not yet implemented in bootstrap compiler\00"
@.str.1096 = private unnamed_addr constant [1 x i8] c"\00"
@.str.1097 = private unnamed_addr constant [15 x i8] c" Writing: \00"
@.str.1098 = private unnamed_addr constant [18 x i8] c" Compiled to: \00"
@.str.1099 = private unnamed_addr constant [12 x i8] c"/Cargo.toml\00"
@.str.1100 = private unnamed_addr constant [15 x i8] c"   Generated: \00"
