; KORE Compiler Output - LLVM IR
; Generated by Project Ouroboros
; Compile with: clang output.ll kore_runtime.o -o output

target triple = "x86_64-pc-windows-msvc"

; External Runtime Functions
declare i8* @malloc(i64)
declare void @free(i8*)
declare i32 @printf(i8*, ...)
declare i32 @puts(i8*)

; Kore Runtime
declare void @kore_print_i64(i64)
declare void @kore_print_str(i64)
declare void @kore_println_str(i64) ; DEBUG_UPDATED
declare i8* @kore_str_concat(i8*, i8*)
declare i64 @kore_array_new()
declare i64 @kore_array_push(i64, i64)
declare i64 @kore_array_pop(i64)
declare i64 @kore_array_get(i64, i64)
declare i64 @kore_array_len(i64)

; Kore Stdlib
declare i64 @kore_len(i64)
declare i64 @kore_str_len(i64)
declare i64 @kore_split(i64, i64)
declare i64 @kore_contains(i64, i64)
declare i64 @kore_ord(i64)
declare i64 @kore_chr(i64)
declare i64 @kore_to_int(i64)
declare i64 @kore_to_float(i64)
declare i64 @kore_to_string(i64)
declare i64 @kore_range(i64, i64)
declare i64 @kore_slice(i64, i64, i64)
declare i64 @kore_char_at(i64, i64)
declare i64 @kore_substring(i64, i64, i64)
declare i64 @kore_str_eq(i64, i64)
declare i64 @kore_append(i64, i64)
declare i64 @kore_add_op(i64, i64)
declare i64 @kore_sub_op(i64, i64)
declare i64 @kore_mul_op(i64, i64)
declare i64 @kore_div_op(i64, i64)
declare i64 @kore_rem_op(i64, i64)
declare i64 @kore_eq_op(i64, i64)
declare i64 @kore_neq_op(i64, i64)
declare i64 @kore_lt_op(i64, i64)
declare i64 @kore_le_op(i64, i64)
declare i64 @kore_gt_op(i64, i64)
declare i64 @kore_ge_op(i64, i64)
declare i64 @kore_is_truthy(i64)

; Direct Main Wrappers
declare i64 @args()
declare void @exit(i64)
declare i64 @read_file(i64)
declare i64 @write_file(i64, i64)
declare i64 @substring(i64, i64, i64)
declare i64 @replace(i64, i64, i64)
declare i64 @starts_with(i64, i64)
declare i64 @char_code_at(i64, i64)
declare i64 @char_from_code(i64)

; Built-in generic types (used as opaque pointers)
%Box = type { i64, i64 }
%Array = type { i64 }
%Option = type { i64, i8*, i8* }
%Vec = type { i64 }
%StringBuilder = type { i64 }
%Result = type { i64, i8*, i8* }
%HashMap = type { i64 }
%HashSet = type { i64 }
%Map = type { i64 }
%Set = type { i64 }

; Option/Box helpers
declare i64 @kore_some(i64)
declare i64 @kore_none()
declare i64 @kore_box(i64)
declare i64 @kore_unwrap(i64)
declare void @kore_panic(i64)

; Map/Variant helpers
declare i64 @kore_contains_key(i64, i64)
declare i64 @kore_join(i64, i64)
declare i64 @kore_peek(i64)
declare i64 @kore_peek_offset(i64, i64)
declare i64 @kore_variant_of(i64)
declare i64 @kore_variant_field(i64, i64)
declare i64 @Map_new()
declare void @kore_map_set(i64, i64, i64)
declare i64 @kore_map_get(i64, i64)
declare i64 @kore_create_token_payload(i64, i64)
declare i64 @kore_create_token_simple(i64)


define i64 @main_kore() {
  entry:
  %t0 = alloca i64
  store i64 -2216615441596406, i64* %t0
  %t1 = alloca i64
  store i64 -2216615441596396, i64* %t1
  %t2 = load i64, i64* %t0
  %t3 = load i64, i64* %t1
  %t4 = call i64 @kore_add_op(i64 %t2, i64 %t3)
  %t5 = alloca i64
  store i64 %t4, i64* %t5
  %t6 = getelementptr [11 x i8], [11 x i8]* @.str.0, i64 0, i64 0
  %t7 = ptrtoint i8* %t6 to i64
  %t8 = lshr i64 %t7, 3
  %t9 = or i64 %t8, 18444633011384221696
  %t10 = load i64, i64* %t5
  %t11 = call i64 @kore_to_string(i64 %t10)
  %t12 = call i64 @kore_str_concat(i64 %t9, i64 %t11)
  %t13 = inttoptr i64 %t12 to i8*
  call void @kore_println_str(i8* %t13)
  %t14 = load i64, i64* %t1
  %t15 = load i64, i64* %t0
  %t16 = call i64 @kore_sub_op(i64 %t14, i64 %t15)
  %t17 = alloca i64
  store i64 %t16, i64* %t17
  %t18 = getelementptr [11 x i8], [11 x i8]* @.str.1, i64 0, i64 0
  %t19 = ptrtoint i8* %t18 to i64
  %t20 = lshr i64 %t19, 3
  %t21 = or i64 %t20, 18444633011384221696
  %t22 = load i64, i64* %t17
  %t23 = call i64 @kore_to_string(i64 %t22)
  %t24 = call i64 @kore_str_concat(i64 %t21, i64 %t23)
  %t25 = inttoptr i64 %t24 to i8*
  call void @kore_println_str(i8* %t25)
  %t26 = load i64, i64* %t0
  %t27 = call i64 @kore_mul_op(i64 %t26, i64 -2216615441596411)
  %t28 = alloca i64
  store i64 %t27, i64* %t28
  %t29 = getelementptr [10 x i8], [10 x i8]* @.str.2, i64 0, i64 0
  %t30 = ptrtoint i8* %t29 to i64
  %t31 = lshr i64 %t30, 3
  %t32 = or i64 %t31, 18444633011384221696
  %t33 = load i64, i64* %t28
  %t34 = call i64 @kore_to_string(i64 %t33)
  %t35 = call i64 @kore_str_concat(i64 %t32, i64 %t34)
  %t36 = inttoptr i64 %t35 to i8*
  call void @kore_println_str(i8* %t36)
  %t37 = load i64, i64* %t1
  %t38 = call i64 @kore_div_op(i64 %t37, i64 -2216615441596414)
  %t39 = alloca i64
  store i64 %t38, i64* %t39
  %t40 = getelementptr [10 x i8], [10 x i8]* @.str.3, i64 0, i64 0
  %t41 = ptrtoint i8* %t40 to i64
  %t42 = lshr i64 %t41, 3
  %t43 = or i64 %t42, 18444633011384221696
  %t44 = load i64, i64* %t39
  %t45 = call i64 @kore_to_string(i64 %t44)
  %t46 = call i64 @kore_str_concat(i64 %t43, i64 %t45)
  %t47 = inttoptr i64 %t46 to i8*
  call void @kore_println_str(i8* %t47)
  %t48 = load i64, i64* %t0
  %t49 = load i64, i64* %t1
  %t50 = call i64 @kore_lt_op(i64 %t48, i64 %t49)
  %t51 = call i64 @kore_is_truthy(i64 %t50)
  %t52 = icmp ne i64 %t51, 0
  br i1 %t52, label %then0, label %else1
  then0:
  %t53 = getelementptr [16 x i8], [16 x i8]* @.str.4, i64 0, i64 0
  %t54 = ptrtoint i8* %t53 to i64
  %t55 = lshr i64 %t54, 3
  %t56 = or i64 %t55, 18444633011384221696
  %t57 = inttoptr i64 %t56 to i8*
  call void @kore_println_str(i8* %t57)
  br label %endif2
  else1:
  %t58 = getelementptr [25 x i8], [25 x i8]* @.str.5, i64 0, i64 0
  %t59 = ptrtoint i8* %t58 to i64
  %t60 = lshr i64 %t59, 3
  %t61 = or i64 %t60, 18444633011384221696
  %t62 = inttoptr i64 %t61 to i8*
  call void @kore_println_str(i8* %t62)
  br label %endif2
  endif2:
  %t63 = load i64, i64* %t1
  %t64 = load i64, i64* %t0
  %t65 = call i64 @kore_gt_op(i64 %t63, i64 %t64)
  %t66 = call i64 @kore_is_truthy(i64 %t65)
  %t67 = icmp ne i64 %t66, 0
  br i1 %t67, label %then3, label %else4
  then3:
  %t68 = getelementptr [16 x i8], [16 x i8]* @.str.6, i64 0, i64 0
  %t69 = ptrtoint i8* %t68 to i64
  %t70 = lshr i64 %t69, 3
  %t71 = or i64 %t70, 18444633011384221696
  %t72 = inttoptr i64 %t71 to i8*
  call void @kore_println_str(i8* %t72)
  br label %endif5
  else4:
  %t73 = getelementptr [25 x i8], [25 x i8]* @.str.7, i64 0, i64 0
  %t74 = ptrtoint i8* %t73 to i64
  %t75 = lshr i64 %t74, 3
  %t76 = or i64 %t75, 18444633011384221696
  %t77 = inttoptr i64 %t76 to i8*
  call void @kore_println_str(i8* %t77)
  br label %endif5
  endif5:
  ret i64 0
}

; String Constants
@.str.0 = private unnamed_addr constant [11 x i8] c"10 + 20 = \00", align 8
@.str.1 = private unnamed_addr constant [11 x i8] c"20 - 10 = \00", align 8
@.str.2 = private unnamed_addr constant [10 x i8] c"10 * 5 = \00", align 8
@.str.3 = private unnamed_addr constant [10 x i8] c"20 / 2 = \00", align 8
@.str.4 = private unnamed_addr constant [16 x i8] c"10 < 20 is true\00", align 8
@.str.5 = private unnamed_addr constant [25 x i8] c"10 < 20 is false (ERROR)\00", align 8
@.str.6 = private unnamed_addr constant [16 x i8] c"20 > 10 is true\00", align 8
@.str.7 = private unnamed_addr constant [25 x i8] c"20 > 10 is false (ERROR)\00", align 8
