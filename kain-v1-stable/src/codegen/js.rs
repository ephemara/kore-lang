//! JavaScript Code Generation - Transpiles KAIN AST to JavaScript
//!
//! This module generates clean, modern JavaScript (ES6+) from a typed KAIN program.
//! The generated JS can run directly in browsers or Node.js.
//!
//! Key features:
//! - JSX → DOM manipulation
//! - Components → Functions returning DOM nodes
//! - Clean, readable output
//! - No runtime dependencies

use crate::types::{TypedProgram, TypedItem};
use crate::error::{KainResult, KainError};
use crate::ast::{
    Type, Expr, Stmt, Block, BinaryOp, UnaryOp, Pattern, Function, Struct, Enum,
    Field, Variant, VariantFields, Impl, Param, MatchArm, CallArg, ElseBranch,
    VariantPatternFields, EnumVariantFields, Component, JSXNode, JSXAttribute, JSXAttrValue,
};
use crate::span::Span;

/// Generate JavaScript source code from a typed program
pub fn generate(program: &TypedProgram) -> KainResult<String> {
    let mut gen = JSGen::new();
    Ok(gen.gen_program(program))
}

// StringBuilder helper for accumulated output
struct StringBuilder {
    lines: Vec<String>,
}

impl StringBuilder {
    fn new() -> Self {
        Self { lines: Vec::new() }
    }

    fn push(&mut self, text: &str) {
        self.lines.push(text.to_string());
    }

    fn push_line(&mut self, text: &str) {
        self.lines.push(format!("{}\n", text));
    }

    fn build(&self) -> String {
        self.lines.join("")
    }
}

// Main JavaScript code generator
struct JSGen {
    output: StringBuilder,
    indent: usize,
}

impl JSGen {
    fn new() -> Self {
        Self {
            output: StringBuilder::new(),
            indent: 0,
        }
    }

    fn indent(&mut self) {
        self.indent += 1;
    }

    fn dedent(&mut self) {
        if self.indent > 0 {
            self.indent -= 1;
        }
    }

    fn write(&mut self, text: &str) {
        self.output.push(text);
    }

    fn writeln(&mut self, text: &str) {
        let indent_str = "  ".repeat(self.indent);
        self.output.push_line(&format!("{}{}", indent_str, text));
    }

    fn gen_program(&mut self, program: &TypedProgram) -> String {
        // Header comment
        self.writeln("// Generated by KAIN compiler");
        self.writeln("// Target: JavaScript (ES6+)");
        self.writeln("");

        // Generate all items
        for item in &program.items {
            match item {
                TypedItem::Function(f) => self.gen_function(&f.ast),
                TypedItem::Struct(s) => self.gen_struct(&s.ast),
                TypedItem::Enum(e) => self.gen_enum(&e.ast),
                TypedItem::Component(c) => self.gen_component(&c.ast),
                TypedItem::Const(c) => self.gen_const(&c.ast.name, &c.ast.value),
                TypedItem::Impl(i) => self.gen_impl(&i.ast),
                _ => {} // Skip other items for now
            }
            self.writeln("");
        }

        self.output.build()
    }

    fn gen_function(&mut self, func: &Function) {
        // Function signature
        let params = func.params.iter()
            .map(|p| p.name.clone())
            .collect::<Vec<_>>()
            .join(", ");

        self.writeln(&format!("function {}({}) {{", func.name, params));
        self.indent();

        // Function body
        self.gen_block(&func.body);

        self.dedent();
        self.writeln("}");
    }

    fn gen_struct(&mut self, s: &Struct) {
        // Generate as a class
        self.writeln(&format!("class {} {{", s.name));
        self.indent();

        // Constructor
        let params = s.fields.iter()
            .map(|f| f.name.clone())
            .collect::<Vec<_>>()
            .join(", ");

        self.writeln(&format!("constructor({}) {{", params));
        self.indent();
        for field in &s.fields {
            self.writeln(&format!("this.{} = {};", field.name, field.name));
        }
        self.dedent();
        self.writeln("}");

        self.dedent();
        self.writeln("}");
    }

    fn gen_enum(&mut self, e: &Enum) {
        // Generate enum as object with variant constructors
        self.writeln(&format!("const {} = {{", e.name));
        self.indent();

        for variant in &e.variants {
            match &variant.fields {
                VariantFields::Unit => {
                    self.writeln(&format!("{}: {{ type: '{}', tag: '{}' }},", 
                        variant.name, e.name, variant.name));
                }
                VariantFields::Tuple(types) => {
                    let params = (0..types.len())
                        .map(|i| format!("_{}", i))
                        .collect::<Vec<_>>()
                        .join(", ");
                    
                    self.writeln(&format!("{}: ({}) => ({{", variant.name, params));
                    self.indent();
                    self.writeln(&format!("type: '{}',", e.name));
                    self.writeln(&format!("tag: '{}',", variant.name));
                    for i in 0..types.len() {
                        self.writeln(&format!("_{}: _{},", i, i));
                    }
                    self.dedent();
                    self.writeln("}),");
                }
                VariantFields::Struct(fields) => {
                    let params = fields.iter()
                        .map(|f| f.name.clone())
                        .collect::<Vec<_>>()
                        .join(", ");
                    
                    self.writeln(&format!("{}: ({}) => ({{", variant.name, params));
                    self.indent();
                    self.writeln(&format!("type: '{}',", e.name));
                    self.writeln(&format!("tag: '{}',", variant.name));
                    for field in fields {
                        self.writeln(&format!("{},", field.name));
                    }
                    self.dedent();
                    self.writeln("}),");
                }
            }
        }

        self.dedent();
        self.writeln("};");
    }

    fn gen_component(&mut self, comp: &Component) {
        // Component as function returning DOM node
        let params = comp.props.iter()
            .map(|p| p.name.clone())
            .collect::<Vec<_>>()
            .join(", ");

        self.writeln(&format!("function {}({}) {{", comp.name, params));
        self.indent();

        // State initialization
        for state in &comp.state {
            self.write(&format!("let {} = ", state.name));
            self.gen_expr(&state.initial);
            self.writeln(";");
        }

        // Methods
        for method in &comp.methods {
            self.gen_function(method);
        }

        // Render JSX to DOM
        self.write("return ");
        self.gen_jsx(&comp.body);
        self.writeln(";");

        self.dedent();
        self.writeln("}");
    }

    fn gen_const(&mut self, name: &str, value: &Expr) {
        self.write(&format!("const {} = ", name));
        self.gen_expr(value);
        self.writeln(";");
    }

    fn gen_impl(&mut self, impl_block: &Impl) {
        // Generate methods as static or prototype methods
        if let Type::Named { name, .. } = &impl_block.target_type {
            for method in &impl_block.methods {
                let params = method.params.iter()
                    .skip(if method.params.first().map(|p| p.name == "self").unwrap_or(false) { 1 } else { 0 })
                    .map(|p| p.name.clone())
                    .collect::<Vec<_>>()
                    .join(", ");

                let has_self = method.params.first().map(|p| p.name == "self").unwrap_or(false);
                
                if has_self {
                    // Instance method
                    self.writeln(&format!("{}.prototype.{} = function({}) {{", 
                        name, method.name, params));
                } else {
                    // Static method
                    self.writeln(&format!("{}.{} = function({}) {{", 
                        name, method.name, params));
                }
                
                self.indent();
                self.gen_block(&method.body);
                self.dedent();
                self.writeln("};");
            }
        }
    }

    fn gen_block(&mut self, block: &Block) {
        for stmt in &block.stmts {
            self.gen_stmt(stmt);
        }
    }

    fn gen_stmt(&mut self, stmt: &Stmt) {
        match stmt {
            Stmt::Expr(expr) => {
                self.gen_expr(expr);
                self.writeln(";");
            }
            Stmt::Let { pattern, value, .. } => {
                if let Pattern::Binding { name, .. } = pattern {
                    self.write(&format!("let {} = ", name));
                    if let Some(val) = value {
                        self.gen_expr(val);
                    } else {
                        self.write("null");
                    }
                    self.writeln(";");
                }
            }
            Stmt::Return(expr, _) => {
                self.write("return");
                if let Some(e) = expr {
                    self.write(" ");
                    self.gen_expr(e);
                }
                self.writeln(";");
            }
            Stmt::For { binding, iter, body, .. } => {
                if let Pattern::Binding { name, .. } = binding {
                    self.write(&format!("for (const {} of ", name));
                    self.gen_expr(iter);
                    self.writeln(") {");
                    self.indent();
                    self.gen_block(body);
                    self.dedent();
                    self.writeln("}");
                }
            }
            Stmt::While { condition, body, .. } => {
                self.write("while (");
                self.gen_expr(condition);
                self.writeln(") {");
                self.indent();
                self.gen_block(body);
                self.dedent();
                self.writeln("}");
            }
            Stmt::Loop { body, .. } => {
                self.writeln("while (true) {");
                self.indent();
                self.gen_block(body);
                self.dedent();
                self.writeln("}");
            }
            Stmt::Break(expr, _) => {
                if expr.is_some() {
                    self.writeln("// Note: break with value not supported in JS");
                }
                self.writeln("break;");
            }
            Stmt::Continue(_) => {
                self.writeln("continue;");
            }
            _ => {
                self.writeln("// Unsupported statement");
            }
        }
    }

    fn gen_expr(&mut self, expr: &Expr) {
        match expr {
            Expr::Int(n, _) => self.write(&n.to_string()),
            Expr::Float(f, _) => self.write(&f.to_string()),
            Expr::String(s, _) => self.write(&format!("\"{}\"", s.escape_default())),
            Expr::Bool(b, _) => self.write(if *b { "true" } else { "false" }),
            Expr::None(_) => self.write("null"),
            Expr::Ident(name, _) => self.write(name),
            
            Expr::Binary { left, op, right, .. } => {
                self.write("(");
                self.gen_expr(left);
                self.write(&format!(" {} ", self.gen_binop(*op)));
                self.gen_expr(right);
                self.write(")");
            }
            
            Expr::Unary { op, operand, .. } => {
                self.write(&format!("({}",
 self.gen_unop(*op)));
                self.gen_expr(operand);
                self.write(")");
            }
            
            Expr::Call { callee, args, .. } => {
                self.gen_expr(callee);
                self.write("(");
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.gen_expr(&arg.value);
                }
                self.write(")");
            }
            
            Expr::Array(elements, _) => {
                self.write("[");
                for (i, elem) in elements.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.gen_expr(elem);
                }
                self.write("]");
            }
            
            Expr::Tuple(elements, _) => {
                // Tuples as arrays in JS
                self.write("[");
                for (i, elem) in elements.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.gen_expr(elem);
                }
                self.write("]");
            }
            
            Expr::Index { object, index, .. } => {
                self.gen_expr(object);
                self.write("[");
                self.gen_expr(index);
                self.write("]");
            }
            
            Expr::Field { object, field, .. } => {
                self.gen_expr(object);
                self.write(&format!(".{}", field));
            }
            
            Expr::MethodCall { receiver, method, args, .. } => {
                self.gen_expr(receiver);
                self.write(&format!(".{}(", method));
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.gen_expr(&arg.value);
                }
                self.write(")");
            }
            
            Expr::Struct { name, fields, .. } => {
                self.write(&format!("new {}(", name));
                for (i, (_, expr)) in fields.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.gen_expr(expr);
                }
                self.write(")");
            }
            
            Expr::If { condition, then_branch, else_branch, .. } => {
                self.write("(");
                self.gen_expr(condition);
                self.write(" ? ");
                self.gen_block_as_expr(then_branch);
                self.write(" : ");
                if let Some(else_br) = else_branch {
                    match else_br.as_ref() {
                        ElseBranch::Else(else_block) => self.gen_block_as_expr(else_block),
                        ElseBranch::ElseIf { .. } => {
                            // Nested if-else
                            self.write("/* else-if */null");
                        }
                    }
                } else {
                    self.write("null");
                }
                self.write(")");
            }
            
            Expr::Match { scrutinee, arms, .. } => {
                // Generate as IIFE with switch/if-else
                self.write("(() => {");
                self.indent();
                self.writeln("");
                self.write("const __match = ");
                self.gen_expr(scrutinee);
                self.writeln(";");
                
                for (i, arm) in arms.iter().enumerate() {
                    if i == 0 {
                        self.write("if (");
                    } else {
                        self.write("else if (");
                    }
                    self.gen_pattern_match("__match", &arm.pattern);
                    self.writeln(") {");
                    self.indent();
                    self.write("return ");
                    self.gen_expr(&arm.body);
                    self.writeln(";");
                    self.dedent();
                    self.write("} ");
                }
                self.writeln("");
                self.writeln("throw new Error('Non-exhaustive match');");
                self.dedent();
                self.write("})()");
            }
            
            Expr::Lambda { params, body, .. } => {
                let param_names = params.iter()
                    .map(|p| p.name.clone())
                    .collect::<Vec<_>>()
                    .join(", ");
                self.write(&format!("({}) => ", param_names));
                self.gen_expr(body);
            }
            
            Expr::Block(block, _) => {
                self.write("(() => {");
                self.indent();
                self.writeln("");
                self.gen_block(block);
                self.dedent();
                self.write("})()");
            }
            
            Expr::Assign { target, value, .. } => {
                self.gen_expr(target);
                self.write(" = ");
                self.gen_expr(value);
            }
            
            Expr::FString(parts, _) => {
                self.write("`");
                for part in parts {
                    match part {
                        Expr::String(s, _) => self.write(s),
                        _ => {
                            self.write("${");
                            self.gen_expr(part);
                            self.write("}");
                        }
                    }
                }
                self.write("`");
            }
            
            Expr::JSX(node, _) => {
                self.gen_jsx(node);
            }
            
            Expr::EnumVariant { enum_name, variant, fields, .. } => {
                self.write(&format!("{}.{}(", enum_name, variant));
                match fields {
                    EnumVariantFields::Unit => {}
                    EnumVariantFields::Tuple(exprs) => {
                        for (i, expr) in exprs.iter().enumerate() {
                            if i > 0 {
                                self.write(", ");
                            }
                            self.gen_expr(expr);
                        }
                    }
                    EnumVariantFields::Struct(named) => {
                        for (i, (_, expr)) in named.iter().enumerate() {
                            if i > 0 {
                                self.write(", ");
                            }
                            self.gen_expr(expr);
                        }
                    }
                }
                self.write(")");
            }
            
            _ => {
                self.write("/* unsupported expr */");
            }
        }
    }

    fn gen_jsx(&mut self, node: &JSXNode) {
        match node {
            JSXNode::Element { tag, attributes, children, .. } => {
                // Create element
                self.write(&format!("(() => {{"));
                self.indent();
                self.writeln("");
                self.writeln(&format!("const __el = document.createElement('{}');", tag));
                
                // Set attributes
                for attr in attributes {
                    match &attr.value {
                        JSXAttrValue::String(s) => {
                            if attr.name == "class" {
                                self.writeln(&format!("__el.className = '{}';", s));
                            } else {
                                self.writeln(&format!("__el.setAttribute('{}', '{}');", attr.name, s));
                            }
                        }
                        JSXAttrValue::Bool(b) => {
                            if *b {
                                self.writeln(&format!("__el.setAttribute('{}', '');", attr.name));
                            }
                        }
                        JSXAttrValue::Expr(expr) => {
                            if attr.name.starts_with("on_") {
                                // Event handler
                                let event = attr.name.trim_start_matches("on_");
                                self.write(&format!("__el.addEventListener('{}', ", event));
                                self.gen_expr(expr);
                                self.writeln(");");
                            } else if attr.name == "class" {
                                self.write("__el.className = ");
                                self.gen_expr(expr);
                                self.writeln(";");
                            } else {
                                self.write(&format!("__el.setAttribute('{}', ", attr.name));
                                self.gen_expr(expr);
                                self.writeln(");");
                            }
                        }
                    }
                }
                
                // Append children
                for child in children {
                    self.write("__el.appendChild(");
                    self.gen_jsx(child);
                    self.writeln(");");
                }
                
                self.writeln("return __el;");
                self.dedent();
                self.write("})()");
            }
            
            JSXNode::Text(text, _) => {
                self.write(&format!("document.createTextNode('{}')", text.escape_default()));
            }
            
            JSXNode::Expression(expr) => {
                self.write("(() => {");
                self.indent();
                self.writeln("");
                self.write("const __val = ");
                self.gen_expr(expr);
                self.writeln(";");
                self.writeln("if (typeof __val === 'string' || typeof __val === 'number') {");
                self.indent();
                self.writeln("return document.createTextNode(String(__val));");
                self.dedent();
                self.writeln("} else if (__val instanceof Node) {");
                self.indent();
                self.writeln("return __val;");
                self.dedent();
                self.writeln("} else {");
                self.indent();
                self.writeln("return document.createTextNode('');");
                self.dedent();
                self.writeln("}");
                self.dedent();
                self.write("})()");
            }
            
            JSXNode::ComponentCall { name, props, children, .. } => {
                self.write(&format!("{}({{", name));
                for (i, prop) in props.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.write(&format!("{}: ", prop.name));
                    match &prop.value {
                        JSXAttrValue::String(s) => self.write(&format!("'{}'", s)),
                        JSXAttrValue::Bool(b) => self.write(&b.to_string()),
                        JSXAttrValue::Expr(e) => self.gen_expr(e),
                    }
                }
                if !children.is_empty() {
                    if !props.is_empty() {
                        self.write(", ");
                    }
                    self.write("children: [");
                    for (i, child) in children.iter().enumerate() {
                        if i > 0 {
                            self.write(", ");
                        }
                        self.gen_jsx(child);
                    }
                    self.write("]");
                }
                self.write("})");
            }
            
            JSXNode::Fragment(children, _) => {
                self.write("(() => {");
                self.indent();
                self.writeln("");
                self.writeln("const __frag = document.createDocumentFragment();");
                for child in children {
                    self.write("__frag.appendChild(");
                    self.gen_jsx(child);
                    self.writeln(");");
                }
                self.writeln("return __frag;");
                self.dedent();
                self.write("})()");
            }
            
            JSXNode::For { binding, iter, body, .. } => {
                self.write("(() => {");
                self.indent();
                self.writeln("");
                self.writeln("const __frag = document.createDocumentFragment();");
                self.write(&format!("for (const {} of ", binding));
                self.gen_expr(iter);
                self.writeln(") {");
                self.indent();
                self.write("__frag.appendChild(");
                self.gen_jsx(body);
                self.writeln(");");
                self.dedent();
                self.writeln("}");
                self.writeln("return __frag;");
                self.dedent();
                self.write("})()");
            }
            
            JSXNode::If { condition, then_branch, else_branch, .. } => {
                self.write("(() => {");
                self.indent();
                self.writeln("");
                self.write("if (");
                self.gen_expr(condition);
                self.writeln(") {");
                self.indent();
                self.write("return ");
                self.gen_jsx(then_branch);
                self.writeln(";");
                self.dedent();
                if let Some(else_node) = else_branch {
                    self.writeln("} else {");
                    self.indent();
                    self.write("return ");
                    self.gen_jsx(else_node);
                    self.writeln(";");
                    self.dedent();
                }
                self.writeln("}");
                self.writeln("return document.createTextNode('');");
                self.dedent();
                self.write("})()");
            }
        }
    }

    fn gen_block_as_expr(&mut self, block: &Block) {
        self.write("(() => {");
        self.indent();
        self.writeln("");
        self.gen_block(block);
        self.dedent();
        self.write("})()");
    }

    fn gen_pattern_match(&mut self, scrutinee: &str, pattern: &Pattern) {
        match pattern {
            Pattern::Wildcard(_) => self.write("true"),
            Pattern::Binding { .. } => self.write("true"),
            Pattern::Literal(expr) => {
                self.write(&format!("{} === ", scrutinee));
                self.gen_expr(expr);
            }
            Pattern::Variant { enum_name, variant, fields, .. } => {
                if let Some(enum_name) = enum_name {
                    self.write(&format!("{}.type === '{}' && {}.tag === '{}'", 
                        scrutinee, enum_name, scrutinee, variant));
                } else {
                    self.write(&format!("{}.tag === '{}'", scrutinee, variant));
                }
                
                // Check fields if needed
                match fields {
                    VariantPatternFields::Tuple(patterns) => {
                        for (i, _) in patterns.iter().enumerate() {
                            self.write(&format!(" && typeof {}._{} !== 'undefined'", scrutinee, i));
                        }
                    }
                    _ => {}
                }
            }
            _ => self.write("false"),
        }
    }

    fn gen_binop(&self, op: BinaryOp) -> &'static str {
        match op {
            BinaryOp::Add => "+",
            BinaryOp::Sub => "-",
            BinaryOp::Mul => "*",
            BinaryOp::Div => "/",
            BinaryOp::Mod => "%",
            BinaryOp::Pow => "**",
            BinaryOp::Eq => "===",
            BinaryOp::Ne => "!==",
            BinaryOp::Lt => "<",
            BinaryOp::Le => "<=",
            BinaryOp::Gt => ">",
            BinaryOp::Ge => ">=",
            BinaryOp::And => "&&",
            BinaryOp::Or => "||",
            BinaryOp::BitAnd => "&",
            BinaryOp::BitOr => "|",
            BinaryOp::BitXor => "^",
            BinaryOp::Shl => "<<",
            BinaryOp::Shr => ">>",
            BinaryOp::Assign => "=",
            BinaryOp::AddAssign => "+=",
            BinaryOp::SubAssign => "-=",
            BinaryOp::MulAssign => "*=",
            BinaryOp::DivAssign => "/=",
            BinaryOp::Range | BinaryOp::RangeInclusive => {
                // Ranges need special handling, not a simple operator
                "/* range */"
            }
        }
    }

    fn gen_unop(&self, op: UnaryOp) -> &'static str {
        match op {
            UnaryOp::Neg => "-",
            UnaryOp::Not => "!",
            UnaryOp::BitNot => "~",
            UnaryOp::Ref | UnaryOp::RefMut | UnaryOp::Deref => {
                // JS doesn't have these concepts, just pass through
                ""
            }
        }
    }
}
