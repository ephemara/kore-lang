//! HLSL Code Generation - Direct KAIN to HLSL/USF
//! Bypasses SPIR-V for maximum control and code generation power

use crate::types::{TypedProgram, TypedItem, TypedShader};
use crate::error::{KainResult, KainError};
use crate::ast::{Type, ShaderStage, Expr, Stmt, Block, BinaryOp, Pattern};
use std::collections::HashMap;

pub fn generate(program: &TypedProgram) -> KainResult<String> {
    let mut output = String::new();
    
    // HLSL header
    output.push_str("// Generated by KAIN Compiler\n");
    output.push_str("// Direct HLSL codegen - SUPERCHARGED\n\n");
    
    for item in &program.items {
        if let TypedItem::Shader(shader) = item {
            output.push_str(&emit_shader(shader)?);
        }
    }
    
    Ok(output)
}

struct HLSLContext {
    // Variable name -> HLSL type
    vars: HashMap<String, String>,
    indent_level: usize,
    // Track uniform bindings
    uniform_bindings: Vec<(String, String, u32)>, // (name, type, binding)
}

impl HLSLContext {
    fn new() -> Self {
        Self {
            vars: HashMap::new(),
            indent_level: 0,
            uniform_bindings: Vec::new(),
        }
    }
    
    fn indent(&self) -> String {
        "    ".repeat(self.indent_level)
    }
    
    fn push_indent(&mut self) {
        self.indent_level += 1;
    }
    
    fn pop_indent(&mut self) {
        if self.indent_level > 0 {
            self.indent_level -= 1;
        }
    }
}

fn emit_shader(shader: &TypedShader) -> KainResult<String> {
    let mut output = String::new();
    let mut ctx = HLSLContext::new();
    
    // Collect uniforms
    for uniform in &shader.ast.uniforms {
        let hlsl_type = map_type_to_hlsl(&uniform.ty);
        ctx.uniform_bindings.push((uniform.name.clone(), hlsl_type, uniform.binding));
    }
    
    // Generate constant buffers for non-texture uniforms
    let mut cbuffer_uniforms = Vec::new();
    let mut texture_uniforms = Vec::new();
    let mut buffer_uniforms = Vec::new();
    
    for (name, ty, binding) in &ctx.uniform_bindings {
        if ty.contains("Texture") || ty.contains("Sampler") {
            texture_uniforms.push((name.clone(), ty.clone(), *binding));
        } else if ty.contains("Buffer") || ty.contains("RWBuffer") || ty.contains("StructuredBuffer") {
            buffer_uniforms.push((name.clone(), ty.clone(), *binding));
        } else {
            cbuffer_uniforms.push((name.clone(), ty.clone(), *binding));
        }
    }
    
    // Emit constant buffer
    if !cbuffer_uniforms.is_empty() {
        output.push_str("cbuffer ShaderParams : register(b0)\n{\n");
        for (name, ty, _) in &cbuffer_uniforms {
            output.push_str(&format!("    {} {};\n", ty, name));
        }
        output.push_str("};\n\n");
    }
    
    // Emit texture declarations
    for (name, ty, binding) in &texture_uniforms {
        output.push_str(&format!("{} {} : register(t{});\n", ty, name, binding));
        output.push_str(&format!("SamplerState {}_sampler : register(s{});\n", name, binding));
    }
    if !texture_uniforms.is_empty() {
        output.push_str("\n");
    }
    
    // Emit buffer declarations
    for (name, ty, binding) in &buffer_uniforms {
        output.push_str(&format!("{} {} : register(u{});\n", ty, name, binding));
    }
    if !buffer_uniforms.is_empty() {
        output.push_str("\n");
    }
    
    match shader.ast.stage {
        ShaderStage::Compute => {
            // Compute shader - different structure
            output.push_str("[numthreads(8, 8, 1)]\n");
            output.push_str("void CSMain(uint3 dispatchThreadID : SV_DispatchThreadID,\n");
            output.push_str("            uint3 groupThreadID : SV_GroupThreadID,\n");
            output.push_str("            uint3 groupID : SV_GroupID,\n");
            output.push_str("            uint groupIndex : SV_GroupIndex)\n{\n");
            ctx.push_indent();
            
            // Add compute shader built-ins to context
            ctx.vars.insert("dispatch_thread_id".to_string(), "dispatchThreadID".to_string());
            ctx.vars.insert("group_thread_id".to_string(), "groupThreadID".to_string());
            ctx.vars.insert("group_id".to_string(), "groupID".to_string());
            ctx.vars.insert("group_index".to_string(), "groupIndex".to_string());
            
            // Emit function body
            let body_code = emit_block(&mut ctx, &shader.ast.body)?;
            output.push_str(&body_code);
            
            ctx.pop_indent();
            output.push_str("}\n");
        },
        ShaderStage::Vertex => {
            // Generate input struct
            output.push_str("struct VSInput\n{\n");
            for (i, param) in shader.ast.inputs.iter().enumerate() {
                let hlsl_type = map_type_to_hlsl(&param.ty);
                let semantic = match param.name.as_str() {
                    "position" => "POSITION",
                    "normal" => "NORMAL",
                    "tangent" => "TANGENT",
                    "color" => "COLOR",
                    _ => "TEXCOORD",
                };
                output.push_str(&format!("    {} {} : {}{};\n", 
                    hlsl_type, param.name, semantic, 
                    if semantic == "TEXCOORD" { i.to_string() } else { "".to_string() }
                ));
            }
            output.push_str("};\n\n");
            
            // Generate output struct
            output.push_str("struct VSOutput\n{\n");
            output.push_str("    float4 position : SV_Position;\n");
            // TODO: Add other vertex outputs based on shader.ast.outputs
            output.push_str("};\n\n");
            
            // Generate main function
            output.push_str("VSOutput VSMain(VSInput input)\n{\n");
            ctx.push_indent();
            
            // Add input variables to context
            for param in &shader.ast.inputs {
                ctx.vars.insert(param.name.clone(), format!("input.{}", param.name));
            }
            
            // Emit function body
            let body_code = emit_block(&mut ctx, &shader.ast.body)?;
            output.push_str(&body_code);
            
            ctx.pop_indent();
            output.push_str("}\n");
        },
        ShaderStage::Fragment => {
            // Generate input struct
            output.push_str("struct VSInput\n{\n");
            for (i, param) in shader.ast.inputs.iter().enumerate() {
                let hlsl_type = map_type_to_hlsl(&param.ty);
                output.push_str(&format!("    {} {} : TEXCOORD{};\n", hlsl_type, param.name, i));
            }
            output.push_str("};\n\n");
            
            // Generate output struct
            output.push_str("struct PSOutput\n{\n");
            let out_type = map_type_to_hlsl(&shader.ast.outputs);
            output.push_str(&format!("    {} color : SV_Target0;\n", out_type));
            // TODO: Support multiple render targets
            output.push_str("};\n\n");
            
            // Generate main function
            output.push_str("PSOutput PSMain(VSInput input)\n{\n");
            ctx.push_indent();
            
            // Add input variables to context
            for param in &shader.ast.inputs {
                ctx.vars.insert(param.name.clone(), format!("input.{}", param.name));
            }
            
            // Emit function body
            let body_code = emit_block(&mut ctx, &shader.ast.body)?;
            output.push_str(&body_code);
            
            ctx.pop_indent();
            output.push_str("}\n");
        },
    }
    
    Ok(output)
}

fn emit_block(ctx: &mut HLSLContext, block: &Block) -> KainResult<String> {
    let mut output = String::new();
    
    for stmt in &block.stmts {
        output.push_str(&emit_stmt(ctx, stmt)?);
    }
    
    Ok(output)
}

fn emit_stmt(ctx: &mut HLSLContext, stmt: &Stmt) -> KainResult<String> {
    let mut output = String::new();
    
    match stmt {
        Stmt::Let { pattern, value, .. } => {
            if let Some(value) = value {
                if let Pattern::Binding { name, .. } = pattern {
                    let (expr_code, expr_type) = emit_expr(ctx, value)?;
                    output.push_str(&format!("{}{} {} = {};\n", ctx.indent(), expr_type, name, expr_code));
                    ctx.vars.insert(name.clone(), name.clone());
                }
            }
        },
        Stmt::Return(Some(expr), _) => {
            let (expr_code, _) = emit_expr(ctx, expr)?;
            output.push_str(&format!("{}PSOutput _result;\n", ctx.indent()));
            output.push_str(&format!("{}_result.color = {};\n", ctx.indent(), expr_code));
            output.push_str(&format!("{}return _result;\n", ctx.indent()));
        },
        Stmt::Return(None, _) => {
            output.push_str(&format!("{}return;\n", ctx.indent()));
        },
        Stmt::Expr(expr) => {
            let (expr_code, _) = emit_expr(ctx, expr)?;
            output.push_str(&format!("{}{};\n", ctx.indent(), expr_code));
        },
        // If expressions are handled in Expr::If, not Stmt::If
        Stmt::While { condition, body, .. } => {
            let (cond_code, _) = emit_expr(ctx, condition)?;
            output.push_str(&format!("{}while ({})\n", ctx.indent(), cond_code));
            output.push_str(&format!("{}{{\n", ctx.indent()));
            ctx.push_indent();
            output.push_str(&emit_block(ctx, body)?);
            ctx.pop_indent();
            output.push_str(&format!("{}}}\n", ctx.indent()));
        },
        Stmt::For { binding, iter: _, body, .. } => {
            // Simple for loop support - assumes range-like iteration
            if let Pattern::Binding { name, .. } = binding {
                output.push_str(&format!("{}for (int {} = 0; {} < 10; {}++)\n", 
                    ctx.indent(), name, name, name));
                output.push_str(&format!("{}{{\n", ctx.indent()));
                ctx.push_indent();
                ctx.vars.insert(name.clone(), name.clone());
                output.push_str(&emit_block(ctx, body)?);
                ctx.pop_indent();
                output.push_str(&format!("{}}}\n", ctx.indent()));
            }
        },
        Stmt::Break(_, _) => {
            output.push_str(&format!("{}break;\n", ctx.indent()));
        },
        Stmt::Continue(_) => {
            output.push_str(&format!("{}continue;\n", ctx.indent()));
        },
        _ => {}
    }
    
    Ok(output)
}

fn emit_expr(ctx: &mut HLSLContext, expr: &Expr) -> KainResult<(String, String)> {
    match expr {
        Expr::Ident(name, _) => {
            if let Some(mapped) = ctx.vars.get(name) {
                Ok((mapped.clone(), "float4".to_string()))
            } else {
                Ok((name.clone(), "float4".to_string()))
            }
        },
        Expr::Float(f, _) => {
            Ok((format!("{:.6}", f), "float".to_string()))
        },
        Expr::Int(i, _) => {
            Ok((format!("{}", i), "int".to_string()))
        },
        Expr::Bool(b, _) => {
            Ok((format!("{}", b), "bool".to_string()))
        },
        Expr::String(s, _) => {
            // HLSL doesn't have strings, but we can use this for debug/comments
            Ok((format!("\"{}\"", s), "string".to_string()))
        },
        Expr::Binary { left, op, right, .. } => {
            let (left_code, left_ty) = emit_expr(ctx, left)?;
            let (right_code, _) = emit_expr(ctx, right)?;
            
            let op_str = match op {
                BinaryOp::Add => "+",
                BinaryOp::Sub => "-",
                BinaryOp::Mul => "*",
                BinaryOp::Div => "/",
                BinaryOp::Mod => "%",
                BinaryOp::Eq => "==",
                BinaryOp::Ne => "!=",
                BinaryOp::Lt => "<",
                BinaryOp::Le => "<=",
                BinaryOp::Gt => ">",
                BinaryOp::Ge => ">=",
                BinaryOp::And => "&&",
                BinaryOp::Or => "||",
                BinaryOp::BitAnd => "&",
                BinaryOp::BitOr => "|",
                BinaryOp::BitXor => "^",
                BinaryOp::Shl => "<<",
                BinaryOp::Shr => ">>",
                _ => return Err(KainError::codegen("Unsupported binary op", expr.span())),
            };
            
            // Preserve type from left operand for most ops
            let result_ty = match op {
                BinaryOp::Eq | BinaryOp::Ne | BinaryOp::Lt | BinaryOp::Le | 
                BinaryOp::Gt | BinaryOp::Ge | BinaryOp::And | BinaryOp::Or => "bool".to_string(),
                _ => left_ty,
            };
            
            Ok((format!("({} {} {})", left_code, op_str, right_code), result_ty))
        },
        Expr::Unary { op, operand, .. } => {
            let (operand_code, ty) = emit_expr(ctx, operand)?;
            let op_str = match op {
                crate::ast::UnaryOp::Neg => "-",
                crate::ast::UnaryOp::Not => "!",
                crate::ast::UnaryOp::BitNot => "~",
                crate::ast::UnaryOp::Ref | crate::ast::UnaryOp::RefMut => {
                    // HLSL doesn't have explicit references, just pass through
                    return Ok((operand_code, ty));
                },
                crate::ast::UnaryOp::Deref => {
                    // HLSL doesn't have explicit dereferencing, just pass through
                    return Ok((operand_code, ty));
                },
            };
            Ok((format!("({}{})", op_str, operand_code), ty))
        },
        Expr::Call { callee, args, .. } => {
            if let Expr::Ident(name, _) = &**callee {
                emit_function_call(ctx, name, args)
            } else {
                Err(KainError::codegen("Complex callee not supported", expr.span()))
            }
        },
        Expr::Field { object, field, .. } => {
            let (obj_code, _) = emit_expr(ctx, object)?;
            
            // HLSL supports direct swizzling - just pass it through!
            // Supports: .x .y .z .w .r .g .b .a
            // And combinations: .xy .xyz .rgba .xyzw .bgra etc.
            Ok((format!("{}.{}", obj_code, field), infer_swizzle_type(field)))
        },
        Expr::Index { object, index, .. } => {
            let (obj_code, obj_ty) = emit_expr(ctx, object)?;
            let (idx_code, _) = emit_expr(ctx, index)?;
            // Array indexing preserves element type
            let elem_ty = if obj_ty.starts_with("float") {
                "float".to_string()
            } else {
                obj_ty
            };
            Ok((format!("{}[{}]", obj_code, idx_code), elem_ty))
        },
        Expr::If { condition, then_branch, else_branch, .. } => {
            // HLSL ternary operator for simple if expressions
            let (cond_code, _) = emit_expr(ctx, condition)?;
            
            // For now, emit as ternary if we can extract simple expressions
            // TODO: Handle complex if expressions with multiple statements
            if then_branch.stmts.len() == 1 && else_branch.is_some() {
                if let Stmt::Expr(then_expr) = &then_branch.stmts[0] {
                    let (then_code, then_ty) = emit_expr(ctx, then_expr)?;
                    
                    if let Some(crate::ast::ElseBranch::Else(else_block)) = else_branch.as_ref().map(|b| b.as_ref()) {
                        if else_block.stmts.len() == 1 {
                            if let Stmt::Expr(else_expr) = &else_block.stmts[0] {
                                let (else_code, _) = emit_expr(ctx, else_expr)?;
                                return Ok((format!("({} ? {} : {})", cond_code, then_code, else_code), then_ty));
                            }
                        }
                    }
                }
            }
            
            // Fallback: can't emit as expression
            Err(KainError::codegen("Complex if expressions not yet supported in HLSL backend", expr.span()))
        },
        Expr::Paren(inner, _) => {
            // Parenthesized expression - just emit the inner expression with parens
            let (inner_code, ty) = emit_expr(ctx, inner)?;
            Ok((format!("({})", inner_code), ty))
        },
        _ => Err(KainError::codegen("Unsupported expression", expr.span())),
    }
}

fn emit_function_call(ctx: &mut HLSLContext, name: &str, args: &[crate::ast::CallArg]) -> KainResult<(String, String)> {
    match name {
        // Vector constructors
        "vec2" | "Vec2" => {
            let mut arg_codes = Vec::new();
            for arg in args {
                let (code, _) = emit_expr(ctx, &arg.value)?;
                arg_codes.push(code);
            }
            Ok((format!("float2({})", arg_codes.join(", ")), "float2".to_string()))
        },
        "vec3" | "Vec3" => {
            let mut arg_codes = Vec::new();
            for arg in args {
                let (code, _) = emit_expr(ctx, &arg.value)?;
                arg_codes.push(code);
            }
            Ok((format!("float3({})", arg_codes.join(", ")), "float3".to_string()))
        },
        "vec4" | "Vec4" => {
            let mut arg_codes = Vec::new();
            for arg in args {
                let (code, _) = emit_expr(ctx, &arg.value)?;
                arg_codes.push(code);
            }
            Ok((format!("float4({})", arg_codes.join(", ")), "float4".to_string()))
        },
        
        // Math functions - Trigonometry
        "sin" | "cos" | "tan" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("{}({})", name, arg_code), ty))
        },
        "asin" | "acos" | "atan" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("{}({})", name, arg_code), ty))
        },
        "atan2" => {
            let (arg1, ty) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("atan2({}, {})", arg1, arg2), ty))
        },
        
        // Math functions - Common
        "abs" | "floor" | "ceil" | "round" | "trunc" | "fract" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            let hlsl_name = if name == "fract" { "frac" } else { name };
            Ok((format!("{}({})", hlsl_name, arg_code), ty))
        },
        "sqrt" | "rsqrt" | "exp" | "exp2" | "log" | "log2" | "log10" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("{}({})", name, arg_code), ty))
        },
        "sign" | "saturate" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("{}({})", name, arg_code), ty))
        },
        
        // Math functions - Two arguments
        "pow" | "min" | "max" | "fmod" | "step" => {
            let (arg1, ty) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("{}({}, {})", name, arg1, arg2), ty))
        },
        
        // Math functions - Three arguments
        "clamp" | "smoothstep" | "mad" => {
            let (arg1, ty) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            let (arg3, _) = emit_expr(ctx, &args[2].value)?;
            Ok((format!("{}({}, {}, {})", name, arg1, arg2, arg3), ty))
        },
        "mix" | "lerp" => {
            let (arg1, ty) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            let (arg3, _) = emit_expr(ctx, &args[2].value)?;
            Ok((format!("lerp({}, {}, {})", arg1, arg2, arg3), ty))
        },
        
        // Vector functions
        "length" => {
            let (arg_code, _) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("length({})", arg_code), "float".to_string()))
        },
        "distance" => {
            let (arg1, _) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("distance({}, {})", arg1, arg2), "float".to_string()))
        },
        "normalize" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("normalize({})", arg_code), ty))
        },
        "dot" => {
            let (arg1, _) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("dot({}, {})", arg1, arg2), "float".to_string()))
        },
        "cross" => {
            let (arg1, ty) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("cross({}, {})", arg1, arg2), ty))
        },
        "reflect" => {
            let (arg1, ty) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("reflect({}, {})", arg1, arg2), ty))
        },
        "refract" => {
            let (arg1, ty) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            let (arg3, _) = emit_expr(ctx, &args[2].value)?;
            Ok((format!("refract({}, {}, {})", arg1, arg2, arg3), ty))
        },
        "faceforward" => {
            let (arg1, ty) = emit_expr(ctx, &args[0].value)?;
            let (arg2, _) = emit_expr(ctx, &args[1].value)?;
            let (arg3, _) = emit_expr(ctx, &args[2].value)?;
            Ok((format!("faceforward({}, {}, {})", arg1, arg2, arg3), ty))
        },
        
        // Matrix functions
        "transpose" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("transpose({})", arg_code), ty))
        },
        "determinant" => {
            let (arg_code, _) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("determinant({})", arg_code), "float".to_string()))
        },
        
        // Texture sampling
        "sample" => {
            let (sampler, _) = emit_expr(ctx, &args[0].value)?;
            let (coords, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("{}.Sample({}_sampler, {})", sampler, sampler, coords), "float4".to_string()))
        },
        "sample_lod" => {
            let (sampler, _) = emit_expr(ctx, &args[0].value)?;
            let (coords, _) = emit_expr(ctx, &args[1].value)?;
            let (lod, _) = emit_expr(ctx, &args[2].value)?;
            Ok((format!("{}.SampleLevel({}_sampler, {}, {})", sampler, sampler, coords, lod), "float4".to_string()))
        },
        "sample_grad" => {
            let (sampler, _) = emit_expr(ctx, &args[0].value)?;
            let (coords, _) = emit_expr(ctx, &args[1].value)?;
            let (ddx, _) = emit_expr(ctx, &args[2].value)?;
            let (ddy, _) = emit_expr(ctx, &args[3].value)?;
            Ok((format!("{}.SampleGrad({}_sampler, {}, {}, {})", sampler, sampler, coords, ddx, ddy), "float4".to_string()))
        },
        "sample_bias" => {
            let (sampler, _) = emit_expr(ctx, &args[0].value)?;
            let (coords, _) = emit_expr(ctx, &args[1].value)?;
            let (bias, _) = emit_expr(ctx, &args[2].value)?;
            Ok((format!("{}.SampleBias({}_sampler, {}, {})", sampler, sampler, coords, bias), "float4".to_string()))
        },
        "sample_cmp" => {
            let (sampler, _) = emit_expr(ctx, &args[0].value)?;
            let (coords, _) = emit_expr(ctx, &args[1].value)?;
            let (compare, _) = emit_expr(ctx, &args[2].value)?;
            Ok((format!("{}.SampleCmp({}_sampler, {}, {})", sampler, sampler, coords, compare), "float".to_string()))
        },
        "load" => {
            let (texture, _) = emit_expr(ctx, &args[0].value)?;
            let (location, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("{}.Load({})", texture, location), "float4".to_string()))
        },
        
        // Derivative functions
        "ddx" | "ddy" | "ddx_fine" | "ddy_fine" | "ddx_coarse" | "ddy_coarse" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("{}({})", name, arg_code), ty))
        },
        "fwidth" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("fwidth({})", arg_code), ty))
        },
        
        // Bit operations
        "countbits" | "firstbithigh" | "firstbitlow" | "reversebits" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("{}({})", name, arg_code), ty))
        },
        
        // Interpolation
        "all" | "any" => {
            let (arg_code, _) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("{}({})", name, arg_code), "bool".to_string()))
        },
        
        // Noise functions (custom implementations)
        "noise" => {
            let (arg_code, _) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("frac(sin(dot({}, float2(12.9898, 78.233))) * 43758.5453)", arg_code), "float".to_string()))
        },
        "noise3d" => {
            let (arg_code, _) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("frac(sin(dot({}, float3(12.9898, 78.233, 37.719))) * 43758.5453)", arg_code), "float".to_string()))
        },
        
        // Packing/Unpacking functions
        "pack_half_2x16" => {
            let (arg_code, _) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("f32tof16({}).x | (f32tof16({}).y << 16)", arg_code, arg_code), "uint".to_string()))
        },
        "unpack_half_2x16" => {
            let (arg_code, _) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("float2(f16tof32({} & 0xFFFF), f16tof32({} >> 16))", arg_code, arg_code), "float2".to_string()))
        },
        
        // Advanced texture operations
        "texture_size" => {
            let (texture, _) = emit_expr(ctx, &args[0].value)?;
            let (lod, _) = if args.len() > 1 {
                emit_expr(ctx, &args[1].value)?
            } else {
                ("0".to_string(), "int".to_string())
            };
            Ok((format!("{}.GetDimensions({})", texture, lod), "int2".to_string()))
        },
        "texture_query_lod" => {
            let (sampler, _) = emit_expr(ctx, &args[0].value)?;
            let (coords, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("{}.CalculateLevelOfDetail({}_sampler, {})", sampler, sampler, coords), "float".to_string()))
        },
        "texture_gather" => {
            let (texture, _) = emit_expr(ctx, &args[0].value)?;
            let (coords, _) = emit_expr(ctx, &args[1].value)?;
            let component = if args.len() > 2 {
                if let Expr::Int(i, _) = &args[2].value {
                    *i as u32
                } else {
                    0
                }
            } else {
                0
            };
            Ok((format!("{}.Gather({}_sampler, {}, {})", texture, texture, coords, component), "float4".to_string()))
        },
        
        // Color space conversions
        "rgb_to_hsv" => {
            let (rgb, _) = emit_expr(ctx, &args[0].value)?;
            let code = format!(
                "({{ \
                    float3 _rgb = {}; \
                    float4 K = float4(0.0, -1.0/3.0, 2.0/3.0, -1.0); \
                    float4 p = lerp(float4(_rgb.bg, K.wz), float4(_rgb.gb, K.xy), step(_rgb.b, _rgb.g)); \
                    float4 q = lerp(float4(p.xyw, _rgb.r), float4(_rgb.r, p.yzx), step(p.x, _rgb.r)); \
                    float d = q.x - min(q.w, q.y); \
                    float e = 1.0e-10; \
                    float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); \
                }})", rgb
            );
            Ok((code, "float3".to_string()))
        },
        "hsv_to_rgb" => {
            let (hsv, _) = emit_expr(ctx, &args[0].value)?;
            let code = format!(
                "({{ \
                    float3 _hsv = {}; \
                    float4 K = float4(1.0, 2.0/3.0, 1.0/3.0, 3.0); \
                    float3 p = abs(frac(_hsv.xxx + K.xyz) * 6.0 - K.www); \
                    lerp(K.xxx, saturate(p - K.xxx), _hsv.y) * _hsv.z; \
                }})", hsv
            );
            Ok((code, "float3".to_string()))
        },
        
        // Matrix construction
        "mat2" | "Mat2" => {
            let mut arg_codes = Vec::new();
            for arg in args {
                let (code, _) = emit_expr(ctx, &arg.value)?;
                arg_codes.push(code);
            }
            Ok((format!("float2x2({})", arg_codes.join(", ")), "float2x2".to_string()))
        },
        "mat3" | "Mat3" => {
            let mut arg_codes = Vec::new();
            for arg in args {
                let (code, _) = emit_expr(ctx, &arg.value)?;
                arg_codes.push(code);
            }
            Ok((format!("float3x3({})", arg_codes.join(", ")), "float3x3".to_string()))
        },
        "mat4" | "Mat4" => {
            let mut arg_codes = Vec::new();
            for arg in args {
                let (code, _) = emit_expr(ctx, &arg.value)?;
                arg_codes.push(code);
            }
            Ok((format!("float4x4({})", arg_codes.join(", ")), "float4x4".to_string()))
        },
        
        // Advanced math
        "modf" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("modf({}, _modf_int)", arg_code), ty))
        },
        "frexp" => {
            let (arg_code, ty) = emit_expr(ctx, &args[0].value)?;
            Ok((format!("frexp({}, _frexp_exp)", arg_code), ty))
        },
        "ldexp" => {
            let (x, ty) = emit_expr(ctx, &args[0].value)?;
            let (exp, _) = emit_expr(ctx, &args[1].value)?;
            Ok((format!("ldexp({}, {})", x, exp), ty))
        },
        
        // Interpolation attributes (for vertex shader outputs)
        "flat" | "noperspective" | "centroid" => {
            // These are interpolation modifiers, not functions
            // They would be handled in struct field declarations
            Err(KainError::codegen(format!("{} is an interpolation modifier, not a function", name), crate::span::Span::new(0, 0)))
        },
        
        // Atomic operations (for compute shaders)
        "atomic_add" | "atomic_sub" | "atomic_min" | "atomic_max" | 
        "atomic_and" | "atomic_or" | "atomic_xor" | "atomic_exchange" | "atomic_cas" => {
            let hlsl_name = match name {
                "atomic_add" => "InterlockedAdd",
                "atomic_sub" => "InterlockedAdd", // with negated value
                "atomic_min" => "InterlockedMin",
                "atomic_max" => "InterlockedMax",
                "atomic_and" => "InterlockedAnd",
                "atomic_or" => "InterlockedOr",
                "atomic_xor" => "InterlockedXor",
                "atomic_exchange" => "InterlockedExchange",
                "atomic_cas" => "InterlockedCompareExchange",
                _ => name,
            };
            
            let mut arg_codes = Vec::new();
            for arg in args {
                let (code, _) = emit_expr(ctx, &arg.value)?;
                arg_codes.push(code);
            }
            
            Ok((format!("{}({})", hlsl_name, arg_codes.join(", ")), "void".to_string()))
        },
        
        // Wave intrinsics (shader model 6.0+)
        "wave_active_all_true" | "wave_active_any_true" | "wave_active_ballot" |
        "wave_active_sum" | "wave_active_product" | "wave_active_min" | "wave_active_max" |
        "wave_prefix_sum" | "wave_prefix_product" | "wave_read_lane_first" | "wave_read_lane_at" => {
            let hlsl_name = match name {
                "wave_active_all_true" => "WaveActiveAllTrue",
                "wave_active_any_true" => "WaveActiveAnyTrue",
                "wave_active_ballot" => "WaveActiveBallot",
                "wave_active_sum" => "WaveActiveSum",
                "wave_active_product" => "WaveActiveProduct",
                "wave_active_min" => "WaveActiveMin",
                "wave_active_max" => "WaveActiveMax",
                "wave_prefix_sum" => "WavePrefixSum",
                "wave_prefix_product" => "WavePrefixProduct",
                "wave_read_lane_first" => "WaveReadLaneFirst",
                "wave_read_lane_at" => "WaveReadLaneAt",
                _ => name,
            };
            
            let mut arg_codes = Vec::new();
            for arg in args {
                let (code, _) = emit_expr(ctx, &arg.value)?;
                arg_codes.push(code);
            }
            
            let return_type = if name.contains("ballot") {
                "uint4".to_string()
            } else if name.contains("all_true") || name.contains("any_true") {
                "bool".to_string()
            } else if !args.is_empty() {
                emit_expr(ctx, &args[0].value)?.1
            } else {
                "float".to_string()
            };
            
            Ok((format!("{}({})", hlsl_name, arg_codes.join(", ")), return_type))
        },
        
        _ => Err(KainError::codegen(format!("Unknown function: {}", name), crate::span::Span::new(0, 0))),
    }
}

fn map_type_to_hlsl(ty: &Type) -> String {
    match ty {
        Type::Named { name, .. } => match name.as_str() {
            "Float" | "f32" => "float".to_string(),
            "Int" | "i32" => "int".to_string(),
            "UInt" | "u32" => "uint".to_string(),
            "Bool" => "bool".to_string(),
            "Vec2" => "float2".to_string(),
            "Vec3" => "float3".to_string(),
            "Vec4" => "float4".to_string(),
            "IVec2" => "int2".to_string(),
            "IVec3" => "int3".to_string(),
            "IVec4" => "int4".to_string(),
            "UVec2" => "uint2".to_string(),
            "UVec3" => "uint3".to_string(),
            "UVec4" => "uint4".to_string(),
            "Mat4" => "float4x4".to_string(),
            "Mat3" => "float3x3".to_string(),
            "Mat2" => "float2x2".to_string(),
            "Sampler2D" => "Texture2D".to_string(),
            "Sampler3D" => "Texture3D".to_string(),
            "SamplerCube" => "TextureCube".to_string(),
            "Sampler2DArray" => "Texture2DArray".to_string(),
            "SamplerCubeArray" => "TextureCubeArray".to_string(),
            "Sampler2DMS" => "Texture2DMS".to_string(),
            "RWTexture2D" => "RWTexture2D<float4>".to_string(),
            "RWTexture3D" => "RWTexture3D<float4>".to_string(),
            "Buffer" => "Buffer<float4>".to_string(),
            "RWBuffer" => "RWBuffer<float4>".to_string(),
            "StructuredBuffer" => "StructuredBuffer<float4>".to_string(),
            "RWStructuredBuffer" => "RWStructuredBuffer<float4>".to_string(),
            "ByteAddressBuffer" => "ByteAddressBuffer".to_string(),
            "RWByteAddressBuffer" => "RWByteAddressBuffer".to_string(),
            "Void" => "void".to_string(),
            _ => "float4".to_string(),
        },
        Type::Array(element, _size, _span) => {
            let elem_ty = map_type_to_hlsl(element);
            // HLSL arrays use fixed size
            format!("{}[{}]", elem_ty, _size)
        },
        _ => "float4".to_string(),
    }
}

fn infer_swizzle_type(swizzle: &str) -> String {
    match swizzle.len() {
        1 => "float".to_string(),
        2 => "float2".to_string(),
        3 => "float3".to_string(),
        4 => "float4".to_string(),
        _ => "float".to_string(),
    }
}
