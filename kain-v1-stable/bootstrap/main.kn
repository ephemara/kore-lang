// ============================================================================
// KAIN Bootstrap Compiler - Main Entry Point
// ============================================================================
// Project Ouroboros - The Self-Hosted Compiler
//
// This is the main compiler driver written in KAIN itself.
// It orchestrates lexing, parsing, and code generation.
//
// Usage:
//   kain compile main.kn                    # Default: LLVM backend
//   kain compile main.kn --target rust      # Rust transpiler
//   kain compile main.kn --target llvm      # LLVM IR
//   kain compile main.kn --target wasm      # WebAssembly
//
// This module is written in KAIN itself!
// ============================================================================

use std/io
use std/fs
use std/env
use compiler/lexer
use compiler/parser
use compiler/codegen
use compiler/codegen_rust

struct Path:
    path: String

impl Path:
    pub fn new(path: String) -> Path:
        return Path { path: path }
    
    pub fn with_extension(self, ext: String) -> String:
        // Simple implementation: remove last extension if present, add new one
        // Note: this returns a String, not a Path, as per usage
        let p = self.path
        // TODO: Proper path manipulation
        return p + "." + ext
        
    pub fn parent(self) -> String:
        // TODO: Proper path manipulation
        return "."
        
    pub fn stem(self) -> String:
        // TODO: Proper path manipulation
        return "project"

// =============================================================================
// Argument Parsing
// =============================================================================

struct ArgParser:
    args: Vec<String>

impl ArgParser:
    pub fn new() -> ArgParser:
        return ArgParser { args: args() }
    
    pub fn get_value(self, flag: String) -> Option<String>:
        let i = 0
        while i < array_len(self.args) - 1:
            if str_eq(self.args[i], flag):
                return Option::Some(self.args[i+1])
            i = i + 1
        return Option::None
    
    pub fn has_flag(self, flag: String) -> Bool:
        for arg in self.args:
            if str_eq(arg, flag):
                return true
        return false
    
    pub fn input_file(self) -> Option<String>:
        let i = 1
        while i < array_len(self.args):
            let arg = self.args[i]
            let first = substring(arg, 0, 1)
            if !str_eq(first, "-"):
                let prev = self.args[i-1]
                if !str_eq(prev, "-o") && !str_eq(prev, "--target"):
                    return Option::Some(arg)
            i = i + 1
        return Option::None

// =============================================================================
// Compiler Configuration
// =============================================================================

enum Target:
    LLVM
    Rust
    WASM

struct CompilerConfig:
    input_file: String
    output_file: Option<String>
    target: Target
    verbose: Bool

impl CompilerConfig:
    pub fn from_args() -> CompilerConfig:
        let parser = ArgParser::new()
        
        let output = parser.get_value("-o")
        let verbose = parser.has_flag("--verbose") || parser.has_flag("-v")
        
        let input = ""
        match parser.input_file():
            Some(f) => input = f
            None => 
                println("Error: No input file specified")
                exit(1)
        
        let target = Target::LLVM
        match parser.get_value("--target"):
            Some(t) =>
                if str_eq(t, "rust"):
                    target = Target::Rust
                else if str_eq(t, "wasm"):
                    target = Target::WASM
                else:
                    target = Target::LLVM
            None =>
                target = Target::LLVM
        
        return CompilerConfig {
            input_file: input,
            output_file: output,
            target: target,
            verbose: verbose
        }

// =============================================================================
// Compiler Driver
// =============================================================================

struct Compiler:
    config: CompilerConfig

impl Compiler:
    pub fn new(config: CompilerConfig) -> Compiler:
        return Compiler { config: config }
    
    /// Run the full compilation pipeline
    pub fn compile(self) -> Bool:
        if self.config.verbose:
            println(" KAIN Compiler (Ouroboros)")
            println("")
        
        // 1. Read source file
        if self.config.verbose:
            println(" Reading: " + self.config.input_file)
        
        let source = read_file(self.config.input_file)
        
        // 2. Tokenize
        if self.config.verbose:
            println(" Tokenizing...")
        
        let lexer = Lexer::new(source)
        let tokens = lexer.tokenize()
        
        if self.config.verbose:
            println("   " + str(len(tokens)) + " tokens")
        
        // 3. Parse
        if self.config.verbose:
            println(" Parsing...")
        
        let parser = Parser::new(tokens)
        let program = parser.parse_program()
        
        if self.config.verbose:
            println("   " + str(len(program.items)) + " items")
        
        // 4. Generate code based on target
        let output_code = ""
        let output_ext = ""
        
        match self.config.target:
            Target::LLVM =>
                if self.config.verbose:
                    println(" Generating LLVM IR...")
                let gen = CodeGen::new()
                output_code = gen.gen_program(program)
                output_ext = ".ll"
            
            Target::Rust =>
                if self.config.verbose:
                    println(" Generating Rust...")
                let gen = RustGen::new()
                output_code = gen.gen_program(program)
                output_ext = ".rs"
            
            Target::WASM =>
                if self.config.verbose:
                    println(" Generating WASM...")
                // TODO: Implement WASM codegen
                println("WASM backend not yet implemented in bootstrap compiler")
                return false
        
        // 5. Write output
        let output_path = ""
        match self.config.output_file:
            Some(p) => output_path = p
            None =>
                let input_path = Path::new(self.config.input_file)
                output_path = input_path.with_extension(substring(output_ext, 1, len(output_ext)))
        
        if self.config.verbose:
            println(" Writing: " + output_path)
        
        write_file(output_path, output_code)
        
        // 6. Success!
        println(" Compiled to: " + output_path)
        
        // 7. Generate Cargo.toml for Rust target
        match self.config.target:
            Target::Rust =>
                let cargo_path = Path::new(output_path).parent() + "/Cargo.toml"
                let input_path = Path::new(self.config.input_file)
                let cargo_content = gen_cargo_toml(input_path.stem(), [])
                write_file(cargo_path, cargo_content)
                println("   Generated: " + cargo_path)
            _ =>
                // No extra files for other targets
                pass
        
        return true

// =============================================================================
// Main Entry Point
// =============================================================================

fn main():
    let args = args()
    
    // Show help if no args
    if len(args) < 2:
        print_help()
        exit(0)
    
    // Check for help flag
    if contains(args, "--help") || contains(args, "-h"):
        print_help()
        exit(0)
    
    // Parse config and compile
    let config = CompilerConfig::from_args()
    let compiler = Compiler::new(config)
    
    if compiler.compile():
        exit(0)
    else:
        exit(1)

fn print_help():
    println(" KAIN Compiler (Ouroboros) - Self-Hosted Edition")
    println("")
    println("USAGE:")
    println("    kainc <input.kn> [OPTIONS]")
    println("")
    println("OPTIONS:")
    println("    --target <TARGET>   Set compilation target:")
    println("                        - llvm  : LLVM IR (default)")
    println("                        - rust  : Rust source code")
    println("                        - wasm  : WebAssembly")
    println("    -o <FILE>           Output file path")
    println("    -v, --verbose       Verbose output")
    println("    -h, --help          Show this help")
    println("")
    println("EXAMPLES:")
    println("    kainc main.kn                     # Compile to LLVM IR")
    println("    kainc main.kn --target rust       # Transpile to Rust")
    println("    kainc main.kn -o out.ll           # Specify output")
    println("")
    println("PROJECT OUROBOROS")
    println("    This compiler is written in KAIN itself!")
    println("    github.com/ephemara/kain-lang")

// Run!
// main() - Entry point is implicitly called by runtime
