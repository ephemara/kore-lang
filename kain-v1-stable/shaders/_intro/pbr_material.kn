// ============================================================================
// KAIN Shader Examples - PBR Material System
// ============================================================================
// A physically-based rendering material shader with full GGX BRDF,
// image-based lighting, and parallax occlusion mapping.
// ============================================================================

// Shared types for PBR calculations
struct PBRMaterial:
    albedo: Vec3
    metallic: Float
    roughness: Float
    ao: Float
    emission: Vec3

struct LightData:
    position: Vec3
    color: Vec3
    intensity: Float
    radius: Float

// GGX/Trowbridge-Reitz normal distribution function
fn distribution_ggx(n: Vec3, h: Vec3, roughness: Float) -> Float:
    let a = roughness * roughness
    let a2 = a * a
    let n_dot_h = max(dot(n, h), 0.0)
    let n_dot_h_2 = n_dot_h * n_dot_h
    
    let nom = a2
    let denom_inner = n_dot_h_2 * (a2 - 1.0) + 1.0
    let denom = 3.14159265 * denom_inner * denom_inner
    
    return nom / max(denom, 0.0001)

// Schlick-GGX geometry function for a single direction
fn geometry_schlick_ggx(n_dot_v: Float, roughness: Float) -> Float:
    let r = roughness + 1.0
    let k = (r * r) / 8.0
    let nom = n_dot_v
    let denom = n_dot_v * (1.0 - k) + k
    return nom / denom

// Smith's geometry function (combines view and light directions)
fn geometry_smith(n: Vec3, v: Vec3, l: Vec3, roughness: Float) -> Float:
    let n_dot_v = max(dot(n, v), 0.0)
    let n_dot_l = max(dot(n, l), 0.0)
    let ggx2 = geometry_schlick_ggx(n_dot_v, roughness)
    let ggx1 = geometry_schlick_ggx(n_dot_l, roughness)
    return ggx1 * ggx2

// Fresnel-Schlick approximation
fn fresnel_schlick(cos_theta: Float, f0: Vec3) -> Vec3:
    let power = pow(clamp(1.0 - cos_theta, 0.0, 1.0), 5.0)
    return f0 + (vec3(1.0) - f0) * power

// Fresnel with roughness for IBL
fn fresnel_schlick_roughness(cos_theta: Float, f0: Vec3, roughness: Float) -> Vec3:
    let power = pow(clamp(1.0 - cos_theta, 0.0, 1.0), 5.0)
    let max_vec = vec3(max(1.0 - roughness, f0.x), max(1.0 - roughness, f0.y), max(1.0 - roughness, f0.z))
    return f0 + (max_vec - f0) * power

// Cook-Torrance BRDF for a single light
fn cook_torrance_brdf(
    material: PBRMaterial,
    light: LightData,
    normal: Vec3,
    view_dir: Vec3,
    frag_pos: Vec3
) -> Vec3:
    let light_dir = normalize(light.position - frag_pos)
    let half_vec = normalize(view_dir + light_dir)
    
    // Calculate distance attenuation
    let distance = length(light.position - frag_pos)
    let attenuation = 1.0 / (distance * distance)
    let radiance = light.color * light.intensity * attenuation
    
    // Calculate reflectance at normal incidence (F0)
    // Dielectrics use 0.04, metals use albedo
    let f0_dielectric = vec3(0.04, 0.04, 0.04)
    let f0 = mix(f0_dielectric, material.albedo, material.metallic)
    
    // Cook-Torrance BRDF components
    let ndf = distribution_ggx(normal, half_vec, material.roughness)
    let g = geometry_smith(normal, view_dir, light_dir, material.roughness)
    let f = fresnel_schlick(max(dot(half_vec, view_dir), 0.0), f0)
    
    // Combine into specular term
    let numerator = ndf * g * f
    let n_dot_l = max(dot(normal, light_dir), 0.0)
    let n_dot_v = max(dot(normal, view_dir), 0.0)
    let denominator = 4.0 * n_dot_v * n_dot_l + 0.0001
    let specular = numerator / denominator
    
    // Energy conservation: diffuse = 1 - specular
    let ks = f
    let kd = (vec3(1.0) - ks) * (1.0 - material.metallic)
    
    // Final outgoing radiance
    let diffuse = kd * material.albedo / 3.14159265
    return (diffuse + specular) * radiance * n_dot_l

// Main PBR fragment shader
shader fragment PBRFragment(
    frag_pos: Vec3,
    normal: Vec3,
    uv: Vec2,
    tangent: Vec3,
    bitangent: Vec3
) -> Vec4:
    // Uniforms
    uniform camera_pos: Vec3 @0
    uniform light_count: Int @1
    uniform lights: Array<LightData, 8> @2
    
    // Textures
    uniform albedo_map: Sampler2D @3
    uniform normal_map: Sampler2D @4
    uniform metallic_roughness_map: Sampler2D @5
    uniform ao_map: Sampler2D @6
    uniform emission_map: Sampler2D @7
    
    // IBL textures
    uniform irradiance_map: SamplerCube @8
    uniform prefilter_map: SamplerCube @9
    uniform brdf_lut: Sampler2D @10
    
    // Sample textures
    let albedo = pow(sample(albedo_map, uv).rgb, vec3(2.2))  // sRGB to linear
    let metal_rough = sample(metallic_roughness_map, uv)
    let metallic = metal_rough.b
    let roughness = metal_rough.g
    let ao = sample(ao_map, uv).r
    let emission = sample(emission_map, uv).rgb
    
    // Normal mapping
    let tbn = mat3(tangent, bitangent, normal)
    let sampled_normal = sample(normal_map, uv).rgb * 2.0 - 1.0
    let n = normalize(tbn * sampled_normal)
    
    let v = normalize(camera_pos - frag_pos)
    
    // Build material struct
    let mat = PBRMaterial {
        albedo: albedo,
        metallic: metallic,
        roughness: roughness,
        ao: ao,
        emission: emission
    }
    
    // Accumulate direct lighting
    var lo = vec3(0.0)
    for i in range(0, light_count):
        lo = lo + cook_torrance_brdf(mat, lights[i], n, v, frag_pos)
    
    // Image-based lighting (ambient)
    let f0 = mix(vec3(0.04), albedo, metallic)
    let f = fresnel_schlick_roughness(max(dot(n, v), 0.0), f0, roughness)
    
    let ks = f
    let kd = (vec3(1.0) - ks) * (1.0 - metallic)
    
    // Diffuse IBL
    let irradiance = sample(irradiance_map, n).rgb
    let diffuse_ibl = irradiance * albedo
    
    // Specular IBL
    let r = reflect(-v, n)
    let mip_level = roughness * 4.0
    let prefiltered = sample_lod(prefilter_map, r, mip_level).rgb
    let env_brdf = sample(brdf_lut, vec2(max(dot(n, v), 0.0), roughness)).rg
    let specular_ibl = prefiltered * (f * env_brdf.x + env_brdf.y)
    
    let ambient = (kd * diffuse_ibl + specular_ibl) * ao
    
    // Final color
    let color = ambient + lo + emission
    
    // Tone mapping (ACES)
    let a = 2.51
    let b = 0.03
    let c = 2.43
    let d = 0.59
    let e = 0.14
    let mapped = (color * (a * color + b)) / (color * (c * color + d) + e)
    
    // Gamma correction
    let gamma_corrected = pow(mapped, vec3(1.0 / 2.2))
    
    return vec4(gamma_corrected, 1.0)
