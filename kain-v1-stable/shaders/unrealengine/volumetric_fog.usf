// Generated by KAIN Compiler - Unreal Shader Format
// Compatible with UE5 SHADER_PARAMETER_STRUCT bindings

#include "/Engine/Public/Platform.ush"

// Scalar Parameters - Bind via SHADER_PARAMETER_STRUCT
float time;
float fog_density;
float fog_height;
float fog_falloff;
float absorption;
float scattering;
float noise_scale;
float henyey_g;
float ray_steps;
float near_plane;
float far_plane;
float3 light_dir;
float3 light_color;
float3 fog_color;
float3 camera_pos;

struct FPSInput
{
    float4 position : TEXCOORD0;
    float2 uv : TEXCOORD1;
    float3 world_pos : TEXCOORD2;
    float3 view_dir : TEXCOORD3;
};

struct FPSOutput
{
    float4 Color : SV_Target0;
};

FPSOutput VolumetricFogPS(FPSInput Input)
{
    float4 ray_origin = camera_pos;
    float4 ray_dir = normalize(Input.view_dir);
    float4 step_size = (((far_plane - near_plane)) / ray_steps);
    float jitter = (frac(((sin(dot(Input.uv, float2(12.989800, 78.233000))) * 43758.545300) + time)) * step_size);
    float3 accumulated_fog = float3(0.000000, 0.000000, 0.000000);
    float transmittance = 1.000000;
    float4 t = (near_plane + jitter);
    float i = 0.000000;
    while ((i < ray_steps))
    {
        float4 sample_pos = (ray_origin + (ray_dir * t));
        float height_factor = exp(((-max((sample_pos.y - fog_height), 0.000000)) * fog_falloff));
        float4 noise_coord = ((sample_pos * noise_scale) + float3((time * 0.100000), 0.000000, 0.000000));
        float noise1 = ((sin((noise_coord.x * 1.000000)) * cos((noise_coord.y * 1.000000))) * sin((noise_coord.z * 1.000000)));
        float noise2 = ((sin((noise_coord.x * 2.100000)) * cos((noise_coord.y * 1.900000))) * sin((noise_coord.z * 2.300000)));
        float noise3 = ((sin((noise_coord.x * 4.300000)) * cos((noise_coord.y * 3.700000))) * sin((noise_coord.z * 4.100000)));
        float4 fbm_noise = (((((noise1 + (noise2 * 0.500000)) + (noise3 * 0.250000))) * 0.500000) + 0.500000);
        float4 density = ((fog_density * height_factor) * fbm_noise);
        if ((density > 0.001000))
        {
            float cos_theta = dot(ray_dir, light_dir);
            float4 g2 = (henyey_g * henyey_g);
            float phase_denom = ((1.000000 + g2) - ((2.000000 * henyey_g) * cos_theta));
            float phase = (((1.000000 - g2)) / (((4.000000 * 3.141590) * pow(phase_denom, 1.500000))));
            float shadow_density = 0.000000;
            float shadow_t = 0.000000;
            float j = 0.000000;
            while ((j < 6.000000))
            {
                float4 shadow_pos = (sample_pos + (light_dir * shadow_t));
                float shadow_h = exp(((-max((shadow_pos.y - fog_height), 0.000000)) * fog_falloff));
                shadow_density = (shadow_density + ((fog_density * shadow_h) * step_size));
                shadow_t = (shadow_t + (step_size * 3.000000));
                j = (j + 1.000000);
            }
            float4 light_occlusion = exp(((-shadow_density) * absorption));
            float4 in_scatter = (((light_color * phase) * scattering) * light_occlusion);
            float4 step_transmittance = exp((((-density) * step_size) * absorption));
            float4 fog_contrib = (((((fog_color + in_scatter)) * density) * transmittance) * step_size);
            accumulated_fog = (accumulated_fog + fog_contrib);
            transmittance = (transmittance * step_transmittance);
            if ((transmittance < 0.010000))
            {
                i = ray_steps;
            }
        }
        t = (t + step_size);
        i = (i + 1.000000);
    }
    float fog_opacity = (1.000000 - transmittance);
    FPSOutput _Result;
    _Result.Color = float4(accumulated_fog, fog_opacity);
    return _Result;
}
