// ============================================================================
// KAIN SPIR-V Code Generator
// ============================================================================
// Ported from legacy_prototype/src/codegen/spirv.rs
//
// Generates SPIR-V bytecode for GPU shaders from Kain AST.
// Supports vertex, fragment, and compute shaders.
//
// SPIR-V is the intermediate language for Vulkan, OpenGL 4.6+, and OpenCL.
// ============================================================================

use std/collections

// =============================================================================
// SPIR-V Constants
// =============================================================================

// Magic number for SPIR-V binary
const SPIRV_MAGIC: Int = 0x07230203

// SPIR-V version (1.0)
const SPIRV_VERSION: Int = 0x00010000

// Generator magic (Kain = 0x4B4F5245)
const KAIN_GENERATOR: Int = 0x4B4F5245

// Capabilities
enum Capability:
    Shader
    Matrix
    Float64
    Int64

// Addressing models
enum AddressingModel:
    Logical
    Physical32
    Physical64

// Memory models
enum MemoryModel:
    Simple
    GLSL450
    OpenCL

// Execution models
enum ExecutionModel:
    Vertex
    TessellationControl
    TessellationEvaluation
    Geometry
    Fragment
    GLCompute

// Execution modes
enum ExecutionMode:
    OriginUpperLeft
    OriginLowerLeft
    DepthReplacing
    LocalSize

// Storage classes
enum StorageClass:
    UniformConstant
    Input
    Uniform
    Output
    Workgroup
    CrossWorkgroup
    Private
    Function
    Generic
    PushConstant
    AtomicCounter
    Image
    StorageBuffer

// Decorations
enum Decoration:
    Location
    Binding
    DescriptorSet
    Block
    Offset
    ArrayStride
    MatrixStride
    BuiltIn
    Flat
    NoPerspective

// Built-in variables
enum BuiltIn:
    Position
    VertexIndex
    InstanceIndex
    FragCoord
    FragDepth
    FrontFacing
    GlobalInvocationId
    LocalInvocationId
    WorkgroupId

// =============================================================================
// SPIR-V Builder
// =============================================================================

/// SPIR-V instruction
struct SpvInstruction:
    opcode: Int
    result_type: Option<Int>
    result_id: Option<Int>
    operands: Array<Int>

/// SPIR-V module builder
struct SpvBuilder:
    // ID management
    next_id: Int
    bound: Int
    
    // Sections (SPIR-V requires specific ordering)
    capabilities: Array<SpvInstruction>
    extensions: Array<SpvInstruction>
    ext_inst_imports: Array<SpvInstruction>
    memory_model: Option<SpvInstruction>
    entry_points: Array<SpvInstruction>
    execution_modes: Array<SpvInstruction>
    debug_names: Array<SpvInstruction>
    decorations: Array<SpvInstruction>
    types_constants: Array<SpvInstruction>
    variables: Array<SpvInstruction>
    functions: Array<SpvInstruction>
    
    // Type caching
    type_void: Option<Int>
    type_bool: Option<Int>
    type_int32: Option<Int>
    type_uint32: Option<Int>
    type_float32: Option<Int>
    type_float64: Option<Int>
    type_vec2: Option<Int>
    type_vec3: Option<Int>
    type_vec4: Option<Int>
    type_mat4: Option<Int>
    
    // Current function state
    current_function: Option<Int>
    current_block: Option<Int>

impl SpvBuilder:
    /// Create a new SPIR-V builder
    pub fn new() -> SpvBuilder:
        return SpvBuilder {
            next_id: 1,
            bound: 1,
            capabilities: [],
            extensions: [],
            ext_inst_imports: [],
            memory_model: None,
            entry_points: [],
            execution_modes: [],
            debug_names: [],
            decorations: [],
            types_constants: [],
            variables: [],
            functions: [],
            type_void: None,
            type_bool: None,
            type_int32: None,
            type_uint32: None,
            type_float32: None,
            type_float64: None,
            type_vec2: None,
            type_vec3: None,
            type_vec4: None,
            type_mat4: None,
            current_function: None,
            current_block: None
        }
    
    /// Generate a fresh ID
    fn fresh_id(self) -> Int:
        let id = self.next_id
        self.next_id = self.next_id + 1
        if self.next_id > self.bound:
            self.bound = self.next_id
        return id
    
    // =========================================================================
    // Capability & Extension Instructions
    // =========================================================================
    
    /// OpCapability
    pub fn capability(self, cap: Capability) -> Unit:
        let cap_id = match cap:
            Capability::Shader => 1
            Capability::Matrix => 5
            Capability::Float64 => 10
            Capability::Int64 => 11
        
        push(self.capabilities, SpvInstruction {
            opcode: 17,  // OpCapability
            result_type: None,
            result_id: None,
            operands: [cap_id]
        })
    
    /// OpExtInstImport (e.g., GLSL.std.450)
    pub fn ext_inst_import(self, name: String) -> Int:
        let id = self.fresh_id()
        push(self.ext_inst_imports, SpvInstruction {
            opcode: 11,  // OpExtInstImport
            result_type: None,
            result_id: Some(id),
            operands: []  // String encoded separately
        })
        return id
    
    /// OpMemoryModel
    pub fn memory_model(self, addressing: AddressingModel, memory: MemoryModel) -> Unit:
        let addr_id = match addressing:
            AddressingModel::Logical => 0
            AddressingModel::Physical32 => 1
            AddressingModel::Physical64 => 2
        
        let mem_id = match memory:
            MemoryModel::Simple => 0
            MemoryModel::GLSL450 => 1
            MemoryModel::OpenCL => 2
        
        self.memory_model = Some(SpvInstruction {
            opcode: 14,  // OpMemoryModel
            result_type: None,
            result_id: None,
            operands: [addr_id, mem_id]
        })
    
    // =========================================================================
    // Type Instructions
    // =========================================================================
    
    /// OpTypeVoid
    pub fn type_void(self) -> Int:
        match self.type_void:
            Some(id) => return id
            None => pass
        
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 19,  // OpTypeVoid
            result_type: None,
            result_id: Some(id),
            operands: []
        })
        self.type_void = Some(id)
        return id
    
    /// OpTypeBool
    pub fn type_bool(self) -> Int:
        match self.type_bool:
            Some(id) => return id
            None => pass
        
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 20,  // OpTypeBool
            result_type: None,
            result_id: Some(id),
            operands: []
        })
        self.type_bool = Some(id)
        return id
    
    /// OpTypeInt
    pub fn type_int(self, width: Int, signed: Bool) -> Int:
        if width == 32 and signed:
            match self.type_int32:
                Some(id) => return id
                None => pass
        
        if width == 32 and !signed:
            match self.type_uint32:
                Some(id) => return id
                None => pass
        
        let id = self.fresh_id()
        let sign_bit = if signed: 1 else: 0
        push(self.types_constants, SpvInstruction {
            opcode: 21,  // OpTypeInt
            result_type: None,
            result_id: Some(id),
            operands: [width, sign_bit]
        })
        
        if width == 32 and signed:
            self.type_int32 = Some(id)
        if width == 32 and !signed:
            self.type_uint32 = Some(id)
        
        return id
    
    /// OpTypeFloat
    pub fn type_float(self, width: Int) -> Int:
        if width == 32:
            match self.type_float32:
                Some(id) => return id
                None => pass
        
        if width == 64:
            match self.type_float64:
                Some(id) => return id
                None => pass
        
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 22,  // OpTypeFloat
            result_type: None,
            result_id: Some(id),
            operands: [width]
        })
        
        if width == 32:
            self.type_float32 = Some(id)
        if width == 64:
            self.type_float64 = Some(id)
        
        return id
    
    /// OpTypeVector
    pub fn type_vector(self, component_type: Int, count: Int) -> Int:
        // Check cache for common vectors
        if count == 2:
            match self.type_vec2:
                Some(id) => return id
                None => pass
        if count == 3:
            match self.type_vec3:
                Some(id) => return id
                None => pass
        if count == 4:
            match self.type_vec4:
                Some(id) => return id
                None => pass
        
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 23,  // OpTypeVector
            result_type: None,
            result_id: Some(id),
            operands: [component_type, count]
        })
        
        // Cache common float vectors
        if count == 2:
            self.type_vec2 = Some(id)
        if count == 3:
            self.type_vec3 = Some(id)
        if count == 4:
            self.type_vec4 = Some(id)
        
        return id
    
    /// OpTypeMatrix
    pub fn type_matrix(self, column_type: Int, column_count: Int) -> Int:
        if column_count == 4:
            match self.type_mat4:
                Some(id) => return id
                None => pass
        
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 24,  // OpTypeMatrix
            result_type: None,
            result_id: Some(id),
            operands: [column_type, column_count]
        })
        
        if column_count == 4:
            self.type_mat4 = Some(id)
        
        return id
    
    /// OpTypeImage
    pub fn type_image(self, sampled_type: Int, dim: Int, depth: Int, arrayed: Int, ms: Int, sampled: Int, format: Int) -> Int:
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 25,  // OpTypeImage
            result_type: None,
            result_id: Some(id),
            operands: [sampled_type, dim, depth, arrayed, ms, sampled, format]
        })
        return id
    
    /// OpTypeSampledImage
    pub fn type_sampled_image(self, image_type: Int) -> Int:
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 27,  // OpTypeSampledImage
            result_type: None,
            result_id: Some(id),
            operands: [image_type]
        })
        return id
    
    /// OpTypeArray
    pub fn type_array(self, element_type: Int, length: Int) -> Int:
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 28,  // OpTypeArray
            result_type: None,
            result_id: Some(id),
            operands: [element_type, length]
        })
        return id
    
    /// OpTypeRuntimeArray
    pub fn type_runtime_array(self, element_type: Int) -> Int:
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 29,  // OpTypeRuntimeArray
            result_type: None,
            result_id: Some(id),
            operands: [element_type]
        })
        return id
    
    /// OpTypeStruct
    pub fn type_struct(self, member_types: Array<Int>) -> Int:
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 30,  // OpTypeStruct
            result_type: None,
            result_id: Some(id),
            operands: member_types
        })
        return id
    
    /// OpTypePointer
    pub fn type_pointer(self, storage_class: StorageClass, pointee_type: Int) -> Int:
        let sc_id = storage_class_to_int(storage_class)
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 32,  // OpTypePointer
            result_type: None,
            result_id: Some(id),
            operands: [sc_id, pointee_type]
        })
        return id
    
    /// OpTypeFunction
    pub fn type_function(self, return_type: Int, param_types: Array<Int>) -> Int:
        let id = self.fresh_id()
        var operands = [return_type]
        for pt in param_types:
            push(operands, pt)
        push(self.types_constants, SpvInstruction {
            opcode: 33,  // OpTypeFunction
            result_type: None,
            result_id: Some(id),
            operands: operands
        })
        return id
    
    // =========================================================================
    // Constant Instructions
    // =========================================================================
    
    /// OpConstant (32-bit)
    pub fn constant_bit32(self, type_id: Int, value: Int) -> Int:
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 43,  // OpConstant
            result_type: Some(type_id),
            result_id: Some(id),
            operands: [value]
        })
        return id
    
    /// OpConstantComposite
    pub fn constant_composite(self, type_id: Int, constituents: Array<Int>) -> Int:
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 44,  // OpConstantComposite
            result_type: Some(type_id),
            result_id: Some(id),
            operands: constituents
        })
        return id
    
    /// OpConstantTrue
    pub fn constant_true(self, type_id: Int) -> Int:
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 41,  // OpConstantTrue
            result_type: Some(type_id),
            result_id: Some(id),
            operands: []
        })
        return id
    
    /// OpConstantFalse
    pub fn constant_false(self, type_id: Int) -> Int:
        let id = self.fresh_id()
        push(self.types_constants, SpvInstruction {
            opcode: 42,  // OpConstantFalse
            result_type: Some(type_id),
            result_id: Some(id),
            operands: []
        })
        return id
    
    // =========================================================================
    // Variable Instructions
    // =========================================================================
    
    /// OpVariable
    pub fn variable(self, type_id: Int, storage_class: StorageClass, initializer: Option<Int>) -> Int:
        let sc_id = storage_class_to_int(storage_class)
        let id = self.fresh_id()
        var operands = [sc_id]
        match initializer:
            Some(init_id) => push(operands, init_id)
            None => pass
        
        // Variables go in different sections based on storage class
        match storage_class:
            StorageClass::Function => 
                // Function-local variables go in the function section
                push(self.functions, SpvInstruction {
                    opcode: 59,  // OpVariable
                    result_type: Some(type_id),
                    result_id: Some(id),
                    operands: operands
                })
            _ =>
                // Global variables go in the variables section
                push(self.variables, SpvInstruction {
                    opcode: 59,  // OpVariable
                    result_type: Some(type_id),
                    result_id: Some(id),
                    operands: operands
                })
        
        return id
    
    // =========================================================================
    // Decoration Instructions
    // =========================================================================
    
    /// OpDecorate
    pub fn decorate(self, target: Int, decoration: Decoration, operands: Array<Int>) -> Unit:
        let dec_id = decoration_to_int(decoration)
        var all_operands = [target, dec_id]
        for op in operands:
            push(all_operands, op)
        push(self.decorations, SpvInstruction {
            opcode: 71,  // OpDecorate
            result_type: None,
            result_id: None,
            operands: all_operands
        })
    
    /// OpMemberDecorate
    pub fn member_decorate(self, struct_type: Int, member: Int, decoration: Decoration, operands: Array<Int>) -> Unit:
        let dec_id = decoration_to_int(decoration)
        var all_operands = [struct_type, member, dec_id]
        for op in operands:
            push(all_operands, op)
        push(self.decorations, SpvInstruction {
            opcode: 72,  // OpMemberDecorate
            result_type: None,
            result_id: None,
            operands: all_operands
        })
    
    // =========================================================================
    // Entry Point & Execution Mode
    // =========================================================================
    
    /// OpEntryPoint
    pub fn entry_point(self, model: ExecutionModel, func: Int, name: String, interface: Array<Int>) -> Unit:
        let model_id = execution_model_to_int(model)
        var operands = [model_id, func]  // Name encoded separately
        for iface in interface:
            push(operands, iface)
        push(self.entry_points, SpvInstruction {
            opcode: 15,  // OpEntryPoint
            result_type: None,
            result_id: None,
            operands: operands
        })
    
    /// OpExecutionMode
    pub fn execution_mode(self, entry: Int, mode: ExecutionMode, operands: Array<Int>) -> Unit:
        let mode_id = execution_mode_to_int(mode)
        var all_operands = [entry, mode_id]
        for op in operands:
            push(all_operands, op)
        push(self.execution_modes, SpvInstruction {
            opcode: 16,  // OpExecutionMode
            result_type: None,
            result_id: None,
            operands: all_operands
        })
    
    // =========================================================================
    // Function Instructions
    // =========================================================================
    
    /// OpFunction
    pub fn begin_function(self, return_type: Int, function_type: Int) -> Int:
        let id = self.fresh_id()
        push(self.functions, SpvInstruction {
            opcode: 54,  // OpFunction
            result_type: Some(return_type),
            result_id: Some(id),
            operands: [0, function_type]  // Function control = None
        })
        self.current_function = Some(id)
        return id
    
    /// OpFunctionEnd
    pub fn end_function(self) -> Unit:
        push(self.functions, SpvInstruction {
            opcode: 56,  // OpFunctionEnd
            result_type: None,
            result_id: None,
            operands: []
        })
        self.current_function = None
    
    /// OpLabel (begin basic block)
    pub fn begin_block(self) -> Int:
        let id = self.fresh_id()
        push(self.functions, SpvInstruction {
            opcode: 248,  // OpLabel
            result_type: None,
            result_id: Some(id),
            operands: []
        })
        self.current_block = Some(id)
        return id
    
    /// OpReturn
    pub fn ret(self) -> Unit:
        push(self.functions, SpvInstruction {
            opcode: 253,  // OpReturn
            result_type: None,
            result_id: None,
            operands: []
        })
    
    /// OpReturnValue
    pub fn ret_value(self, value: Int) -> Unit:
        push(self.functions, SpvInstruction {
            opcode: 254,  // OpReturnValue
            result_type: None,
            result_id: None,
            operands: [value]
        })
    
    // =========================================================================
    // Arithmetic Instructions
    // =========================================================================
    
    /// OpFAdd
    pub fn f_add(self, type_id: Int, a: Int, b: Int) -> Int:
        let id = self.fresh_id()
        push(self.functions, SpvInstruction {
            opcode: 129,  // OpFAdd
            result_type: Some(type_id),
            result_id: Some(id),
            operands: [a, b]
        })
        return id
    
    /// OpFSub
    pub fn f_sub(self, type_id: Int, a: Int, b: Int) -> Int:
        let id = self.fresh_id()
        push(self.functions, SpvInstruction {
            opcode: 131,  // OpFSub
            result_type: Some(type_id),
            result_id: Some(id),
            operands: [a, b]
        })
        return id
    
    /// OpFMul
    pub fn f_mul(self, type_id: Int, a: Int, b: Int) -> Int:
        let id = self.fresh_id()
        push(self.functions, SpvInstruction {
            opcode: 133,  // OpFMul
            result_type: Some(type_id),
            result_id: Some(id),
            operands: [a, b]
        })
        return id
    
    /// OpFDiv
    pub fn f_div(self, type_id: Int, a: Int, b: Int) -> Int:
        let id = self.fresh_id()
        push(self.functions, SpvInstruction {
            opcode: 136,  // OpFDiv
            result_type: Some(type_id),
            result_id: Some(id),
            operands: [a, b]
        })
        return id
    
    /// OpMatrixTimesMatrix
    pub fn matrix_times_matrix(self, type_id: Int, a: Int, b: Int) -> Int:
        let id = self.fresh_id()
        push(self.functions, SpvInstruction {
            opcode: 146,  // OpMatrixTimesMatrix
            result_type: Some(type_id),
            result_id: Some(id),
            operands: [a, b]
        })
        return id
    
    /// OpMatrixTimesVector
    pub fn matrix_times_vector(self, type_id: Int, matrix: Int, vector: Int) -> Int:
        let id = self.fresh_id()
        push(self.functions, SpvInstruction {
            opcode: 145,  // OpMatrixTimesVector
            result_type: Some(type_id),
            result_id: Some(id),
            operands: [matrix, vector]
        })
        return id
    
    /// OpVectorTimesMatrix
    pub fn vector_times_matrix(self, type_id: Int, vector: Int, matrix: Int) -> Int:
        let id = self.fresh_id()
        push(self.functions, SpvInstruction {
            opcode: 144,  // OpVectorTimesMatrix
            result_type: Some(type_id),
            result_id: Some(id),
            operands: [vector, matrix]
        })
        return id
    
    // =========================================================================
    // Memory Instructions
    // =========================================================================
    
    /// OpLoad
    pub fn load(self, type_id: Int, pointer: Int) -> Int:
        let id = self.fresh_id()
        push(self.functions, SpvInstruction {
            opcode: 61,  // OpLoad
            result_type: Some(type_id),
            result_id: Some(id),
            operands: [pointer]
        })
        return id
    
    /// OpStore
    pub fn store(self, pointer: Int, value: Int) -> Unit:
        push(self.functions, SpvInstruction {
            opcode: 62,  // OpStore
            result_type: None,
            result_id: None,
            operands: [pointer, value]
        })
    
    // =========================================================================
    // Composite Instructions
    // =========================================================================
    
    /// OpCompositeConstruct
    pub fn composite_construct(self, type_id: Int, constituents: Array<Int>) -> Int:
        let id = self.fresh_id()
        push(self.functions, SpvInstruction {
            opcode: 80,  // OpCompositeConstruct
            result_type: Some(type_id),
            result_id: Some(id),
            operands: constituents
        })
        return id
    
    /// OpCompositeExtract
    pub fn composite_extract(self, type_id: Int, composite: Int, indices: Array<Int>) -> Int:
        let id = self.fresh_id()
        var operands = [composite]
        for idx in indices:
            push(operands, idx)
        push(self.functions, SpvInstruction {
            opcode: 81,  // OpCompositeExtract
            result_type: Some(type_id),
            result_id: Some(id),
            operands: operands
        })
        return id
    
    // =========================================================================
    // Module Assembly
    // =========================================================================
    
    /// Assemble the module into SPIR-V binary
    pub fn assemble(self) -> Array<Int>:
        var words: Array<Int> = []
        
        // Header
        push(words, SPIRV_MAGIC)
        push(words, SPIRV_VERSION)
        push(words, KAIN_GENERATOR)
        push(words, self.bound)  // Bound
        push(words, 0)  // Schema (reserved)
        
        // Capabilities
        for instr in self.capabilities:
            emit_instruction(words, instr)
        
        // Extensions
        for instr in self.extensions:
            emit_instruction(words, instr)
        
        // ExtInstImports
        for instr in self.ext_inst_imports:
            emit_instruction(words, instr)
        
        // Memory model
        match self.memory_model:
            Some(instr) => emit_instruction(words, instr)
            None => pass
        
        // Entry points
        for instr in self.entry_points:
            emit_instruction(words, instr)
        
        // Execution modes
        for instr in self.execution_modes:
            emit_instruction(words, instr)
        
        // Debug (names)
        for instr in self.debug_names:
            emit_instruction(words, instr)
        
        // Decorations
        for instr in self.decorations:
            emit_instruction(words, instr)
        
        // Types and constants
        for instr in self.types_constants:
            emit_instruction(words, instr)
        
        // Global variables
        for instr in self.variables:
            emit_instruction(words, instr)
        
        // Functions
        for instr in self.functions:
            emit_instruction(words, instr)
        
        return words

/// Emit a single instruction to the word stream
fn emit_instruction(words: Array<Int>, instr: SpvInstruction) -> Unit:
    // Calculate word count
    var word_count = 1  // opcode word
    match instr.result_type:
        Some(_) => word_count = word_count + 1
        None => pass
    match instr.result_id:
        Some(_) => word_count = word_count + 1
        None => pass
    word_count = word_count + len(instr.operands)
    
    // First word: (word_count << 16) | opcode
    let first_word = (word_count << 16) | instr.opcode
    push(words, first_word)
    
    // Result type (if present)
    match instr.result_type:
        Some(type_id) => push(words, type_id)
        None => pass
    
    // Result id (if present)
    match instr.result_id:
        Some(id) => push(words, id)
        None => pass
    
    // Operands
    for op in instr.operands:
        push(words, op)

// =============================================================================
// Enum Conversion Helpers
// =============================================================================

fn storage_class_to_int(sc: StorageClass) -> Int:
    match sc:
        StorageClass::UniformConstant => 0
        StorageClass::Input => 1
        StorageClass::Uniform => 2
        StorageClass::Output => 3
        StorageClass::Workgroup => 4
        StorageClass::CrossWorkgroup => 5
        StorageClass::Private => 6
        StorageClass::Function => 7
        StorageClass::Generic => 8
        StorageClass::PushConstant => 9
        StorageClass::AtomicCounter => 10
        StorageClass::Image => 11
        StorageClass::StorageBuffer => 12

fn decoration_to_int(dec: Decoration) -> Int:
    match dec:
        Decoration::Location => 30
        Decoration::Binding => 33
        Decoration::DescriptorSet => 34
        Decoration::Block => 2
        Decoration::Offset => 35
        Decoration::ArrayStride => 6
        Decoration::MatrixStride => 7
        Decoration::BuiltIn => 11
        Decoration::Flat => 14
        Decoration::NoPerspective => 13

fn execution_model_to_int(model: ExecutionModel) -> Int:
    match model:
        ExecutionModel::Vertex => 0
        ExecutionModel::TessellationControl => 1
        ExecutionModel::TessellationEvaluation => 2
        ExecutionModel::Geometry => 3
        ExecutionModel::Fragment => 4
        ExecutionModel::GLCompute => 5

fn execution_mode_to_int(mode: ExecutionMode) -> Int:
    match mode:
        ExecutionMode::OriginUpperLeft => 7
        ExecutionMode::OriginLowerLeft => 8
        ExecutionMode::DepthReplacing => 12
        ExecutionMode::LocalSize => 17

// =============================================================================
// Shader Compilation
// =============================================================================

/// Shader stage
enum ShaderStage:
    Vertex
    Fragment
    Compute

/// Compiled shader output
struct CompiledShader:
    stage: ShaderStage
    name: String
    spirv: Array<Int>

/// Generate SPIR-V from a shader AST node
pub fn generate_shader(shader: ShaderDef) -> Result<CompiledShader, String>:
    var builder = SpvBuilder::new()
    
    // Setup capabilities and memory model
    builder.capability(Capability::Shader)
    builder.memory_model(AddressingModel::Logical, MemoryModel::GLSL450)
    
    // Determine execution model
    let exec_model = match shader.stage:
        ShaderStage::Vertex => ExecutionModel::Vertex
        ShaderStage::Fragment => ExecutionModel::Fragment
        ShaderStage::Compute => ExecutionModel::GLCompute
    
    // Create basic types
    let void_ty = builder.type_void()
    let float_ty = builder.type_float(32)
    let vec4_ty = builder.type_vector(float_ty, 4)
    
    // Create function type (void -> void for entry point)
    let fn_ty = builder.type_function(void_ty, [])
    
    // Create input/output variables
    var interface_vars: Array<Int> = []
    
    // Input variables
    for i in range(0, len(shader.inputs)):
        let input = shader.inputs[i]
        let input_ty = map_shader_type(builder, input.ty)
        let ptr_ty = builder.type_pointer(StorageClass::Input, input_ty)
        let var_id = builder.variable(ptr_ty, StorageClass::Input, None)
        builder.decorate(var_id, Decoration::Location, [i])
        push(interface_vars, var_id)
    
    // Output variable
    if shader.has_output:
        let out_ty = map_shader_type(builder, shader.output_type)
        let ptr_ty = builder.type_pointer(StorageClass::Output, out_ty)
        let var_id = builder.variable(ptr_ty, StorageClass::Output, None)
        builder.decorate(var_id, Decoration::Location, [0])
        push(interface_vars, var_id)
    
    // Create main function
    let main_fn = builder.begin_function(void_ty, fn_ty)
    builder.begin_block()
    
    // TODO: Compile shader body expressions
    // For now, just return
    
    builder.ret()
    builder.end_function()
    
    // Create entry point
    builder.entry_point(exec_model, main_fn, shader.name, interface_vars)
    
    // Add execution mode for fragment shaders
    match exec_model:
        ExecutionModel::Fragment =>
            builder.execution_mode(main_fn, ExecutionMode::OriginUpperLeft, [])
        _ => pass
    
    // Assemble to SPIR-V
    let spirv = builder.assemble()
    
    return Ok(CompiledShader {
        stage: shader.stage,
        name: shader.name,
        spirv: spirv
    })

/// Map Kain type to SPIR-V type
fn map_shader_type(builder: SpvBuilder, ty: String) -> Int:
    if ty == "Float" or ty == "f32":
        return builder.type_float(32)
    if ty == "Int" or ty == "i32":
        return builder.type_int(32, true)
    if ty == "Bool":
        return builder.type_bool()
    if ty == "Vec2":
        let f = builder.type_float(32)
        return builder.type_vector(f, 2)
    if ty == "Vec3":
        let f = builder.type_float(32)
        return builder.type_vector(f, 3)
    if ty == "Vec4":
        let f = builder.type_float(32)
        return builder.type_vector(f, 4)
    if ty == "Mat4":
        let f = builder.type_float(32)
        let v4 = builder.type_vector(f, 4)
        return builder.type_matrix(v4, 4)
    
    // Default to float
    return builder.type_float(32)

// =============================================================================
// Shader Definition (AST placeholder)
// =============================================================================

/// Shader definition from AST
struct ShaderDef:
    name: String
    stage: ShaderStage
    inputs: Array<ShaderParam>
    uniforms: Array<ShaderUniform>
    has_output: Bool
    output_type: String
    body: Array<Stmt>

/// Shader parameter
struct ShaderParam:
    name: String
    ty: String

/// Shader uniform
struct ShaderUniform:
    name: String
    ty: String
    binding: Int

/// Placeholder for statement AST (would import from ast.kn)
struct Stmt:
    kind: String
