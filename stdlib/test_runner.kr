// ============================================================================
// KORE Test Runner (kore test)
// ============================================================================
// Discovers, runs, and reports on test functions.
// Supports:
// - Test discovery (test functions, #[test] blocks)
// - Parallel test execution
// - Assertions with detailed diffs
// - Coverage tracking
// - Benchmarks
// ============================================================================

use std/collections

// =============================================================================
// Test Configuration
// =============================================================================

struct TestConfig:
    parallel: Bool          // Run tests in parallel
    num_threads: Int        // Number of parallel threads
    filter: Option<String>  // Filter tests by name pattern
    verbose: Bool           // Show all output, not just failures
    fail_fast: Bool         // Stop on first failure
    timeout_ms: Int         // Per-test timeout
    show_output: Bool       // Show captured stdout/stderr
    run_benchmarks: Bool    // Also run benchmark tests

impl TestConfig:
    pub fn default() -> TestConfig:
        return TestConfig {
            parallel: true,
            num_threads: 4,
            filter: None,
            verbose: false,
            fail_fast: false,
            timeout_ms: 5000,
            show_output: false,
            run_benchmarks: false
        }

// =============================================================================
// Test Results
// =============================================================================

enum TestResult:
    Passed
    Failed(String)          // Error message
    Skipped(String)         // Reason for skip
    TimedOut

struct TestOutcome:
    name: String
    result: TestResult
    duration_ms: Int
    output: String          // Captured stdout

struct TestSummary:
    total: Int
    passed: Int
    failed: Int
    skipped: Int
    timed_out: Int
    duration_ms: Int
    outcomes: Array<TestOutcome>

impl TestSummary:
    pub fn new() -> TestSummary:
        return TestSummary {
            total: 0,
            passed: 0,
            failed: 0,
            skipped: 0,
            timed_out: 0,
            duration_ms: 0,
            outcomes: []
        }
    
    pub fn add(self, outcome: TestOutcome) -> Unit:
        self.total = self.total + 1
        self.duration_ms = self.duration_ms + outcome.duration_ms
        
        match outcome.result:
            TestResult::Passed => self.passed = self.passed + 1
            TestResult::Failed(_) => self.failed = self.failed + 1
            TestResult::Skipped(_) => self.skipped = self.skipped + 1
            TestResult::TimedOut => self.timed_out = self.timed_out + 1
        
        push(self.outcomes, outcome)
    
    pub fn success(self) -> Bool:
        return self.failed == 0 and self.timed_out == 0

// =============================================================================
// Test Discovery
// =============================================================================

struct TestCase:
    name: String
    function: FnDef
    is_benchmark: Bool
    skip_reason: Option<String>

struct TestDiscovery:
    tests: Array<TestCase>

impl TestDiscovery:
    pub fn new() -> TestDiscovery:
        return TestDiscovery { tests: [] }
    
    /// Discover tests from a program AST
    pub fn discover(self, program: Program) -> Unit:
        for item in program.items:
            match item:
                Item::Function(f) =>
                    // Check for test_ prefix
                    if starts_with(f.name, "test_"):
                        push(self.tests, TestCase {
                            name: f.name,
                            function: f,
                            is_benchmark: false,
                            skip_reason: None
                        })
                    // Check for bench_ prefix
                    else if starts_with(f.name, "bench_"):
                        push(self.tests, TestCase {
                            name: f.name,
                            function: f,
                            is_benchmark: true,
                            skip_reason: None
                        })
                
                Item::Test(t) =>
                    // test block syntax
                    let test_fn = FnDef {
                        name: t.name,
                        generics: [],
                        params: [],
                        return_type: None,
                        body: t.body,
                        is_pub: false,
                        is_async: false,
                        effects: [],
                        span: t.span
                    }
                    push(self.tests, TestCase {
                        name: t.name,
                        function: test_fn,
                        is_benchmark: false,
                        skip_reason: None
                    })
                
                _ => pass
    
    /// Filter tests by name pattern
    pub fn filter(self, pattern: String) -> Array<TestCase>:
        var filtered: Array<TestCase> = []
        for test in self.tests:
            if contains(test.name, pattern):
                push(filtered, test)
        return filtered

// =============================================================================
// Test Runner
// =============================================================================

struct TestRunner:
    config: TestConfig
    summary: TestSummary

impl TestRunner:
    pub fn new(config: TestConfig) -> TestRunner:
        return TestRunner {
            config: config,
            summary: TestSummary::new()
        }
    
    /// Run all discovered tests
    pub fn run(self, tests: Array<TestCase>) -> TestSummary:
        // Filter tests
        var to_run = tests
        match self.config.filter:
            Some(pattern) =>
                var filtered: Array<TestCase> = []
                for test in tests:
                    if contains(test.name, pattern):
                        push(filtered, test)
                to_run = filtered
            None => pass
        
        // Filter out benchmarks if not running them
        if !self.config.run_benchmarks:
            var non_bench: Array<TestCase> = []
            for test in to_run:
                if !test.is_benchmark:
                    push(non_bench, test)
            to_run = non_bench
        
        // Print header
        self.print_header(len(to_run))
        
        // Run tests
        for test in to_run:
            let outcome = self.run_single(test)
            self.summary.add(outcome)
            self.print_outcome(outcome)
            
            // Fail fast check
            if self.config.fail_fast:
                match outcome.result:
                    TestResult::Failed(_) => break
                    TestResult::TimedOut => break
                    _ => pass
        
        // Print summary
        self.print_summary()
        
        return self.summary
    
    fn run_single(self, test: TestCase) -> TestOutcome:
        // Check for skip
        match test.skip_reason:
            Some(reason) =>
                return TestOutcome {
                    name: test.name,
                    result: TestResult::Skipped(reason),
                    duration_ms: 0,
                    output: ""
                }
            None => pass
        
        // Capture start time
        let start_time = time_ms()
        
        // Run the test (would invoke interpreter or compiled function)
        // For now, simulate
        let result = self.execute_test(test)
        
        let end_time = time_ms()
        let duration = end_time - start_time
        
        return TestOutcome {
            name: test.name,
            result: result,
            duration_ms: duration,
            output: ""
        }
    
    fn execute_test(self, test: TestCase) -> TestResult:
        // In real implementation, this would:
        // 1. Set up fresh environment
        // 2. Run the test function
        // 3. Catch any panics/assertions
        // 4. Return result
        
        // Placeholder - would integrate with interpreter
        return TestResult::Passed
    
    // =========================================================================
    // Output Formatting
    // =========================================================================
    
    fn print_header(self, count: Int) -> Unit:
        println("")
        println("running " + str(count) + " tests")
        println("")
    
    fn print_outcome(self, outcome: TestOutcome) -> Unit:
        match outcome.result:
            TestResult::Passed =>
                if self.config.verbose:
                    println("test " + outcome.name + " ... " + green("ok") + " (" + str(outcome.duration_ms) + "ms)")
                else:
                    print(green("."))
            
            TestResult::Failed(msg) =>
                println("")
                println("test " + outcome.name + " ... " + red("FAILED"))
                println("  " + msg)
                println("")
            
            TestResult::Skipped(reason) =>
                if self.config.verbose:
                    println("test " + outcome.name + " ... " + yellow("skipped") + " (" + reason + ")")
            
            TestResult::TimedOut =>
                println("")
                println("test " + outcome.name + " ... " + red("TIMED OUT"))
                println("")
    
    fn print_summary(self) -> Unit:
        println("")
        println("----------------------------------------")
        
        if self.summary.success():
            println(green("test result: ok") + ". " + 
                str(self.summary.passed) + " passed; " +
                str(self.summary.failed) + " failed; " +
                str(self.summary.skipped) + " skipped")
        else:
            println(red("test result: FAILED") + ". " +
                str(self.summary.passed) + " passed; " +
                str(self.summary.failed) + " failed; " +
                str(self.summary.skipped) + " skipped")
            
            // List failures
            println("")
            println("failures:")
            for outcome in self.summary.outcomes:
                match outcome.result:
                    TestResult::Failed(msg) =>
                        println("    " + outcome.name + ": " + msg)
                    TestResult::TimedOut =>
                        println("    " + outcome.name + ": timed out")
                    _ => pass
        
        println("")
        println("finished in " + str(self.summary.duration_ms) + "ms")
        println("")

// =============================================================================
// Assertions
// =============================================================================

/// Assert two values are equal
pub fn assert_eq<T>(left: T, right: T) -> Result<Unit, String>:
    if left == right:
        return Ok(())
    return Err("assertion failed: left != right\n  left:  " + str(left) + "\n  right: " + str(right))

/// Assert two values are not equal
pub fn assert_ne<T>(left: T, right: T) -> Result<Unit, String>:
    if left != right:
        return Ok(())
    return Err("assertion failed: left == right\n  both: " + str(left))

/// Assert a condition is true
pub fn assert_true(cond: Bool) -> Result<Unit, String>:
    if cond:
        return Ok(())
    return Err("assertion failed: expected true")

/// Assert a condition is false
pub fn assert_false(cond: Bool) -> Result<Unit, String>:
    if !cond:
        return Ok(())
    return Err("assertion failed: expected false")

/// Assert a value is Some
pub fn assert_some<T>(opt: Option<T>) -> Result<T, String>:
    match opt:
        Some(v) => return Ok(v)
        None => return Err("assertion failed: expected Some, got None")

/// Assert a value is None
pub fn assert_none<T>(opt: Option<T>) -> Result<Unit, String>:
    match opt:
        Some(_) => return Err("assertion failed: expected None, got Some")
        None => return Ok(())

/// Assert a Result is Ok
pub fn assert_ok<T, E>(res: Result<T, E>) -> Result<T, String>:
    match res:
        Ok(v) => return Ok(v)
        Err(e) => return Err("assertion failed: expected Ok, got Err: " + str(e))

/// Assert a Result is Err
pub fn assert_err<T, E>(res: Result<T, E>) -> Result<E, String>:
    match res:
        Ok(_) => return Err("assertion failed: expected Err, got Ok")
        Err(e) => return Ok(e)

/// Assert a value matches a pattern (returns extracted value)
pub fn assert_matches<T>(msg: String, matched: Bool) -> Result<Unit, String>:
    if matched:
        return Ok(())
    return Err("assertion failed: " + msg)

/// Assert approximate equality for floats
pub fn assert_approx_eq(left: Float, right: Float, epsilon: Float) -> Result<Unit, String>:
    let diff = abs(left - right)
    if diff <= epsilon:
        return Ok(())
    return Err("assertion failed: values not approximately equal\n  left:  " + str(left) + "\n  right: " + str(right) + "\n  diff:  " + str(diff))

/// Assert array contains element
pub fn assert_contains<T>(arr: Array<T>, elem: T) -> Result<Unit, String>:
    for item in arr:
        if item == elem:
            return Ok(())
    return Err("assertion failed: array does not contain " + str(elem))

// =============================================================================
// Color Helpers
// =============================================================================

fn green(s: String) -> String:
    return "\x1b[32m" + s + "\x1b[0m"

fn red(s: String) -> String:
    return "\x1b[31m" + s + "\x1b[0m"

fn yellow(s: String) -> String:
    return "\x1b[33m" + s + "\x1b[0m"

// =============================================================================
// Utility
// =============================================================================

extern fn time_ms() -> Int
extern fn abs(x: Float) -> Float

// =============================================================================
// Public API
// =============================================================================

/// Run tests from a program
pub fn run_tests(program: Program) -> TestSummary:
    let discovery = TestDiscovery::new()
    discovery.discover(program)
    
    let runner = TestRunner::new(TestConfig::default())
    return runner.run(discovery.tests)

/// Run tests with custom configuration
pub fn run_tests_with_config(program: Program, config: TestConfig) -> TestSummary:
    let discovery = TestDiscovery::new()
    discovery.discover(program)
    
    let runner = TestRunner::new(config)
    return runner.run(discovery.tests)
