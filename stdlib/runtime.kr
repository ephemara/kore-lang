// ============================================================================
// KORE Runtime (Interpreter)
// ============================================================================
// Ported from legacy_prototype/src/runtime.rs
//
// This is the reference interpreter for Kore. It provides:
// - Expression and statement evaluation
// - Standard library functions
// - Actor system
// - HTTP/JSON support
// - Python FFI (via extern)
// - VDOM/JSX rendering
// ============================================================================

use std/collections

// =============================================================================
// Runtime Values
// =============================================================================

/// VDOM Node for JSX rendering
enum VNode:
    Element(String, Map<String, Value>, Array<VNode>)  // tag, attrs, children
    Text(String)

/// Runtime value
enum Value:
    Int(Int)
    Float(Float)
    Bool(Bool)
    String(String)
    Unit
    None
    Array(Array<Value>)
    Tuple(Array<Value>)
    Map(Map<String, Value>)
    Struct(String, Map<String, Value>)  // name, fields
    Enum(String, String, Array<Value>)  // enum_name, variant, data
    Function(String, Array<Param>, Block, Env)  // name, params, body, closure
    NativeFunction(String)  // name of native function
    VNode(VNode)
    ActorRef(ActorRef)
    Future(String, Map<String, Value>)  // state machine name, state
    Poll(Bool, Option<Value>)  // is_ready, value

impl Value:
    pub fn type_name(self) -> String:
        match self:
            Value::Int(_) => "Int"
            Value::Float(_) => "Float"
            Value::Bool(_) => "Bool"
            Value::String(_) => "String"
            Value::Unit => "Unit"
            Value::None => "None"
            Value::Array(_) => "Array"
            Value::Tuple(_) => "Tuple"
            Value::Map(_) => "Map"
            Value::Struct(name, _) => name
            Value::Enum(name, _, _) => name
            Value::Function(name, _, _, _) => "fn " + name
            Value::NativeFunction(name) => "native fn " + name
            Value::VNode(_) => "VNode"
            Value::ActorRef(_) => "ActorRef"
            Value::Future(name, _) => "Future<" + name + ">"
            Value::Poll(ready, _) => if ready: "Poll::Ready" else: "Poll::Pending"
    
    pub fn is_truthy(self) -> Bool:
        match self:
            Value::Bool(b) => b
            Value::Int(n) => n != 0
            Value::Float(f) => f != 0.0
            Value::String(s) => len(s) > 0
            Value::None => false
            Value::Unit => false
            Value::Array(a) => len(a) > 0
            _ => true
    
    pub fn to_string(self) -> String:
        match self:
            Value::Int(n) => str(n)
            Value::Float(f) => str(f)
            Value::Bool(b) => if b: "true" else: "false"
            Value::String(s) => s
            Value::Unit => "()"
            Value::None => "None"
            Value::Array(items) =>
                var parts: Array<String> = []
                for item in items:
                    push(parts, item.to_string())
                "[" + join(parts, ", ") + "]"
            Value::Tuple(items) =>
                var parts: Array<String> = []
                for item in items:
                    push(parts, item.to_string())
                "(" + join(parts, ", ") + ")"
            Value::Map(m) =>
                var parts: Array<String> = []
                for k, v in m:
                    push(parts, k + ": " + v.to_string())
                "{" + join(parts, ", ") + "}"
            Value::Struct(name, fields) =>
                var parts: Array<String> = []
                for k, v in fields:
                    push(parts, k + ": " + v.to_string())
                name + " { " + join(parts, ", ") + " }"
            Value::Enum(ename, variant, data) =>
                if len(data) == 0:
                    ename + "::" + variant
                else:
                    ename + "::" + variant + "(...)"
            Value::Function(name, _, _, _) => "<fn " + name + ">"
            Value::NativeFunction(name) => "<native " + name + ">"
            _ => "<?>"

// =============================================================================
// Actor System
// =============================================================================

struct ActorRef:
    id: Int
    name: String

struct Message:
    handler: String
    args: Array<Value>
    reply_to: Option<ActorRef>

// =============================================================================
// Environment (Scope Chain)
// =============================================================================

struct Env:
    scopes: Array<Map<String, Value>>
    functions: Map<String, Function>
    structs: Map<String, Struct>
    enums: Map<String, Enum>
    actors: Map<Int, ActorState>
    next_actor_id: Int

struct ActorState:
    def: Actor
    state: Map<String, Value>
    mailbox: Array<Message>

impl Env:
    pub fn new() -> Env:
        var env = Env {
            scopes: [Map::new()],
            functions: Map::new(),
            structs: Map::new(),
            enums: Map::new(),
            actors: Map::new(),
            next_actor_id: 1
        }
        env.register_stdlib()
        return env
    
    pub fn push_scope(self) -> Unit:
        push(self.scopes, Map::new())
    
    pub fn pop_scope(self) -> Unit:
        if len(self.scopes) > 1:
            pop(self.scopes)
    
    pub fn define(self, name: String, value: Value) -> Unit:
        let last = len(self.scopes) - 1
        self.scopes[last][name] = value
    
    pub fn assign(self, name: String, value: Value) -> Result<Unit, String>:
        // Search from innermost to outermost
        var i = len(self.scopes) - 1
        while i >= 0:
            if contains_key(self.scopes[i], name):
                self.scopes[i][name] = value
                return Ok(())
            i = i - 1
        return Err("Undefined variable: " + name)
    
    pub fn lookup(self, name: String) -> Option<Value>:
        var i = len(self.scopes) - 1
        while i >= 0:
            if contains_key(self.scopes[i], name):
                return Some(self.scopes[i][name])
            i = i - 1
        return None
    
    // =========================================================================
    // Standard Library Registration
    // =========================================================================
    
    fn register_stdlib(self) -> Unit:
        // I/O
        self.define("print", Value::NativeFunction("print"))
        self.define("println", Value::NativeFunction("println"))
        self.define("input", Value::NativeFunction("input"))
        
        // Type conversions
        self.define("str", Value::NativeFunction("str"))
        self.define("int", Value::NativeFunction("int"))
        self.define("float", Value::NativeFunction("float"))
        self.define("bool", Value::NativeFunction("bool"))
        
        // Collections
        self.define("len", Value::NativeFunction("len"))
        self.define("push", Value::NativeFunction("push"))
        self.define("pop", Value::NativeFunction("pop"))
        self.define("get", Value::NativeFunction("get"))
        self.define("set", Value::NativeFunction("set"))
        self.define("contains", Value::NativeFunction("contains"))
        self.define("keys", Value::NativeFunction("keys"))
        self.define("values", Value::NativeFunction("values"))
        self.define("range", Value::NativeFunction("range"))
        self.define("map", Value::NativeFunction("map"))
        self.define("filter", Value::NativeFunction("filter"))
        self.define("fold", Value::NativeFunction("fold"))
        self.define("zip", Value::NativeFunction("zip"))
        self.define("enumerate", Value::NativeFunction("enumerate"))
        self.define("sort", Value::NativeFunction("sort"))
        self.define("reverse", Value::NativeFunction("reverse"))
        self.define("join", Value::NativeFunction("join"))
        self.define("split", Value::NativeFunction("split"))
        
        // String operations
        self.define("substring", Value::NativeFunction("substring"))
        self.define("starts_with", Value::NativeFunction("starts_with"))
        self.define("ends_with", Value::NativeFunction("ends_with"))
        self.define("trim", Value::NativeFunction("trim"))
        self.define("to_upper", Value::NativeFunction("to_upper"))
        self.define("to_lower", Value::NativeFunction("to_lower"))
        self.define("replace", Value::NativeFunction("replace"))
        self.define("char_at", Value::NativeFunction("char_at"))
        self.define("index_of", Value::NativeFunction("index_of"))
        
        // Math
        self.define("abs", Value::NativeFunction("abs"))
        self.define("min", Value::NativeFunction("min"))
        self.define("max", Value::NativeFunction("max"))
        self.define("floor", Value::NativeFunction("floor"))
        self.define("ceil", Value::NativeFunction("ceil"))
        self.define("round", Value::NativeFunction("round"))
        self.define("sqrt", Value::NativeFunction("sqrt"))
        self.define("pow", Value::NativeFunction("pow"))
        self.define("sin", Value::NativeFunction("sin"))
        self.define("cos", Value::NativeFunction("cos"))
        self.define("tan", Value::NativeFunction("tan"))
        self.define("log", Value::NativeFunction("log"))
        self.define("exp", Value::NativeFunction("exp"))
        
        // Option/Result
        self.define("Some", Value::NativeFunction("Some"))
        self.define("unwrap", Value::NativeFunction("unwrap"))
        self.define("unwrap_or", Value::NativeFunction("unwrap_or"))
        self.define("is_some", Value::NativeFunction("is_some"))
        self.define("is_none", Value::NativeFunction("is_none"))
        self.define("Ok", Value::NativeFunction("Ok"))
        self.define("Err", Value::NativeFunction("Err"))
        self.define("is_ok", Value::NativeFunction("is_ok"))
        self.define("is_err", Value::NativeFunction("is_err"))
        
        // Assertions
        self.define("assert", Value::NativeFunction("assert"))
        self.define("assert_eq", Value::NativeFunction("assert_eq"))
        self.define("panic", Value::NativeFunction("panic"))
        
        // Type checking
        self.define("type_of", Value::NativeFunction("type_of"))
        self.define("variant_of", Value::NativeFunction("variant_of"))
        
        // File I/O
        self.define("read_file", Value::NativeFunction("read_file"))
        self.define("write_file", Value::NativeFunction("write_file"))
        self.define("file_exists", Value::NativeFunction("file_exists"))
        
        // HTTP (networking)
        self.define("http_get", Value::NativeFunction("http_get"))
        self.define("http_post", Value::NativeFunction("http_post"))
        self.define("http_post_json", Value::NativeFunction("http_post_json"))
        
        // JSON
        self.define("json_parse", Value::NativeFunction("json_parse"))
        self.define("json_string", Value::NativeFunction("json_string"))
        
        // Actors
        self.define("spawn", Value::NativeFunction("spawn"))
        self.define("send", Value::NativeFunction("send"))

// =============================================================================
// Interpreter Entry Point
// =============================================================================

pub fn interpret(program: TypedProgram) -> Result<Value, String>:
    var env = Env::new()
    
    // First pass: register all definitions
    for item in program.items:
        match item:
            TypedItem::Function(func) =>
                env.functions[func.ast.name] = func.ast
            
            TypedItem::Struct(s) =>
                env.structs[s.ast.name] = s.ast
            
            TypedItem::Enum(e) =>
                env.enums[e.ast.name] = e.ast
                // Register variant constructors
                for variant in e.ast.variants:
                    let ename = e.ast.name
                    let vname = variant.name
                    env.define(vname, Value::NativeFunction("enum_variant:" + ename + ":" + vname))
            
            TypedItem::Impl(imp) =>
                // Register methods
                let type_name = match imp.ast.target_type:
                    Type::Named(name, _, _) => name
                    _ => continue
                
                for method in imp.ast.methods:
                    let mangled = type_name + "_" + method.name
                    env.functions[mangled] = method
            
            TypedItem::Actor(actor) =>
                // Register actor definition
                // Actors are spawned at runtime
                pass
            
            TypedItem::Use(u) =>
                load_module(env, u)?
            
            _ => pass
    
    // Second pass: find and call main
    if contains_key(env.functions, "main"):
        let main_fn = env.functions["main"]
        return eval_block(env, main_fn.body)
    
    return Ok(Value::Unit)

/// Load an external module
fn load_module(env: Env, u: Use) -> Result<Unit, String>:
    // Parse module path
    let path = join(u.path, "/") + ".kr"
    
    // Check if file exists
    if !file_exists(path):
        return Err("Module not found: " + path)
    
    // Read and parse
    let source = read_file(path)?
    let tokens = Lexer::new(source).tokenize()?
    let program = Parser::new(tokens).parse()?
    
    // Register definitions from module
    for item in program.items:
        match item:
            TypedItem::Function(func) =>
                // Apply prefix if not wildcard import
                match u.items:
                    ImportItems::All =>
                        env.functions[func.ast.name] = func.ast
                    ImportItems::Named(names) =>
                        if contains(names, func.ast.name):
                            env.functions[func.ast.name] = func.ast
            
            TypedItem::Struct(s) =>
                match u.items:
                    ImportItems::All =>
                        env.structs[s.ast.name] = s.ast
                    ImportItems::Named(names) =>
                        if contains(names, s.ast.name):
                            env.structs[s.ast.name] = s.ast
            
            TypedItem::Enum(e) =>
                match u.items:
                    ImportItems::All =>
                        env.enums[e.ast.name] = e.ast
                    ImportItems::Named(names) =>
                        if contains(names, e.ast.name):
                            env.enums[e.ast.name] = e.ast
            
            _ => pass
    
    return Ok(())

// =============================================================================
// Block and Statement Evaluation
// =============================================================================

fn eval_block(env: Env, block: Block) -> Result<Value, String>:
    env.push_scope()
    var result = Value::Unit
    
    for stmt in block.stmts:
        result = eval_stmt(env, stmt)?
        
        // Check for early return
        match result:
            Value::Enum("Return", _, data) =>
                env.pop_scope()
                if len(data) > 0:
                    return Ok(data[0])
                return Ok(Value::Unit)
            _ => pass
    
    env.pop_scope()
    return Ok(result)

fn eval_stmt(env: Env, stmt: Stmt) -> Result<Value, String>:
    match stmt:
        Stmt::Let(pattern, _, value, _) =>
            let val = match value:
                Some(v) => eval_expr(env, v)?
                None => Value::None
            
            bind_pattern(env, pattern, val)
            return Ok(Value::Unit)
        
        Stmt::Expr(e, _) =>
            return eval_expr(env, e)
        
        Stmt::Return(Some(e), _) =>
            let val = eval_expr(env, e)?
            return Ok(Value::Enum("Return", "Value", [val]))
        
        Stmt::Return(None, _) =>
            return Ok(Value::Enum("Return", "Unit", []))
        
        Stmt::For(pattern, iter, body, _) =>
            let iter_val = eval_expr(env, iter)?
            let items = match iter_val:
                Value::Array(arr) => arr
                _ => return Err("For loop requires iterable")
            
            for item in items:
                env.push_scope()
                bind_pattern(env, pattern, item)
                let result = eval_block(env, body)?
                env.pop_scope()
                
                // Check for break/continue/return
                match result:
                    Value::Enum("Return", _, _) => return Ok(result)
                    Value::Enum("Break", _, _) => break
                    Value::Enum("Continue", _, _) => continue
                    _ => pass
            
            return Ok(Value::Unit)
        
        Stmt::While(cond, body, _) =>
            loop:
                let cond_val = eval_expr(env, cond)?
                if !cond_val.is_truthy():
                    break
                
                let result = eval_block(env, body)?
                match result:
                    Value::Enum("Return", _, _) => return Ok(result)
                    Value::Enum("Break", _, _) => break
                    Value::Enum("Continue", _, _) => continue
                    _ => pass
            
            return Ok(Value::Unit)
        
        Stmt::Break(_) =>
            return Ok(Value::Enum("Break", "Unit", []))
        
        Stmt::Continue(_) =>
            return Ok(Value::Enum("Continue", "Unit", []))
        
        Stmt::Pass(_) =>
            return Ok(Value::Unit)
        
        _ =>
            return Ok(Value::Unit)

fn bind_pattern(env: Env, pattern: Pattern, value: Value) -> Unit:
    match pattern:
        Pattern::Binding(name, _, _) =>
            env.define(name, value)
        
        Pattern::Tuple(pats, _) =>
            match value:
                Value::Tuple(vals) =>
                    for i in range(0, min(len(pats), len(vals))):
                        bind_pattern(env, pats[i], vals[i])
                _ => pass
        
        Pattern::Wildcard(_) =>
            pass  // Ignore value
        
        _ => pass

// =============================================================================
// Expression Evaluation
// =============================================================================

fn eval_expr(env: Env, expr: Expr) -> Result<Value, String>:
    match expr:
        Expr::Int(n, _) =>
            return Ok(Value::Int(n))
        
        Expr::Float(f, _) =>
            return Ok(Value::Float(f))
        
        Expr::Bool(b, _) =>
            return Ok(Value::Bool(b))
        
        Expr::String(s, _) =>
            return Ok(Value::String(s))
        
        Expr::None(_) =>
            return Ok(Value::None)
        
        Expr::Ident(name, _) =>
            match env.lookup(name):
                Some(val) => return Ok(val)
                None => return Err("Undefined: " + name)
        
        Expr::Binary(left, op, right, _) =>
            let l = eval_expr(env, left)?
            let r = eval_expr(env, right)?
            return eval_binop(l, op, r)
        
        Expr::Unary(op, operand, _) =>
            let val = eval_expr(env, operand)?
            return eval_unop(op, val)
        
        Expr::Call(callee, args, _) =>
            let func = eval_expr(env, callee)?
            var arg_vals: Array<Value> = []
            for arg in args:
                push(arg_vals, eval_expr(env, arg.value)?)
            return call_function(env, func, arg_vals)
        
        Expr::MethodCall(receiver, method, args, _) =>
            let recv = eval_expr(env, receiver)?
            let type_name = recv.type_name()
            let mangled = type_name + "_" + method
            
            if contains_key(env.functions, mangled):
                var all_args = [recv]
                for arg in args:
                    push(all_args, eval_expr(env, arg.value)?)
                return call_user_function(env, env.functions[mangled], all_args)
            
            return Err("Unknown method: " + method + " on " + type_name)
        
        Expr::Field(object, field, _) =>
            let obj = eval_expr(env, object)?
            match obj:
                Value::Struct(_, fields) =>
                    if contains_key(fields, field):
                        return Ok(fields[field])
                    return Err("Unknown field: " + field)
                Value::Map(m) =>
                    if contains_key(m, field):
                        return Ok(m[field])
                    return Ok(Value::None)
                _ =>
                    return Err("Cannot access field on " + obj.type_name())
        
        Expr::Index(object, index, _) =>
            let obj = eval_expr(env, object)?
            let idx = eval_expr(env, index)?
            
            match (obj, idx):
                (Value::Array(arr), Value::Int(i)) =>
                    if i >= 0 and i < len(arr):
                        return Ok(arr[i])
                    return Err("Index out of bounds")
                (Value::String(s), Value::Int(i)) =>
                    if i >= 0 and i < len(s):
                        return Ok(Value::String(char_at(s, i)))
                    return Err("Index out of bounds")
                (Value::Map(m), Value::String(k)) =>
                    if contains_key(m, k):
                        return Ok(m[k])
                    return Ok(Value::None)
                _ =>
                    return Err("Cannot index " + obj.type_name())
        
        Expr::Assign(target, value, _) =>
            let val = eval_expr(env, value)?
            eval_assignment(env, target, val)?
            return Ok(val)
        
        Expr::If(cond, then_b, else_b, _) =>
            let cond_val = eval_expr(env, cond)?
            if cond_val.is_truthy():
                return eval_block(env, then_b)
            else:
                match else_b:
                    Some(ElseBranch::Else(b)) =>
                        return eval_block(env, b)
                    Some(ElseBranch::ElseIf(cond2, then2, next)) =>
                        let cond2_val = eval_expr(env, cond2)?
                        if cond2_val.is_truthy():
                            return eval_block(env, then2)
                        else:
                            match next:
                                Some(n) => return eval_else_branch(env, n)
                                None => return Ok(Value::Unit)
                    None =>
                        return Ok(Value::Unit)
        
        Expr::Match(scrutinee, arms, _) =>
            let val = eval_expr(env, scrutinee)?
            
            for arm in arms:
                if pattern_matches(val, arm.pattern):
                    env.push_scope()
                    bind_pattern(env, arm.pattern, val)
                    
                    // Check guard
                    match arm.guard:
                        Some(guard) =>
                            let guard_val = eval_expr(env, guard)?
                            if !guard_val.is_truthy():
                                env.pop_scope()
                                continue
                        None => pass
                    
                    let result = eval_expr(env, arm.body)?
                    env.pop_scope()
                    return Ok(result)
            
            return Err("No matching arm in match expression")
        
        Expr::Block(block, _) =>
            return eval_block(env, block)
        
        Expr::Array(items, _) =>
            var vals: Array<Value> = []
            for item in items:
                push(vals, eval_expr(env, item)?)
            return Ok(Value::Array(vals))
        
        Expr::Tuple(items, _) =>
            var vals: Array<Value> = []
            for item in items:
                push(vals, eval_expr(env, item)?)
            return Ok(Value::Tuple(vals))
        
        Expr::Struct(name, fields, _) =>
            var field_vals: Map<String, Value> = Map::new()
            for (fname, fval) in fields:
                field_vals[fname] = eval_expr(env, fval)?
            return Ok(Value::Struct(name, field_vals))
        
        Expr::Lambda(params, body, _, _) =>
            // Capture current environment
            return Ok(Value::Function("lambda", params, Block { stmts: [Stmt::Expr(body, body.span())], span: body.span() }, clone(env)))
        
        Expr::EnumVariant(ename, variant, fields, _) =>
            var data: Array<Value> = []
            match fields:
                EnumVariantFields::Tuple(exprs) =>
                    for e in exprs:
                        push(data, eval_expr(env, e)?)
                EnumVariantFields::Struct(pairs) =>
                    for (_, e) in pairs:
                        push(data, eval_expr(env, e)?)
                _ => pass
            return Ok(Value::Enum(ename, variant, data))
        
        Expr::JSX(node, _) =>
            return eval_jsx(env, node)
        
        Expr::Await(inner, _) =>
            // For interpreter, just evaluate the inner expression
            // (async is lowered in monomorphization for native)
            return eval_expr(env, inner)
        
        Expr::Return(Some(inner), _) =>
            let val = eval_expr(env, inner)?
            return Ok(Value::Enum("Return", "Value", [val]))
        
        Expr::Return(None, _) =>
            return Ok(Value::Enum("Return", "Unit", []))
        
        _ =>
            return Ok(Value::Unit)

fn eval_else_branch(env: Env, branch: ElseBranch) -> Result<Value, String>:
    match branch:
        ElseBranch::Else(b) => return eval_block(env, b)
        ElseBranch::ElseIf(cond, then_b, next) =>
            let cond_val = eval_expr(env, cond)?
            if cond_val.is_truthy():
                return eval_block(env, then_b)
            match next:
                Some(n) => return eval_else_branch(env, n)
                None => return Ok(Value::Unit)

fn eval_assignment(env: Env, target: Expr, value: Value) -> Result<Unit, String>:
    match target:
        Expr::Ident(name, _) =>
            return env.assign(name, value)
        
        Expr::Field(object, field, _) =>
            let obj = eval_expr(env, object)?
            match obj:
                Value::Struct(name, fields) =>
                    fields[field] = value
                    // Need to update the original - this is simplified
                    return Ok(())
                _ =>
                    return Err("Cannot assign to field on " + obj.type_name())
        
        Expr::Index(object, index, span) =>
            let obj = eval_expr(env, object)?
            let idx = eval_expr(env, index)?
            
            match (obj, idx):
                (Value::Array(arr), Value::Int(i)) =>
                    if i >= 0 and i < len(arr):
                        arr[i] = value
                        return Ok(())
                    return Err("Index out of bounds")
                (Value::Map(m), Value::String(k)) =>
                    m[k] = value
                    return Ok(())
                _ =>
                    return Err("Cannot index-assign")
        
        _ =>
            return Err("Invalid assignment target")

// =============================================================================
// Binary and Unary Operations
// =============================================================================

fn eval_binop(left: Value, op: BinaryOp, right: Value) -> Result<Value, String>:
    match op:
        BinaryOp::Add =>
            match (left, right):
                (Value::Int(a), Value::Int(b)) => Ok(Value::Int(a + b))
                (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a + b))
                (Value::String(a), Value::String(b)) => Ok(Value::String(a + b))
                (Value::Int(a), Value::Float(b)) => Ok(Value::Float(float(a) + b))
                (Value::Float(a), Value::Int(b)) => Ok(Value::Float(a + float(b)))
                _ => Err("Cannot add " + left.type_name() + " and " + right.type_name())
        
        BinaryOp::Sub =>
            match (left, right):
                (Value::Int(a), Value::Int(b)) => Ok(Value::Int(a - b))
                (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a - b))
                _ => Err("Cannot subtract")
        
        BinaryOp::Mul =>
            match (left, right):
                (Value::Int(a), Value::Int(b)) => Ok(Value::Int(a * b))
                (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a * b))
                _ => Err("Cannot multiply")
        
        BinaryOp::Div =>
            match (left, right):
                (Value::Int(a), Value::Int(b)) =>
                    if b == 0: Err("Division by zero")
                    else: Ok(Value::Int(a / b))
                (Value::Float(a), Value::Float(b)) =>
                    if b == 0.0: Err("Division by zero")
                    else: Ok(Value::Float(a / b))
                _ => Err("Cannot divide")
        
        BinaryOp::Mod =>
            match (left, right):
                (Value::Int(a), Value::Int(b)) =>
                    if b == 0: Err("Division by zero")
                    else: Ok(Value::Int(a % b))
                _ => Err("Cannot modulo")
        
        BinaryOp::Eq =>
            Ok(Value::Bool(values_equal(left, right)))
        
        BinaryOp::Ne =>
            Ok(Value::Bool(!values_equal(left, right)))
        
        BinaryOp::Lt =>
            match (left, right):
                (Value::Int(a), Value::Int(b)) => Ok(Value::Bool(a < b))
                (Value::Float(a), Value::Float(b)) => Ok(Value::Bool(a < b))
                (Value::String(a), Value::String(b)) => Ok(Value::Bool(a < b))
                _ => Err("Cannot compare")
        
        BinaryOp::Le =>
            match (left, right):
                (Value::Int(a), Value::Int(b)) => Ok(Value::Bool(a <= b))
                (Value::Float(a), Value::Float(b)) => Ok(Value::Bool(a <= b))
                _ => Err("Cannot compare")
        
        BinaryOp::Gt =>
            match (left, right):
                (Value::Int(a), Value::Int(b)) => Ok(Value::Bool(a > b))
                (Value::Float(a), Value::Float(b)) => Ok(Value::Bool(a > b))
                _ => Err("Cannot compare")
        
        BinaryOp::Ge =>
            match (left, right):
                (Value::Int(a), Value::Int(b)) => Ok(Value::Bool(a >= b))
                (Value::Float(a), Value::Float(b)) => Ok(Value::Bool(a >= b))
                _ => Err("Cannot compare")
        
        BinaryOp::And =>
            Ok(Value::Bool(left.is_truthy() and right.is_truthy()))
        
        BinaryOp::Or =>
            Ok(Value::Bool(left.is_truthy() or right.is_truthy()))
        
        _ => Err("Unknown binary operator")

fn eval_unop(op: UnaryOp, val: Value) -> Result<Value, String>:
    match op:
        UnaryOp::Neg =>
            match val:
                Value::Int(n) => Ok(Value::Int(-n))
                Value::Float(f) => Ok(Value::Float(-f))
                _ => Err("Cannot negate")
        
        UnaryOp::Not =>
            Ok(Value::Bool(!val.is_truthy()))
        
        _ => Err("Unknown unary operator")

fn values_equal(a: Value, b: Value) -> Bool:
    match (a, b):
        (Value::Int(x), Value::Int(y)) => x == y
        (Value::Float(x), Value::Float(y)) => x == y
        (Value::Bool(x), Value::Bool(y)) => x == y
        (Value::String(x), Value::String(y)) => x == y
        (Value::None, Value::None) => true
        (Value::Unit, Value::Unit) => true
        _ => false

// =============================================================================
// Pattern Matching
// =============================================================================

fn pattern_matches(value: Value, pattern: Pattern) -> Bool:
    match pattern:
        Pattern::Wildcard(_) => true
        
        Pattern::Binding(_, _, _) => true
        
        Pattern::Literal(lit, _) =>
            match (value, lit):
                (Value::Int(a), Expr::Int(b, _)) => a == b
                (Value::Bool(a), Expr::Bool(b, _)) => a == b
                (Value::String(a), Expr::String(b, _)) => a == b
                _ => false
        
        Pattern::Variant(enum_name, variant, _, _) =>
            match value:
                Value::Enum(ename, vname, _) =>
                    match enum_name:
                        Some(en) => en == ename and variant == vname
                        None => variant == vname
                _ => false
        
        Pattern::Tuple(pats, _) =>
            match value:
                Value::Tuple(vals) =>
                    if len(pats) != len(vals): return false
                    for i in range(0, len(pats)):
                        if !pattern_matches(vals[i], pats[i]): return false
                    true
                _ => false
        
        _ => false

// =============================================================================
// Function Calls
// =============================================================================

fn call_function(env: Env, func: Value, args: Array<Value>) -> Result<Value, String>:
    match func:
        Value::Function(name, params, body, closure) =>
            return call_user_function_with_env(closure, params, body, args)
        
        Value::NativeFunction(name) =>
            return call_native(env, name, args)
        
        _ =>
            return Err("Cannot call " + func.type_name())

fn call_user_function(env: Env, func: Function, args: Array<Value>) -> Result<Value, String>:
    env.push_scope()
    
    for i in range(0, min(len(func.params), len(args))):
        env.define(func.params[i].name, args[i])
    
    let result = eval_block(env, func.body)
    env.pop_scope()
    return result

fn call_user_function_with_env(closure: Env, params: Array<Param>, body: Block, args: Array<Value>) -> Result<Value, String>:
    closure.push_scope()
    
    for i in range(0, min(len(params), len(args))):
        closure.define(params[i].name, args[i])
    
    let result = eval_block(closure, body)
    closure.pop_scope()
    return result

// =============================================================================
// Native Function Dispatch
// =============================================================================

fn call_native(env: Env, name: String, args: Array<Value>) -> Result<Value, String>:
    // I/O
    if name == "print":
        for arg in args:
            native_print(arg.to_string())
        return Ok(Value::Unit)
    
    if name == "println":
        var out = ""
        for arg in args:
            out = out + arg.to_string()
        native_println(out)
        return Ok(Value::Unit)
    
    if name == "input":
        return Ok(Value::String(native_input()))
    
    // Type conversions
    if name == "str":
        if len(args) > 0:
            return Ok(Value::String(args[0].to_string()))
        return Ok(Value::String(""))
    
    if name == "int":
        if len(args) > 0:
            match args[0]:
                Value::Int(n) => return Ok(Value::Int(n))
                Value::Float(f) => return Ok(Value::Int(int(f)))
                Value::String(s) => return Ok(Value::Int(parse_int(s)))
                _ => return Err("Cannot convert to int")
        return Ok(Value::Int(0))
    
    if name == "float":
        if len(args) > 0:
            match args[0]:
                Value::Int(n) => return Ok(Value::Float(float(n)))
                Value::Float(f) => return Ok(Value::Float(f))
                Value::String(s) => return Ok(Value::Float(parse_float(s)))
                _ => return Err("Cannot convert to float")
        return Ok(Value::Float(0.0))
    
    // Collections
    if name == "len":
        if len(args) > 0:
            match args[0]:
                Value::String(s) => return Ok(Value::Int(len(s)))
                Value::Array(a) => return Ok(Value::Int(len(a)))
                Value::Map(m) => return Ok(Value::Int(len(m)))
                _ => return Err("No len for " + args[0].type_name())
        return Ok(Value::Int(0))
    
    if name == "push":
        if len(args) >= 2:
            match args[0]:
                Value::Array(arr) =>
                    push(arr, args[1])
                    return Ok(Value::Unit)
                _ => return Err("push requires array")
        return Err("push requires 2 arguments")
    
    if name == "range":
        if len(args) >= 2:
            match (args[0], args[1]):
                (Value::Int(start), Value::Int(end)) =>
                    var result: Array<Value> = []
                    for i in range(start, end):
                        push(result, Value::Int(i))
                    return Ok(Value::Array(result))
                _ => return Err("range requires int arguments")
        return Err("range requires 2 arguments")
    
    if name == "contains":
        if len(args) >= 2:
            match args[0]:
                Value::Array(arr) =>
                    for item in arr:
                        if values_equal(item, args[1]):
                            return Ok(Value::Bool(true))
                    return Ok(Value::Bool(false))
                Value::String(s) =>
                    match args[1]:
                        Value::String(sub) =>
                            return Ok(Value::Bool(string_contains(s, sub)))
                        _ => pass
                Value::Map(m) =>
                    match args[1]:
                        Value::String(k) =>
                            return Ok(Value::Bool(contains_key(m, k)))
                        _ => pass
                _ => pass
        return Ok(Value::Bool(false))
    
    // String operations
    if name == "substring":
        if len(args) >= 3:
            match (args[0], args[1], args[2]):
                (Value::String(s), Value::Int(start), Value::Int(end)) =>
                    return Ok(Value::String(substring(s, start, end)))
                _ => return Err("substring requires (string, int, int)")
        return Err("substring requires 3 arguments")
    
    if name == "split":
        if len(args) >= 2:
            match (args[0], args[1]):
                (Value::String(s), Value::String(delim)) =>
                    let parts = split(s, delim)
                    var result: Array<Value> = []
                    for part in parts:
                        push(result, Value::String(part))
                    return Ok(Value::Array(result))
                _ => return Err("split requires (string, string)")
        return Err("split requires 2 arguments")
    
    if name == "join":
        if len(args) >= 2:
            match (args[0], args[1]):
                (Value::Array(arr), Value::String(delim)) =>
                    var parts: Array<String> = []
                    for item in arr:
                        push(parts, item.to_string())
                    return Ok(Value::String(join(parts, delim)))
                _ => pass
        return Err("join requires (array, string)")
    
    // Type checking
    if name == "type_of":
        if len(args) > 0:
            return Ok(Value::String(args[0].type_name()))
        return Ok(Value::String("Unit"))
    
    if name == "variant_of":
        if len(args) > 0:
            match args[0]:
                Value::Enum(_, variant, _) =>
                    return Ok(Value::String(variant))
                _ =>
                    return Ok(Value::String(args[0].type_name()))
        return Ok(Value::String(""))
    
    // Option/Result
    if name == "Some":
        if len(args) > 0:
            return Ok(Value::Enum("Option", "Some", [args[0]]))
        return Err("Some requires argument")
    
    if name == "unwrap":
        if len(args) > 0:
            match args[0]:
                Value::Enum("Option", "Some", data) =>
                    if len(data) > 0: return Ok(data[0])
                Value::Enum("Result", "Ok", data) =>
                    if len(data) > 0: return Ok(data[0])
                _ => pass
        return Err("Cannot unwrap")
    
    if name == "is_some":
        if len(args) > 0:
            match args[0]:
                Value::Enum("Option", "Some", _) => return Ok(Value::Bool(true))
                _ => return Ok(Value::Bool(false))
        return Ok(Value::Bool(false))
    
    if name == "is_none":
        if len(args) > 0:
            match args[0]:
                Value::Enum("Option", "None", _) => return Ok(Value::Bool(true))
                Value::None => return Ok(Value::Bool(true))
                _ => return Ok(Value::Bool(false))
        return Ok(Value::Bool(true))
    
    // Assertions
    if name == "assert":
        if len(args) > 0:
            if !args[0].is_truthy():
                return Err("Assertion failed")
        return Ok(Value::Unit)
    
    if name == "assert_eq":
        if len(args) >= 2:
            if !values_equal(args[0], args[1]):
                return Err("Assertion failed: " + args[0].to_string() + " != " + args[1].to_string())
        return Ok(Value::Unit)
    
    if name == "panic":
        let msg = if len(args) > 0: args[0].to_string() else: "panic!"
        return Err(msg)
    
    // HTTP (stubs - would use FFI in real implementation)
    if name == "http_get":
        if len(args) > 0:
            match args[0]:
                Value::String(url) =>
                    return Ok(Value::String(native_http_get(url)))
                _ => pass
        return Err("http_get requires url string")
    
    if name == "http_post_json":
        if len(args) >= 2:
            match (args[0], args[1]):
                (Value::String(url), body) =>
                    let body_str = value_to_json(body)
                    return Ok(Value::String(native_http_post(url, body_str)))
                _ => pass
        return Err("http_post_json requires (url, body)")
    
    // JSON
    if name == "json_parse":
        if len(args) > 0:
            match args[0]:
                Value::String(s) =>
                    return json_to_value(s)
                _ => pass
        return Err("json_parse requires string")
    
    if name == "json_string":
        if len(args) > 0:
            return Ok(Value::String(value_to_json(args[0])))
        return Ok(Value::String("null"))
    
    // File I/O
    if name == "read_file":
        if len(args) > 0:
            match args[0]:
                Value::String(path) =>
                    match native_read_file(path):
                        Ok(content) => return Ok(Value::String(content))
                        Err(e) => return Err(e)
                _ => pass
        return Err("read_file requires path")
    
    if name == "write_file":
        if len(args) >= 2:
            match (args[0], args[1]):
                (Value::String(path), Value::String(content)) =>
                    match native_write_file(path, content):
                        Ok(_) => return Ok(Value::Unit)
                        Err(e) => return Err(e)
                _ => pass
        return Err("write_file requires (path, content)")
    
    if name == "file_exists":
        if len(args) > 0:
            match args[0]:
                Value::String(path) =>
                    return Ok(Value::Bool(native_file_exists(path)))
                _ => pass
        return Ok(Value::Bool(false))
    
    // Check for enum variant constructor
    if starts_with(name, "enum_variant:"):
        let parts = split(name, ":")
        if len(parts) >= 3:
            let ename = parts[1]
            let vname = parts[2]
            return Ok(Value::Enum(ename, vname, args))
    
    return Err("Unknown native function: " + name)

// =============================================================================
// JSX Evaluation
// =============================================================================

fn eval_jsx(env: Env, node: JSXNode) -> Result<Value, String>:
    match node:
        JSXNode::Element(el) =>
            var attrs: Map<String, Value> = Map::new()
            for attr in el.attributes:
                attrs[attr.name] = eval_expr(env, attr.value)?
            
            var children: Array<VNode> = []
            for child in el.children:
                let child_val = eval_jsx(env, child)?
                match child_val:
                    Value::VNode(vn) => push(children, vn)
                    Value::String(s) => push(children, VNode::Text(s))
                    _ => push(children, VNode::Text(child_val.to_string()))
            
            return Ok(Value::VNode(VNode::Element(el.name, attrs, children)))
        
        JSXNode::Text(text) =>
            return Ok(Value::VNode(VNode::Text(text)))
        
        JSXNode::Expr(e) =>
            return eval_expr(env, e)
        
        JSXNode::Fragment(children) =>
            var result: Array<VNode> = []
            for child in children:
                let child_val = eval_jsx(env, child)?
                match child_val:
                    Value::VNode(vn) => push(result, vn)
                    _ => pass
            // Return first child or empty text
            if len(result) > 0:
                return Ok(Value::VNode(result[0]))
            return Ok(Value::VNode(VNode::Text("")))

// =============================================================================
// JSON Helpers
// =============================================================================

fn json_to_value(s: String) -> Result<Value, String>:
    // Simple JSON parser (would use proper parser in real impl)
    let trimmed = trim(s)
    
    if trimmed == "null":
        return Ok(Value::None)
    if trimmed == "true":
        return Ok(Value::Bool(true))
    if trimmed == "false":
        return Ok(Value::Bool(false))
    
    if starts_with(trimmed, "\"") and ends_with(trimmed, "\""):
        return Ok(Value::String(substring(trimmed, 1, len(trimmed) - 1)))
    
    // Try as number
    if is_digit(char_at(trimmed, 0)) or char_at(trimmed, 0) == "-":
        if string_contains(trimmed, "."):
            return Ok(Value::Float(parse_float(trimmed)))
        return Ok(Value::Int(parse_int(trimmed)))
    
    // TODO: Parse arrays and objects
    return Ok(Value::String(s))

fn value_to_json(v: Value) -> String:
    match v:
        Value::None => "null"
        Value::Bool(b) => if b: "true" else: "false"
        Value::Int(n) => str(n)
        Value::Float(f) => str(f)
        Value::String(s) => "\"" + escape_json(s) + "\""
        Value::Array(arr) =>
            var parts: Array<String> = []
            for item in arr:
                push(parts, value_to_json(item))
            "[" + join(parts, ",") + "]"
        Value::Map(m) =>
            var parts: Array<String> = []
            for k, val in m:
                push(parts, "\"" + k + "\":" + value_to_json(val))
            "{" + join(parts, ",") + "}"
        Value::Struct(_, fields) =>
            var parts: Array<String> = []
            for k, val in fields:
                push(parts, "\"" + k + "\":" + value_to_json(val))
            "{" + join(parts, ",") + "}"
        _ => "null"

fn escape_json(s: String) -> String:
    var result = ""
    for ch in chars(s):
        if ch == "\"": result = result + "\\\""
        else if ch == "\\": result = result + "\\\\"
        else if ch == "\n": result = result + "\\n"
        else if ch == "\t": result = result + "\\t"
        else: result = result + ch
    return result

fn chars(s: String) -> Array<String>:
    var result: Array<String> = []
    for i in range(0, len(s)):
        push(result, char_at(s, i))
    return result

// =============================================================================
// Native Function Stubs (Platform-Specific)
// =============================================================================

extern fn native_print(s: String) -> Unit
extern fn native_println(s: String) -> Unit
extern fn native_input() -> String
extern fn native_http_get(url: String) -> String
extern fn native_http_post(url: String, body: String) -> String
extern fn native_read_file(path: String) -> Result<String, String>
extern fn native_write_file(path: String, content: String) -> Result<Unit, String>
extern fn native_file_exists(path: String) -> Bool
extern fn parse_int(s: String) -> Int
extern fn parse_float(s: String) -> Float
extern fn string_contains(haystack: String, needle: String) -> Bool
extern fn is_digit(c: String) -> Bool
extern fn file_exists(path: String) -> Bool
extern fn read_file(path: String) -> Result<String, String>
