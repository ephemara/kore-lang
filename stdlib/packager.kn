// ============================================================================
// KAIN Package Manager
// ============================================================================
// Ported from legacy_prototype/src/packager.rs
// 
// Handles package manifests (kain.toml), project initialization,
// and dependency management.
// ============================================================================

use std/io
use std/fs
use std/collections

// =============================================================================
// Data Structures
// =============================================================================

/// Package information from kain.toml [package] section
struct PackageInfo:
    name: String
    version: String
    authors: Array<String>
    description: Option<String>
    license: Option<String>
    repository: Option<String>
    homepage: Option<String>
    keywords: Array<String>

/// Full package manifest (kain.toml)
struct PackageManifest:
    package: PackageInfo
    dependencies: Map<String, String>
    dev_dependencies: Map<String, String>
    build_dependencies: Map<String, String>

// =============================================================================
// PackageInfo Implementation
// =============================================================================

impl PackageInfo:
    /// Create a default PackageInfo with just a name
    pub fn new(name: String) -> PackageInfo:
        return PackageInfo {
            name: name,
            version: "0.1.0",
            authors: [],
            description: None,
            license: None,
            repository: None,
            homepage: None,
            keywords: []
        }
    
    /// Create PackageInfo with name and version
    pub fn with_version(name: String, version: String) -> PackageInfo:
        return PackageInfo {
            name: name,
            version: version,
            authors: [],
            description: None,
            license: None,
            repository: None,
            homepage: None,
            keywords: []
        }
    
    /// Add an author
    pub fn add_author(self, author: String) -> PackageInfo:
        push(self.authors, author)
        return self
    
    /// Set description
    pub fn set_description(self, desc: String) -> PackageInfo:
        self.description = Some(desc)
        return self
    
    /// Set license
    pub fn set_license(self, license: String) -> PackageInfo:
        self.license = Some(license)
        return self

// =============================================================================
// PackageManifest Implementation
// =============================================================================

impl PackageManifest:
    /// Create a default manifest for a new project
    pub fn default(name: String) -> PackageManifest:
        return PackageManifest {
            package: PackageInfo::new(name),
            dependencies: Map::new(),
            dev_dependencies: Map::new(),
            build_dependencies: Map::new()
        }
    
    /// Add a dependency
    pub fn add_dependency(self, name: String, version: String) -> PackageManifest:
        self.dependencies[name] = version
        return self
    
    /// Add a dev dependency
    pub fn add_dev_dependency(self, name: String, version: String) -> PackageManifest:
        self.dev_dependencies[name] = version
        return self
    
    /// Add a build dependency
    pub fn add_build_dependency(self, name: String, version: String) -> PackageManifest:
        self.build_dependencies[name] = version
        return self
    
    /// Check if a dependency exists
    pub fn has_dependency(self, name: String) -> Bool:
        return contains_key(self.dependencies, name)
    
    /// Get dependency version
    pub fn get_dependency_version(self, name: String) -> Option<String>:
        if contains_key(self.dependencies, name):
            return Some(self.dependencies[name])
        return None
    
    /// Serialize to TOML string
    pub fn to_toml(self) -> String:
        var result = ""
        
        // [package] section
        result = result + "[package]\n"
        result = result + "name = \"" + self.package.name + "\"\n"
        result = result + "version = \"" + self.package.version + "\"\n"
        
        if len(self.package.authors) > 0:
            result = result + "authors = ["
            var first = true
            for author in self.package.authors:
                if !first:
                    result = result + ", "
                first = false
                result = result + "\"" + author + "\""
            result = result + "]\n"
        
        match self.package.description:
            Some(desc) => result = result + "description = \"" + desc + "\"\n"
            None => pass
        
        match self.package.license:
            Some(lic) => result = result + "license = \"" + lic + "\"\n"
            None => pass
        
        match self.package.repository:
            Some(repo) => result = result + "repository = \"" + repo + "\"\n"
            None => pass
        
        // [dependencies] section
        if len(self.dependencies) > 0:
            result = result + "\n[dependencies]\n"
            for name, version in self.dependencies:
                result = result + name + " = \"" + version + "\"\n"
        
        // [dev-dependencies] section
        if len(self.dev_dependencies) > 0:
            result = result + "\n[dev-dependencies]\n"
            for name, version in self.dev_dependencies:
                result = result + name + " = \"" + version + "\"\n"
        
        // [build-dependencies] section
        if len(self.build_dependencies) > 0:
            result = result + "\n[build-dependencies]\n"
            for name, version in self.build_dependencies:
                result = result + name + " = \"" + version + "\"\n"
        
        return result

// =============================================================================
// Project Operations
// =============================================================================

/// Initialize a new Kain project in the given directory
pub fn init_project(path: String, name: Option<String>) -> Result<Unit, String> with IO:
    // Create directory if it doesn't exist
    if !dir_exists(path):
        match mkdir(path):
            Err(e) => return Err("Failed to create directory: " + e)
            Ok(_) => pass
    
    // Determine project name
    let project_name = match name:
        Some(n) => n
        None => basename(path)
    
    // Create kain.toml
    let manifest = PackageManifest::default(project_name)
    let toml_content = manifest.to_toml()
    let toml_path = join_path(path, "kain.toml")
    
    match write_file(toml_path, toml_content):
        Err(e) => return Err("Failed to write kain.toml: " + e)
        Ok(_) => pass
    
    // Create src directory
    let src_dir = join_path(path, "src")
    if !dir_exists(src_dir):
        match mkdir(src_dir):
            Err(e) => return Err("Failed to create src directory: " + e)
            Ok(_) => pass
    
    // Create main.kn
    let main_content = "// " + project_name + " - Main Entry Point\n\n"
    main_content = main_content + "fn main():\n"
    main_content = main_content + "    println(\"Hello, Kain!\")\n"
    
    let main_path = join_path(src_dir, "main.kn")
    match write_file(main_path, main_content):
        Err(e) => return Err("Failed to write main.kn: " + e)
        Ok(_) => pass
    
    // Create .gitignore
    let gitignore_content = "# Build artifacts\n"
    gitignore_content = gitignore_content + "target/\n"
    gitignore_content = gitignore_content + "*.ll\n"
    gitignore_content = gitignore_content + "*.o\n"
    gitignore_content = gitignore_content + "*.obj\n"
    gitignore_content = gitignore_content + "*.exe\n"
    gitignore_content = gitignore_content + "\n# IDE\n"
    gitignore_content = gitignore_content + ".vscode/\n"
    gitignore_content = gitignore_content + ".idea/\n"
    
    let gitignore_path = join_path(path, ".gitignore")
    match write_file(gitignore_path, gitignore_content):
        Err(e) => return Err("Failed to write .gitignore: " + e)
        Ok(_) => pass
    
    println(" Initialized new Kain project: " + project_name)
    return Ok(())

/// Load a package manifest from a directory
pub fn load_manifest(path: String) -> Result<PackageManifest, String> with IO:
    // Find kain.toml
    let manifest_path = if ends_with(path, "kain.toml"):
        path
    else:
        join_path(path, "kain.toml")
    
    if !file_exists(manifest_path):
        return Err("Manifest not found at " + manifest_path)
    
    // Read file content
    let content = match read_file(manifest_path):
        Ok(c) => c
        Err(e) => return Err("Failed to read kain.toml: " + e)
    
    // Parse TOML
    return parse_manifest(content)

/// Parse TOML content into a PackageManifest
fn parse_manifest(content: String) -> Result<PackageManifest, String>:
    var manifest = PackageManifest::default("unknown")
    var current_section = ""
    
    let lines = split(content, "\n")
    for line in lines:
        let trimmed = trim(line)
        
        // Skip empty lines and comments
        if len(trimmed) == 0 or starts_with(trimmed, "#"):
            continue
        
        // Check for section header
        if starts_with(trimmed, "[") and ends_with(trimmed, "]"):
            current_section = substring(trimmed, 1, len(trimmed) - 1)
            continue
        
        // Parse key = value
        let parts = split(trimmed, "=")
        if len(parts) != 2:
            continue
        
        let key = trim(parts[0])
        let value = trim(parts[1])
        
        // Remove quotes from value
        let clean_value = if starts_with(value, "\"") and ends_with(value, "\""):
            substring(value, 1, len(value) - 1)
        else:
            value
        
        // Apply to correct section
        if current_section == "package":
            if key == "name":
                manifest.package.name = clean_value
            else if key == "version":
                manifest.package.version = clean_value
            else if key == "description":
                manifest.package.description = Some(clean_value)
            else if key == "license":
                manifest.package.license = Some(clean_value)
            else if key == "repository":
                manifest.package.repository = Some(clean_value)
            else if key == "homepage":
                manifest.package.homepage = Some(clean_value)
        else if current_section == "dependencies":
            manifest.dependencies[key] = clean_value
        else if current_section == "dev-dependencies":
            manifest.dev_dependencies[key] = clean_value
        else if current_section == "build-dependencies":
            manifest.build_dependencies[key] = clean_value
    
    return Ok(manifest)

// =============================================================================
// Dependency Resolution
// =============================================================================

/// Dependency node for resolution graph
struct DepNode:
    name: String
    version: String
    dependencies: Array<String>
    resolved: Bool

/// Resolve all dependencies for a project
pub fn resolve_dependencies(manifest: PackageManifest) -> Result<Array<DepNode>, String> with IO:
    var resolved: Array<DepNode> = []
    var to_resolve: Array<String> = []
    
    // Start with direct dependencies
    for name, version in manifest.dependencies:
        push(to_resolve, name)
    
    // TODO: Implement transitive dependency resolution
    // This requires fetching package manifests from a registry
    
    // For now, return direct dependencies as resolved
    for name, version in manifest.dependencies:
        push(resolved, DepNode {
            name: name,
            version: version,
            dependencies: [],
            resolved: true
        })
    
    return Ok(resolved)

// =============================================================================
// Build Operations
// =============================================================================

/// Build configuration
struct BuildConfig:
    release: Bool
    target: String
    output_dir: String
    verbose: Bool

impl BuildConfig:
    pub fn default() -> BuildConfig:
        return BuildConfig {
            release: false,
            target: "native",
            output_dir: "target",
            verbose: false
        }
    
    pub fn release_mode(self) -> BuildConfig:
        self.release = true
        return self
    
    pub fn set_target(self, target: String) -> BuildConfig:
        self.target = target
        return self

/// Build a project
pub fn build_project(path: String, config: BuildConfig) -> Result<String, String> with IO:
    // Load manifest
    let manifest = match load_manifest(path):
        Ok(m) => m
        Err(e) => return Err(e)
    
    // Find main.kn
    let src_dir = join_path(path, "src")
    let main_path = join_path(src_dir, "main.kn")
    
    if !file_exists(main_path):
        return Err("No main.kn found in src/")
    
    // Create output directory
    let out_dir = join_path(path, config.output_dir)
    if !dir_exists(out_dir):
        match mkdir(out_dir):
            Err(e) => return Err("Failed to create output directory: " + e)
            Ok(_) => pass
    
    // Determine output name
    let out_name = if config.release:
        manifest.package.name
    else:
        manifest.package.name + "_debug"
    
    let out_path = join_path(out_dir, out_name)
    
    if config.verbose:
        println("Building " + manifest.package.name + " v" + manifest.package.version)
        println("  Source: " + main_path)
        println("  Output: " + out_path)
        println("  Target: " + config.target)
        println("  Mode: " + (if config.release: "release" else: "debug"))
    
    // TODO: Invoke kainc to compile
    // For now, return the expected output path
    
    return Ok(out_path)

// =============================================================================
// Utility Functions (stubs - would be in std/fs)
// =============================================================================

extern fn dir_exists(path: String) -> Bool
extern fn file_exists(path: String) -> Bool
extern fn mkdir(path: String) -> Result<Unit, String>
extern fn read_file(path: String) -> Result<String, String>
extern fn write_file(path: String, content: String) -> Result<Unit, String>
extern fn join_path(base: String, child: String) -> String
extern fn basename(path: String) -> String
