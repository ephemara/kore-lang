// KAIN Standard Library - I/O Module
// Provides file reading/writing and console I/O for self-hosted compiler
//
// These functions wrap the native C runtime (kain_runtime.c) for LLVM targets
// and the built-in interpreter functions for interpreted execution.

// =============================================================================
// File I/O
// =============================================================================

/// Read the entire contents of a file as a String.
/// Returns the file contents, or panics if the file doesn't exist.
///
/// Example:
///     let source = File::read("main.kn")
///     println(source)
///
pub fn read_file(path: String) -> String:
    // This maps to the built-in `read_file` in runtime.rs
    // and `file_read` in kain_runtime.c
    return read_file(path)

/// Write content to a file, creating it if it doesn't exist.
/// Overwrites existing content.
///
/// Example:
///     File::write("output.txt", "Hello, World!")
///
pub fn write_file(path: String, content: String) -> Unit:
    // Maps to built-in `write_file`
    write_file(path, content)

/// Check if a file exists at the given path.
///
/// Example:
///     if file_exists("config.toml"):
///         let config = read_file("config.toml")
///
pub fn file_exists(path: String) -> Bool:
    return file_exists(path)

// =============================================================================
// File Struct (Object-Oriented API)
// =============================================================================

/// Represents a file handle for reading/writing.
/// Provides a more ergonomic API than the raw functions.
struct File:
    path: String
    content: Option<String>

impl File:
    /// Open a file for reading. Loads content immediately.
    pub fn open(path: String) -> File:
        let content = read_file(path)
        return File { path: path, content: Some(content) }
    
    /// Create a new empty file handle (for writing).
    pub fn new(path: String) -> File:
        return File { path: path, content: None }
    
    /// Get the file contents. Panics if not loaded.
    pub fn read(self) -> String:
        match self.content:
            Some(c) => return c
            None => panic("File not loaded")
    
    /// Write content to the file.
    pub fn write(self, content: String) -> Unit:
        write_file(self.path, content)
    
    /// Append content to existing file content.
    pub fn append(self, extra: String) -> Unit:
        let existing = read_file(self.path)
        write_file(self.path, existing + extra)

// =============================================================================
// Console I/O
// =============================================================================

/// Print a line to stdout with a newline.
pub fn println(msg: String) -> Unit:
    println(msg)

/// Print to stdout without a newline.
pub fn print(msg: String) -> Unit:
    print(msg)

/// Read a line from stdin.
pub fn read_line() -> String:
    return read_line()

// =============================================================================
// Buffered Writer (for efficient string building)
// =============================================================================

/// A buffer for efficiently building large strings.
/// Useful for code generation where we concat many small pieces.
struct StringBuilder:
    parts: Array<String>

impl StringBuilder:
    /// Create a new empty StringBuilder.
    pub fn new() -> StringBuilder:
        return StringBuilder { parts: [] }
    
    /// Append a string to the buffer.
    pub fn push(self, s: String) -> Unit:
        push(self.parts, s)
    
    /// Append a string followed by a newline.
    pub fn push_line(self, s: String) -> Unit:
        push(self.parts, s)
        push(self.parts, "\n")
    
    /// Get the final concatenated string.
    pub fn build(self) -> String:
        return join(self.parts, "")
    
    /// Get the number of parts.
    pub fn len(self) -> Int:
        return len(self.parts)
